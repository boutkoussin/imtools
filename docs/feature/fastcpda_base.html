<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html>  <head>    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">    <title>FASTCPDA_BASE - Base function for FASTCPDA.</title>    <meta name="generator" content="MATLAB 7.11">    <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">    <meta name="DC.date" content="2011-07-08">    <meta name="DC.source" content="fastcpda_base.m">    <style type="text/css">body {  background-color: white;  margin:10px;}h1 {  color: #990000;   font-size: x-large;}h2 {  color: #990000;  font-size: medium;}/* Make the text shrink to fit narrow windows, but not stretch too far in wide windows. */ p,h1,h2,div.content div {  max-width: 600px;  /* Hack for IE6 */  width: auto !important; width: 600px;}pre.codeinput {  background: #EEEEEE;  padding: 10px;}@media print {  pre.codeinput {word-wrap:break-word; width:100%;}} span.keyword {color: #0000FF}span.comment {color: #228B22}span.string {color: #A020F0}span.untermstring {color: #B20000}span.syscmd {color: #B28C00}pre.codeoutput {  color: #666666;  padding: 10px;}pre.error {  color: red;}p.footer {  text-align: right;  font-size: xx-small;  font-weight: lighter;  font-style: italic;  color: gray;}  </style>  </head>  <body>    <div class="content">      <h1>FASTCPDA_BASE - Base function for FASTCPDA.</h1>      <!--introduction--><!--/introduction-->      <h2>Contents</h2>      <div>        <ul>          <li><a href="#1">Syntax</a></li>          <li><a href="#2">Acknowledgement</a></li>          <li><a href="#3">Contact</a></li>          <li><a href="#4">See also</a></li>          <li><a href="#5">Function implementation</a></li>          <li><a href="#10">Subfunctions</a></li>        </ul>      </div>      <h2>Syntax<a name="1"></a></h2>      <pre>   [pt, map, cd] = FASTCPDA_BASE(BW, Gap_size, T_angle, EP);</pre>      <h2>Acknowledgement<a name="2"></a></h2>      <p>This is an adaptation of the original code of [AL08,ALFR09]        available at: <a href="http://www.mathworks.com/matlabcentral/fileexchange/28207-a-fast-corner-detector-based-on-the-chord-to-point-distance-accumulation-technique">http://www.mathworks.com/matlabcentral/fileexchange/28207-a-fast-corner-detector-based-on-the-chord-to-point-distance-accumulation-technique</a></p>      <p>Part of this code was already from the source code of        [HY04,HY08] available at: <a href="http://www.mathworks.com/matlabcentral/fileexchange/loadFile.do?objectId=7652&amp;objectType=file">http://www.mathworks.com/matlabcentral/fileexchange/loadFile.do?objectId=7652&amp;objectType=file</a></p>      <h2>See also<a name="4"></a></h2>      <p>Related: <a href="FASTCPDA.html"><tt>FASTCPDA</tt></a>, <a href="HARRISCORNER_BASE.html"><tt>HARRISCORNER_BASE</tt></a>,        <a href="SUSANCORNER_BASE.html"><tt>SUSANCORNER_BASE</tt></a>, <a          href="EDGECORNER_BASE.html"><tt>EDGECORNER_BASE</tt></a>,        <a href="FASTCORNER_BASE.html"><tt>FASTCORNER_BASE</tt></a>.</p>      <h2>Function implementation<a name="5"></a></h2>      <pre class="codeinput"><span class="keyword">function</span> [pt, varargout] = fastcpda_base(BW, Gap_size, T_angle, EP)</pre>      <pre class="codeinput">[sizex sizey C] = size(BW);</pre>      <p>dealing with multispectral images</p>      <pre class="codeinput">pt = cell(C,1);<span class="keyword">if</span> nargout&gt;=2    varargout{1} = false(size(BW));    <span class="keyword">if</span> nargout==3, varargout{2} = cell(C,1); <spanclass="keyword">end</span>;<span class="keyword">end</span><span class="keyword">if</span> C&gt;1    <span class="keyword">for</span> c=1:C        [tmp1, tmp2, tmp3] = fastcpda_base(BW(:,:,c), Gap_size, T_angle, EP);        pt{c} = tmp1{1};        <span class="keyword">if</span> nargout&gt;=2,            varargout{1}(:,:,c) = tmp2;            <span class="keyword">if</span> nargout==3, varargout{2}{c} = tmp3{1};  <spanclass="keyword">end</span>;        <span class="keyword">end</span>     <span class="keyword">end</span>    <span class="keyword">return</span>;<span class="keyword">end</span></pre>      <p>extract curves from the edge-image</p>      <pre class="codeinput">[curve, curve_start, curve_end, curve_mode, curve_num, TJ, BW_edge] = <spanclass="keyword">...</span>    extract_curve(BW, Gap_size);<span class="comment">% curve : MATLAB cell data structure where each cell is a 2D array containing</span><span class="comment">%         pixel locations (x and y values)</span><span class="comment">% curve_start : starting points of extracted curves</span><span class="comment">% curve_end : ending points of extracted curves</span><span class="comment">% curve_mode : two curve modes - 'line' and 'loop'. If the both ends of</span><span class="comment">%              a curve are at maximum 25 square pixels (default) away, then</span><span class="comment">%              the curve is a loop curve, otherwise a line curve</span><span class="comment">% curve_num : number of extracted curves</span><span class="comment">% TJ : the T-junction found in the edge-extraction process</span>BW_edge;                                                               <spanclass="comment">%#ok</span><span class="keyword">if</span> ~isempty(curve)    [point_selected, smoothed_curve, Width] = <span class="keyword">...</span>        selectPoint(curve, curve_mode, curve_num, sizex, sizey);    <span class="comment">% detect corners on the extracted edges</span>    [pt{1}, ~, cd2] = <span class="keyword">...</span>        getcorner(curve, curve_mode, curve_start, curve_num, T_angle, <spanclass="keyword">...</span>        point_selected, smoothed_curve, Width);    <span class="comment">% pt : n by 2 matrix containing the positions of the detected corners,</span>    <span class="comment">%      where n is the number of detected corners</span>    <span class="comment">% index : MATLAB cell data structure where each cell is an 1D column</span>    <span class="comment">%         matrix contaning the edge pixel numbers (in curve) where the</span>    <span class="comment">%         corners are detected</span>    <span class="comment">% Sig : the sigma values used to smooth the curves</span>    <span class="comment">% cd2 : cpda curvature values of the detected corners</span>    <span class="comment">% update the T-junctions</span>    [pt{1}, cd{1}] = <span class="keyword">...</span>        Refine_TJunctions(pt{1}, TJ, cd2, <span class="keyword">...</span>        curve, curve_num, curve_start, curve_end, curve_mode, EP);    <span class="comment">% pt : n by 2 matrix containing the positions of the detected corners,</span>    <span class="comment">%      where n is the number of detected corners</span>    <span class="comment">% cd : cpda curvature values of the detected corners</span>    <span class="keyword">if</span> nargout &gt;= 2        varargout{1} = false(size(BW));        varargout{1}(sub2ind([sizex,sizey],pt{1}(:,1),pt{1}(:,2))) = true;        <span class="keyword">if</span> nargout == 3,  varargout{2}{1} = cd;  <spanclass="keyword">end</span>    <span class="keyword">end</span><span class="keyword">else</span>    pt{1} = [];    <span class="keyword">for</span> i=1:nargout-1, varargout{i} = [];   <spanclass="keyword">end</span><span class="keyword">end</span></pre>      <pre class="codeinput"><span class="keyword">end</span> <span class="comment">% end of fastcpda_base</span></pre>      <h2>Subfunctions<a name="10"></a></h2>      <p><tt>SELECTPOINT</tt> - Select points from extracted curves.</p>      <pre class="codeinput"><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> [point_selected smoothed_curve Width Sig] = <spanclass="keyword">...</span>    selectPoint(curve, curve_mode, curve_num, sizex, sizey)<span class="comment">%S = 1.5*s;</span>s = 3.0;S = 4.0;[gau w] = find_Gaussian(s);[Gau W] = find_Gaussian(S);extra = W-w;gau1 = [zeros(1,extra) gau zeros(1,extra)];DoG = Gau-gau1;<span class="comment">%t = 0.1;</span>smoothed_curve = cell(curve_num);point_selected = cell(curve_num);Width = w; Sig = s;<span class="keyword">for</span> i = 1:curve_num    x = curve{i}(:,2) - sizey/2;    y = sizex/2 - curve{i}(:,1);    L = size(x,1);    <span class="keyword">if</span> (L&gt;W)        <span class="comment">% Calculate curvature</span>        <span class="keyword">if</span> strcmpi(curve_mode(i,:),<span class="string">'loop'</span>)            x1=[x(L-W+1:L);x;x(1:W)];            y1=[y(L-W+1:L);y;y(1:W)];        <span class="keyword">else</span>            x1=[ones(W,1)*2*x(1)-x(W+1:-1:2); <span class="keyword">...</span>                x; <span class="keyword">...</span>                ones(W,1)*2*x(L)-x(L-1:-1:L-W)];            y1=[ones(W,1)*2*y(1)-y(W+1:-1:2); <span class="keyword">...</span>                y; <span class="keyword">...</span>                ones(W,1)*2*y(L)-y(L-1:-1:L-W)];        <span class="keyword">end</span>        xx = conv(x1,DoG);        xx = xx(W+1:L+3*W);        yy = conv(y1,DoG);        yy = yy(W+1:L+3*W);        K = xx.^2 + yy.^2;        <span class="comment">% Find curvature local maxima as corner candidates</span>        N = size(K,1);        n = 0;        Search = 1;        extremum = zeros(1,N);        <span class="keyword">for</span> j=1:N-1            <span class="keyword">if</span> (K(j+1)-K(j))*Search&gt;0                n=n+1;                <span class="comment">% in extremum, odd points is minima and even points is maxima</span>                extremum(n) = j;                Search = -Search;            <span class="keyword">end</span>        <span class="keyword">end</span>        <span class="keyword">if</span> mod(n,2)==0            n = n+1;            extremum(n) = N;        <span class="keyword">end</span>        extremum(n+1:N) = [];        <span class="comment">%n=size(extremum,2);</span>        <span class="comment">%flag=ones(size(extremum));</span>        <span class="comment">% Compare with adaptive local threshold to remove round corners</span>        <span class="comment">%for j=2:2:n</span>        <span class="comment">%    if K(extremum(j))&lt;t</span>        <span class="comment">%        flag(j)=0;</span>        <span class="comment">%    end</span>        <span class="comment">%end</span>        extremum = extremum(2:2:n);        <span class="comment">%flag=flag(2:2:n);</span>        <span class="comment">%extremum=extremum(find(flag==1));</span>        extremum = extremum-W;        extremum = extremum(extremum&gt;0 &amp; extremum&lt;=L);        xx = conv(x1,gau);        xx = xx(W+1:L+3*W);        yy = conv(y1,gau);        yy = yy(W+1:L+3*W);        smoothed_curve{i} = [xx yy];        point_selected{i} = extremum;        <span class="comment">%Width = [Width W];</span>        <span class="comment">%Sig = [Sig s];</span>    <span class="keyword">else</span>        smoothed_curve{i} = [];        point_selected{i} = [];        <span class="comment">%Width = [Width 0];</span>        <span class="comment">%Sig = [Sig 0];</span>    <span class="keyword">end</span>    <span class="comment">%here = 1;</span><span class="keyword">end</span><span class="keyword">end</span> <span class="comment">% end of selectPoint</span></pre>      <p><tt>GETCORNER</tt> - Extract corners from curve representation.</p>      <pre class="codeinput"><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> [corners index cd] = <span class="keyword">...</span>    getcorner(curve, curve_mode, curve_start, curve_num, T_angle, point_selected, sm_curve, W)corners = [];cd = [];CLen = [10 20 30];T = 0.2; <span class="comment">% define the curvature threshold</span>index = cell(curve_num);<span class="keyword">for</span> i=1:curve_num;    <span class="comment">% C = [];  C3 = [];</span>    <span class="comment">%x = curve{i}(:,2) - sizey/2;</span>    <span class="comment">%y = sizex/2 - curve{i}(:,1);</span>    <span class="comment">%curveLen = size(x,1);</span>    <span class="comment">%[sig] = find_sig(curveLen);</span>    <span class="comment">% smooth the curve with Gaussian kernel</span>    <span class="comment">%[xs ys gau W] = smoothing(x,y,curveLen,curve_mode(i,:),sig,1);</span>    <span class="comment">%xs = sm_curve{i}(:,1);</span>    <span class="comment">%ys = sm_curve{i}(:,2);</span>    <span class="comment">%W = Width(i);</span>    <span class="keyword">if</span> ~isempty(sm_curve{i})        xs = sm_curve{i}(:,2) ;        ys = sm_curve{i}(:,1);        L = size(xs,1);        curveLen = L-2*W;        <span class="comment">%curveLen = L-2*W;</span>        <span class="comment">%sig = Sigma(i);</span>        <span class="keyword">if</span> L&gt;1            <span class="comment">%if curve_mode(i,:)=='loop'</span>            <span class="comment">%    xs1=[xs(curveLen-W+1:curveLen);xs;xs(1:W)];</span>            <span class="comment">%    ys1=[ys(curveLen-W+1:curveLen);ys;ys(1:W)];</span>            <span class="comment">%else %expand the ends to gaussian window</span>            <span class="comment">%    xs1=[ones(W,1)*2*xs(1)-xs(W+1:-1:2); ...</span>            <span class="comment">%         xs; ...</span>            <span class="comment">%         ones(W,1)*2*xs(curveLen)-xs(curveLen-1:-1:curveLen-W)];</span>            <span class="comment">%    ys1=[ones(W,1)*2*ys(1)-ys(W+1:-1:2); ...</span>            <span class="comment">%         ys; ...</span>            <span class="comment">%         ones(W,1)*2*ys(curveLen)-ys(curveLen-1:-1:curveLen-W)];</span>            <span class="comment">%end</span>            <span class="comment">%xs = xs1;</span>            <span class="comment">%ys = ys1;</span>            <span class="comment">%L = curveLen+2*W;</span>            extremum = point_selected{i};            <span class="keyword">if</span> size(extremum,2)&gt;0                C3 = zeros(3,L);                <span class="keyword">for</span> j = 1:3                    chordLen = CLen(1,j);                    C3(j,1:L) = abs(accumulate_chord_distance(xs,ys,chordLen,L,extremum,W));                <span class="keyword">end</span>                c1 = C3(1,W+1:curveLen+W)/max(C3(1,W+1:curveLen+W));                c2 = C3(2,W+1:curveLen+W)/max(C3(2,W+1:curveLen+W));                c3 = C3(3,W+1:curveLen+W)/max(C3(3,W+1:curveLen+W));                C = c1.*c2.*c3;                <span class="comment">%A = mean(C);</span>                L = curveLen;                xs = xs(W+1:L+W);                ys = ys(W+1:L+W);                <span class="comment">%flag = (extremum &gt; W &amp; extremum &lt;= L+W);</span>                <span class="comment">%extremum = extremum(flag == 1);</span>                <span class="comment">%extremum = extremum-W;</span>                <span class="comment">% Find curvature local maxima as corner candidates</span>                <span class="comment">%extremum=[];</span>                <span class="comment">%N=size(C,2);</span>                <span class="comment">%n=0;</span>                <span class="comment">%Search=1;</span>                <span class="comment">%for j=1:N-1</span>                <span class="comment">%    if (C(j+1)-C(j))*Search&gt;0</span>                <span class="comment">%        n=n+1;</span>                <span class="comment">% % In extremum, odd points are minima and even points are maxima</span>                <span class="comment">%        extremum(n)=j;</span>                <span class="comment">% % minima: when K starts to go up; maxima: when K starts to go down</span>                <span class="comment">%        Search=-Search;</span>                <span class="comment">%    end</span>                <span class="comment">%end</span>                <span class="comment">%if mod(size(extremum,2),2)==0 %to make odd number of extrema</span>                <span class="comment">%    n=n+1;</span>                <span class="comment">%    extremum(n)=N;</span>                <span class="comment">%end</span>                <span class="comment">% accumulate candidate corners</span>                <span class="comment">%n = size(extremum,2);</span>                <span class="comment">%for j = 1:n</span>                <span class="comment">%    cor = [cor; curve{i}(extremum(j),:)];</span>                <span class="comment">%end</span>                n = size(extremum,2);                flag = ones(size(extremum));                <span class="comment">% Compare each maxima with its contour average</span>                <span class="comment">% if the maxima is less than local minima, remove it as false corner</span>                <span class="keyword">for</span> j=1:n                    <span class="keyword">if</span> (C(extremum(j)) &gt; T),   flag(j)=0;  <spanclass="keyword">end</span>                <span class="keyword">end</span>                <span class="comment">%extremum = extremum(2:2:n); % only maxima are corners, not minima</span>                <span class="comment">%flag = flag(2:2:n);</span>                extremum = extremum(flag==0);                <span class="comment">% Check corner angle to remove false corners due to boundary noise and trivial details</span>                <span class="comment">%fl = 0;</span>                <span class="comment">%if fl</span>                <span class="comment">%flag=0;</span>                smoothed_curve = [xs,ys];                <span class="keyword">while</span> sum(flag==0) &gt; 0                    n = size(extremum,2);                    flag = ones(size(extremum));                    <span class="keyword">for</span> j=1:n                        <span class="comment">% second argument of curve_tangent function is always</span>                        <span class="comment">% the</span>                        <span class="comment">% position of the extrema in the first argument which is</span>                        <span class="comment">% an array of points between two extrema</span>                        <span class="keyword">if</span> j==1 &amp;&amp; j==n                            ang = curve_tangent(smoothed_curve(1:L,:), extremum(j));                        <span class="keyword">elseif</span> j==1                            ang = curve_tangent(smoothed_curve(1:extremum(j+1),:), extremum(j));                        <span class="keyword">elseif</span> j==n                            ang = curve_tangent(smoothed_curve(extremum(j-1):L,:), <spanclass="keyword">...</span>                                extremum(j)-extremum(j-1)+1);                        <span class="keyword">else</span>                            ang = curve_tangent(smoothed_curve(extremum(j-1):extremum(j+1),:), <spanclass="keyword">...</span>                                extremum(j)-extremum(j-1)+1);                        <span class="keyword">end</span>                        <span class="comment">% if angle is between T_angle = 162 and (360-T_angle) = 198</span>                        <span class="keyword">if</span> ang&gt;T_angle &amp;&amp; ang&lt;(360-T_angle)                            flag(j) = 0;                        <span class="keyword">end</span>                    <span class="keyword">end</span>                    <span class="keyword">if</span> size(extremum,2) == 0                        extremum = [];                    <span class="keyword">else</span>                        extremum = extremum(flag~=0);                    <span class="keyword">end</span>                <span class="keyword">end</span>                <span class="comment">% find corners which are not endpoints of the curve</span>                <span class="comment">%extremum=extremum(find(extremum&gt;0 &amp; extremum&lt;=curveLen));</span>                index{i} = extremum';                <span class="comment">% Sig(i,1) = sig;</span>                n = size(extremum,2);                <span class="keyword">for</span> j = 1:n                    corners = [corners; curve{i}(extremum(j),:)];      <spanclass="comment">%#ok</span>                    cd = [cd; C(extremum(j))];                         <spanclass="comment">%#ok</span>                <span class="keyword">end</span>                fl = 1;                <span class="keyword">if</span> fl &amp;&amp; strcmp(curve_mode(i,:),<spanclass="string">'loop'</span>) &amp;&amp; n&gt;1                    comp_corner = corners-ones(size(corners,1),1)*curve_start(i,:);                    comp_corner = comp_corner.^2;                    comp_corner = comp_corner(:,1) + comp_corner(:,2);                    <span class="keyword">if</span> min(comp_corner)&gt;100                        <span class="comment">% add end points far from detected corners, i.e.</span>                        <span class="comment">% outside of 5 by 5 neighbor</span>                        left = smoothed_curve(extremum(1):-1:1,:);                        right = smoothed_curve(end:-1:extremum(end),:);                        <span class="comment">% detect corner at the first point or last point of the</span>                        <span class="comment">% loop curve</span>                        ang = curve_tangent([left;right],extremum(1));                        <span class="comment">% if angle is between T_angle = 162 and (360-T_angle) = 198</span>                        <span class="keyword">if</span> ang&gt;T_angle &amp;&amp; ang&lt;(360-T_angle)                        <span class="keyword">else</span><span class="comment">%if C(W+1)&gt;T/2</span>                            corners = [corners; curve_start(i,:)];     <spanclass="comment">%#ok</span>                            cd = [cd;5];                               <spanclass="comment">%#ok</span>                        <span class="keyword">end</span>                    <span class="keyword">end</span>                <span class="keyword">end</span>            <span class="keyword">end</span>        <span class="keyword">end</span>    <span class="keyword">end</span><span class="keyword">end</span><span class="keyword">end</span> <span class="comment">% end of getcorner</span></pre>      <p><tt>ACCUMULATE_CHORD_DISTANCE</tt> - Accumulate chord        distances.</p>      <pre class="codeinput"><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> Cd = <span class="keyword">...</span>    accumulate_chord_distance(xs, ys, chordLen, curveLen, point_selected, W)Cd = zeros(1,curveLen);<span class="keyword">for</span> j = 1:size(point_selected,2)    k = point_selected(j)+W;    <span class="comment">%if k&gt;W</span>    xk = xs(k); <span class="comment">% (x1,y1) = point at which distance will be accumulated</span>    yk = ys(k);    <span class="keyword">if</span> k-chordLen+1 &lt; 1,    s = 1;    <span class="keyword">else</span>                    s = k-chordLen+1;    <span class="keyword">end</span>    <span class="keyword">for</span> i = s:k-1        <span class="keyword">if</span> i+chordLen &lt;= curveLen            <span class="comment">% (leftx,lefty) = current left point for which distance will be</span>            <span class="comment">% accumulated</span>            x1 = xs(i);            y1 = ys(i);            <span class="comment">% (rightx,righty) = current right point for which distance will</span>            <span class="comment">% be accumulated</span>            x2 = xs(i+chordLen);            y2 = ys(i+chordLen);            <span class="comment">% coefficients of st. line through points (x1,y1) and (x2,y2)</span>            a = y2-y1;            b = x1-x2;            c = x2*y1 - x1*y2;            d = sqrt(a*a+b*b);            <span class="keyword">if</span> d~=0,  dist = (a*xk + b*yk + c)/d;            <span class="keyword">else</span>      dist = 0;            <span class="keyword">end</span>            Cd(1,k) = Cd(1,k)+ dist;        <span class="keyword">else</span>            <span class="keyword">break</span>;        <span class="keyword">end</span>    <span class="keyword">end</span><span class="keyword">end</span><span class="keyword">end</span> <span class="comment">% end of accumulate_chord_distance</span></pre>      <p><tt>EXTRACT_CURVE</tt> - Extract curves from input binary edge        map: if the endpoint of a contour is nearly connected to another        endpoint, fill the gap and continue the extraction.</p>      <pre class="codeinput"><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> [curve, curve_start, curve_end, curve_mode, cur_num, TJ, BW_edge] = <spanclass="keyword">...</span>    extract_curve(BW, Gap_size)<span class="comment">% the default gap size is 1 pixel</span>[L,W] = size(BW);BW1 = zeros(L+2*Gap_size,W+2*Gap_size);BW_edge = zeros(L,W);BW1(Gap_size+1:Gap_size+L,Gap_size+1:Gap_size+W) = BW;[r,c] = find(BW1==1); <span class="comment">% returns indices of non-zero elements</span>cur_num = 0;<span class="keyword">while</span> size(r,1)&gt;0 <span class="comment">% when number of rows &gt; 0</span>    point = [r(1),c(1)];    cur = point;    <span class="comment">% mask the pixel</span>    BW1(point(1),point(2)) = 0;    <span class="comment">% find if any pixel around the current point is an edge pixel</span>    [I,J] = find(BW1(point(1)-Gap_size:point(1)+Gap_size,point(2)-Gap_size:point(2)+Gap_size)==1);    <span class="keyword">while</span> size(I,1) &gt; 0 <span class="comment">%if number of row &gt; 0</span>        dist = (I-Gap_size-1).^2 + (J-Gap_size-1).^2;        [~,index] = min(dist);        p = point+[I(index),J(index)];        <span class="comment">% next is the current point</span>        point = p-Gap_size-1;        <span class="comment">% add point to curve</span>        cur = [cur;point];                                             <spanclass="comment">%#ok</span>        <span class="comment">% mask the pixel</span>        BW1(point(1),point(2)) = 0;        <span class="comment">% find if any pixel around the current point is an edge pixel</span>        [I,J] = find(BW1(point(1)-Gap_size:point(1)+Gap_size,point(2)-Gap_size:point(2)+Gap_size)==1);    <span class="keyword">end</span>    <span class="comment">% Extract edge towards another direction</span>    point  =[r(1),c(1)];    BW1(point(1),point(2)) = 0;    [I,J] = find(BW1(point(1)-Gap_size:point(1)+Gap_size,point(2)-Gap_size:point(2)+Gap_size)==1);    <span class="keyword">while</span> size(I,1)&gt;0        dist = (I-Gap_size-1).^2 + (J-Gap_size-1).^2;        [~,index] = min(dist);        point = point+[I(index),J(index)]-Gap_size-1;        cur = [point;cur];                                             <spanclass="comment">%#ok</span>        BW1(point(1),point(2)) = 0;        [I,J] = find(BW1(point(1)-Gap_size:point(1)+Gap_size,point(2)-Gap_size:point(2)+Gap_size)==1);    <span class="keyword">end</span>    <span class="comment">% ?!!! for 512 by 512 image, choose curve if its length &gt; 40 ?!!!</span>    <span class="keyword">if</span> size(cur,1)&gt;(size(BW,1)+size(BW,2))/25        <span class="comment">% one can change this value to control the length of the extracted edges</span>        cur_num = cur_num+1;        curve{cur_num} = cur-Gap_size;                                 <spanclass="comment">%#ok</span>    <span class="keyword">end</span>    [r,c] = find(BW1==1);<span class="keyword">end</span>curve_mode = char(zeros(cur_num,4));<span class="keyword">for</span> i=1:cur_num    curve_start(i,:) = curve{i}(1,:);                                  <spanclass="comment">%#ok</span>    curve_end(i,:) = curve{i}(size(curve{i},1),:);                     <spanclass="comment">%#ok</span>    <span class="keyword">if</span> (curve_start(i,1)-curve_end(i,1))^2+<spanclass="keyword">...</span>        (curve_start(i,2)-curve_end(i,2))^2&lt;=25  <span class="comment">%if curve's ends are within sqrt(32) pixels</span>        curve_mode(i,:) = <span class="string">'loop'</span>;    <span class="keyword">else</span>        curve_mode(i,:) = <span class="string">'line'</span>;    <span class="keyword">end</span>    BW_edge(curve{i}(:,1)+(curve{i}(:,2)-1)*L) = 1;<span class="keyword">end</span><span class="comment">% if a contour goes just outsize of ends, i.e., outside of gapsize we note</span><span class="comment">% a T-junction there</span><span class="keyword">if</span> cur_num&gt;0    TJ = find_TJunctions(curve, cur_num, Gap_size+1);<span class="keyword">else</span>    curve{1} = [];    curve_start = [];    curve_end = [];    curve_mode = [];    cur_num = [];    TJ = [];<span class="keyword">end</span><span class="keyword">end</span> <span class="comment">% end of extract_curve</span></pre>      <p><tt>FIND_TJUNCTIONS</tt> - Find T-junctions in planar curves        within (gap by gap) neighborhood, where gap = Gap_size + 1;        edges were continued when ends are within (Gap_size by Gap_size)</p>      <pre class="codeinput"><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> TJ = find_TJunctions(curve, cur_num, gap)TJ = [];<span class="keyword">for</span> i = 1:cur_num    cur = curve{i};    szi = size(cur,1);    <span class="keyword">for</span> j = 1:cur_num        <span class="keyword">if</span> i ~= j            temp_cur = curve{j};            comp_send = temp_cur - ones(size(temp_cur, 1),1)* cur(1,:);            comp_send = comp_send.^2;            comp_send = comp_send(:,1)+comp_send(:,2);            <span class="comment">% add curve strat-points as T-junctions using a (gap by gap)</span>            <span class="comment">% neighborhood</span>            <span class="keyword">if</span> min(comp_send)&lt;=gap*gap                TJ = [TJ; cur(1,:)];                                   <spanclass="comment">%#ok</span>            <span class="keyword">end</span>            comp_eend = temp_cur - ones(size(temp_cur, 1),1)* cur(szi,:);            comp_eend = comp_eend.^2;            comp_eend = comp_eend(:,1)+comp_eend(:,2);            <span class="comment">% add end-points T-junctions using a (gap by gap) neighborhood</span>            <span class="keyword">if</span> min(comp_eend) &lt;= gap*gap                TJ = [TJ; cur(szi,:)];                                 <spanclass="comment">%#ok</span>            <span class="keyword">end</span>        <span class="keyword">end</span>    <span class="keyword">end</span><span class="keyword">end</span><span class="keyword">end</span> <span class="comment">% end of find_TJunctions</span></pre>      <p><tt>REFINE_TJUNCTIONS</tt> - Compare T-junctions with obtained        corners and add T-junctions to corners which are far away        (outside a 5 by 5 neighborhood) from detected corners</p>      <pre class="codeinput"><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> [corner_final c3] = <span class="keyword">...</span>    Refine_TJunctions(corner_out, TJ, c2,curve, curve_num, curve_start, curve_end, curve_mode,EP)<span class="comment">% corner_final = corner_out;</span>c3 = c2;<span class="comment">% add end points</span><span class="keyword">if</span> EP    corner_num = size(corner_out,1);    <span class="keyword">for</span> i=1:curve_num        <span class="keyword">if</span> size(curve{i},1)&gt;0 &amp;&amp; strcmpi(curve_mode(i,:),<spanclass="string">'line'</span>)            <span class="comment">% Start point compare with detected corners</span>            comp_corner = corner_out - ones(size(corner_out,1),1)*curve_start(i,:);            comp_corner = comp_corner.^2;            comp_corner = comp_corner(:,1) + comp_corner(:,2);            <span class="keyword">if</span> min(comp_corner) &gt; 100       <spanclass="comment">% Add end points far from detected corners</span>                corner_num = corner_num + 1;                corner_out(corner_num,:) = curve_start(i,:);                c3 = [c3;8];                                           <spanclass="comment">%#ok</span>            <span class="keyword">end</span>            <span class="comment">% End point compare with detected corners</span>            comp_corner = corner_out - ones(size(corner_out,1),1)*curve_end(i,:);            comp_corner = comp_corner.^2;            comp_corner = comp_corner(:,1) + comp_corner(:,2);            <span class="keyword">if</span> min(comp_corner) &gt; 100                corner_num = corner_num + 1;                corner_out(corner_num,:) = curve_end(i,:);                c3 = [c3;9];                                           <spanclass="comment">%#ok</span>            <span class="keyword">end</span>        <span class="keyword">end</span>    <span class="keyword">end</span><span class="keyword">end</span><span class="comment">% add T-junctions</span>corner_final = corner_out;<span class="keyword">for</span> i=1:size(TJ,1)    <span class="comment">% T-junctions compared with detected corners</span>    <span class="keyword">if</span> size(corner_final)&gt;0        comp_corner = corner_final - ones(size(corner_final,1),1)*TJ(i,:);        comp_corner = comp_corner.^2;        comp_corner = comp_corner(:,1) + comp_corner(:,2);        <span class="keyword">if</span> min(comp_corner) &gt; 100       <spanclass="comment">% Add end points far from detected corners, i.e. outside of 5 by 5 neighbor</span>            corner_final = [corner_final; TJ(i,:)];                    <spanclass="comment">%#ok</span>            c3 = [c3;10];                                              <spanclass="comment">%#ok</span>        <span class="keyword">end</span>    <span class="keyword">else</span>        corner_final = [corner_final; TJ(i,:)];                        <spanclass="comment">%#ok</span>        c3 = [c3;10];                                                  <spanclass="comment">%#ok</span>    <span class="keyword">end</span><span class="keyword">end</span><span class="keyword">end</span> <span class="comment">% end of Refine_TJunctions</span></pre>      <p><tt>CURVE_TANGENT</tt> - Compute the tangent direction over a        curve.</p>      <pre class="codeinput"><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> ang = curve_tangent(cur, center)<span class="comment">% center is always the position of the corresponding extrema in cur</span>dir = zeros(2,1);<span class="keyword">for</span> i=1:2    <span class="keyword">if</span> i == 1,     curve = cur(center:-1:1,:);    <span class="keyword">else</span>           curve = cur(center:size(cur,1),:);    <span class="keyword">end</span>    L = size(curve,1);    <span class="keyword">if</span> L&gt;3        <span class="keyword">if</span> sum(curve(1,:) ~= curve(L,:))~=0 <spanclass="comment">% if not collinear</span>            M = ceil(L/2);            x1 = curve(1,1);    y1 = curve(1,2);            x2 = curve(M,1);    y2 = curve(M,2);            x3 = curve(L,1);    y3 = curve(L,2);        <span class="keyword">else</span>            M1 = ceil(L/3);     M2 = ceil(2*L/3);            x1 = curve(1,1);    y1 = curve(1,2);            x2 = curve(M1,1);   y2 = curve(M1,2);            x3 = curve(M2,1);   y3 = curve(M2,2);        <span class="keyword">end</span>        <span class="keyword">if</span> abs((x1-x2)*(y1-y3) - (x1-x3)*(y1-y2))&lt;1e-8  <spanclass="comment">% straight line</span>            tangent_dir = <span class="keyword">...</span>                angle(complex(curve(L,1)-curve(1,1), curve(L,2)-curve(1,2)));        <span class="keyword">else</span>            <span class="comment">% Fit a circle</span>            x0 = 1/2 * (-y1*x2^2 + y3*x2^2 - y3*y1^2 - y3*x1^2 - y2*y3^2 + <spanclass="keyword">...</span>                x3^2*y1 + y2*y1^2 - y2*x3^2 - y2^2*y1 + y2*x1^2 + y3^2*y1 + <spanclass="keyword">...</span>                y2^2*y3) / (-y1*x2 + y1*x3 + y3*x2 + x1*y2 - x1*y3 - x3*y2);            y0 = -1/2 * (x1^2*x2 - x1^2*x3 + y1^2*x2 - y1^2*x3 + x1*x3^2 - <spanclass="keyword">...</span>                x1*x2^2 - x3^2*x2 - y3^2*x2 + x3*y2^2 + x1*y3^2 - x1*y2^2 + <spanclass="keyword">...</span>                x3*x2^2) / (-y1*x2 + y1*x3 + y3*x2 + x1*y2 - x1*y3 - x3*y2);            <span class="comment">% R = (x0-x1)^2+(y0-y1)^2;</span>            radius_dir = angle(complex(x0-x1,y0-y1));            <span class="keyword">if</span> radius_dir&lt;0                radius_dir = 2*pi-abs(radius_dir);            <span class="keyword">end</span>            adjacent_dir = angle(complex(x2-x1,y2-y1));            <span class="keyword">if</span> adjacent_dir&lt;0                adjacent_dir = 2*pi-abs(adjacent_dir);            <span class="keyword">end</span>            tangent_dir = sign(sin(adjacent_dir-radius_dir))*pi/2 + radius_dir;            <span class="keyword">if</span> tangent_dir&lt;0                tangent_dir = 2*pi-abs(tangent_dir);            <span class="keyword">elseif</span> tangent_dir&gt;2*pi                tangent_dir = tangent_dir-2*pi;            <span class="keyword">end</span>        <span class="keyword">end</span>    <span class="keyword">else</span> <span class="comment">% very short line</span>        tangent_dir = <span class="keyword">...</span>            angle(complex(curve(L,1)-curve(1,1),curve(L,2)-curve(1,2)));    <span class="keyword">end</span>    dir(i) = tangent_dir*180/pi;<span class="keyword">end</span>ang = abs(dir(1) - dir(2));<span class="keyword">end</span> <span class="comment">% end of curve_tangent</span></pre>      <p><tt>MAKEGFILTER</tt></p>      <pre class="codeinput"><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> [G W] = makeGFilter(sig)GaussianDieOff = .0001;pw = 1:100;ssq = sig*sig;W = find(exp(-(pw.*pw)/(2*ssq))&gt;GaussianDieOff, 1, <span class="string">'last'</span>);<span class="keyword">if</span> isempty(W),     W = 1;   <span class="keyword">end</span>t = (-W:W);gau = exp(-(t.*t)/(2*ssq))/(2*pi*ssq);G = gau/sum(gau);<span class="keyword">end</span> <span class="comment">% end of makeGFilter</span></pre>      <p><tt>FIND_GAUSSIAN</tt></p>      <pre class="codeinput"><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> [gau width] = find_Gaussian(sig)GaussianDieOff = .0001;pw = 1:30;ssq = sig*sig;width = find(exp(-(pw.*pw)/(2*ssq))&gt;GaussianDieOff, 1, <span class="string">'last'</span>);<span class="keyword">if</span> isempty(width),    width = 1;   <span class="keyword">end</span>t = (-width:width);gau = exp(-(t.*t)/(2*ssq))/(2*pi*ssq);gau = gau/sum(gau);<span class="keyword">end</span> <span class="comment">% end of find_Gaussian</span></pre>      <p><tt>ENLARGE</tt></p>      <pre class="codeinput"><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> [xse yse] = enlarge(xs, ys, CL, curve_mode)                   <spanclass="comment">%#ok</span><span class="comment">% CL = chord length</span>L = size(xs,1);<span class="keyword">if</span> strcmpi(curve_mode,<span class="string">'loop'</span>) <spanclass="comment">% wrap around the curve by CL pixles at both ends</span>    xse = [xs(L-CL+1:L); <span class="keyword">...</span>        xs; <span class="keyword">...</span>        xs(1:CL)];    yse = [ys(L-CL+1:L); <span class="keyword">...</span>        ys; <span class="keyword">...</span>        ys(1:CL)];<span class="keyword">else</span> <span class="comment">% extend each line curve by CL pixels at both ends</span>    xse = [ones(CL,1)*2*xs(1)-xs(CL+1:-1:2); <span class="keyword">...</span>        xs; <span class="keyword">...</span>        ones(CL,1)*2*xs(L)-xs(L-1:-1:L-CL)];    yse = [ones(CL,1)*2*ys(1)-ys(CL+1:-1:2); <span class="keyword">...</span>        ys; <span class="keyword">...</span>        ones(CL,1)*2*ys(L)-ys(L-1:-1:L-CL)];<span class="keyword">end</span><span class="keyword">end</span> <span class="comment">% end of enlarge</span></pre>      <p><tt>SMOOTHING</tt></p>      <pre class="codeinput"><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> [xs ys gau W] = smoothing(x, y, L, curve_mode, sig, mode)     <spanclass="comment">%#ok</span>[gau W] = makeGFilter(sig);<span class="keyword">if</span> L&gt;W    <span class="keyword">if</span> strcmpi(curve_mode,<span class="string">'loop'</span>) <spanclass="comment">% wrap around the curve by W pixles at both ends</span>        x1 = [x(L-W+1:L); <span class="keyword">...</span>            x; <span class="keyword">...</span>            x(1:W)];        y1 = [y(L-W+1:L); <span class="keyword">...</span>            y; <span class="keyword">...</span>            y(1:W)];    <span class="keyword">else</span> <span class="comment">% extend each line curve by W pixels at both ends</span>        x1 = [ones(W,1)*2*x(1)-x(W+1:-1:2); <span class="keyword">...</span>            x; <span class="keyword">...</span>            ones(W,1)*2*x(L)-x(L-1:-1:L-W)];        y1 = [ones(W,1)*2*y(1)-y(W+1:-1:2); <span class="keyword">...</span>            y; <span class="keyword">...</span>            ones(W,1)*2*y(L)-y(L-1:-1:L-W)];    <span class="keyword">end</span>    xx = conv(x1,gau);    yy = conv(y1,gau);    <span class="keyword">if</span> (mode == 1)        xs = xx(W+1:L+3*W);        ys = yy(W+1:L+3*W);    <span class="keyword">else</span>        xs = xx(2*W+1:L+2*W);        ys = yy(2*W+1:L+2*W);    <span class="keyword">end</span><span class="keyword">else</span>    xs = [];    ys = [];<span class="keyword">end</span><span class="keyword">end</span> <span class="comment">% end of smoothing</span></pre>      <p><tt>FIND_SIG</tt></p>      <pre class="codeinput"><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> [sig] = find_sig(L)                                           <spanclass="comment">%#ok</span><span class="keyword">if</span> L&lt;=100    sig = 3;    <span class="comment">%wid = 4;</span><span class="keyword">elseif</span> L&lt;=200    sig = 3;    <span class="comment">%wid = 8;</span><span class="keyword">else</span>    sig = 3;    <span class="comment">%wid = 12;</span><span class="keyword">end</span><span class="keyword">end</span> <span class="comment">% end of find_sig</span></pre> </div>    <!--##### SOURCE BEGIN #####%% FASTCPDA_BASE - Base function for FASTCPDA.%%% Syntax%     [pt, map, cd] = FASTCPDA_BASE(BW, Gap_size, T_angle, EP);%%% Acknowledgement% This is an adaptation of the original code of [AL08,ALFR09] available at:%  <http://www.mathworks.com/matlabcentral/fileexchange/28207-a-fast-corner-detector-based-on-the-chord-to-point-distance-accumulation-technique>%% Part of this code was already from the source code of [HY04,HY08] available at:%  <http://www.mathworks.com/matlabcentral/fileexchange/loadFile.do?objectId=7652&objectType=file>%%% Contact% <mailto:grazzja@lanl.gov J.Grazzini> (ISR-2/LANL)%%% See also% Related:% <FASTCPDA.html |FASTCPDA|>,% <HARRISCORNER_BASE.html |HARRISCORNER_BASE|>,% <SUSANCORNER_BASE.html |SUSANCORNER_BASE|>,% <EDGECORNER_BASE.html |EDGECORNER_BASE|>,% <FASTCORNER_BASE.html |FASTCORNER_BASE|>.%% Function implementationfunction [pt, varargout] = fastcpda_base(BW, Gap_size, T_angle, EP)[sizex sizey C] = size(BW);%%% dealing with multispectral imagespt = cell(C,1);if nargout>=2     varargout{1} = false(size(BW));    if nargout==3, varargout{2} = cell(C,1); end;endif C>1    for c=1:C        [tmp1, tmp2, tmp3] = fastcpda_base(BW(:,:,c), Gap_size, T_angle, EP);        pt{c} = tmp1{1};        if nargout>=2,             varargout{1}(:,:,c) = tmp2;            if nargout==3, varargout{2}{c} = tmp3{1};  end;        end     end    return;end%% % extract curves from the edge-image[curve, curve_start, curve_end, curve_mode, curve_num, TJ, BW_edge] = ...    extract_curve(BW, Gap_size);  % curve : MATLAB cell data structure where each cell is a 2D array containing%         pixel locations (x and y values)% curve_start : starting points of extracted curves% curve_end : ending points of extracted curves% curve_mode : two curve modes - 'line' and 'loop'. If the both ends of%              a curve are at maximum 25 square pixels (default) away, then %              the curve is a loop curve, otherwise a line curve% curve_num : number of extracted curves% TJ : the T-junction found in the edge-extraction processBW_edge;                                                               %#okif ~isempty(curve)        [point_selected, smoothed_curve, Width] = ...        selectPoint(curve, curve_mode, curve_num, sizex, sizey);        % detect corners on the extracted edges    [pt{1}, ~, cd2] = ...        getcorner(curve, curve_mode, curve_start, curve_num, T_angle, ...        point_selected, smoothed_curve, Width);    % pt : n by 2 matrix containing the positions of the detected corners,    %      where n is the number of detected corners    % index : MATLAB cell data structure where each cell is an 1D column    %         matrix contaning the edge pixel numbers (in curve) where the    %         corners are detected    % Sig : the sigma values used to smooth the curves    % cd2 : cpda curvature values of the detected corners        % update the T-junctions    [pt{1}, cd{1}] = ...        Refine_TJunctions(pt{1}, TJ, cd2, ...        curve, curve_num, curve_start, curve_end, curve_mode, EP);    % pt : n by 2 matrix containing the positions of the detected corners,    %      where n is the number of detected corners    % cd : cpda curvature values of the detected corners        if nargout >= 2        varargout{1} = false(size(BW));        varargout{1}(sub2ind([sizex,sizey],pt{1}(:,1),pt{1}(:,2))) = true;        if nargout == 3,  varargout{2}{1} = cd;  end    end        else    pt{1} = [];    for i=1:nargout-1, varargout{i} = [];   endendend % end of fastcpda_base%% Subfunctions%%% |SELECTPOINT| - Select points from extracted curves.%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction [point_selected smoothed_curve Width Sig] = ...    selectPoint(curve, curve_mode, curve_num, sizex, sizey)%S = 1.5*s;s = 3.0;S = 4.0;[gau w] = find_Gaussian(s);[Gau W] = find_Gaussian(S);extra = W-w;gau1 = [zeros(1,extra) gau zeros(1,extra)];DoG = Gau-gau1;%t = 0.1;smoothed_curve = cell(curve_num);point_selected = cell(curve_num);Width = w; Sig = s;for i = 1:curve_num        x = curve{i}(:,2) - sizey/2;    y = sizex/2 - curve{i}(:,1);    L = size(x,1);    if (L>W)        % Calculate curvature        if strcmpi(curve_mode(i,:),'loop')            x1=[x(L-W+1:L);x;x(1:W)];            y1=[y(L-W+1:L);y;y(1:W)];        else            x1=[ones(W,1)*2*x(1)-x(W+1:-1:2); ...                x; ...                ones(W,1)*2*x(L)-x(L-1:-1:L-W)];            y1=[ones(W,1)*2*y(1)-y(W+1:-1:2); ...                y; ...                ones(W,1)*2*y(L)-y(L-1:-1:L-W)];        end                xx = conv(x1,DoG);        xx = xx(W+1:L+3*W);        yy = conv(y1,DoG);        yy = yy(W+1:L+3*W);        K = xx.^2 + yy.^2;                % Find curvature local maxima as corner candidates        N = size(K,1);        n = 0;        Search = 1;        extremum = zeros(1,N);                for j=1:N-1            if (K(j+1)-K(j))*Search>0                n=n+1;                % in extremum, odd points is minima and even points is maxima                extremum(n) = j;                Search = -Search;            end        end        if mod(n,2)==0            n = n+1;            extremum(n) = N;        end        extremum(n+1:N) = [];        %n=size(extremum,2);        %flag=ones(size(extremum));                % Compare with adaptive local threshold to remove round corners        %for j=2:2:n        %    if K(extremum(j))<t        %        flag(j)=0;        %    end        %end        extremum = extremum(2:2:n);        %flag=flag(2:2:n);        %extremum=extremum(find(flag==1));        extremum = extremum-W;        extremum = extremum(extremum>0 & extremum<=L);                xx = conv(x1,gau);        xx = xx(W+1:L+3*W);        yy = conv(y1,gau);        yy = yy(W+1:L+3*W);                smoothed_curve{i} = [xx yy];        point_selected{i} = extremum;        %Width = [Width W];        %Sig = [Sig s];    else        smoothed_curve{i} = [];        point_selected{i} = [];        %Width = [Width 0];        %Sig = [Sig 0];    end    %here = 1;endend % end of selectPoint%%% |GETCORNER| - Extract corners from curve representation.%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction [corners index cd] = ...    getcorner(curve, curve_mode, curve_start, curve_num, T_angle, point_selected, sm_curve, W)corners = [];cd = [];CLen = [10 20 30];T = 0.2; % define the curvature thresholdindex = cell(curve_num);for i=1:curve_num;    % C = [];  C3 = [];    %x = curve{i}(:,2) - sizey/2;    %y = sizex/2 - curve{i}(:,1);    %curveLen = size(x,1);    %[sig] = find_sig(curveLen);    % smooth the curve with Gaussian kernel    %[xs ys gau W] = smoothing(x,y,curveLen,curve_mode(i,:),sig,1);    %xs = sm_curve{i}(:,1);    %ys = sm_curve{i}(:,2);    %W = Width(i);            if ~isempty(sm_curve{i})        xs = sm_curve{i}(:,2) ;        ys = sm_curve{i}(:,1);        L = size(xs,1);        curveLen = L-2*W;        %curveLen = L-2*W;        %sig = Sigma(i);        if L>1            %if curve_mode(i,:)=='loop'            %    xs1=[xs(curveLen-W+1:curveLen);xs;xs(1:W)];            %    ys1=[ys(curveLen-W+1:curveLen);ys;ys(1:W)];            %else %expand the ends to gaussian window            %    xs1=[ones(W,1)*2*xs(1)-xs(W+1:-1:2); ...            %         xs; ...            %         ones(W,1)*2*xs(curveLen)-xs(curveLen-1:-1:curveLen-W)];            %    ys1=[ones(W,1)*2*ys(1)-ys(W+1:-1:2); ...            %         ys; ...            %         ones(W,1)*2*ys(curveLen)-ys(curveLen-1:-1:curveLen-W)];            %end            %xs = xs1;            %ys = ys1;            %L = curveLen+2*W;            extremum = point_selected{i};            if size(extremum,2)>0                C3 = zeros(3,L);                for j = 1:3                    chordLen = CLen(1,j);                    C3(j,1:L) = abs(accumulate_chord_distance(xs,ys,chordLen,L,extremum,W));                end                c1 = C3(1,W+1:curveLen+W)/max(C3(1,W+1:curveLen+W));                c2 = C3(2,W+1:curveLen+W)/max(C3(2,W+1:curveLen+W));                c3 = C3(3,W+1:curveLen+W)/max(C3(3,W+1:curveLen+W));                                C = c1.*c2.*c3;                %A = mean(C);                L = curveLen;                xs = xs(W+1:L+W);                ys = ys(W+1:L+W);                %flag = (extremum > W & extremum <= L+W);                %extremum = extremum(flag == 1);                %extremum = extremum-W;                                % Find curvature local maxima as corner candidates                %extremum=[];                %N=size(C,2);                %n=0;                %Search=1;                                %for j=1:N-1                %    if (C(j+1)-C(j))*Search>0                %        n=n+1;                % % In extremum, odd points are minima and even points are maxima                %        extremum(n)=j;                % % minima: when K starts to go up; maxima: when K starts to go down                %        Search=-Search;                %    end                %end                %if mod(size(extremum,2),2)==0 %to make odd number of extrema                %    n=n+1;                %    extremum(n)=N;                %end                                % accumulate candidate corners                %n = size(extremum,2);                %for j = 1:n                %    cor = [cor; curve{i}(extremum(j),:)];                %end                                n = size(extremum,2);                flag = ones(size(extremum));                                % Compare each maxima with its contour average                % if the maxima is less than local minima, remove it as false corner                for j=1:n                    if (C(extremum(j)) > T),   flag(j)=0;  end                end                %extremum = extremum(2:2:n); % only maxima are corners, not minima                %flag = flag(2:2:n);                extremum = extremum(flag==0);                                % Check corner angle to remove false corners due to boundary noise and trivial details                %fl = 0;                %if fl                %flag=0;                smoothed_curve = [xs,ys];                while sum(flag==0) > 0                    n = size(extremum,2);                    flag = ones(size(extremum));                    for j=1:n                        % second argument of curve_tangent function is always                        % the                        % position of the extrema in the first argument which is                        % an array of points between two extrema                        if j==1 && j==n                            ang = curve_tangent(smoothed_curve(1:L,:), extremum(j));                        elseif j==1                            ang = curve_tangent(smoothed_curve(1:extremum(j+1),:), extremum(j));                        elseif j==n                            ang = curve_tangent(smoothed_curve(extremum(j-1):L,:), ...                                extremum(j)-extremum(j-1)+1);                        else                            ang = curve_tangent(smoothed_curve(extremum(j-1):extremum(j+1),:), ...                                extremum(j)-extremum(j-1)+1);                        end                        % if angle is between T_angle = 162 and (360-T_angle) = 198                        if ang>T_angle && ang<(360-T_angle)                            flag(j) = 0;                        end                    end                                        if size(extremum,2) == 0                        extremum = [];                    else                        extremum = extremum(flag~=0);                    end                end                % find corners which are not endpoints of the curve                %extremum=extremum(find(extremum>0 & extremum<=curveLen));                index{i} = extremum';                % Sig(i,1) = sig;                n = size(extremum,2);                                for j = 1:n                    corners = [corners; curve{i}(extremum(j),:)];      %#ok                    cd = [cd; C(extremum(j))];                         %#ok                end                                                fl = 1;                if fl && strcmp(curve_mode(i,:),'loop') && n>1                    comp_corner = corners-ones(size(corners,1),1)*curve_start(i,:);                    comp_corner = comp_corner.^2;                    comp_corner = comp_corner(:,1) + comp_corner(:,2);                    if min(comp_corner)>100                        % add end points far from detected corners, i.e.                        % outside of 5 by 5 neighbor                        left = smoothed_curve(extremum(1):-1:1,:);                        right = smoothed_curve(end:-1:extremum(end),:);                        % detect corner at the first point or last point of the                        % loop curve                        ang = curve_tangent([left;right],extremum(1));                                                % if angle is between T_angle = 162 and (360-T_angle) = 198                        if ang>T_angle && ang<(360-T_angle)                        else%if C(W+1)>T/2                            corners = [corners; curve_start(i,:)];     %#ok                            cd = [cd;5];                               %#ok                        end                    end                end            end        end    endendend % end of getcorner%%% |ACCUMULATE_CHORD_DISTANCE| - Accumulate chord distances.%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction Cd = ...    accumulate_chord_distance(xs, ys, chordLen, curveLen, point_selected, W)Cd = zeros(1,curveLen);for j = 1:size(point_selected,2)    k = point_selected(j)+W;    %if k>W    xk = xs(k); % (x1,y1) = point at which distance will be accumulated    yk = ys(k);        if k-chordLen+1 < 1,    s = 1;    else                    s = k-chordLen+1;    end        for i = s:k-1        if i+chordLen <= curveLen            % (leftx,lefty) = current left point for which distance will be            % accumulated            x1 = xs(i);            y1 = ys(i);                        % (rightx,righty) = current right point for which distance will            % be accumulated            x2 = xs(i+chordLen);            y2 = ys(i+chordLen);                        % coefficients of st. line through points (x1,y1) and (x2,y2)            a = y2-y1;            b = x1-x2;            c = x2*y1 - x1*y2;                        d = sqrt(a*a+b*b);            if d~=0,  dist = (a*xk + b*yk + c)/d;            else      dist = 0;            end            Cd(1,k) = Cd(1,k)+ dist;        else            break;        end    end    endend % end of accumulate_chord_distance%%% |EXTRACT_CURVE| - Extract curves from input binary edge map: if the endpoint% of a contour is nearly connected to another endpoint, fill the gap and continue% the extraction.%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction [curve, curve_start, curve_end, curve_mode, cur_num, TJ, BW_edge] = ...    extract_curve(BW, Gap_size)% the default gap size is 1 pixel[L,W] = size(BW);BW1 = zeros(L+2*Gap_size,W+2*Gap_size);BW_edge = zeros(L,W);BW1(Gap_size+1:Gap_size+L,Gap_size+1:Gap_size+W) = BW;[r,c] = find(BW1==1); % returns indices of non-zero elementscur_num = 0;while size(r,1)>0 % when number of rows > 0    point = [r(1),c(1)];    cur = point;    % mask the pixel    BW1(point(1),point(2)) = 0;     % find if any pixel around the current point is an edge pixel    [I,J] = find(BW1(point(1)-Gap_size:point(1)+Gap_size,point(2)-Gap_size:point(2)+Gap_size)==1);     while size(I,1) > 0 %if number of row > 0        dist = (I-Gap_size-1).^2 + (J-Gap_size-1).^2;        [~,index] = min(dist);        p = point+[I(index),J(index)];        % next is the current point        point = p-Gap_size-1;        % add point to curve         cur = [cur;point];                                             %#ok        % mask the pixel        BW1(point(1),point(2)) = 0;        % find if any pixel around the current point is an edge pixel        [I,J] = find(BW1(point(1)-Gap_size:point(1)+Gap_size,point(2)-Gap_size:point(2)+Gap_size)==1);                  end        % Extract edge towards another direction    point  =[r(1),c(1)];    BW1(point(1),point(2)) = 0;    [I,J] = find(BW1(point(1)-Gap_size:point(1)+Gap_size,point(2)-Gap_size:point(2)+Gap_size)==1);        while size(I,1)>0        dist = (I-Gap_size-1).^2 + (J-Gap_size-1).^2;        [~,index] = min(dist);        point = point+[I(index),J(index)]-Gap_size-1;        cur = [point;cur];                                             %#ok        BW1(point(1),point(2)) = 0;        [I,J] = find(BW1(point(1)-Gap_size:point(1)+Gap_size,point(2)-Gap_size:point(2)+Gap_size)==1);    end            % ?!!! for 512 by 512 image, choose curve if its length > 40 ?!!!    if size(cur,1)>(size(BW,1)+size(BW,2))/25         % one can change this value to control the length of the extracted edges        cur_num = cur_num+1;        curve{cur_num} = cur-Gap_size;                                 %#ok    end    [r,c] = find(BW1==1);    endcurve_mode = char(zeros(cur_num,4));for i=1:cur_num    curve_start(i,:) = curve{i}(1,:);                                  %#ok    curve_end(i,:) = curve{i}(size(curve{i},1),:);                     %#ok    if (curve_start(i,1)-curve_end(i,1))^2+...        (curve_start(i,2)-curve_end(i,2))^2<=25  %if curve's ends are within sqrt(32) pixels        curve_mode(i,:) = 'loop';    else        curve_mode(i,:) = 'line';    end    BW_edge(curve{i}(:,1)+(curve{i}(:,2)-1)*L) = 1;end% if a contour goes just outsize of ends, i.e., outside of gapsize we note% a T-junction thereif cur_num>0    TJ = find_TJunctions(curve, cur_num, Gap_size+1); else    curve{1} = [];    curve_start = [];    curve_end = [];    curve_mode = [];    cur_num = [];    TJ = [];    endend % end of extract_curve%%% |FIND_TJUNCTIONS| - Find T-junctions in planar curves within (gap by gap)% neighborhood, where gap = Gap_size + 1; edges were continued when ends are% within (Gap_size by Gap_size)%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction TJ = find_TJunctions(curve, cur_num, gap)TJ = [];for i = 1:cur_num    cur = curve{i};    szi = size(cur,1);    for j = 1:cur_num        if i ~= j            temp_cur = curve{j};            comp_send = temp_cur - ones(size(temp_cur, 1),1)* cur(1,:);            comp_send = comp_send.^2;            comp_send = comp_send(:,1)+comp_send(:,2);            % add curve strat-points as T-junctions using a (gap by gap)            % neighborhood            if min(comp_send)<=gap*gap                TJ = [TJ; cur(1,:)];                                   %#ok            end                        comp_eend = temp_cur - ones(size(temp_cur, 1),1)* cur(szi,:);            comp_eend = comp_eend.^2;            comp_eend = comp_eend(:,1)+comp_eend(:,2);            % add end-points T-junctions using a (gap by gap) neighborhood            if min(comp_eend) <= gap*gap                TJ = [TJ; cur(szi,:)];                                 %#ok            end        end    endendend % end of find_TJunctions%%% |REFINE_TJUNCTIONS| - Compare T-junctions with obtained corners and add % T-junctions to corners which are far away (outside a 5 by 5 neighborhood) % from detected corners%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction [corner_final c3] = ...    Refine_TJunctions(corner_out, TJ, c2,curve, curve_num, curve_start, curve_end, curve_mode,EP)% corner_final = corner_out;c3 = c2;% add end pointsif EP    corner_num = size(corner_out,1);    for i=1:curve_num        if size(curve{i},1)>0 && strcmpi(curve_mode(i,:),'line')                        % Start point compare with detected corners            comp_corner = corner_out - ones(size(corner_out,1),1)*curve_start(i,:);            comp_corner = comp_corner.^2;            comp_corner = comp_corner(:,1) + comp_corner(:,2);            if min(comp_corner) > 100       % Add end points far from detected corners                corner_num = corner_num + 1;                corner_out(corner_num,:) = curve_start(i,:);                c3 = [c3;8];                                           %#ok            end                        % End point compare with detected corners            comp_corner = corner_out - ones(size(corner_out,1),1)*curve_end(i,:);            comp_corner = comp_corner.^2;            comp_corner = comp_corner(:,1) + comp_corner(:,2);            if min(comp_corner) > 100                corner_num = corner_num + 1;                corner_out(corner_num,:) = curve_end(i,:);                c3 = [c3;9];                                           %#ok            end        end    endend% add T-junctionscorner_final = corner_out;for i=1:size(TJ,1)    % T-junctions compared with detected corners    if size(corner_final)>0        comp_corner = corner_final - ones(size(corner_final,1),1)*TJ(i,:);        comp_corner = comp_corner.^2;        comp_corner = comp_corner(:,1) + comp_corner(:,2);        if min(comp_corner) > 100       % Add end points far from detected corners, i.e. outside of 5 by 5 neighbor            corner_final = [corner_final; TJ(i,:)];                    %#ok            c3 = [c3;10];                                              %#ok        end    else        corner_final = [corner_final; TJ(i,:)];                        %#ok        c3 = [c3;10];                                                  %#ok    endendend % end of Refine_TJunctions %%% |CURVE_TANGENT| - Compute the tangent direction over a curve.%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction ang = curve_tangent(cur, center) % center is always the position of the corresponding extrema in curdir = zeros(2,1);for i=1:2    if i == 1,     curve = cur(center:-1:1,:);    else           curve = cur(center:size(cur,1),:);      end    L = size(curve,1);        if L>3        if sum(curve(1,:) ~= curve(L,:))~=0 % if not collinear            M = ceil(L/2);            x1 = curve(1,1);    y1 = curve(1,2);            x2 = curve(M,1);    y2 = curve(M,2);            x3 = curve(L,1);    y3 = curve(L,2);        else            M1 = ceil(L/3);     M2 = ceil(2*L/3);            x1 = curve(1,1);    y1 = curve(1,2);            x2 = curve(M1,1);   y2 = curve(M1,2);            x3 = curve(M2,1);   y3 = curve(M2,2);        end                if abs((x1-x2)*(y1-y3) - (x1-x3)*(y1-y2))<1e-8  % straight line            tangent_dir = ...                angle(complex(curve(L,1)-curve(1,1), curve(L,2)-curve(1,2)));        else            % Fit a circle             x0 = 1/2 * (-y1*x2^2 + y3*x2^2 - y3*y1^2 - y3*x1^2 - y2*y3^2 + ...                x3^2*y1 + y2*y1^2 - y2*x3^2 - y2^2*y1 + y2*x1^2 + y3^2*y1 + ...                y2^2*y3) / (-y1*x2 + y1*x3 + y3*x2 + x1*y2 - x1*y3 - x3*y2);            y0 = -1/2 * (x1^2*x2 - x1^2*x3 + y1^2*x2 - y1^2*x3 + x1*x3^2 - ...                x1*x2^2 - x3^2*x2 - y3^2*x2 + x3*y2^2 + x1*y3^2 - x1*y2^2 + ...                x3*x2^2) / (-y1*x2 + y1*x3 + y3*x2 + x1*y2 - x1*y3 - x3*y2);            % R = (x0-x1)^2+(y0-y1)^2;            radius_dir = angle(complex(x0-x1,y0-y1));            if radius_dir<0                radius_dir = 2*pi-abs(radius_dir);            end                        adjacent_dir = angle(complex(x2-x1,y2-y1));                        if adjacent_dir<0                adjacent_dir = 2*pi-abs(adjacent_dir);            end                        tangent_dir = sign(sin(adjacent_dir-radius_dir))*pi/2 + radius_dir;            if tangent_dir<0                tangent_dir = 2*pi-abs(tangent_dir);            elseif tangent_dir>2*pi                tangent_dir = tangent_dir-2*pi;            end        end        else % very short line        tangent_dir = ...            angle(complex(curve(L,1)-curve(1,1),curve(L,2)-curve(1,2)));    end    dir(i) = tangent_dir*180/pi;endang = abs(dir(1) - dir(2));end % end of curve_tangent%%% |MAKEGFILTER|%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction [G W] = makeGFilter(sig)GaussianDieOff = .0001; pw = 1:100;ssq = sig*sig;W = find(exp(-(pw.*pw)/(2*ssq))>GaussianDieOff, 1, 'last');if isempty(W),     W = 1;   endt = (-W:W);gau = exp(-(t.*t)/(2*ssq))/(2*pi*ssq); G = gau/sum(gau);end % end of makeGFilter%%% |FIND_GAUSSIAN|%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction [gau width] = find_Gaussian(sig)GaussianDieOff = .0001; pw = 1:30; ssq = sig*sig;width = find(exp(-(pw.*pw)/(2*ssq))>GaussianDieOff, 1, 'last');if isempty(width),    width = 1;   endt = (-width:width);gau = exp(-(t.*t)/(2*ssq))/(2*pi*ssq); gau = gau/sum(gau);end % end of find_Gaussian%%% |ENLARGE|%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction [xse yse] = enlarge(xs, ys, CL, curve_mode)                   %#ok% CL = chord lengthL = size(xs,1);if strcmpi(curve_mode,'loop') % wrap around the curve by CL pixles at both ends    xse = [xs(L-CL+1:L); ...        xs; ...        xs(1:CL)];    yse = [ys(L-CL+1:L); ...        ys; ...        ys(1:CL)];else % extend each line curve by CL pixels at both ends    xse = [ones(CL,1)*2*xs(1)-xs(CL+1:-1:2); ...        xs; ...        ones(CL,1)*2*xs(L)-xs(L-1:-1:L-CL)];    yse = [ones(CL,1)*2*ys(1)-ys(CL+1:-1:2); ...        ys; ...        ones(CL,1)*2*ys(L)-ys(L-1:-1:L-CL)];endend % end of enlarge%%% |SMOOTHING|%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction [xs ys gau W] = smoothing(x, y, L, curve_mode, sig, mode)     %#ok[gau W] = makeGFilter(sig);if L>W    if strcmpi(curve_mode,'loop') % wrap around the curve by W pixles at both ends        x1 = [x(L-W+1:L); ...            x; ...            x(1:W)];        y1 = [y(L-W+1:L); ...            y; ...            y(1:W)];    else % extend each line curve by W pixels at both ends        x1 = [ones(W,1)*2*x(1)-x(W+1:-1:2); ...            x; ...            ones(W,1)*2*x(L)-x(L-1:-1:L-W)];        y1 = [ones(W,1)*2*y(1)-y(W+1:-1:2); ...            y; ...            ones(W,1)*2*y(L)-y(L-1:-1:L-W)];    end        xx = conv(x1,gau);        yy = conv(y1,gau);    if (mode == 1)        xs = xx(W+1:L+3*W);        ys = yy(W+1:L+3*W);        else        xs = xx(2*W+1:L+2*W);        ys = yy(2*W+1:L+2*W);        endelse    xs = [];    ys = [];    endend % end of smoothing%%% |FIND_SIG|%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction [sig] = find_sig(L)                                           %#okif L<=100    sig = 3;    %wid = 4;elseif L<=200    sig = 3;    %wid = 8;else    sig = 3;    %wid = 12;endend % end of find_sig##### SOURCE END #####-->  </body></html>