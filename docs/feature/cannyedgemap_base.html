<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html>  <head>    <meta content="text/html; charset=UTF-8" http-equiv="content-type">    <title>CANNYEDGEMAP_BASE - Base function for CANNYEDGEMAP.</title>    <meta name="generator" content="MATLAB 7.11">    <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">    <meta name="DC.date" content="2011-07-08">    <meta name="DC.source" content="cannyedgemap_base.m">    <style type="text/css">body {  background-color: white;  margin:10px;}h1 {  color: #990000;   font-size: x-large;}h2 {  color: #990000;  font-size: medium;}/* Make the text shrink to fit narrow windows, but not stretch too far in wide windows. */ p,h1,h2,div.content div {  max-width: 600px;  /* Hack for IE6 */  width: auto !important; width: 600px;}pre.codeinput {  background: #EEEEEE;  padding: 10px;}@media print {  pre.codeinput {word-wrap:break-word; width:100%;}} span.keyword {color: #0000FF}span.comment {color: #228B22}span.string {color: #A020F0}span.untermstring {color: #B20000}span.syscmd {color: #B28C00}pre.codeoutput {  color: #666666;  padding: 10px;}pre.error {  color: red;}p.footer {  text-align: right;  font-size: xx-small;  font-weight: lighter;  font-style: italic;  color: gray;}  </style>  </head>  <body>    <div class="content">      <h1>CANNYEDGEMAP_BASE - Base function for CANNYEDGEMAP.</h1>      <!--introduction--><!--/introduction-->      <h2>Contents</h2>      <div>        <ul>          <li><a href="#1">Syntax</a></li>          <li><a href="#2">Acknowledgment</a></li>          <li><a href="#4">See also</a></li>          <li><a href="#5">Function implementation</a></li>          <li><a href="#12">Subfunctions</a></li>        </ul>      </div>      <h2>Syntax<a name="1"></a></h2>      <pre>   map = CANNYEDGEMAP_BASE(gx, gy, der, mag, or, hyst, ratio);   [map, mag, or] = CANNYEDGEMAP_BASE(gx, gy, der, mag, or, hyst, ratio);</pre>      <h2>Acknowledgment<a name="2"></a></h2>      <p>This function is a copy/paste and crop of several proposed functions        implemented for thresholding, non maximum suppression and thinning of        edge maps. Specifically: VISTA functions, Kovesi's library.</p>      <h2>See also<a name="4"></a></h2>      <p>Related: <a href="CANNYEDGEMAP.html"><tt>CANNYEDGEMAP</tt></a>, <a href="CANNYEDGE_BASE.html"><tt>CANNYEDGE_BASE</tt></a>,        <a href="EDGECORNER_BASE.html"><tt>EDGECORNER_BASE</tt></a>, <a href="ROTHWELLEDGE_BASE.html"><tt>ROTHWELLEDGE_BASE</tt></a>,        <a href="CONGRUENCYEDGE_BASE.html"><tt>CONGRUENCYEDGE_BASE</tt></a>, <a          href="COMPASSEDGE_BASE.html"><tt>COMPASSEDGE_BASE</tt></a>,        <a href="ANISOEDGE_BASE.html"><tt>ANISOEDGE_BASE</tt></a>, <a href="ELDERZUCKEREDGE_BASE.html"><tt>ELDERZUCKEREDGE_BASE</tt></a>,        <a href="KOETHEDGE_BASE.html"><tt>KOETHEDGE_BASE</tt></a>, <a href="SDGDEDGE_BASE.html"><tt>SDGDEDGE_BASE</tt></a>,        <a href="PETROUEDGE_BASE.html"><tt>PETROUEDGE_BASE</tt></a>.</p>      <h2>Function implementation<a name="5"></a></h2>      <pre class="codeinput"><span class="keyword">function</span> [map,varargout] = cannyedgemap_base(gx, gy, der, mag, or, hyst, ratio)</pre>      <p>retrieve the gradient magnitude if not passed as an argument</p>      <pre class="codeinput">C = size(gx,3);<span class="keyword">if</span> isempty(mag)    mag = zeros(size(gx(:,:,1)));    <span class="keyword">for</span> c = 1:C        mag = max(mag, sqrt((gx(:,:,c).*gx(:,:,c)) + (gy(:,:,c).*gy(:,:,c))));    <span class="keyword">end</span>    magmax = max(mag(:));    <span class="keyword">if</span> magmax&gt;0        mag = mag / magmax;   <span class="comment">% normalize</span>    <span class="keyword">end</span><span class="keyword">end</span></pre>      <p>retrieve the gradient orientation if not passed as an argument</p>      <pre class="codeinput"><span class="keyword">if</span> isempty(or)    or = atan2(gy,gx);<span class="keyword">end</span><span class="keyword">if</span> isempty(ratio),   ratio = [1/3 0.08];  <span class="keyword">end</span>;<span class="keyword">if</span> strcmpi(der,<span class="string">'vista'</span>),    nbins = 128;<span class="keyword">else</span>                        nbins = 64;   <span class="keyword">end</span>;<span class="keyword">if</span> isempty(hyst)    hyst = selecthyst(mag, ratio, nbins);<span class="keyword">elseif</span> hyst(1) &gt; hyst(2)    <span class="comment">% swap values</span>    tmp = hyst(1); hyst(1) = hyst(2); hyst(2) = tmp;<span class="keyword">end</span></pre>      <p>estimations</p>      <pre class="codeinput"><span class="keyword">switch</span> der    <span class="keyword">case</span> <span class="string">'kovesi'</span>        radius = 1;        <span class="comment">% note that the orientation in Kovesi's function is defined with</span>        <span class="comment">% respect to the standard Matlab axis</span>        or = (or+pi/2);  or(or&gt;pi) = or(or&gt;pi) - 2*pi;        or = -or;        or = or.*~(or&lt;0) + (or+pi).*(or&lt;0); <span class="comment">% map angles to 0-pi</span>        or = or * 180/pi;   <span class="comment">% do convert to degrees</span>        map = nonmaxsup_kovesi(mag, or, radius);        <span class="comment">% hyst = max(mag(:)) * hyst; % mag already normalized</span>        map = hysthresh_kovesi(map, hyst);    <span class="keyword">case</span> {<span class="string">'matlab'</span>,<spanclass="string">'vista'</span>}        map = hystnonmaxsup_matlab(gx, gy, mag, hyst );<span class="keyword">end</span></pre>      <p>outputs</p>      <pre class="codeinput"><span class="keyword">if</span> nargout&gt;=2,  varargout{1} = mag;  <spanclass="keyword">end</span>;<span class="keyword">if</span> nargout==3,  varargout{2} = or;  <span class="keyword">end</span>;</pre>      <pre class="codeinput"><span class="keyword">end</span>  <span class="comment">% end of cannyedgemap_base</span></pre>      <h2>Subfunctions<a name="12"></a></h2>      <p><tt>SELECTHYST</tt> - Hysteresis thresholds' selection.</p>      <pre class="codeinput"><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> hyst = selecthyst(mag, ratio, nbins)[m,n] = size(mag(:,:,1));[counts,x] = imhist(mag, nbins);pixratio = ratio(1);<span class="keyword">if</span> pixratio&lt;0    meanx = sum(counts.*x)/sum(counts);    stdx = sqrt(sum(counts.*((x-meanx).^2))/sum(counts));    pixratio = 1-(meanx+2*stdx)/max(x);<span class="keyword">end</span>thresratio = ratio(2);highThresh = find(cumsum(counts) &gt; (1-pixratio)*m*n,1,<span class="string">'first'</span>) / nbins;lowThresh = thresratio*highThresh;hyst = [lowThresh highThresh];<span class="keyword">end</span> <span class="comment">% end of selecthyst</span></pre>      <p><tt>HYSTNONMAXSUP_MATLAB</tt> - Non-maximum supression.</p>      <pre class="codeinput"><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> map = hystnonmaxsup_matlab(gx, gy, mag, hyst)[m,n] = size(gx(:,:,1));                                               <span class="comment">%#ok</span>map = zeros(size(mag)); <span class="comment">% map = repmat(false, m, n);</span><span class="comment">% we accrue indices which specify ON pixels in strong map; the array e will</span><span class="comment">% become the weak edge map</span>idxStrong = [];<span class="keyword">for</span> dir = 1:4    idxLocalMax = findmaxima_matlab(dir,gx,gy,mag);    idxWeak = idxLocalMax(mag(idxLocalMax) &gt; hyst(1));    map(idxWeak)=1;    idxStrong = [idxStrong; idxWeak(mag(idxWeak) &gt; hyst(2))];          <spanclass="comment">%#ok</span><span class="keyword">end</span>rstrong = rem(idxStrong-1, m)+1;cstrong = floor((idxStrong-1)/m)+1;<span class="comment">% apply connectivity rules</span>map = bwselect(map, cstrong, rstrong, 8);<span class="comment">% thin double (or triple) pixel wide contours</span>map = bwmorph(map, <span class="string">'thin'</span>, 1);<span class="keyword">end</span> <span class="comment">% end of hystnonmaxsup_edge</span></pre>      <p><tt>FINDMAXIMA_MATLAB</tt> - This function helps with the non-maximum        supression in the Canny edge detector. It is a copy paste of the        original FINDMAXIMA function implemented in Matlab.</p>      <p>Inputs: <tt>direction</tt> : the index of which direction the gradient        is pointing, read from the diagram below. direction is 1, 2, 3, or 4.</p>      <pre> |ix| : input image filtered by derivative of Gaussian along X</pre>      <pre> |iy| : input image filtered by derivative of Gaussian along Y</pre>      <pre> |mag| : the gradient magnitude image</pre>      <p>Output: <tt>idxLocalMax</tt> : index of the local maxima in the        gradient magnituce image map</p>      <pre class="codeinput"><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> idxLocalMax = findmaxima_matlab(direction,ix,iy,mag)</pre>      <pre class="codeinput">[m,n] = size(mag(:,:,1));</pre>      <p>find the indices of all points whose gradient (specified by the vector        (ix,iy)) is going in the direction we're looking at.</p>      <pre class="codeinput"><span class="keyword">switch</span> direction    <span class="keyword">case</span> 1        idx = find((iy&lt;=0 &amp; ix&gt;-iy)  | (iy&gt;=0 &amp; ix&lt;-iy));    <span class="keyword">case</span> 2        idx = find((ix&gt;0 &amp; -iy&gt;=ix)  | (ix&lt;0 &amp; -iy&lt;=ix));    <span class="keyword">case</span> 3        idx = find((ix&lt;=0 &amp; ix&gt;iy) | (ix&gt;=0 &amp; ix&lt;iy));    <span class="keyword">case</span> 4        idx = find((iy&lt;0 &amp; ix&lt;=iy) | (iy&gt;0 &amp; ix&gt;=iy));<span class="keyword">end</span></pre>      <p>exclude the exterior pixels</p>      <pre class="codeinput"><span class="keyword">if</span> ~isempty(idx)    v = mod(idx,m);    idx(v==1 | v==0 | idx&lt;=m | (idx&gt;(n-1)*m)) = [];<span class="keyword">end</span>ixv = ix(idx);iyv = iy(idx);gradmag = mag(idx);</pre>      <p>do the linear interpolations for the interior pixels</p>      <pre class="codeinput"><span class="keyword">switch</span> direction    <span class="keyword">case</span> 1        d = abs(iyv./ixv);        gradmag1 = mag(idx+m).*(1-d) + mag(idx+m-1).*d;        gradmag2 = mag(idx-m).*(1-d) + mag(idx-m+1).*d;    <span class="keyword">case</span> 2        d = abs(ixv./iyv);        gradmag1 = mag(idx-1).*(1-d) + mag(idx+m-1).*d;        gradmag2 = mag(idx+1).*(1-d) + mag(idx-m+1).*d;    <span class="keyword">case</span> 3        d = abs(ixv./iyv);        gradmag1 = mag(idx-1).*(1-d) + mag(idx-m-1).*d;        gradmag2 = mag(idx+1).*(1-d) + mag(idx+m+1).*d;    <span class="keyword">case</span> 4        d = abs(iyv./ixv);        gradmag1 = mag(idx-m).*(1-d) + mag(idx-m-1).*d;        gradmag2 = mag(idx+m).*(1-d) + mag(idx+m+1).*d;<span class="keyword">end</span>idxLocalMax = idx(gradmag&gt;=gradmag1 &amp; gradmag&gt;=gradmag2);</pre>      <pre class="codeinput"><span class="keyword">end</span> <span class="comment">% end of findmaxima_edge</span></pre>      <p><tt>HYSTHRESH_KOVESI</tt> - Perform hysteresis thresholding of an        image.</p>      <p>Inputs: <tt>im</tt> : image to be thresholded (assumed to be        non-negative)</p>      <pre> |hyst=[T1,T2]| : upper and lower threshold values |(T1 &gt; T2)|</pre>      <p>Output: <tt>bw</tt> : the thresholded image (containing values 0 or 1)</p>      <pre class="codeinput"><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> bw = hysthresh_kovesi(im, hyst)T1 = hyst(1); T2=hyst(2);<span class="keyword">if</span> T1 &lt; T2    <span class="comment">% T1 and T2 reversed - swap values</span>    tmp = T1;    T1 = T2;    T2 = tmp;<span class="keyword">end</span>aboveT2 = im &gt; T2;   <span class="comment">% edge points above lower threshold.</span>[aboveT1r, aboveT1c] = find(im &gt; T1);  <span class="comment">% Row and colum coords of points</span><span class="comment">% above upper threshold.</span><span class="comment">% Obtain all connected regions in aboveT2 that include a point that has a</span><span class="comment">% value above T1</span>bw = bwselect(aboveT2, aboveT1c, aboveT1r, 8);<span class="keyword">end</span> <span class="comment">% end of hysthresh_kovesi</span></pre>      <p><tt>NONMAXSUP_KOVESI</tt> - Function for performing non-maxima        suppression on an image using an orientation image. It is assumed that        the orientation image gives feature normal orientation angles in degrees        (0-180).</p>      <p>Inputs: <tt>inimage</tt> : image to be non-maxima suppressed.</p>      <pre> |orient| : image containing feature normal orientation angles in degrees    (0-180), angles positive anti-clockwise.</pre>      <pre> |radius| : distance in pixel units to be looked at on each side of each    pixel when determining whether it is a local maxima or not; this    value cannot be less than 1; suggested value about 1.2 - 1.5.</pre>      <p>Output <tt>im</tt> : non maximally suppressed image.</p>      <pre class="codeinput"><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> im = nonmaxsup_kovesi(inimage, orient, radius)</pre>      <pre class="codeinput">[rows,cols] = size(inimage);im = zeros(rows,cols); <span class="comment">% preallocate memory for output image</span>iradius = ceil(radius);</pre>      <p>precalculate x and y offsets relative to centre pixel for each        orientation angle</p>      <pre class="codeinput">angle = (0:180).*pi/180; <span class="comment">% array of angles in 1 degree increments (but in radians).</span>xoff = radius*cos(angle); <span class="comment">% x and y offset of points at specified radius and angle</span>yoff = radius*sin(angle); <span class="comment">% from each reference position.</span>hfrac = xoff - floor(xoff); <span class="comment">% fractional offset of xoff relative to integer location</span>vfrac = yoff - floor(yoff); <span class="comment">% fractional offset of yoff relative to integer location</span>orient = fix(orient)+1; <span class="comment">% orientations start at 0 degrees but arrays start with index 1.</span></pre>      <p>now run through the image interpolating grey values on each side of the        centre pixel to be used for the non-maximal suppression.</p>      <pre class="codeinput"><span class="keyword">for</span> row = (iradius+1):(rows - iradius)    <span class="keyword">for</span> col = (iradius+1):(cols - iradius)        or = orient(row,col);   <span class="comment">% Index into precomputed arrays</span>        x = col + xoff(or);     <span class="comment">% x, y location on one side of the point in question</span>        y = row - yoff(or);        fx = floor(x);          <span class="comment">% Get integer pixel locations that surround location x,y</span>        cx = ceil(x);        fy = floor(y);        cy = ceil(y);        tl = inimage(fy,fx);    <span class="comment">% Value at top left integer pixel location.</span>        tr = inimage(fy,cx);    <span class="comment">% top right</span>        bl = inimage(cy,fx);    <span class="comment">% bottom left</span>        br = inimage(cy,cx);    <span class="comment">% bottom right</span>        upperavg = tl + hfrac(or) * (tr - tl);  <span class="comment">% Now use bilinear interpolation to</span>        loweravg = bl + hfrac(or) * (br - bl);  <span class="comment">% estimate value at x,y</span>        v1 = upperavg + vfrac(or) * (loweravg - upperavg);        <span class="keyword">if</span> inimage(row, col) &gt; v1 <span class="comment">% We need to check the value on the other side...</span>            x = col - xoff(or);     <span class="comment">% x, y location on the `other side' of the point in question</span>            y = row + yoff(or);            fx = floor(x);            cx = ceil(x);            fy = floor(y);            cy = ceil(y);            tl = inimage(fy,fx);    <span class="comment">% Value at top left integer pixel location.</span>            tr = inimage(fy,cx);    <span class="comment">% top right</span>            bl = inimage(cy,fx);    <span class="comment">% bottom left</span>            br = inimage(cy,cx);    <span class="comment">% bottom right</span>            upperavg = tl + hfrac(or) * (tr - tl);            loweravg = bl + hfrac(or) * (br - bl);            v2 = upperavg + vfrac(or) * (loweravg - upperavg);            <span class="keyword">if</span> inimage(row,col) &gt; v2            <spanclass="comment">% This is a local maximum.</span>                im(row, col) = inimage(row, col); <span class="comment">% Record value in the output</span>                <span class="comment">% image.</span>            <span class="keyword">end</span>        <span class="keyword">end</span>    <span class="keyword">end</span><span class="keyword">end</span></pre>      <p>finally thin the 'nonmaximally suppressed' image by pointwise        multiplying itself with a morphological skeletonization of itself.</p>      <pre class="codeinput">skel = bwmorph(im,<span class="string">'skel'</span>,Inf);im = im.*skel;</pre>      <pre class="codeinput"><span class="keyword">end</span>  <span class="comment">% end of nonmaxsup_kovesi</span></pre> </div>    <!--##### SOURCE BEGIN #####%% CANNYEDGEMAP_BASE - Base function for CANNYEDGEMAP.%%% Syntax%     map = CANNYEDGEMAP_BASE(gx, gy, der, mag, or, hyst, ratio);%     [map, mag, or] = CANNYEDGEMAP_BASE(gx, gy, der, mag, or, hyst, ratio);%%% Acknowledgment% This function is a copy/paste and crop of several proposed functions % implemented for thresholding, non maximum suppression and thinning of edge% maps. Specifically: VISTA functions, Kovesi's library.% %% Credit% <mailto:grazzja@lanl.gov J.Grazzini> (ISR-2/LANL)%%% See also% Related:% <CANNYEDGEMAP.html |CANNYEDGEMAP|>,% <CANNYEDGE_BASE.html |CANNYEDGE_BASE|>,% <EDGECORNER_BASE.html |EDGECORNER_BASE|>,% <ROTHWELLEDGE_BASE.html |ROTHWELLEDGE_BASE|>,% <CONGRUENCYEDGE_BASE.html |CONGRUENCYEDGE_BASE|>,% <COMPASSEDGE_BASE.html |COMPASSEDGE_BASE|>,% <ANISOEDGE_BASE.html |ANISOEDGE_BASE|>,% <ELDERZUCKEREDGE_BASE.html |ELDERZUCKEREDGE_BASE|>,% <KOETHEDGE_BASE.html |KOETHEDGE_BASE|>,% <SDGDEDGE_BASE.html |SDGDEDGE_BASE|>,% <PETROUEDGE_BASE.html |PETROUEDGE_BASE|>.%% Function implementationfunction [map,varargout] = cannyedgemap_base(gx, gy, der, mag, or, hyst, ratio)%%% retrieve the gradient magnitude if not passed as an argumentC = size(gx,3);if isempty(mag)    mag = zeros(size(gx(:,:,1)));    for c = 1:C        mag = max(mag, sqrt((gx(:,:,c).*gx(:,:,c)) + (gy(:,:,c).*gy(:,:,c))));    end    magmax = max(mag(:));    if magmax>0        mag = mag / magmax;   % normalize    endend%%% retrieve the gradient orientation if not passed as an argumentif isempty(or)    or = atan2(gy,gx);  endif isempty(ratio),   ratio = [1/3 0.08];  end;if strcmpi(der,'vista'),    nbins = 128;else                        nbins = 64;   end;if isempty(hyst)    hyst = selecthyst(mag, ratio, nbins);elseif hyst(1) > hyst(2)    % swap values    tmp = hyst(1); hyst(1) = hyst(2); hyst(2) = tmp;end%%% estimationsswitch der        case 'kovesi'        radius = 1;        % note that the orientation in Kovesi's function is defined with        % respect to the standard Matlab axis        or = (or+pi/2);  or(or>pi) = or(or>pi) - 2*pi;        or = -or;                        or = or.*~(or<0) + (or+pi).*(or<0); % map angles to 0-pi        or = or * 180/pi;   % do convert to degrees        map = nonmaxsup_kovesi(mag, or, radius);        % hyst = max(mag(:)) * hyst; % mag already normalized        map = hysthresh_kovesi(map, hyst);            case {'matlab','vista'}        map = hystnonmaxsup_matlab(gx, gy, mag, hyst );end%%% outputsif nargout>=2,  varargout{1} = mag;  end;if nargout==3,  varargout{2} = or;  end;end  % end of cannyedgemap_base%% Subfunctions%%% |SELECTHYST| - Hysteresis thresholds' selection.%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction hyst = selecthyst(mag, ratio, nbins)[m,n] = size(mag(:,:,1));[counts,x] = imhist(mag, nbins);pixratio = ratio(1);if pixratio<0    meanx = sum(counts.*x)/sum(counts);    stdx = sqrt(sum(counts.*((x-meanx).^2))/sum(counts));    pixratio = 1-(meanx+2*stdx)/max(x);endthresratio = ratio(2);highThresh = find(cumsum(counts) > (1-pixratio)*m*n,1,'first') / nbins;lowThresh = thresratio*highThresh;hyst = [lowThresh highThresh];end % end of selecthyst%%% |HYSTNONMAXSUP_MATLAB| - Non-maximum supression.%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction map = hystnonmaxsup_matlab(gx, gy, mag, hyst)[m,n] = size(gx(:,:,1));                                               %#ok          map = zeros(size(mag)); % map = repmat(false, m, n);% we accrue indices which specify ON pixels in strong map; the array e will % become the weak edge mapidxStrong = [];for dir = 1:4    idxLocalMax = findmaxima_matlab(dir,gx,gy,mag);    idxWeak = idxLocalMax(mag(idxLocalMax) > hyst(1));    map(idxWeak)=1;    idxStrong = [idxStrong; idxWeak(mag(idxWeak) > hyst(2))];          %#okendrstrong = rem(idxStrong-1, m)+1;cstrong = floor((idxStrong-1)/m)+1;% apply connectivity rulesmap = bwselect(map, cstrong, rstrong, 8);% thin double (or triple) pixel wide contoursmap = bwmorph(map, 'thin', 1);  end % end of hystnonmaxsup_edge%%% |FINDMAXIMA_MATLAB| - This function helps with the non-maximum supression in % the Canny edge detector. It is a copy paste of the original FINDMAXIMA% function implemented in Matlab.% % Inputs:%   |direction| : the index of which direction the gradient is pointing, read%      from the diagram below. direction is 1, 2, 3, or 4.%%   |ix| : input image filtered by derivative of Gaussian along X%%   |iy| : input image filtered by derivative of Gaussian along Y%%   |mag| : the gradient magnitude image%% Output:%   |idxLocalMax| : index of the local maxima in the gradient magnituce image%     map%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction idxLocalMax = findmaxima_matlab(direction,ix,iy,mag)[m,n] = size(mag(:,:,1));%%% find the indices of all points whose gradient (specified by the% vector (ix,iy)) is going in the direction we're looking at.switch direction    case 1        idx = find((iy<=0 & ix>-iy)  | (iy>=0 & ix<-iy));    case 2        idx = find((ix>0 & -iy>=ix)  | (ix<0 & -iy<=ix));    case 3        idx = find((ix<=0 & ix>iy) | (ix>=0 & ix<iy));    case 4        idx = find((iy<0 & ix<=iy) | (iy>0 & ix>=iy));end%%% exclude the exterior pixelsif ~isempty(idx)    v = mod(idx,m);    idx(v==1 | v==0 | idx<=m | (idx>(n-1)*m)) = [];endixv = ix(idx);iyv = iy(idx);gradmag = mag(idx);%%% do the linear interpolations for the interior pixelsswitch direction    case 1        d = abs(iyv./ixv);        gradmag1 = mag(idx+m).*(1-d) + mag(idx+m-1).*d;        gradmag2 = mag(idx-m).*(1-d) + mag(idx-m+1).*d;    case 2        d = abs(ixv./iyv);        gradmag1 = mag(idx-1).*(1-d) + mag(idx+m-1).*d;        gradmag2 = mag(idx+1).*(1-d) + mag(idx-m+1).*d;    case 3        d = abs(ixv./iyv);        gradmag1 = mag(idx-1).*(1-d) + mag(idx-m-1).*d;        gradmag2 = mag(idx+1).*(1-d) + mag(idx+m+1).*d;    case 4        d = abs(iyv./ixv);        gradmag1 = mag(idx-m).*(1-d) + mag(idx-m-1).*d;        gradmag2 = mag(idx+m).*(1-d) + mag(idx+m+1).*d;endidxLocalMax = idx(gradmag>=gradmag1 & gradmag>=gradmag2);end % end of findmaxima_edge%%% |HYSTHRESH_KOVESI| - Perform hysteresis thresholding of an image.%% Inputs:%   |im| : image to be thresholded (assumed to be non-negative)%%   |hyst=[T1,T2]| : upper and lower threshold values |(T1 > T2)|%% Output:%   |bw| : the thresholded image (containing values 0 or 1)%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction bw = hysthresh_kovesi(im, hyst)T1 = hyst(1); T2=hyst(2);if T1 < T2    % T1 and T2 reversed - swap values    tmp = T1;    T1 = T2;    T2 = tmp;endaboveT2 = im > T2;   % edge points above lower threshold.[aboveT1r, aboveT1c] = find(im > T1);  % Row and colum coords of points% above upper threshold.% Obtain all connected regions in aboveT2 that include a point that has a% value above T1bw = bwselect(aboveT2, aboveT1c, aboveT1r, 8);end % end of hysthresh_kovesi%%% |NONMAXSUP_KOVESI| - Function for performing non-maxima suppression on an % image using an orientation image.  It is assumed that the orientation % image gives feature normal orientation angles in degrees (0-180).%% Inputs:%   |inimage| : image to be non-maxima suppressed.%%   |orient| : image containing feature normal orientation angles in degrees%      (0-180), angles positive anti-clockwise.%%   |radius| : distance in pixel units to be looked at on each side of each%      pixel when determining whether it is a local maxima or not; this%      value cannot be less than 1; suggested value about 1.2 - 1.5.%% Output%   |im| : non maximally suppressed image.%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction im = nonmaxsup_kovesi(inimage, orient, radius)[rows,cols] = size(inimage);im = zeros(rows,cols); % preallocate memory for output imageiradius = ceil(radius);%%% precalculate x and y offsets relative to centre pixel for each orientation angle angle = (0:180).*pi/180; % array of angles in 1 degree increments (but in radians).xoff = radius*cos(angle); % x and y offset of points at specified radius and angleyoff = radius*sin(angle); % from each reference position.hfrac = xoff - floor(xoff); % fractional offset of xoff relative to integer locationvfrac = yoff - floor(yoff); % fractional offset of yoff relative to integer locationorient = fix(orient)+1; % orientations start at 0 degrees but arrays start with index 1.%%% now run through the image interpolating grey values on each side% of the centre pixel to be used for the non-maximal suppression.for row = (iradius+1):(rows - iradius)    for col = (iradius+1):(cols - iradius)                or = orient(row,col);   % Index into precomputed arrays        x = col + xoff(or);     % x, y location on one side of the point in question        y = row - yoff(or);                fx = floor(x);          % Get integer pixel locations that surround location x,y        cx = ceil(x);        fy = floor(y);        cy = ceil(y);        tl = inimage(fy,fx);    % Value at top left integer pixel location.        tr = inimage(fy,cx);    % top right        bl = inimage(cy,fx);    % bottom left        br = inimage(cy,cx);    % bottom right                upperavg = tl + hfrac(or) * (tr - tl);  % Now use bilinear interpolation to        loweravg = bl + hfrac(or) * (br - bl);  % estimate value at x,y        v1 = upperavg + vfrac(or) * (loweravg - upperavg);                if inimage(row, col) > v1 % We need to check the value on the other side...                        x = col - xoff(or);     % x, y location on the `other side' of the point in question            y = row + yoff(or);                        fx = floor(x);            cx = ceil(x);            fy = floor(y);            cy = ceil(y);            tl = inimage(fy,fx);    % Value at top left integer pixel location.            tr = inimage(fy,cx);    % top right            bl = inimage(cy,fx);    % bottom left            br = inimage(cy,cx);    % bottom right            upperavg = tl + hfrac(or) * (tr - tl);            loweravg = bl + hfrac(or) * (br - bl);            v2 = upperavg + vfrac(or) * (loweravg - upperavg);                        if inimage(row,col) > v2            % This is a local maximum.                im(row, col) = inimage(row, col); % Record value in the output                % image.            end                    end    endend%%% finally thin the 'nonmaximally suppressed' image by pointwise% multiplying itself with a morphological skeletonization of itself.skel = bwmorph(im,'skel',Inf);im = im.*skel;end  % end of nonmaxsup_kovesi##### SOURCE END #####-->  </body></html>