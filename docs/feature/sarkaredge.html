<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html>  <head>    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">    <title>sarkaredge</title>    <meta name="generator" content="MATLAB 7.11">    <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">    <meta name="DC.date" content="2011-07-08">    <meta name="DC.source" content="sarkaredge.m">    <style type="text/css">body {  background-color: white;  margin:10px;}h1 {  color: #990000;   font-size: x-large;}h2 {  color: #990000;  font-size: medium;}/* Make the text shrink to fit narrow windows, but not stretch too far in wide windows. */ p,h1,h2,div.content div {  max-width: 600px;  /* Hack for IE6 */  width: auto !important; width: 600px;}pre.codeinput {  background: #EEEEEE;  padding: 10px;}@media print {  pre.codeinput {word-wrap:break-word; width:100%;}} span.keyword {color: #0000FF}span.comment {color: #228B22}span.string {color: #A020F0}span.untermstring {color: #B20000}span.syscmd {color: #B28C00}pre.codeoutput {  color: #666666;  padding: 10px;}pre.error {  color: red;}p.footer {  text-align: right;  font-size: xx-small;  font-weight: lighter;  font-style: italic;  color: gray;}  </style>  </head>  <body>    <div class="content">      <h2>Contents</h2>      <div>        <ul>          <li><a href="#3">Build the causal and non causal filters</a></li>          <li><a href="#4">Apply filters</a></li>          <li><a href="#5">Inner product of gradient with itself for the              gradient squared magnitude.</a></li>          <li><a href="#6">Detect and qualify zcs</a></li>        </ul>      </div>      <pre class="codeinput"><span class="keyword">function</span> [ZCmap,GradSq] = sarkaredge(I, alpha, beta,Imult,ZCThr)</pre>      <pre class="codeinput"><span class="comment">% SARKAREDGE - Implements the Optimal Zero Crossing edge Operator (OZCO)</span><span class="comment">% gamma = scale;</span><span class="comment">% alpha in -1.5 to 1.5, the OZCO shape parameter; default alpha=0.312</span><span class="comment">% beta in 0.2 to 2.0, the OZCO scale parameter; default: beta=1/gamma</span>	<span class="comment">% Imult : image brightness multiplier for ZC in ROI</span>	<span class="comment">% ZCThr : threshold for ZC validation</span><span class="comment">%   [SB91] 	S. Sarkar and K. L. Boyer: "Optimal Infinite Impulse response zero</span><span class="comment">%      crossing based edge detectors", CVGIP, 54(2):224-243, 1992.</span><span class="comment">%I = I0/max(I0(:));</span>[sizeR,sizeC] = size(I);<span class="keyword">if</span> exist(<span class="string">'sarkaredge_mex'</span>,<spanclass="string">'file'</span>)    warning(<span class="string">'sarkaredge_base:error'</span>, <span class="keyword">...</span>        [<span class="string">'TODO:wrong version of sarkaredge_mex implemented - '</span><spanclass="keyword">...</span>        <span class="string">'currently using matlab code'</span>]);<span class="keyword">end</span></pre>      <h2>Build the causal and non causal filters<a name="3"></a></h2>      <p> - px (py) is the smoothing function (second integral of OZCO).        - dx (dy) is the smoothed differentiator (first integral of        OZCO).</p>      <pre class="codeinput"><span class="comment">% the filter is performed in 2D by applying the optimal filter perpendicular</span><span class="comment">% H to the edge and a projection function G parallel to the edge</span><span class="comment">% i) apply the noncausal projection filter G(z) to the rows of the im0.3age and</span><span class="comment">%  the noncausal edge detection filter H(z) to the columns; this estimates</span><span class="comment">%  the smoothed image gradient in the row direction.</span><span class="comment">% ii) similarly, apply the noncausal version of G(z) to the columns and the</span><span class="comment">%  noncausal version of H(z) to the rows to get an estimate of the smoothed</span><span class="comment">%  gradient in the column direction.</span><span class="comment">% The number of multiplications per pixel is 40 and is independent of the</span><span class="comment">% size (scale) of the filter used.</span><span class="comment">% 	First, some constants needed...</span><span class="comment">% sampling interval</span>tau = 1; <span class="comment">% tau = [taux tauy];</span>alpha0 = (alpha+2) / beta^2;alpha1 = exp(-beta*tau) * <span class="keyword">...</span>    (tau*(alpha+2)/beta + 0.5*tau^2*(alpha+1) - 2*(alpha+2)/beta^2);alpha2 = exp(-2*beta*tau) * <span class="keyword">...</span>    (-tau*(alpha+2)/beta + 0.5*tau^2*(alpha+1) + (alpha+2)/beta^2);beta1 = -3 * exp(-beta*tau);beta2 = 3 * exp(-2*beta*tau);beta3 = - exp(-3*beta*tau);gamma1 = (0.5*beta*tau^2*(alpha+1) + tau) * exp(-beta*tau);  <span class="comment">%a01</span>gamma2 = (0.5*beta*tau^2*(alpha+1) - tau) * exp(-2*beta*tau); <span class="comment">% a02</span>nconst = 2 * (3*alpha+5) / beta^3;<span class="comment">% expression of the projection IIR filter:</span><span class="comment">%     G(z) = (a0 + a1*z + a2*z^2) / (1 - b1 *z - b2*z^2 - b3*z^3)</span><span class="comment">% the projection function is chosen to be the integral of the edge detection</span><span class="comment">% filter, which is a low-pass filter very similar to a Gaussian</span><span class="comment">% this noncausal filter can be realized by the sum of two identical causal</span><span class="comment">% filters operating in opposite directions</span><span class="comment">% see functions derivy_convl and derivx_convl</span><span class="comment">% build the smoothing function feedforward (causal) coefficient vector</span>pb = [alpha0 alpha1 alpha2];  <span class="comment">% used with half_projec_convl</span>pb = pb * beta^2;<span class="comment">% build the smoothing function feedback (anti causal) coefficient vector</span>pa = [1 beta1 beta2 beta3];<span class="comment">% build the differentiator feedforward coefficient vector</span>db = [0 gamma1 gamma2]; <span class="comment">% used with half_opt_convl</span><span class="comment">% the differentiator feedback coefficients are the same as the smoother's</span>da = pa;<span class="comment">% OZCO Infinite Impulse Responses: run the filters over a unit pulse and</span><span class="comment">% display the response</span><span class="comment">%test = [zeros(1,100) 1 zeros(1,100)];</span><span class="comment">%pxr = filter(pb,pa,test);</span><span class="comment">%dxr = filter(db,da,test);</span><span class="comment">%pxl(201:-1:1) = filter(pb,pa,test(201:-1:1));</span><span class="comment">%dxl(201:-1:1) = filter(db,da,test(201:-1:1));</span><span class="comment">%px = pxl + pxr - [zeros(1,100) pxr(101) zeros(1,100)];</span><span class="comment">%dx = dxr - dxl;</span><span class="comment">%plot(px,'g')</span><span class="comment">%plot(10*dx,'b')</span><span class="comment">% Obtain zc detection and validation parameters</span>ZCThr = -ZCThr;<span class="comment">%	ImThr = Imult*max(max(I));</span></pre>      <h2>Apply filters<a name="4"></a></h2>      <p>convolve with differentiator in X, smoothing function in Y for        the X- component of the smoothed gradient. first apply opt_convl</p>      <pre class="codeinput">Ifx = filter(db, da, I, [], 2);Ibx = fliplr(filter(db, da, fliplr(I), [], 2));Ifx = Ifx - Ibx;<span class="comment">% then apply projec_convl</span>Ibx = flipud(filter(pb, pa, flipud(Ifx), [], 2));Ifx = filter(pb, pa, Ifx, [], 1);Ifx = Ifx + Ibx - alpha0*Ifx;<span class="comment">% convolve with differentiator in Y, smoothing Function in X for the Y-</span><span class="comment">% component of the smoothed gradient.</span><span class="comment">% first apply projec_convl</span>Ify = filter(pb, pa, I, [], 2);Iby = fliplr(filter(pb, pa, fliplr(I), [], 2));Ify = Ify + Iby - alpha0*I;<span class="comment">% then apply opt_convl</span>Iby = flipud(filter(db, da, flipud(Ify), [], 2));Ify = filter(db, da, Ify, [], 1);Ify = Ify - Iby;</pre>      <h2>Inner product of gradient with itself for the gradient squared        magnitude.<a name="5"></a></h2>      <pre class="codeinput">Ig = (Ifx .* Ifx) + (Ify .* Ify);max(Ig(:))Itheta = atan2(Ify,Ifx);<span class="comment">% compute the gradient of the gradient squared magnitude for the first</span><span class="comment">% directional derivatives</span>[gx,gy] = gradient(Ig);<span class="comment">% compute the inner product of the gradient of gradient squared with the</span><span class="comment">% original smoothed gradient for the second directional derivative in the</span><span class="comment">% direction	of the smoothed gradient.</span><span class="comment">% zero crossings in this image indicate potential edges, subject to</span><span class="comment">% qualification and strength tests.</span>DI = Ifx .* gx + Ify .* gy;DI = DI ./ (2 * tau * Ig);DI = DI / nconst;DI(Ig==0) = 0;max(DI(:))</pre>      <h2>Detect and qualify zcs<a name="6"></a></h2>      <pre class="codeinput"><span class="comment">% ZCs equal border pixels in DI; corresponding Image pixel &gt; ImThr</span>ZCmap = zeros(sizeR,sizeC);<span class="comment">% ZC2 = zeros(sizeR,sizeC);</span><span class="comment">% DxI= zeros(sizeR,sizeC);</span><span class="comment">% GradX = zeros(sizeR,sizeC);</span><span class="comment">% GradY = zeros(sizeR,sizeC);</span><span class="comment">% computing initial ZC map</span>r = 2:sizeR-1;c = 2:sizeC-1;ImThr = Imult*max(Ig(:));<span class="comment">%ZCmap(r,c) = I(r,c)&gt;ImThr &amp; DI(r,c) &gt;= 0 &amp; (DI(r-1,c)&lt;0 | ...</span><span class="comment">%   DI(r+1,c)&lt;0 |DI(r,c+1)&lt;0 | DI(r,c-1)&lt;0);</span>size(Ig(r,c))max(max(Ig(r,c)))figure, imagesc(Ig(r,c)&gt;ImThr)ZCmap(r,c) = Ig(r,c)&gt;ImThr &amp; DI(r,c) &gt;= 0 &amp; <span class="keyword">...</span>    (DI(r-1,c)&lt;0 | DI(r+1,c)&lt;0 |DI(r,c+1)&lt;0 | DI(r,c-1)&lt;0);max(ZCmap(:))figure, imagesc(ZCmap)<span class="comment">% smoothed gradient consistent with third directional derivative</span><span class="comment">% compute normalized third directional derivatives</span>[GradX,GradY] = gradient(DI);DxI = (Ifx .* GradX) + (Ify .* GradY);DxI = DxI/max(max(abs(DxI)));<span class="comment">% pruning weak ZCs from map</span>ZCmap = ZCmap &amp; (DxI &lt; ZCThr);<span class="comment">% pruning ZCs inconsistent with gradient orientation</span><span class="comment">% DxI = (DxI .* GradSq);</span><span class="comment">% ZCmap = ZCmap &amp; (DxI &lt; 0);</span><span class="comment">% qualified ZCmap : phantoms deleted</span><span class="comment">%    1-ZCmap</span><span class="comment">% qualified ZCmap overlay : strong ZCs</span><span class="comment">%    max(ZCmap,Image)</span></pre>      <pre class="codeinput"><span class="keyword">end</span></pre> </div>    <!--##### SOURCE BEGIN #####function [ZCmap,GradSq] = sarkaredge(I, alpha, beta,Imult,ZCThr)% SARKAREDGE - Implements the Optimal Zero Crossing edge Operator (OZCO)% gamma = scale;% alpha in -1.5 to 1.5, the OZCO shape parameter; default alpha=0.312% beta in 0.2 to 2.0, the OZCO scale parameter; default: beta=1/gamma	% Imult : image brightness multiplier for ZC in ROI 	% ZCThr : threshold for ZC validation %   [SB91] 	S. Sarkar and K. L. Boyer: "Optimal Infinite Impulse response zero%      crossing based edge detectors", CVGIP, 54(2):224-243, 1992.%I = I0/max(I0(:));[sizeR,sizeC] = size(I);if exist('sarkaredge_mex','file')    warning('sarkaredge_base:error', ...        ['TODO:wrong version of sarkaredge_mex implemented - '...        'currently using matlab code']);end   %% Build the causal and non causal filters% 	- px (py) is the smoothing function (second integral of OZCO).% 	- dx (dy) is the smoothed differentiator (first integral of OZCO).% the filter is performed in 2D by applying the optimal filter perpendicular% H to the edge and a projection function G parallel to the edge% i) apply the noncausal projection filter G(z) to the rows of the im0.3age and%  the noncausal edge detection filter H(z) to the columns; this estimates%  the smoothed image gradient in the row direction. % ii) similarly, apply the noncausal version of G(z) to the columns and the%  noncausal version of H(z) to the rows to get an estimate of the smoothed%  gradient in the column direction. % The number of multiplications per pixel is 40 and is independent of the % size (scale) of the filter used.% 	First, some constants needed...% sampling intervaltau = 1; % tau = [taux tauy];alpha0 = (alpha+2) / beta^2;alpha1 = exp(-beta*tau) * ...    (tau*(alpha+2)/beta + 0.5*tau^2*(alpha+1) - 2*(alpha+2)/beta^2);alpha2 = exp(-2*beta*tau) * ...    (-tau*(alpha+2)/beta + 0.5*tau^2*(alpha+1) + (alpha+2)/beta^2);beta1 = -3 * exp(-beta*tau);beta2 = 3 * exp(-2*beta*tau);beta3 = - exp(-3*beta*tau);gamma1 = (0.5*beta*tau^2*(alpha+1) + tau) * exp(-beta*tau);  %a01gamma2 = (0.5*beta*tau^2*(alpha+1) - tau) * exp(-2*beta*tau); % a02nconst = 2 * (3*alpha+5) / beta^3;% expression of the projection IIR filter:%     G(z) = (a0 + a1*z + a2*z^2) / (1 - b1 *z - b2*z^2 - b3*z^3)% the projection function is chosen to be the integral of the edge detection% filter, which is a low-pass filter very similar to a Gaussian% this noncausal filter can be realized by the sum of two identical causal% filters operating in opposite directions% see functions derivy_convl and derivx_convl% build the smoothing function feedforward (causal) coefficient vectorpb = [alpha0 alpha1 alpha2];  % used with half_projec_convlpb = pb * beta^2;% build the smoothing function feedback (anti causal) coefficient vectorpa = [1 beta1 beta2 beta3];% build the differentiator feedforward coefficient vectordb = [0 gamma1 gamma2]; % used with half_opt_convl% the differentiator feedback coefficients are the same as the smoother'sda = pa; % OZCO Infinite Impulse Responses: run the filters over a unit pulse and% display the response%test = [zeros(1,100) 1 zeros(1,100)];%pxr = filter(pb,pa,test);%dxr = filter(db,da,test);%pxl(201:-1:1) = filter(pb,pa,test(201:-1:1));%dxl(201:-1:1) = filter(db,da,test(201:-1:1));%px = pxl + pxr - [zeros(1,100) pxr(101) zeros(1,100)];%dx = dxr - dxl;%plot(px,'g')%plot(10*dx,'b')% Obtain zc detection and validation parameters ZCThr = -ZCThr;%	ImThr = Imult*max(max(I));%% Apply filters% convolve with differentiator in X, smoothing function in Y for the X-% component of the smoothed gradient.% first apply opt_convlIfx = filter(db, da, I, [], 2);Ibx = fliplr(filter(db, da, fliplr(I), [], 2)); Ifx = Ifx - Ibx;   % then apply projec_convl Ibx = flipud(filter(pb, pa, flipud(Ifx), [], 2));Ifx = filter(pb, pa, Ifx, [], 1);Ifx = Ifx + Ibx - alpha0*Ifx;% convolve with differentiator in Y, smoothing Function in X for the Y-% component of the smoothed gradient.% first apply projec_convlIfy = filter(pb, pa, I, [], 2);Iby = fliplr(filter(pb, pa, fliplr(I), [], 2));Ify = Ify + Iby - alpha0*I;% then apply opt_convl Iby = flipud(filter(db, da, flipud(Ify), [], 2));Ify = filter(db, da, Ify, [], 1);Ify = Ify - Iby;%% Inner product of gradient with itself for the gradient squared magnitude.Ig = (Ifx .* Ifx) + (Ify .* Ify);max(Ig(:))Itheta = atan2(Ify,Ifx);% compute the gradient of the gradient squared magnitude for the first% directional derivatives[gx,gy] = gradient(Ig); % compute the inner product of the gradient of gradient squared with the% original smoothed gradient for the second directional derivative in the% direction	of the smoothed gradient.  % zero crossings in this image indicate potential edges, subject to% qualification and strength tests.DI = Ifx .* gx + Ify .* gy;DI = DI ./ (2 * tau * Ig);DI = DI / nconst;DI(Ig==0) = 0;max(DI(:))%% Detect and qualify zcs% ZCs equal border pixels in DI; corresponding Image pixel > ImThrZCmap = zeros(sizeR,sizeC);% ZC2 = zeros(sizeR,sizeC);% DxI= zeros(sizeR,sizeC);% GradX = zeros(sizeR,sizeC);% GradY = zeros(sizeR,sizeC);% computing initial ZC mapr = 2:sizeR-1;c = 2:sizeC-1;ImThr = Imult*max(Ig(:));%ZCmap(r,c) = I(r,c)>ImThr & DI(r,c) >= 0 & (DI(r-1,c)<0 | ...%   DI(r+1,c)<0 |DI(r,c+1)<0 | DI(r,c-1)<0);size(Ig(r,c))max(max(Ig(r,c)))figure, imagesc(Ig(r,c)>ImThr)ZCmap(r,c) = Ig(r,c)>ImThr & DI(r,c) >= 0 & ...    (DI(r-1,c)<0 | DI(r+1,c)<0 |DI(r,c+1)<0 | DI(r,c-1)<0);max(ZCmap(:))figure, imagesc(ZCmap)% smoothed gradient consistent with third directional derivative% compute normalized third directional derivatives[GradX,GradY] = gradient(DI);DxI = (Ifx .* GradX) + (Ify .* GradY);DxI = DxI/max(max(abs(DxI)));% pruning weak ZCs from mapZCmap = ZCmap & (DxI < ZCThr);% pruning ZCs inconsistent with gradient orientation% DxI = (DxI .* GradSq);% ZCmap = ZCmap & (DxI < 0);% qualified ZCmap : phantoms deleted%    1-ZCmap% qualified ZCmap overlay : strong ZCs%    max(ZCmap,Image)end##### SOURCE END #####-->  </body></html>