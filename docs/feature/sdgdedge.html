<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html>  <head>    <meta content="text/html; charset=utf-8" http-equiv="content-type">    <!--This HTML was auto-generated from MATLAB code.To make changes, update the MATLAB code and republish this document.      -->    <title>SDGDEDGE - Edge detection based on gradient second derivative.</title>    <meta name="generator" content="MATLAB 7.14">    <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">    <meta name="DC.date" content="2012-05-31">    <meta name="DC.source" content="sdgdedge.m">    <style type="text/css">html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}html { min-height:100%; margin-bottom:1px; }html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }html body td { vertical-align:top; text-align:left; }h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }a { color:#005fce; text-decoration:none; }a:hover { color:#005fce; text-decoration:underline; }a:visited { color:#004aa0; text-decoration:none; }p { padding:0px; margin:0px 0px 20px; }img { padding:0px; margin:0px 0px 20px; border:none; }p img, pre img, tt img, li img { margin-bottom:0px; } ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }ul li { padding:0px; margin:0px 0px 7px 0px; }ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }ul li ol li { list-style:decimal; }ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }ol li ol li { list-style-type:lower-alpha; }ol li ul { padding-top:7px; }ol li ul li { list-style:square; }.content { font-size:1.2em; line-height:140%; padding: 20px; }pre, tt, code { font-size:12px; }pre { margin:0px 0px 20px; }pre.error { color:red; }pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }span.keyword { color:#0000FF }span.comment { color:#228B22 }span.string { color:#A020F0 }span.untermstring { color:#B20000 }span.syscmd { color:#B28C00 }.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }.footer p { margin:0px; }  </style>  </head>  <body>    <div class="content">      <h1>SDGDEDGE - Edge detection based on gradient second derivative.</h1>      <!--introduction--><!--/introduction-->      <h2>Contents</h2>      <div>        <ul>          <li><a href="#1">Description</a></li>          <li><a href="#2">Syntax</a></li>          <li><a href="#3">Inputs</a></li>          <li><a href="#4">Property [propertyname propertyvalues]</a></li>          <li><a href="#5">Outputs</a></li>          <li><a href="#6">Acknowledgment</a></li>          <li><a href="#7">References</a></li>          <li><a href="#9">See also</a></li>          <li><a href="#10">Function implementation</a></li>        </ul>      </div>      <h2>Description<a name="1"></a></h2>      <p>Edge detection filter with 2D kernel based on the 2nd derivative in the        gradient direction or its combination with the Laplacian. This function        convolves the input image with set 2D Gaussian kernels and then combines        the results in accordance to the formula in [MH86].</p>      <h2>Syntax<a name="2"></a></h2>      <pre>   edgemap = SDGDEDGE(I);   edgemap = SDGDEDGE(I, sigma, 'propertyname',propertyvalues ...);</pre>      <h2>Inputs<a name="3"></a></h2>      <p><b><tt>I</tt></b> : input image of size <tt>(X,Y,C)</tt>, possibly        multichannel with <tt>C&gt;1</tt>.</p>      <p><b><tt>sigma</tt></b> : optional standard deviation of the Gaussian        filter used for smoothing of the image; default: <tt>sigma=1</tt>.</p>      <h2>Property [propertyname propertyvalues]<a name="4"></a></h2>      <p><b><tt>'plus'</tt></b> : optional boolean flag for using the 2nd        derivative in the gradient direction combined with the Laplacian filter        (filter 'PLUS', see [VV94]) when set to <tt>true</tt>; the regular SDGD        is used otherwise; default: <tt>plus=false</tt>.</p>      <p><b><tt>'thres'</tt></b> : threshold (in <tt>[0,1]</tt>) used for        estimating the binary map from the derivative output filter; default: <tt>thres=0.1</tt>.</p>      <p><b><tt>'hsize'</tt></b> : size of the window of the filtering kernel;        default: <tt>hsize</tt> is estimated depending on <tt>sigma</tt>.</p>      <h2>Outputs<a name="5"></a></h2>      <p><b><tt>edgemap</tt></b> : the output edge map.</p>      <h2>Acknowledgment<a name="6"></a></h2>      <p><a href="mailto:sergei.koptenko%7Bat%7Dresonantmedical.com">Sergei          Koptenko</a>, Resonant Medical, Montreal (Qc., Canada), <a href="www.resonantmedical.com">www.resonantmedical.com</a>.</p>      <h2>References<a name="7"></a></h2>      <p>[MH86] D. Marr and E.C. Hildreth: "Theory of edge Detection",        Proceedings of the Royal Society, 207:187-217, 1980. <a href="http://rspb.royalsocietypublishing.org/content/207/1167/187">http://rspb.royalsocietypublishing.org/content/207/1167/187</a></p>      <p>[VV94] P.W. Verbeek and L.J. Vliet: "On the location error of curved        edges in low-pass filtered 2-D and 3-D images", IEEE Trans. on Pattern        Analysis and Machine Intelligence, 16(7):726-733, 1994. <a href="http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=297954">http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=297954</a></p>      <h2>See also<a name="9"></a></h2>      <p>Related: <a href="EDGEcorner.html"><tt>EDGECORNER</tt></a>, <a href="cannyedge.html"><tt>CANNYEDGE</tt></a>,        <a href="cannyedgeprod.html"><tt>CANNYEDGEPROD</tt></a>, <a href="rothwelledge.html"><tt>ROTHWELLEDGE</tt></a>,        <a href="congruencyedge.html"><tt>CONGRUENCYEDGE</tt></a>, <a href="compassedge.html"><tt>COMPASSEDGE</tt></a>,        <a href="anisoedge.html"><tt>ANISOEDGE</tt></a>, <a href="elderzuckeredge.html"><tt>ELDERZUCKEREDGE</tt></a>,        <a href="koethedge.html"><tt>KOETHEDGE</tt></a>, <a href="petrouedge.html"><tt>PETROUEDGE</tt></a>.        Called: <a href="sdgdedge_base.html"><tt>SDGDEDGE_BASE</tt></a>.</p>      <h2>Function implementation<a name="10"></a></h2>      <pre class="codeinput"><span class="keyword">function</span> edgemap = sdgdedge(I, varargin)</pre>      <p>parsing parameters</p>      <pre class="codeinput">error(nargchk(1, 18, nargin, <span class="string">'struct'</span>));error(nargoutchk(1, 1, nargout, <span class="string">'struct'</span>));<span class="keyword">if</span> ~isnumeric(I)    error(<span class="string">'sdgdedge:inputparameter'</span>,<span class="string">'a matrix is required in input'</span>);<span class="keyword">end</span>p = createParser(<span class="string">'SDGDEDGE'</span>);p.addOptional(<span class="string">'sigma'</span>, 1., @(x)isscalar(x) &amp;&amp; x&gt;=0.05);p.addParamValue(<span class="string">'plus'</span>, false, @(x)islogical(x));<span class="comment">%p.addParamValue('method', 'sdgd', @(x)ischar(x) &amp;&amp; ...</span><span class="comment">%    any(strcmpi(x,{'sdgd','plus'})));</span>p.addParamValue(<span class="string">'thres'</span>, 0.1, @(x)isscalar(x) &amp;&amp; x&lt;=1 &amp;&amp; x&gt;0);p.addParamValue(<span class="string">'hsize'</span>,[], @isscalar);p.addParamValue(<span class="string">'mu'</span>, 0, @isscalar); <span class="comment">% not used</span><span class="comment">% parse and validate all input arguments</span>p.parse(varargin{:});p = getvarParser(p);</pre>      <p>main computation</p>      <pre class="codeinput">edgemap = sdgdedge_base(I, p.plus, p.sigma, p.mu, p.thres, p.hsize);</pre>      <p>display</p>      <pre class="codeinput"><span class="keyword">if</span> p.disp    figure, imagesc(edgemap), axis <span class="string">image</span> <span class="string">off</span>, title(<spanclass="string">'SDGD edge map'</span>);    <span class="keyword">if</span> size(edgemap,3) == 1, colormap <span class="string">gray</span>;  <spanclass="keyword">end</span>;<span class="keyword">end</span></pre>      <pre class="codeinput"><span class="keyword">end</span></pre></div>    <!--##### SOURCE BEGIN #####%% SDGDEDGE - Edge detection based on gradient second derivative.%%% Description% Edge detection filter with 2D kernel based on the 2nd derivative in the% gradient direction or its combination with the Laplacian. This function% convolves the input image with set 2D Gaussian kernels and then combines % the results in accordance to the formula in [MH86].%%% Syntax%     edgemap = SDGDEDGE(I);%     edgemap = SDGDEDGE(I, sigma, 'propertyname',propertyvalues ...);%%% Inputs% *|I|* : input image of size |(X,Y,C)|, possibly multichannel with |C>1|.%% *|sigma|* : optional standard deviation of the Gaussian filter used for%     smoothing of the image; default: |sigma=1|.%%% Property [propertyname  propertyvalues]% *|'plus'|* : optional boolean flag for using the 2nd derivative in the%     gradient direction combined with the Laplacian filter (filter 'PLUS',%     see [VV94]) when set to |true|; the regular SDGD is used otherwise;%     default: |plus=false|. %% *|'thres'|* : threshold (in |[0,1]|) used for estimating the binary map from%     the derivative output filter; default: |thres=0.1|.%% *|'hsize'|* : size of the window of the filtering kernel; default: |hsize|%     is estimated depending on |sigma|.%%% Outputs% *|edgemap|* : the output edge map.%%% Acknowledgment% <mailto:sergei.koptenko{at}resonantmedical.com  Sergei Koptenko>, Resonant% Medical, Montreal (Qc., Canada), <www.resonantmedical.com>.  %%% References% [MH86]  D. Marr and E.C. Hildreth: "Theory of edge Detection", Proceedings%      of the Royal Society, 207:187-217, 1980.%      <http://rspb.royalsocietypublishing.org/content/207/1167/187>%% [VV94]  P.W. Verbeek and L.J. Vliet: "On the location error of curved%      edges in low-pass filtered 2-D and 3-D images", IEEE Trans. on Pattern %      Analysis and Machine Intelligence, 16(7):726-733, 1994.%      <http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=297954>%%% Contact% <mailto:grazzja@lanl.gov J.Grazzini> (ISR-2/LANL)%%% See also% Related:% <EDGEcorner.html |EDGECORNER|>,% <cannyedge.html |CANNYEDGE|>,% <cannyedgeprod.html |CANNYEDGEPROD|>,% <rothwelledge.html |ROTHWELLEDGE|>,% <congruencyedge.html |CONGRUENCYEDGE|>,% <compassedge.html |COMPASSEDGE|>,% <anisoedge.html |ANISOEDGE|>,% <elderzuckeredge.html |ELDERZUCKEREDGE|>,% <koethedge.html |KOETHEDGE|>,% <petrouedge.html |PETROUEDGE|>.% Called:% <sdgdedge_base.html |SDGDEDGE_BASE|>.%% Function implementationfunction edgemap = sdgdedge(I, varargin)%% % parsing parameters error(nargchk(1, 18, nargin, 'struct'));error(nargoutchk(1, 1, nargout, 'struct'));if ~isnumeric(I)    error('sdgdedge:inputparameter','a matrix is required in input'); endp = createParser('SDGDEDGE');   p.addOptional('sigma', 1., @(x)isscalar(x) && x>=0.05);p.addParamValue('plus', false, @(x)islogical(x));%p.addParamValue('method', 'sdgd', @(x)ischar(x) && ...%    any(strcmpi(x,{'sdgd','plus'})));p.addParamValue('thres', 0.1, @(x)isscalar(x) && x<=1 && x>0);p.addParamValue('hsize',[], @isscalar);p.addParamValue('mu', 0, @isscalar); % not used% parse and validate all input argumentsp.parse(varargin{:}); p = getvarParser(p);                                                            %%% main computationedgemap = sdgdedge_base(I, p.plus, p.sigma, p.mu, p.thres, p.hsize);%%% displayif p.disp    figure, imagesc(edgemap), axis image off, title('SDGD edge map');    if size(edgemap,3) == 1, colormap gray;  end;endend##### SOURCE END #####--></body></html>