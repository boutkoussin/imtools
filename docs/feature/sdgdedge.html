<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html>  <head>    <meta content="text/html; charset=UTF-8" http-equiv="content-type">    <title>SDGDEDGE - Edge detection based on gradient second derivative.</title>    <meta name="generator" content="MATLAB 7.11">    <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">    <meta name="DC.date" content="2011-07-08">    <meta name="DC.source" content="sdgdedge.m">    <style type="text/css">body {  background-color: white;  margin:10px;}h1 {  color: #990000;   font-size: x-large;}h2 {  color: #990000;  font-size: medium;}/* Make the text shrink to fit narrow windows, but not stretch too far in wide windows. */ p,h1,h2,div.content div {  max-width: 600px;  /* Hack for IE6 */  width: auto !important; width: 600px;}pre.codeinput {  background: #EEEEEE;  padding: 10px;}@media print {  pre.codeinput {word-wrap:break-word; width:100%;}} span.keyword {color: #0000FF}span.comment {color: #228B22}span.string {color: #A020F0}span.untermstring {color: #B20000}span.syscmd {color: #B28C00}pre.codeoutput {  color: #666666;  padding: 10px;}pre.error {  color: red;}p.footer {  text-align: right;  font-size: xx-small;  font-weight: lighter;  font-style: italic;  color: gray;}  </style>  </head>  <body>    <div class="content">      <h1>SDGDEDGE - Edge detection based on gradient second derivative.</h1>      <!--introduction--><!--/introduction-->      <h2>Contents</h2>      <div>        <ul>          <li><a href="#1">Description</a></li>          <li><a href="#2">Syntax</a></li>          <li><a href="#3">Inputs</a></li>          <li><a href="#4">Property [propertyname propertyvalues]</a></li>          <li><a href="#5">Outputs</a></li>          <li><a href="#6">Acknowledgment</a></li>          <li><a href="#7">References</a></li>          <li><a href="#9">See also</a></li>          <li><a href="#10">Function implementation</a></li>        </ul>      </div>      <h2>Description<a name="1"></a></h2>      <p>Edge detection filter with 2D kernel based on the 2nd derivative in the        gradient direction or its combination with the Laplacian. This function        convolves the input image with set 2D Gaussian kernels and then combines        the results in accordance to the formula in [MH86].</p>      <h2>Syntax<a name="2"></a></h2>      <pre>   edgemap = SDGDEDGE(I);   edgemap = SDGDEDGE(I, sigma, 'propertyname',propertyvalues ...);</pre>      <h2>Inputs<a name="3"></a></h2>      <p><b><tt>I</tt></b> : input image of size <tt>(X,Y,C)</tt>, possibly        multichannel with <tt>C&gt;1</tt>.</p>      <p><b><tt>sigma</tt></b> : optional standard deviation of the Gaussian        filter used for smoothing of the image; default: <tt>sigma=1</tt>.</p>      <h2>Property [propertyname propertyvalues]<a name="4"></a></h2>      <p><b><tt>'plus'</tt></b> : optional boolean flag for using the 2nd        derivative in the gradient direction combined with the Laplacian filter        (filter 'PLUS', see [VV94]) when set to <tt>true</tt>; the regular SDGD        is used otherwise; default: <tt>plus=false</tt>.</p>      <p><b><tt>'thres'</tt></b> : threshold (in <tt>[0,1]</tt>) used for        estimating the binary map from the derivative output filter; default: <tt>thres=0.1</tt>.</p>      <p><b><tt>'hsize'</tt></b> : size of the window of the filtering kernel;        default: <tt>hsize</tt> is estimated depending on <tt>sigma</tt>.</p>      <h2>Outputs<a name="5"></a></h2>      <p><b><tt>edgemap</tt></b> : the output edge map.</p>      <h2>Acknowledgment<a name="6"></a></h2>      <p><a href="mailto:sergei.koptenko%7Bat%7Dresonantmedical.com"> Sergei          Koptenko</a>, Resonant Medical, Montreal (Qc., Canada), <a href="www.resonantmedical.com">www.resonantmedical.com</a>.</p>      <h2>References<a name="7"></a></h2>      <p>[MH86] D. Marr and E.C. Hildreth: "Theory of edge Detection",        Proceedings of the Royal Society, 207:187-217, 1980. <a href="http://rspb.royalsocietypublishing.org/content/207/1167/187">http://rspb.royalsocietypublishing.org/content/207/1167/187</a></p>      <p>[VV94] P.W. Verbeek and L.J. Vliet: "On the location error of curved        edges in low-pass filtered 2-D and 3-D images", IEEE Trans. on Pattern        Analysis and Machine Intelligence, 16(7):726-733, 1994. <a href="http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=297954">http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=297954</a></p>      <h2>See also<a name="9"></a></h2>      <p>Related: <a href="EDGECORNER.html"><tt>EDGECORNER</tt></a>, <a href="CANNYEDGE.html"><tt>CANNYEDGE</tt></a>,        <a href="CANNYEDGEPROD.html"><tt>CANNYEDGEPROD</tt></a>, <a href="ROTHWELLEDGE.html"><tt>ROTHWELLEDGE</tt></a>,        <a href="CONGRUENCYEDGE.html"><tt>CONGRUENCYEDGE</tt></a>, <a href="COMPASSEDGE.html"><tt>COMPASSEDGE</tt></a>,        <a href="ANISOEDGE.html"><tt>ANISOEDGE</tt></a>, <a href="ELDERZUCKEREDGE.html"><tt>ELDERZUCKEREDGE</tt></a>,        <a href="KOETHEDGE.html"><tt>KOETHEDGE</tt></a>, <a href="PETROUEDGE.html"><tt>PETROUEDGE</tt></a>.        Called: <a href="SDGDEDGE_BASE.html"><tt>SDGDEDGE_BASE</tt></a>.</p>      <h2>Function implementation<a name="10"></a></h2>      <pre class="codeinput"><span class="keyword">function</span> edgemap = sdgdedge(I, varargin)</pre>      <p>parsing parameters</p>      <pre class="codeinput">error(nargchk(1, 18, nargin, <span class="string">'struct'</span>));error(nargoutchk(1, 1, nargout, <span class="string">'struct'</span>));<span class="keyword">if</span> ~isnumeric(I)    error(<span class="string">'sdgdedge:inputparameter'</span>,<span class="string">'a matrix is required in input'</span>);<span class="keyword">end</span>p = createParser(<span class="string">'SDGDEDGE'</span>);p.addOptional(<span class="string">'sigma'</span>, 1., @(x)isscalar(x) &amp;&amp; x&gt;=0.05);p.addParamValue(<span class="string">'plus'</span>, false, @(x)islogical(x));<span class="comment">%p.addParamValue('method', 'sdgd', @(x)ischar(x) &amp;&amp; ...</span><span class="comment">%    any(strcmpi(x,{'sdgd','plus'})));</span>p.addParamValue(<span class="string">'thres'</span>, 0.1, @(x)isscalar(x) &amp;&amp; x&lt;=1 &amp;&amp; x&gt;0);p.addParamValue(<span class="string">'hsize'</span>,[], @isscalar);p.addParamValue(<span class="string">'mu'</span>, 0, @isscalar); <span class="comment">% not used</span><span class="comment">% parse and validate all input arguments</span>p.parse(varargin{:});p = getvarParser(p);</pre>      <p>main computation</p>      <pre class="codeinput">edgemap = sdgdedge_base(I, p.plus, p.sigma, p.mu, p.thres, p.hsize);</pre>      <p>display</p>      <pre class="codeinput"><span class="keyword">if</span> p.disp    figure, imagesc(edgemap), axis <span class="string">image</span> <span class="string">off</span>, title(<spanclass="string">'SDGD edge map'</span>);    <span class="keyword">if</span> size(edgemap,3) == 1, colormap <span class="string">gray</span>;  <spanclass="keyword">end</span>;<span class="keyword">end</span></pre>      <pre class="codeinput"><span class="keyword">end</span></pre> </div>    <!--##### SOURCE BEGIN #####%% SDGDEDGE - Edge detection based on gradient second derivative.%%% Description% Edge detection filter with 2D kernel based on the 2nd derivative in the% gradient direction or its combination with the Laplacian. This function% convolves the input image with set 2D Gaussian kernels and then combines % the results in accordance to the formula in [MH86].%%% Syntax%     edgemap = SDGDEDGE(I);%     edgemap = SDGDEDGE(I, sigma, 'propertyname',propertyvalues ...);%%% Inputs% *|I|* : input image of size |(X,Y,C)|, possibly multichannel with |C>1|.%% *|sigma|* : optional standard deviation of the Gaussian filter used for%     smoothing of the image; default: |sigma=1|.%%% Property [propertyname  propertyvalues]% *|'plus'|* : optional boolean flag for using the 2nd derivative in the%     gradient direction combined with the Laplacian filter (filter 'PLUS',%     see [VV94]) when set to |true|; the regular SDGD is used otherwise;%     default: |plus=false|. %% *|'thres'|* : threshold (in |[0,1]|) used for estimating the binary map from%     the derivative output filter; default: |thres=0.1|.%% *|'hsize'|* : size of the window of the filtering kernel; default: |hsize|%     is estimated depending on |sigma|.%%% Outputs% *|edgemap|* : the output edge map.%%% Acknowledgment% <mailto:sergei.koptenko{at}resonantmedical.com  Sergei Koptenko>, Resonant% Medical, Montreal (Qc., Canada), <www.resonantmedical.com>.  %%% References% [MH86]  D. Marr and E.C. Hildreth: "Theory of edge Detection", Proceedings%      of the Royal Society, 207:187-217, 1980.%      <http://rspb.royalsocietypublishing.org/content/207/1167/187>%% [VV94]  P.W. Verbeek and L.J. Vliet: "On the location error of curved%      edges in low-pass filtered 2-D and 3-D images", IEEE Trans. on Pattern %      Analysis and Machine Intelligence, 16(7):726-733, 1994.%      <http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=297954>%%% Contact% <mailto:grazzja@lanl.gov J.Grazzini> (ISR-2/LANL)%%% See also% Related:% <EDGECORNER.html |EDGECORNER|>,% <CANNYEDGE.html |CANNYEDGE|>,% <CANNYEDGEPROD.html |CANNYEDGEPROD|>,% <ROTHWELLEDGE.html |ROTHWELLEDGE|>,% <CONGRUENCYEDGE.html |CONGRUENCYEDGE|>,% <COMPASSEDGE.html |COMPASSEDGE|>,% <ANISOEDGE.html |ANISOEDGE|>,% <ELDERZUCKEREDGE.html |ELDERZUCKEREDGE|>,% <KOETHEDGE.html |KOETHEDGE|>,% <PETROUEDGE.html |PETROUEDGE|>.% Called:% <SDGDEDGE_BASE.html |SDGDEDGE_BASE|>.%% Function implementationfunction edgemap = sdgdedge(I, varargin)%% % parsing parameters error(nargchk(1, 18, nargin, 'struct'));error(nargoutchk(1, 1, nargout, 'struct'));if ~isnumeric(I)    error('sdgdedge:inputparameter','a matrix is required in input'); endp = createParser('SDGDEDGE');   p.addOptional('sigma', 1., @(x)isscalar(x) && x>=0.05);p.addParamValue('plus', false, @(x)islogical(x));%p.addParamValue('method', 'sdgd', @(x)ischar(x) && ...%    any(strcmpi(x,{'sdgd','plus'})));p.addParamValue('thres', 0.1, @(x)isscalar(x) && x<=1 && x>0);p.addParamValue('hsize',[], @isscalar);p.addParamValue('mu', 0, @isscalar); % not used% parse and validate all input argumentsp.parse(varargin{:}); p = getvarParser(p);                                                            %%% main computationedgemap = sdgdedge_base(I, p.plus, p.sigma, p.mu, p.thres, p.hsize);%%% displayif p.disp    figure, imagesc(edgemap), axis image off, title('SDGD edge map');    if size(edgemap,3) == 1, colormap gray;  end;endend##### SOURCE END #####-->  </body></html>