<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html>  <head>    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">    <title>SUSANCORNER_BASE - Base function for SUSANCORNER.</title>    <meta name="generator" content="MATLAB 7.11">    <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">    <meta name="DC.date" content="2011-07-08">    <meta name="DC.source" content="susancorner_base.m">    <style type="text/css">body {  background-color: white;  margin:10px;}h1 {  color: #990000;   font-size: x-large;}h2 {  color: #990000;  font-size: medium;}/* Make the text shrink to fit narrow windows, but not stretch too far in wide windows. */ p,h1,h2,div.content div {  max-width: 600px;  /* Hack for IE6 */  width: auto !important; width: 600px;}pre.codeinput {  background: #EEEEEE;  padding: 10px;}@media print {  pre.codeinput {word-wrap:break-word; width:100%;}} span.keyword {color: #0000FF}span.comment {color: #228B22}span.string {color: #A020F0}span.untermstring {color: #B20000}span.syscmd {color: #B28C00}pre.codeoutput {  color: #666666;  padding: 10px;}pre.error {  color: red;}p.footer {  text-align: right;  font-size: xx-small;  font-weight: lighter;  font-style: italic;  color: gray;}  </style>  </head>  <body>    <div class="content">      <h1>SUSANCORNER_BASE - Base function for SUSANCORNER.</h1>      <!--introduction--><!--/introduction-->      <h2>Contents</h2>      <div>        <ul>          <li><a href="#1">Syntax</a></li>          <li><a href="#2">Acknowledgment</a></li>          <li><a href="#3">Contact</a></li>          <li><a href="#4">See also</a></li>          <li><a href="#5">Function implementation</a></li>        </ul>      </div>      <h2>Syntax<a name="1"></a></h2>      <pre>   Smap = SUSANCORNER_BASE(I, mode, thres, md, n, q);   [ptcorner, cornermap] = SUSANCORNER_BASE(I, mode, thres, md, n, q);</pre>      <h2>Acknowledgment<a name="2"></a></h2>      <p>The original C code and algorithm description at: <a href="http://www.fmrib.ox.ac.uk/%7Esteve/susan/">http://www.fmrib.ox.ac.uk/~steve/susan/</a>        SUSAN Version 2l (C) 1995-1997: <a href="mailto:steve@fmrib.ox.ac.uk">Stephen
          Smith</a>, DRA UK. author of the mexification (see susan_mex):        , <a href="mailto:jluis@ualg.pt">Joaquim Luis</a></p>      <h2>See also<a name="4"></a></h2>      <p>Related: <a href="SUSANCORNER.html"><tt>SUSANCORNER</tt></a>,        <a href="EDGECORNER_BASE.html"><tt>EDGECORNER_BASE</tt></a>, <a          href="HARRISCORNER_BASE.html"><tt>HARRISCORNER_BASE</tt></a>,        <a href="FASTCPDA_BASE.html"><tt>FASTCPDA_BASE</tt></a>, <a href="FASTCORNER_BASE.html"><tt>FASTCORNER_BASE</tt></a>.        Called: SUSAN_MEX.</p>      <h2>Function implementation<a name="5"></a></h2>      <pre class="codeinput"><span class="keyword">function</span> [Smap, varargout] = susancorner_base(I, mode, thres, md, n, q)</pre>      <p>dealing with multispectral images</p>      <pre class="codeinput">[X,Y,C] = size(I);<span class="keyword">if</span> any(strcmpi(mode,{<span class="string">'e'</span>,<spanclass="string">'¨ei'</span>,<spanclass="string">'s'</span>})),   Smap = false(size(I));<span class="keyword">else</span>    Smap = cell(C,1);    <span class="keyword">if</span> nargout==2,  varargout{1} = false(X,Y);  <spanclass="keyword">end</span>;<span class="keyword">end</span><span class="keyword">if</span> C&gt;1    <span class="keyword">for</span> c=1:C        [tmp1, tmp2] = susancorner_base(I(:,:,c), mode, thres, md, n, q);        <span class="keyword">if</span> any(strcmpi(mode,{<span class="string">'e'</span>,<spanclass="string">'¨ei'</span>,<spanclass="string">'s'</span>})),     Smap(:,:,c) = tmp1;        <span class="keyword">else</span>            Smap{c} = tmp1{1};            <span class="keyword">if</span> nargout==2,  varargout{1}(:,:,c) = tmp2;  <spanclass="keyword">end</span>;        <span class="keyword">end</span>;    <span class="keyword">end</span>    <span class="keyword">return</span>;<span class="keyword">end</span></pre>      <p>main computation</p>      <pre class="codeinput"><span class="comment">% susan_mex is available</span><span class="keyword">if</span> exist(<span class="string">'susan_mex'</span>,<spanclass="string">'file'</span>) &amp;&amp; strcmpi(class(I),<spanclass="string">'uint8'</span>) <spanclass="comment">%&amp;&amp; false</span>    <span class="comment">% create the string storing the list of arguments</span>    larg = [ <span class="string">',''-'</span> num2str(mode) <span class="string">''',''-t'</span> num2str(thres) <spanclass="string">''''</span>];    <span class="keyword">if</span> ischar(md) <span class="comment">% &amp;&amp; strcmp(mask,'flat')</span>        larg = [larg <span class="string">',''-3'''</span>];    <span class="keyword">elseif</span> any(strcmp(mode,{<span class="string">'e'</span>,<spanclass="string">'ei'</span>,<spanclass="string">'s'</span>}))        larg = [larg <span class="string">',''-d'</span> num2str(md) <spanclass="string">''''</span>];    <span class="keyword">end</span>    <span class="keyword">if</span> n,        larg = [larg <span class="string">',''-n'''</span>];    <spanclass="keyword">end</span>    <span class="keyword">if</span> q,        larg = [larg <span class="string">',''-q'''</span>];    <spanclass="keyword">end</span>    <span class="comment">% run the mex file</span>    eval([<span class="string">'S=susan_mex(I'</span> larg <span class="string">');'</span>]);    <span class="keyword">if</span> any(strcmp(mode,{<span class="string">'e'</span>,<spanclass="string">'ei'</span>,<spanclass="string">'s'</span>}))        Smap = S;    <span class="keyword">else</span>        Smap{1} = S;    <span class="keyword">end</span><span class="keyword">elseif</span> any(strcmp(mode,{<span class="string">'e'</span>,<spanclass="string">'ei'</span>}))    <span class="comment">% otherwise for matlab: an attempt to do withtout the C</span>    <span class="comment">% mask for selecting the pixels within the circular region (37 pixels), as</span>    <span class="comment">% used in the SUSAN algorithm</span>    mask = [ 0 0 1 1 1 0 0 ,<span class="keyword">...</span>        0 1 1 1 1 1 0,<span class="keyword">...</span>        1 1 1 1 1 1 1,<span class="keyword">...</span>        1 1 1 1 1 1 1,<span class="keyword">...</span>        1 1 1 1 1 1 1,<span class="keyword">...</span>        0 1 1 1 1 1 0,<span class="keyword">...</span>        0 0 1 1 1 0 0];    mask = mask(:);    wmask = 3;    <span class="comment">% define the USAN area</span>    nmax = 3*37/4;    <span class="comment">% padding the image</span>    pad = 2*wmask+1;    A = padarray(I, [wmask wmask],<span class="string">'replicate'</span>,<spanclass="string">'both'</span>);    pixA = reshape(1:numel(A),size(A));    pixI = reshape(pixA(wmask+1:wmask+X,wmask+1:wmask+Y),1,X*Y);    <span class="comment">% index of the centered neighbour window of analysis</span>    indI = -wmask:wmask;    <span class="keyword">for</span> i=1:wmask        indI = [ (-i*X-wmask):(-i*X+wmask), <span class="keyword">...</span>            indI, <span class="keyword">...</span>            (i*X-wmask):(i*X+wmask) ];                                 <spanclass="comment">%#ok</span>    <span class="keyword">end</span>    indI = indI'; indI = indI(:);    indc = wmask * (pad+1) +1;    <span class="comment">% the output image indicating found edges</span>    Smap = zeros(size(A));    <span class="keyword">for</span> in=pixI        c = mask .* A(indI + in);        <span class="comment">% thresholding scheme: c = exp(-{(I(r)-I(r0))/t}^(5/6)} applied to</span>        <span class="comment">% the current neighborhood of the center pixel within the circle defined</span>        <span class="comment">% by the mask</span>        tmp = (c-c(indc))/thres;        tmp = tmp.^6;        c = exp(-tmp);        <span class="comment">% if binary thresholding is applied</span>        <span class="comment">% c(abs(c-c(indc))&gt;threshold)=0;</span>        <span class="comment">% c(abs(c-c(indc))&lt;=threshold)=1;</span>        g = sum(c(:));        <span class="keyword">if</span> nmax&lt;g, Smap(in) = g-nmax; <spanclass="keyword">end</span>    <span class="keyword">end</span>    Smap = Smap(pixI);<span class="keyword">else</span>    error(<span class="string">'susancorner_base:methoderror'</span>, <spanclass="keyword">...</span>        [<span class="string">'method '</span> mode <span class="string">' implemented only using susan_mex'</span>]);<span class="keyword">end</span><span class="keyword">if</span> nargout==2    <span class="keyword">if</span> ~strcmpi(mode,<span class="string">'c'</span>),     varargout{1} = [];    <span class="keyword">else</span>        varargout{1} = false(X,Y);        varargout{1}(sub2ind([X,Y],Smap{1}(:,1),Smap{1}(:,2))) = true;    <span class="keyword">end</span>;<span class="keyword">end</span></pre>      <pre class="codeinput"><span class="keyword">end</span> <span class="comment">% end of susancorner_base</span></pre> </div>    <!--##### SOURCE BEGIN #####%% SUSANCORNER_BASE - Base function for SUSANCORNER.% %% Syntax%     Smap = SUSANCORNER_BASE(I, mode, thres, md, n, q);%     [ptcorner, cornermap] = SUSANCORNER_BASE(I, mode, thres, md, n, q);%%% Acknowledgment% The original C code and algorithm description at:%    <http://www.fmrib.ox.ac.uk/~steve/susan/>% SUSAN Version 2l (C) 1995-1997: <mailto:steve@fmrib.ox.ac.uk Stephen Smith>, DRA UK.% author of the mexification (see susan_mex): , <mailto:jluis@ualg.pt Joaquim Luis>%%% Contact% <mailto:grazzja@lanl.gov J.Grazzini> (ISR-2/LANL)%%% See also% Related:% <SUSANCORNER.html |SUSANCORNER|>,% <EDGECORNER_BASE.html |EDGECORNER_BASE|>,% <HARRISCORNER_BASE.html |HARRISCORNER_BASE|>,% <FASTCPDA_BASE.html |FASTCPDA_BASE|>,% <FASTCORNER_BASE.html |FASTCORNER_BASE|>.% Called: % SUSAN_MEX.%% Function implementationfunction [Smap, varargout] = susancorner_base(I, mode, thres, md, n, q)%%% dealing with multispectral images[X,Y,C] = size(I);if any(strcmpi(mode,{'e','¨ei','s'})),   Smap = false(size(I));else    Smap = cell(C,1);      if nargout==2,  varargout{1} = false(X,Y);  end;endif C>1       for c=1:C        [tmp1, tmp2] = susancorner_base(I(:,:,c), mode, thres, md, n, q);        if any(strcmpi(mode,{'e','¨ei','s'})),     Smap(:,:,c) = tmp1;        else            Smap{c} = tmp1{1};            if nargout==2,  varargout{1}(:,:,c) = tmp2;  end;        end;    end    return;end%% % main computation% susan_mex is availableif exist('susan_mex','file') && strcmpi(class(I),'uint8') %&& false    % create the string storing the list of arguments    larg = [ ',''-' num2str(mode) ''',''-t' num2str(thres) ''''];    if ischar(md) % && strcmp(mask,'flat')        larg = [larg ',''-3'''];    elseif any(strcmp(mode,{'e','ei','s'}))        larg = [larg ',''-d' num2str(md) ''''];    end    if n,        larg = [larg ',''-n'''];    end    if q,        larg = [larg ',''-q'''];    end    % run the mex file    eval(['S=susan_mex(I' larg ');']);    if any(strcmp(mode,{'e','ei','s'}))        Smap = S;    else        Smap{1} = S;    end    elseif any(strcmp(mode,{'e','ei'}))    % otherwise for matlab: an attempt to do withtout the C        % mask for selecting the pixels within the circular region (37 pixels), as    % used in the SUSAN algorithm    mask = [ 0 0 1 1 1 0 0 ,...        0 1 1 1 1 1 0,...        1 1 1 1 1 1 1,...        1 1 1 1 1 1 1,...        1 1 1 1 1 1 1,...        0 1 1 1 1 1 0,...        0 0 1 1 1 0 0];    mask = mask(:);    wmask = 3;        % define the USAN area    nmax = 3*37/4;        % padding the image    pad = 2*wmask+1;    A = padarray(I, [wmask wmask],'replicate','both');    pixA = reshape(1:numel(A),size(A));    pixI = reshape(pixA(wmask+1:wmask+X,wmask+1:wmask+Y),1,X*Y);        % index of the centered neighbour window of analysis    indI = -wmask:wmask;    for i=1:wmask        indI = [ (-i*X-wmask):(-i*X+wmask), ...            indI, ...            (i*X-wmask):(i*X+wmask) ];                                 %#ok    end    indI = indI'; indI = indI(:);        indc = wmask * (pad+1) +1;        % the output image indicating found edges    Smap = zeros(size(A));        for in=pixI        c = mask .* A(indI + in);                % thresholding scheme: c = exp(-{(I(r)-I(r0))/t}^(5/6)} applied to        % the current neighborhood of the center pixel within the circle defined        % by the mask        tmp = (c-c(indc))/thres;        tmp = tmp.^6;        c = exp(-tmp);        % if binary thresholding is applied        % c(abs(c-c(indc))>threshold)=0;        % c(abs(c-c(indc))<=threshold)=1;                g = sum(c(:));                if nmax<g, Smap(in) = g-nmax; end    end        Smap = Smap(pixI);    else    error('susancorner_base:methoderror', ...        ['method ' mode ' implemented only using susan_mex']);    endif nargout==2    if ~strcmpi(mode,'c'),     varargout{1} = [];    else        varargout{1} = false(X,Y);        varargout{1}(sub2ind([X,Y],Smap{1}(:,1),Smap{1}(:,2))) = true;    end;endend % end of susancorner_base##### SOURCE END #####-->  </body></html>