<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html>  <head>    <meta content="text/html; charset=utf-8" http-equiv="content-type">    <!--This HTML was auto-generated from MATLAB code.To make changes, update the MATLAB code and republish this document.      -->    <title>EDGECORNER_BASE - Base function for EDGECORNER.</title>    <meta name="generator" content="MATLAB 7.14">    <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">    <meta name="DC.date" content="2012-05-31">    <meta name="DC.source" content="edgecorner_base.m">    <style type="text/css">html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}html { min-height:100%; margin-bottom:1px; }html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }html body td { vertical-align:top; text-align:left; }h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }a { color:#005fce; text-decoration:none; }a:hover { color:#005fce; text-decoration:underline; }a:visited { color:#004aa0; text-decoration:none; }p { padding:0px; margin:0px 0px 20px; }img { padding:0px; margin:0px 0px 20px; border:none; }p img, pre img, tt img, li img { margin-bottom:0px; } ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }ul li { padding:0px; margin:0px 0px 7px 0px; }ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }ul li ol li { list-style:decimal; }ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }ol li ol li { list-style-type:lower-alpha; }ol li ul { padding-top:7px; }ol li ul li { list-style:square; }.content { font-size:1.2em; line-height:140%; padding: 20px; }pre, tt, code { font-size:12px; }pre { margin:0px 0px 20px; }pre.error { color:red; }pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }span.keyword { color:#0000FF }span.comment { color:#228B22 }span.string { color:#A020F0 }span.untermstring { color:#B20000 }span.syscmd { color:#B28C00 }.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }.footer p { margin:0px; }  </style>  </head>  <body>    <div class="content">      <h1>EDGECORNER_BASE - Base function for EDGECORNER.</h1>      <!--introduction--><!--/introduction-->      <h2>Contents</h2>      <div>        <ul>          <li><a href="#1">Syntax</a></li>          <li><a href="#3">See also</a></li>          <li><a href="#4">Function implementation</a></li>        </ul>      </div>      <h2>Syntax<a name="1"></a></h2>      <pre>   [edgemap, cormap] = ...            EDGECORNER_BASE(I, edge, corner, rho, sigma, thres, reduce);   [edgemap, cormap, MO] = ...            EDGECORNER_BASE(I, edge, corner, rho, sigma, thres, reduce);   [edgemap, cormap, T] = ...            EDGECORNER_BASE(I, edge, corner, rho, sigma, thres, reduce);</pre>      <h2>See also<a name="3"></a></h2>      <p>Related: <a href="EDGECORNER.html"><tt>EDGECORNER</tt></a>, <a href="CORNER_BASE.html"><tt>CORNER_BASE</tt></a>.        Called: <a href="matlab:webpub%28whichpath%28%27EDGE%27%29%29"><tt>EDGE</tt></a>,        <a href="../../derive/html/GRDSMOOTH_BASE.html"><tt>GRDSMOOTH_BASE</tt></a>,        <a href="../../algebra/html/RESCALE.html"><tt>RESCALE</tt></a>. <a href="../../../vista/html/CANNYEDGES.html"><tt>CANNYEDGES</tt></a>,        <a href="CANNYEDGE_BASE.html"><tt>CANNYEDGE_BASE</tt></a>, <a href="ROTHWELLEDGE_BASE.html"><tt>ROTHWELLEDGE_BASE</tt></a>,        <a href="CANNYEDGEMAP_BASE.html"><tt>CANNYEDGEMAP_BASE</tt></a>, <a href="CONGRUENCYEDGE_BASE.html"><tt>CONGRUENCYEDGE_BASE</tt></a>,        <a href="COMPASSEDGE_BASE.html"><tt>COMPASSEDGE_BASE</tt></a>, <a href="ANISOEDGE_BASE.html"><tt>ANISOEDGE_BASE</tt></a>,        <a href="ELDERZUCKEREDGE_BASE.html"><tt>ELDERZUCKEREDGE_BASE</tt></a>, <a          href="KOETHEDGE_BASE.html"><tt>KOETHEDGE_BASE</tt></a>,        <a href="SDGDEDGE_BASE.html"><tt>SDGDEDGE_BASE</tt></a>, <a href="PETROUEDGE_BASE.html"><tt>PETROUEDGE_BASE</tt></a>,        <a href="HARRISCORNER.html"><tt>HARRISCORNER</tt></a>, <a href="SUSANCORNER_BASE.html"><tt>SUSANCORNER_BASE</tt></a>,        <a href="FASTCPDA_BASE.html"><tt>FASTCPDA_BASE</tt></a>, <a href="FASTCORNER_BASE.html"><tt>FASTCORNER_BASE</tt></a>,        <a href="matlab:webpub%28whichpath%28%27BWMORPH%27%29%29"><tt>BWMORPH</tt></a>.</p>      <h2>Function implementation<a name="4"></a></h2>      <pre class="codeinput"><span class="keyword">function</span> [edgemap, cormap, varargout]  = <spanclass="keyword">...</span>    edgecorner_base(I, met_edge, met_corner, rho, sigma, thres, red, varargin)</pre>      <p>checking/setting variables</p>      <pre class="codeinput">error(nargchk(1, 9, nargin, <span class="string">'struct'</span>));error(nargoutchk(1, 3, nargout, <span class="string">'struct'</span>));<span class="comment">% note: the varargin are used with the method met_edge='koethe' only</span><span class="keyword">if</span> nargin&gt;=8,  int = varargin{1};  <span class="keyword">else</span>   int = <spanclass="string">'ani'</span>; <spanclass="keyword">end</span><span class="keyword">if</span> nargin==9,  samp = varargin{2};  <span class="keyword">else</span> samp=2;     <spanclass="keyword">end</span></pre>      <p>we foresee that edgemap or cormap may be empty in the case the 'met_'        variables are set to false</p>      <p>dealing with multispectral images</p>      <pre class="codeinput">C = size(I,3);<span class="keyword">if</span> C&gt;1 &amp;&amp; <span class="keyword">...</span>        ( (~strcmpi(met_edge,<span class="string">'koethe'</span>) &amp;&amp; <spanclass="keyword">...</span>        ((islogical(red)&amp;&amp;~red) || (ischar(red)&amp;&amp;strcmpi(red,<spanclass="string">'eor'</span>)))))    <span class="keyword">if</span> ischar(met_edge),  edgemap = zeros(size(I)); <spanclass="comment">% else set to dummy</span>    <span class="keyword">else</span>                  edgemap = zeros(1,1,3);  <spanclass="keyword">end</span>    <span class="keyword">if</span> ischar(met_corner),  cormap = zeros(size(I)); <spanclass="comment">% else set to dummy</span>    <span class="keyword">else</span>                    cormap = zeros(1,1,3);  <spanclass="keyword">end</span>    <span class="keyword">if</span> nargout==3,  varargout{1} = cell(C,1);  <spanclass="keyword">end</span>    <span class="keyword">for</span> c=1:C        [A, B, tmp] = <span class="keyword">...</span>            edgecorner_base(I(:,:,c), met_edge, met_corner, rho, sigma, <span class="keyword">...</span>            thres, red, int, samp);        <span class="keyword">if</span> ischar(met_edge),  edgemap(:,:,c) = A;  <spanclass="keyword">end</span>        <span class="keyword">if</span> ischar(met_corner),  cormap(:,:,c) = B; <spanclass="keyword">end</span>        <span class="keyword">if</span> nargout==3,  varargout{1}{c} = tmp; <spanclass="keyword">end</span>    <span class="keyword">end</span>    <span class="keyword">if</span> strcmpi(red,<span class="string">'eor'</span>)        <span class="keyword">for</span> c=2:C            edgemap(:,:,1) = edgemap(:,:,1) | edgemap(:,:,c);            cormap(:,:,1) = cormap(:,:,1) | cormap(:,:,c);            varargout{1}{1}(:,:,1) = <span class="keyword">...</span>                max(cat(3,varargout{1}{1}(:,:,1),varargout{1}{c}(:,:,1)),[],3);            varargout{1}{1}(:,:,2) = <span class="keyword">...</span>                varargout{1}{1}(:,:,2) + varargout{1}{c}(:,:,2);        <span class="keyword">end</span>        varargout{1}{1}(:,:,2) = varargout{1}{1}(:,:,2) / 3;        varargout{1} = varargout{1}{1}; <span class="comment">% reduce the cell to a single matrix</span>        edgemap = edgemap(:,:,1);        <span class="keyword">if</span> ~isempty(ver(<span class="string">'images'</span>))            edgemap = bwmorph(edgemap,<span class="string">'thin'</span>,Inf);        <span class="keyword">end</span>        cormap = cormap(:,:,1);    <span class="keyword">end</span>    <span class="keyword">if</span> ~ischar(met_edge),  edgemap = []; <span class="keyword">end</span>    <span class="keyword">if</span> ~ischar(met_corner),  cormap = []; <span class="keyword">end</span>    <span class="keyword">return</span>;<span class="keyword">end</span><span class="keyword">if</span> C&gt;1 &amp;&amp; ischar(red) <span class="comment">%&amp;&amp; any(strcmpi(red,{'isum','igray','imax'}))</span>    <span class="keyword">if</span> C==3 &amp;&amp; strcmpi(red,<span class="string">'igray'</span>)            I = rgb2gray(rescale(I,0,1));    <span class="keyword">elseif</span> strcmpi(red,<span class="string">'isum'</span>)        <span class="keyword">if</span> C==3            I = 0.3*I(:,:,1) + 0.59*I(:,:,2) + 0.11*I(:,:,3);            I = rescale(I,0,1);        <span class="keyword">else</span>           I = sum(rescale(I,0,1), 3);        <span class="keyword">end</span>    <span class="keyword">elseif</span> strcmpi(red,<span class="string">'imax'</span>)        I = max(rescale(I,0,1), [], 3);    <span class="keyword">end</span><span class="keyword">end</span></pre>      <p>computing edges and junctions all at once: congruency, compass and        Koethe methods</p>      <pre class="codeinput"><span class="keyword">if</span> strcmpi(met_edge,<spanclass="string">'congrue'</span>)    [M, m, or]  = <span class="keyword">...</span>        congruencyedge_base(I, 4, 6, 3, 2.1, 0.55, 2, 0.5, 10, -1);    <span class="keyword">if</span> numel(thres)==1,  thres = [thres, thres];  <spanclass="keyword">end</span>    edgemap = M&gt;thres(1);    cormap = m&gt;thres(2);    mag = [];<span class="keyword">elseif</span> strcmpi(met_edge,<span class="string">'compass'</span>)    [S, O]  = compassedge_base(I, sigma, 180, 6, (size(I,3)~=3 || red));  <spanclass="comment">%#ok</span>    edgemap = S&gt;thres(1);    <span class="comment">% use PCCORNER</span>    mag = []; or = [];<span class="keyword">elseif</span> strcmpi(met_edge,<span class="string">'koethe'</span>)    <span class="comment">% note : samp=2 and int='ani' corresponds to the method proposed by</span>    <span class="comment">% Koethe</span>    [edgemap, cormap, mag] = <span class="keyword">...</span>        koethedge_base(I, rho, sigma, <span class="string">'fast'</span>, int, samp, <spanclass="string">'koe'</span>, [], 3 );    <span class="comment">% note that in fact, mag is a tensor, it is nothing else than the GST</span>    or = [];<span class="keyword">end</span></pre>      <p>computing edges</p>      <pre class="codeinput"><span class="keyword">if</span> any(strcmpi(met_edge,{<spanclass="string">'canny'</span>,<spanclass="string">'log'</span>,<spanclass="string">'rothwell'</span>,<spanclass="string">'black'</span>,<spanclass="string">'elder'</span>})) ||<spanclass="keyword">...</span>        (strcmpi(met_edge,<span class="string">'vista'</span>) &amp;&amp; ~strcmpi(red,<spanclass="string">'gmax'</span>))    <span class="comment">% already implemented edge detection</span>    <span class="keyword">if</span> any(strcmpi(met_edge,{<span class="string">'canny'</span>,<spanclass="string">'log'</span>}))        edgemap = edge(I,met_edge, [], sigma);        mag = []; or = [];    <span class="keyword">elseif</span> strcmpi(met_edge,<span class="string">'vista'</span>)        [edgemap, or, mag] = cannyedges(I, sigma);    <span class="keyword">elseif</span> strcmpi(met_edge,<span class="string">'rothwell'</span>)        [edgemap, mag, or] = rothwelledge_base(I, sigma, 5, 0.8);    <span class="keyword">elseif</span> strcmpi(met_edge,<span class="string">'black'</span>)        [edgemap, mag] = anisoedge_base(I, sigma, 100, true);        or = [];    <span class="keyword">elseif</span> strcmpi(met_edge,<span class="string">'elder'</span>)        edgemap = elderzuckeredge_base(I, sigma);        mag = [];  or = [];    <span class="keyword">end</span><span class="keyword">elseif</span> ischar(met_edge) &amp;&amp; <span class="keyword">...</span>        ~any(strcmpi(met_edge,{<span class="string">'congrue'</span>,<span class="string">'compass'</span>,<spanclass="string">'koethe'</span>})) <spanclass="comment">% all other cases</span>    [gx, gy] = grdsmooth_base(I, sigma, met_edge, [], <span class="string">'xy'</span>);    <span class="keyword">if</span> ischar(red) &amp;&amp; strcmpi(red,<span class="string">'gmax'</span>);        gx = max(gx, [], 3);        gy = max(gy, [], 3);    <span class="keyword">end</span>    [edgemap, mag, or] = <span class="keyword">...</span>        cannyedgemap_base(gx, gy, <span class="string">'matlab'</span>, [], [], [], [1/3 0.08]);<span class="keyword">elseif</span> islogical(met_edge) &amp;&amp; ~met_edge        edgemap = [];        mag = []; or = [];<span class="keyword">end</span></pre>      <p>compute junctions if not already done</p>      <pre class="codeinput"><span class="keyword">if</span> ischar(met_corner) &amp;&amp; <spanclass="keyword">...</span>        (~exist(<span class="string">'cormap'</span>,<span class="string">'var'</span>) || isempty(cormap))    <span class="keyword">if</span> any(strcmp(met_corner,{<span class="string">'harris'</span>,<spanclass="string">'noble'</span>})) &amp;&amp; exist(<spanclass="string">'gx'</span>,<spanclass="string">'var'</span>)        cormap = <span class="keyword">...</span>            corner_base(gx, met_corner, [], 0.06, 3, [], [], [], gy, rho, false);    <span class="keyword">else</span>        cormap = <span class="keyword">...</span>            corner_base(I, met_corner, thres, 0.06, 3, true, 1, 157, sigma, rho, false);    <span class="keyword">end</span><span class="keyword">elseif</span> islogical(met_corner) &amp;&amp; ~met_corner    cormap = [];<span class="keyword">end</span></pre>      <p>other possible outputs: we need to compute mag and/or or if not already        done</p>      <pre class="codeinput"><span class="keyword">if</span> nargout==3    <span class="keyword">if</span> (C==1 || ~strcmpi(met_edge,<span class="string">'koethe'</span>)) &amp;&amp; (isempty(mag) || isempty(or))        <span class="keyword">if</span> exist(<span class="string">'gy'</span>,<spanclass="string">'var'</span>) &amp;&amp; exist(<spanclass="string">'gy'</span>,<spanclass="string">'var'</span>)            <span class="keyword">if</span> isempty(mag)                mag = hypot(gx,gy);                mag = mag / max(mag(:));            <span class="keyword">end</span>            <span class="keyword">if</span> isempty(or)                or = atan2(gy, gx);               <span class="comment">% or = or.*(or&gt;=0) + (or+pi).*(or&lt;0); % in [0,pi]</span>            <span class="keyword">end</span>        <span class="keyword">else</span>            [~, ~, mag1, or1] = grdsmooth_base(I, sigma, <span class="string">'fast'</span>, [], <spanclass="string">'xy'</span>);            <span class="keyword">if</span> isempty(mag),  mag = mag1;  <span class="keyword">end</span>            <span class="keyword">if</span> isempty(or),  or = or1;  <span class="keyword">end</span>        <span class="keyword">end</span>    <span class="keyword">end</span>    <span class="keyword">if</span> (C==1 || ~strcmpi(met_edge,<span class="string">'koethe'</span>)),  mag = cat(3, mag, or);  <spanclass="keyword">end</span>    varargout{1} = mag;<span class="keyword">end</span></pre>      <pre class="codeinput"><span class="keyword">end</span> <span class="comment">% end of edgecorner_base</span></pre></div>    <!--##### SOURCE BEGIN #####%% EDGECORNER_BASE - Base function for EDGECORNER.% %% Syntax%     [edgemap, cormap] = ...%              EDGECORNER_BASE(I, edge, corner, rho, sigma, thres, reduce);%     [edgemap, cormap, MO] = ...%              EDGECORNER_BASE(I, edge, corner, rho, sigma, thres, reduce);%     [edgemap, cormap, T] = ...%              EDGECORNER_BASE(I, edge, corner, rho, sigma, thres, reduce);%%% Credit% <mailto:prasad@lanl.gov L.Prasad> & <mailto:grazzja@lanl.gov J.Grazzini> (ISR-2/LANL)%%% See also% Related: % <EDGECORNER.html |EDGECORNER|>,% <CORNER_BASE.html |CORNER_BASE|>.% Called: % <matlab:webpub(whichpath('EDGE')) |EDGE|>,% <../../derive/html/GRDSMOOTH_BASE.html |GRDSMOOTH_BASE|>,% <../../algebra/html/RESCALE.html |RESCALE|>. % <../../../vista/html/CANNYEDGES.html |CANNYEDGES|>,% <CANNYEDGE_BASE.html |CANNYEDGE_BASE|>,% <ROTHWELLEDGE_BASE.html |ROTHWELLEDGE_BASE|>,% <CANNYEDGEMAP_BASE.html |CANNYEDGEMAP_BASE|>,% <CONGRUENCYEDGE_BASE.html |CONGRUENCYEDGE_BASE|>,% <COMPASSEDGE_BASE.html |COMPASSEDGE_BASE|>,% <ANISOEDGE_BASE.html |ANISOEDGE_BASE|>,% <ELDERZUCKEREDGE_BASE.html |ELDERZUCKEREDGE_BASE|>,% <KOETHEDGE_BASE.html |KOETHEDGE_BASE|>,% <SDGDEDGE_BASE.html |SDGDEDGE_BASE|>,% <PETROUEDGE_BASE.html |PETROUEDGE_BASE|>,% <HARRISCORNER.html |HARRISCORNER|>,% <SUSANCORNER_BASE.html |SUSANCORNER_BASE|>,% <FASTCPDA_BASE.html |FASTCPDA_BASE|>,% <FASTCORNER_BASE.html |FASTCORNER_BASE|>,% <matlab:webpub(whichpath('BWMORPH')) |BWMORPH|>.%% Function implementationfunction [edgemap, cormap, varargout]  = ...    edgecorner_base(I, met_edge, met_corner, rho, sigma, thres, red, varargin)%% % checking/setting variableserror(nargchk(1, 9, nargin, 'struct'));error(nargoutchk(1, 3, nargout, 'struct'));% note: the varargin are used with the method met_edge='koethe' onlyif nargin>=8,  int = varargin{1};  else   int = 'ani'; endif nargin==9,  samp = varargin{2};  else samp=2;     end    %%% we foresee that edgemap or cormap may be empty in the case the 'met_'% variables are set to false%%% dealing with multispectral imagesC = size(I,3);if C>1 && ...        ( (~strcmpi(met_edge,'koethe') && ...        ((islogical(red)&&~red) || (ischar(red)&&strcmpi(red,'eor')))))    if ischar(met_edge),  edgemap = zeros(size(I)); % else set to dummy    else                  edgemap = zeros(1,1,3);  end    if ischar(met_corner),  cormap = zeros(size(I)); % else set to dummy    else                    cormap = zeros(1,1,3);  end    if nargout==3,  varargout{1} = cell(C,1);  end    for c=1:C        [A, B, tmp] = ...            edgecorner_base(I(:,:,c), met_edge, met_corner, rho, sigma, ...            thres, red, int, samp);        if ischar(met_edge),  edgemap(:,:,c) = A;  end        if ischar(met_corner),  cormap(:,:,c) = B; end        if nargout==3,  varargout{1}{c} = tmp; end    end    if strcmpi(red,'eor')        for c=2:C            edgemap(:,:,1) = edgemap(:,:,1) | edgemap(:,:,c);            cormap(:,:,1) = cormap(:,:,1) | cormap(:,:,c);            varargout{1}{1}(:,:,1) = ...                max(cat(3,varargout{1}{1}(:,:,1),varargout{1}{c}(:,:,1)),[],3);            varargout{1}{1}(:,:,2) = ...                varargout{1}{1}(:,:,2) + varargout{1}{c}(:,:,2);        end        varargout{1}{1}(:,:,2) = varargout{1}{1}(:,:,2) / 3;        varargout{1} = varargout{1}{1}; % reduce the cell to a single matrix        edgemap = edgemap(:,:,1);        if ~isempty(ver('images'))              edgemap = bwmorph(edgemap,'thin',Inf);        end        cormap = cormap(:,:,1);    end    if ~ischar(met_edge),  edgemap = []; end    if ~ischar(met_corner),  cormap = []; end    return;endif C>1 && ischar(red) %&& any(strcmpi(red,{'isum','igray','imax'}))        if C==3 && strcmpi(red,'igray')            I = rgb2gray(rescale(I,0,1));        elseif strcmpi(red,'isum')         if C==3            I = 0.3*I(:,:,1) + 0.59*I(:,:,2) + 0.11*I(:,:,3);            I = rescale(I,0,1);        else           I = sum(rescale(I,0,1), 3);        end           elseif strcmpi(red,'imax')        I = max(rescale(I,0,1), [], 3);    endend%%% computing edges and junctions all at once: congruency, compass and Koethe% methodsif strcmpi(met_edge,'congrue')    [M, m, or]  = ...        congruencyedge_base(I, 4, 6, 3, 2.1, 0.55, 2, 0.5, 10, -1);    if numel(thres)==1,  thres = [thres, thres];  end    edgemap = M>thres(1);    cormap = m>thres(2);     mag = [];    elseif strcmpi(met_edge,'compass')       [S, O]  = compassedge_base(I, sigma, 180, 6, (size(I,3)~=3 || red));  %#ok    edgemap = S>thres(1);      % use PCCORNER    mag = []; or = [];    elseif strcmpi(met_edge,'koethe')    % note : samp=2 and int='ani' corresponds to the method proposed by    % Koethe    [edgemap, cormap, mag] = ...        koethedge_base(I, rho, sigma, 'fast', int, samp, 'koe', [], 3 );    % note that in fact, mag is a tensor, it is nothing else than the GST    or = [];end%% % computing edgesif any(strcmpi(met_edge,{'canny','log','rothwell','black','elder'})) ||...        (strcmpi(met_edge,'vista') && ~strcmpi(red,'gmax'))        % already implemented edge detection    if any(strcmpi(met_edge,{'canny','log'}))        edgemap = edge(I,met_edge, [], sigma);        mag = []; or = [];            elseif strcmpi(met_edge,'vista')        [edgemap, or, mag] = cannyedges(I, sigma);            elseif strcmpi(met_edge,'rothwell')        [edgemap, mag, or] = rothwelledge_base(I, sigma, 5, 0.8);            elseif strcmpi(met_edge,'black')        [edgemap, mag] = anisoedge_base(I, sigma, 100, true);        or = [];            elseif strcmpi(met_edge,'elder')        edgemap = elderzuckeredge_base(I, sigma);        mag = [];  or = [];            end        elseif ischar(met_edge) && ...        ~any(strcmpi(met_edge,{'congrue','compass','koethe'})) % all other cases        [gx, gy] = grdsmooth_base(I, sigma, met_edge, [], 'xy');        if ischar(red) && strcmpi(red,'gmax');        gx = max(gx, [], 3);        gy = max(gy, [], 3);    end        [edgemap, mag, or] = ...        cannyedgemap_base(gx, gy, 'matlab', [], [], [], [1/3 0.08]);    elseif islogical(met_edge) && ~met_edge        edgemap = [];        mag = []; or = [];end%% % compute junctions if not already doneif ischar(met_corner) && ...        (~exist('cormap','var') || isempty(cormap))    if any(strcmp(met_corner,{'harris','noble'})) && exist('gx','var')        cormap = ...            corner_base(gx, met_corner, [], 0.06, 3, [], [], [], gy, rho, false);    else        cormap = ...            corner_base(I, met_corner, thres, 0.06, 3, true, 1, 157, sigma, rho, false);    end    elseif islogical(met_corner) && ~met_corner    cormap = [];end%% % other possible outputs: we need to compute mag and/or or if not already doneif nargout==3    if (C==1 || ~strcmpi(met_edge,'koethe')) && (isempty(mag) || isempty(or))        if exist('gy','var') && exist('gy','var')            if isempty(mag)                mag = hypot(gx,gy);                mag = mag / max(mag(:));            end            if isempty(or)                or = atan2(gy, gx);                       % or = or.*(or>=0) + (or+pi).*(or<0); % in [0,pi]            end        else            [~, ~, mag1, or1] = grdsmooth_base(I, sigma, 'fast', [], 'xy');            if isempty(mag),  mag = mag1;  end            if isempty(or),  or = or1;  end        end    end    if (C==1 || ~strcmpi(met_edge,'koethe')),  mag = cat(3, mag, or);  end    varargout{1} = mag;endend % end of edgecorner_base##### SOURCE END #####-->  </body></html>