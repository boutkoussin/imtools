<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html>  <head>    <meta content="text/html; charset=utf-8" http-equiv="content-type">    <!--This HTML was auto-generated from MATLAB code.To make changes, update the MATLAB code and republish this document.      -->    <title>ELDERZUCKEREDGE_BASE - Base function for ELDERZUCKEREDGE.</title>    <meta name="generator" content="MATLAB 7.14">    <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">    <meta name="DC.date" content="2012-05-31">    <meta name="DC.source" content="elderzuckeredge_base.m">    <style type="text/css">html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}html { min-height:100%; margin-bottom:1px; }html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }html body td { vertical-align:top; text-align:left; }h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }a { color:#005fce; text-decoration:none; }a:hover { color:#005fce; text-decoration:underline; }a:visited { color:#004aa0; text-decoration:none; }p { padding:0px; margin:0px 0px 20px; }img { padding:0px; margin:0px 0px 20px; border:none; }p img, pre img, tt img, li img { margin-bottom:0px; } ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }ul li { padding:0px; margin:0px 0px 7px 0px; }ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }ul li ol li { list-style:decimal; }ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }ol li ol li { list-style-type:lower-alpha; }ol li ul { padding-top:7px; }ol li ul li { list-style:square; }.content { font-size:1.2em; line-height:140%; padding: 20px; }pre, tt, code { font-size:12px; }pre { margin:0px 0px 20px; }pre.error { color:red; }pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }span.keyword { color:#0000FF }span.comment { color:#228B22 }span.string { color:#A020F0 }span.untermstring { color:#B20000 }span.syscmd { color:#B28C00 }.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }.footer p { margin:0px; }  </style>  </head>  <body>    <div class="content">      <h1>ELDERZUCKEREDGE_BASE - Base function for ELDERZUCKEREDGE.</h1>      <!--introduction--><!--/introduction-->      <h2>Contents</h2>      <div>        <ul>          <li><a href="#1">Syntax</a></li>          <li><a href="#3">See also</a></li>          <li><a href="#4">Function implementation</a></li>          <li><a href="#13">Subfunctions</a></li>        </ul>      </div>      <h2>Syntax<a name="1"></a></h2>      <pre>   [edgemap, scmap, blur] = ELDERZUCKEREDGE_BASE(I, sigma);</pre>      <h2>See also<a name="3"></a></h2>      <p>Related: <a href="elderzuckeredge.html"><tt>ELDERZUCKEREDGE</tt></a>,        <a href="cannyedge_base.html"><tt>CANNYEDGE_BASE</tt></a>, <a href="EDGEcorner_base.html"><tt>EDGECORNER_BASE</tt></a>,        <a href="congruencyedge_base.html"><tt>CONGRUENCYEDGE_BASE</tt></a>, <a          href="compassedge_base.html"><tt>COMPASSEDGE_BASE</tt></a>,        <a href="rothwelledge_base.html"><tt>ROTHWELLEDGE_BASE</tt></a>, <a href="anisoedge_base.html"><tt>ANISOEDGE_BASE</tt></a>,        <a href="koethedge_base.html"><tt>KOETHEDGE_BASE</tt></a>, <a href="sdgdedge_base.html"><tt>SDGDEDGE_BASE</tt></a>,        <a href="petrouedge_base.html"><tt>PETROUEDGE_BASE</tt></a>. Called: <a          href="matlab:web%28whichpath%28%27EDGE%27%29%29"><tt>EDGE</tt></a>,        <a href="matlab:web%28whichpath%28%27CONV2%27%29%29"><tt>CONV2</tt></a>.</p>      <h2>Function implementation<a name="4"></a></h2>      <pre class="codeinput"><span class="keyword">function</span> [edgemap,varargout] = elderzuckeredge_base(I, sigma, reduce)  <spanclass="comment">%#ok</span></pre>      <p>dealing with multispectral images</p>      <pre class="codeinput">C = size(I,3);<span class="keyword">if</span> C&gt;1    edgemap = zeros(size(I));    <span class="keyword">if</span> nargout&gt;=2,  varargout{1} = zeros(size(I)); <spanclass="keyword">end</span>    <span class="keyword">if</span> nargout==3,  varargout{2} = zeros(size(I)); <spanclass="keyword">end</span>    <span class="keyword">for</span> c=1:C        [edgemap(:,:,c),tmp1,tmp2] = elderzuckeredge_base(I(:,:,c), sigma);        <span class="keyword">if</span> nargout&gt;=2,  varargout{1}(:,:,c) = tmp1; <spanclass="keyword">end</span>        <span class="keyword">if</span> nargout&gt;=3,  varargout{2}(:,:,c) = tmp2; <spanclass="keyword">end</span>    <span class="keyword">end</span>    <span class="keyword">return</span>;<span class="keyword">end</span>pad = 2;I = padarray(I,[pad pad],<span class="string">'replicate'</span>,<span class="string">'both'</span>);[X,Y,C] = size(I);                                                     <span class="comment">%#ok</span></pre>      <p>computing edges</p>      <pre class="codeinput"><span class="comment">%alphaP = 1 - (1 - sigma).^(1./length(I))</span>alphaP = 2e-7;mag = zeros(size(I));ang = zeros(size(I));map = zeros(size(I));</pre>      <p>creating the different scales: these represent the different scale        sizes supported here, expressed as the standard deviation of the filter.</p>      <pre class="codeinput">sd1 = [16 8 4 2 1 0.5];</pre>      <p>we iterate: for each standard deviation, we compute the 'gradient'-        which in this case uses the steering functions defined by Elder and        Zucker.</p>      <pre class="codeinput"><span class="keyword">for</span> h = 1:length(sd1)    [mg ag map] = gradEZD2(I, sd1(h),sigma,alphaP, map);    mag(mg ~= 0) = 0;    mag = mag + mg;    ang(ag ~= 0) = 0;    ang = ang + ag;<span class="keyword">end</span><span class="comment">%scaind = log2(map) + repmat(2, size(map));</span>sd2 = [4 2 1 0.5];scmap = zeros([X,Y]);lap_of_gau = zeros([X,Y]);<span class="keyword">for</span> h = 1:length(sd2)    [l_o_g scmap] = lapEZD2(I,sd2(h),sigma,alphaP, ang, scmap);    lap_of_gau(l_o_g ~= 0) = 0;    lap_of_gau = lap_of_gau + l_o_g;<span class="keyword">end</span><span class="comment">%scaind2 = log2(scmap) + repmat(2, size(scmap));</span></pre>      <p>create the edgemap</p>      <pre class="codeinput">edgemap = edge(lap_of_gau, <span class="string">'canny'</span>);edgemap = edgemap(pad+1:end-pad,pad+1:end-pad,:);<span class="keyword">if</span> nargout&gt;=2    varargout{1} = scmap(pad+1:end-pad,pad+1:end-pad,:);<span class="keyword">end</span></pre>      <p>create the blur map if required</p>      <pre class="codeinput"><span class="keyword">if</span> nargout==3    <span class="comment">% compute the distance between extrema</span>    [A,B] = find(edgemap ~= 0);    [Alim, Blim] = size(I);    window = 20;    w = window;    varargout{2} = zeros(X,Y);    <span class="keyword">for</span> i= 1:length(A),        <span class="comment">%define search window</span>        Alower = A(i) - window;        Blower = B(i) - window;        Aupper = A(i) + window;        Bupper = B(i) + window;        <span class="comment">%clip to edge of image</span>        <span class="keyword">if</span> Alower &lt; 1,        Alower = 1;                              <spanclass="comment">%#ok</span>        <span class="keyword">end</span>        <span class="keyword">if</span> Blower &lt; 1,        Blower = 1;                              <spanclass="comment">%#ok</span>        <span class="keyword">end</span>        <span class="keyword">if</span> Aupper&gt;Alim,       Aupper = Alim;                           <spanclass="comment">%#ok</span>        <span class="keyword">end</span>        <span class="keyword">if</span> Bupper &gt; Blim,     Bupper = Blim;                           <spanclass="comment">%#ok</span>        <span class="keyword">end</span>        currentmax = lap_of_gau(A(i),B(i));        currentmin = currentmax;        nextmin = currentmin;        nextmax = currentmax;        currentpixelx = A(i);        currentpixely = B(i);        currentangle = 45*round(rad2deg(ang(currentpixelx, currentpixely))/45);        <span class="keyword">if</span> (currentangle == 0 )|| (currentangle == 360 )|| (currentangle == -360),            pixelincx = 1;            pixelincy = 0;        <span class="keyword">end</span>        <span class="keyword">if</span> (currentangle == 45 )|| (currentangle == -315),            pixelincx = 1;            pixelincy = 1;        <span class="keyword">end</span>        <span class="keyword">if</span> (currentangle == 90 )|| (currentangle == -270),            pixelincx = 0;            pixelincy = 1;        <span class="keyword">end</span>        <span class="keyword">if</span> (currentangle == 135 )|| (currentangle == -225),            pixelincx = -1;            pixelincy = 1;        <span class="keyword">end</span>        <span class="keyword">if</span> (currentangle == 180 )|| (currentangle == -180),            pixelincx = -1;            pixelincy = 0;        <span class="keyword">end</span>        <span class="keyword">if</span> (currentangle == 225 )|| (currentangle == -135),            pixelincx = -1;            pixelincy = -1;        <span class="keyword">end</span>        <span class="keyword">if</span> (currentangle == 270 )|| (currentangle == -90),            pixelincx = 0;            pixelincy = -1;        <span class="keyword">end</span>        <span class="keyword">if</span> (currentangle == 315 )|| (currentangle == -45),            pixelincx = 1;            pixelincy = -1;        <span class="keyword">end</span>        counter = 0;        <span class="keyword">while</span>(nextmax &gt;= currentmax),            nextmaxx = currentpixelx + pixelincx;            nextmaxy = currentpixely + pixelincy;            <span class="keyword">if</span> nextmaxx &lt; 1 || (nextmaxx &gt; size(I, 1)) || <spanclass="keyword">...</span>                    (nextmaxy &lt; 1) || (nextmaxy &gt; size(I,2))                <span class="keyword">break</span>;            <span class="keyword">end</span>            nextmax = lap_of_gau(nextmaxx, nextmaxy);            counter = counter +1;            <span class="keyword">if</span> counter &gt; w,                <span class="keyword">break</span>;            <span class="keyword">end</span>            currentpixelx = nextmaxx;            currentpixely = nextmaxy;        <span class="keyword">end</span>        maxx = currentpixelx;        maxy = currentpixely;        currentpixelx = A(i);        currentpixely = B(i);        counter = 0;        <span class="keyword">while</span>(nextmin &lt;= currentmin),            nextminx = currentpixelx - pixelincx;            nextminy = currentpixely - pixelincy;            <span class="keyword">if</span> nextminx &lt; 1 || (nextminx &gt; size(I, 1)) || <spanclass="keyword">...</span>                    (nextminy &lt; 1) || (nextminy &gt; size(I,2))                <span class="keyword">break</span>;            <span class="keyword">end</span>            nextmin = lap_of_gau(nextminx, nextminy);            counter = counter +1;            <span class="keyword">if</span> counter &gt; w,                <span class="keyword">break</span>            <span class="keyword">end</span>            currentpixelx = nextminx;            currentpixely = nextminy;        <span class="keyword">end</span>        minx = currentpixelx;        miny = currentpixely;        d = sqrt((maxx-minx)^2 + (maxy-miny)^2);        temp = sqrt((d/2)^2 - scmap(A(i),B(i))^2);        <span class="keyword">if</span> isreal(temp)            varargout{2}(A(i),B(i)) = temp;        <span class="keyword">else</span>            varargout{2}(A(i),B(i)) = 0;        <span class="keyword">end</span>    <span class="keyword">end</span>    varargout{2} = varargout{2}(pad+1:end-pad,pad+1:end-pad,:);<span class="keyword">end</span></pre>      <pre class="codeinput"><span class="keyword">end</span> <span class="comment">% end of elderzuckeredge_base</span></pre>      <h2>Subfunctions<a name="13"></a></h2>      <p><tt>GRADEZD2</tt> - Return two matrices the size of <tt>im</tt> that        contain the magnitude and the angle of the intensity gradient of <tt>im</tt>        using a gaussian directional derivative filter of standard deviation <tt>sd1</tt>.        If given, the optional <tt>marker</tt> matrix will be set to <tt>sd1</tt>        everywhere the gradient magnitude exceeds the critical value function of        <tt>sd1</tt> and left alone elsewhere. This matrix will then be        returned. If no marker matrix is given as an argument, the function        won't return the third value.</p>      <pre class="codeinput"><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> [mg, ag, marker, crit] = gradEZD2(im,scale,sigma,alphaP, marker)<span class="keyword">if</span> (nargin &gt; 5)  error(<span class="string">'Wrong number of arguments to gradient.'</span>);<span class="keyword">end</span><span class="keyword">if</span> (nargin &gt; 4)  <span class="keyword">if</span> (size(marker) ~= size(im))    error(<span class="string">'Marker image not the same size as im.'</span>);  <span class="keyword">end</span><span class="keyword">else</span>  <span class="keyword">if</span> (nargout &gt; 2)    error(<span class="string">'No marker matrix can be returned unless you supply one.'</span>);  <span class="keyword">end</span><span class="keyword">end</span><span class="comment">% we want 2 sd on either side of the filter.</span><span class="comment">% this means that in all, our filter is</span><span class="comment">%  4*scale by 4*scale</span>tail = ceil(2 * scale);<span class="comment">% construct the filter.</span>[X Y] = meshgrid(-tail:tail);gx = g1x(X, Y, scale);gy = g1x(Y, X, scale);<span class="comment">%convolve with the filter.</span><span class="comment">% this becomes very expensive with large sized filters.</span>gimx = conv2(im, gx, <span class="string">'same'</span>);gimy = conv2(im, gy, <span class="string">'same'</span>);ag = angle(gimx + 1i*gimy);mg = steer1(ag, gimx, gimy);abmag = abs(mg);<span class="comment">% compute the critical threshold for the gaussian of this scale.</span><span class="comment">% then threshold the magnitude by this value.</span>crit = c1(scale,sigma,alphaP);<span class="keyword">if</span> (nargin &gt; 4)  list = abmag &gt;= crit;  marker(list) = scale;<span class="keyword">end</span><span class="comment">% output magnitude and angle of only those points</span><span class="comment">%   with absolute magnitude of gaussian greater than</span><span class="comment">%   the critical threshold.</span>list = find(abmag &lt; crit);mg(list) = 0;ag(list) = 0;<span class="keyword">end</span> <span class="comment">% end of gradEZD2</span></pre>      <p><tt>LAPEZD2</tt> - Return a matrix representing the laplacian of <tt>im</tt>        at the angles given by <tt>gau_ang</tt>. If given, the optional <tt>marker</tt>        matrix will be set to <tt>sd2</tt> everywhere the gradient magnitude        exceeds the critical value function of <tt>sd2</tt> and left alone        elsewhere. This matrix will then be returned. If no marker matrix is        given as an argument, the function won't return the third value.</p>      <pre class="codeinput"><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> [lap_of_gau, marker] = lapEZD2(im,sd2, sigma,alphaP, gau_ang, marker)<span class="keyword">if</span> (nargin &gt; 6)  error(<span class="string">'Wrong number of arguments to gradient.'</span>);<span class="keyword">end</span><span class="keyword">if</span> (nargin &gt; 5)  <span class="keyword">if</span> (size(marker) ~= size(im))    error(<span class="string">'Marker image not the same size as im.'</span>);  <span class="keyword">end</span><span class="keyword">else</span>  <span class="keyword">if</span> (nargout &gt; 1)    error(<span class="string">'No marker matrix can be returned unless you supply one.'</span>);  <span class="keyword">end</span><span class="keyword">end</span><span class="comment">% We want 2 sd on either side.</span>tail = ceil(2 * sd2);[X Y] = meshgrid(-tail:tail);gx = g2x(X, Y, sd2);gy = g2x(Y, X, sd2);gxy= g2xy(X, Y, sd2);gimx = conv2(im, gx, <span class="string">'same'</span>);gimy = conv2(im, gy, <span class="string">'same'</span>);gimxy= conv2(im, gxy, <span class="string">'same'</span>);lap_of_gau = steer2(gau_ang, gimx, gimy, gimxy);ablog = abs(lap_of_gau);crit = c2(sd2,sigma,alphaP);<span class="keyword">if</span> (nargin &gt; 5)  list = ablog &gt;= crit;  marker(list) = sd2;<span class="keyword">end</span>list = ablog &lt; crit;lap_of_gau(list) = 0;<span class="keyword">end</span> <span class="comment">% end of lapEZD2</span></pre>      <p><tt>STEER1</tt></p>      <pre class="codeinput"><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> imout = steer1(alpha, x_grad_im, y_grad_im)imout = cos(alpha).*x_grad_im + sin(alpha).*y_grad_im;<span class="keyword">end</span> <span class="comment">% end of steer1</span></pre>      <p><tt>STEER2</tt></p>      <pre class="codeinput"><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> imout = steer2(alpha, xgrd_im, ygrd_im, xygrd_im)ca = cos(alpha);sa = sin(alpha);imout =(ca.^2 .* xgrd_im)+(sa.^2 .* ygrd_im)-(2.*ca.*sa.*xygrd_im);<span class="keyword">end</span> <span class="comment">% end of steer2</span></pre>      <p><tt>G1X</tt></p>      <pre class="codeinput"><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> g = g1x(x,y,s1)s1sq = s1.^2;g = -(x./(2*pi*s1sq.^2)) .* exp(-(x.^2 + y.^2)./(2*s1sq));<span class="keyword">end</span> <span class="comment">% end of g1x</span></pre>      <p><tt>G2X</tt></p>      <pre class="codeinput"><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> g = g2x(x,y,s2)sdnorm = 1 ./ (2*pi*s2.^4);g = sdnorm .* (((x/s2).^2) - 1) .* exp(-(x.^2 + y.^2)./(2*s2.^2));<span class="keyword">end</span> <span class="comment">% end of g2x</span></pre>      <p><tt>G2XY</tt></p>      <pre class="codeinput"><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> g = g2xy(x,y,s2)g = ((x.*y)./(2*pi*s2.^6)) .* exp(-(x.^2 + y.^2)./(2*s2.^2));<span class="keyword">end</span> <span class="comment">% end of g2xy</span></pre>      <p><tt>C1</tt></p>      <pre class="codeinput"><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> out = c1(sd1,sigma,alphaP)s1 = sigma .* (1 ./ (2.*sqrt(2.*pi).*sd1.^2));out = s1 .* sqrt(-2.*log(alphaP));<span class="comment">%out = 5 * out;</span><span class="keyword">end</span> <span class="comment">% end of c1</span></pre>      <p><tt>C2</tt></p>      <pre class="codeinput"><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> out = c2(sd2,sigma,alphaP)s2 = sigma .* ((4.*sqrt(pi/3).*sd2.^3).^-1);out = sqrt(2) .* s2 .* (erfinv(1-alphaP));<span class="comment">% best guess threshold</span><span class="comment">% out = (6 * sigma) ./ sd2.^3;</span><span class="keyword">end</span> <span class="comment">% end of c2</span></pre>      <p><tt>RAD2DEG</tt></p>      <pre class="codeinput"><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> degrees = rad2deg(radians)degrees = radians * 180 / pi;<span class="keyword">end</span> <span class="comment">% end of rad2deg</span></pre></div>    <!--##### SOURCE BEGIN #####%% ELDERZUCKEREDGE_BASE - Base function for ELDERZUCKEREDGE.%%% Syntax%     [edgemap, scmap, blur] = ELDERZUCKEREDGE_BASE(I, sigma);  %%% Credit% <mailto:grazzja@lanl.gov J.Grazzini> (ISR-2/LANL)%%% See also% Related: % <elderzuckeredge.html |ELDERZUCKEREDGE|>,% <cannyedge_base.html |CANNYEDGE_BASE|>,% <EDGEcorner_base.html |EDGECORNER_BASE|>,% <congruencyedge_base.html |CONGRUENCYEDGE_BASE|>,% <compassedge_base.html |COMPASSEDGE_BASE|>,% <rothwelledge_base.html |ROTHWELLEDGE_BASE|>,% <anisoedge_base.html |ANISOEDGE_BASE|>,% <koethedge_base.html |KOETHEDGE_BASE|>,% <sdgdedge_base.html |SDGDEDGE_BASE|>,% <petrouedge_base.html |PETROUEDGE_BASE|>.% Called: % <matlab:web(whichpath('EDGE')) |EDGE|>,% <matlab:web(whichpath('CONV2')) |CONV2|>.%% Function implementationfunction [edgemap,varargout] = elderzuckeredge_base(I, sigma, reduce)  %#ok%%% dealing with multispectral imagesC = size(I,3);if C>1    edgemap = zeros(size(I));    if nargout>=2,  varargout{1} = zeros(size(I)); end    if nargout==3,  varargout{2} = zeros(size(I)); end    for c=1:C        [edgemap(:,:,c),tmp1,tmp2] = elderzuckeredge_base(I(:,:,c), sigma);        if nargout>=2,  varargout{1}(:,:,c) = tmp1; end        if nargout>=3,  varargout{2}(:,:,c) = tmp2; end    end    return;endpad = 2;I = padarray(I,[pad pad],'replicate','both');[X,Y,C] = size(I);                                                     %#ok%%% computing edges                                                        %alphaP = 1 - (1 - sigma).^(1./length(I))alphaP = 2e-7;mag = zeros(size(I));ang = zeros(size(I));map = zeros(size(I));%%% creating the different scales: these represent the different scale sizes% supported here, expressed as the standard deviation of the filter.sd1 = [16 8 4 2 1 0.5];%%% we iterate: for each standard deviation, we compute the 'gradient'- which% in this case uses the steering functions defined by Elder and Zucker.for h = 1:length(sd1)    [mg ag map] = gradEZD2(I, sd1(h),sigma,alphaP, map);    mag(mg ~= 0) = 0;    mag = mag + mg;    ang(ag ~= 0) = 0;    ang = ang + ag;end%scaind = log2(map) + repmat(2, size(map));sd2 = [4 2 1 0.5];scmap = zeros([X,Y]);lap_of_gau = zeros([X,Y]);for h = 1:length(sd2)    [l_o_g scmap] = lapEZD2(I,sd2(h),sigma,alphaP, ang, scmap);    lap_of_gau(l_o_g ~= 0) = 0;    lap_of_gau = lap_of_gau + l_o_g;end%scaind2 = log2(scmap) + repmat(2, size(scmap));%%% create the edgemapedgemap = edge(lap_of_gau, 'canny');edgemap = edgemap(pad+1:end-pad,pad+1:end-pad,:);if nargout>=2    varargout{1} = scmap(pad+1:end-pad,pad+1:end-pad,:);end%%% create the blur map if requiredif nargout==3        % compute the distance between extrema    [A,B] = find(edgemap ~= 0);    [Alim, Blim] = size(I);    window = 20;    w = window;        varargout{2} = zeros(X,Y);    for i= 1:length(A),                %define search window        Alower = A(i) - window;        Blower = B(i) - window;        Aupper = A(i) + window;        Bupper = B(i) + window;        %clip to edge of image        if Alower < 1,        Alower = 1;                              %#ok        end        if Blower < 1,        Blower = 1;                              %#ok        end        if Aupper>Alim,       Aupper = Alim;                           %#ok        end        if Bupper > Blim,     Bupper = Blim;                           %#ok        end                currentmax = lap_of_gau(A(i),B(i));        currentmin = currentmax;        nextmin = currentmin;        nextmax = currentmax;                currentpixelx = A(i);        currentpixely = B(i);        currentangle = 45*round(rad2deg(ang(currentpixelx, currentpixely))/45);        if (currentangle == 0 )|| (currentangle == 360 )|| (currentangle == -360),            pixelincx = 1;            pixelincy = 0;        end        if (currentangle == 45 )|| (currentangle == -315),            pixelincx = 1;            pixelincy = 1;        end        if (currentangle == 90 )|| (currentangle == -270),            pixelincx = 0;            pixelincy = 1;        end        if (currentangle == 135 )|| (currentangle == -225),            pixelincx = -1;            pixelincy = 1;        end        if (currentangle == 180 )|| (currentangle == -180),            pixelincx = -1;            pixelincy = 0;        end        if (currentangle == 225 )|| (currentangle == -135),            pixelincx = -1;            pixelincy = -1;        end        if (currentangle == 270 )|| (currentangle == -90),            pixelincx = 0;            pixelincy = -1;        end        if (currentangle == 315 )|| (currentangle == -45),            pixelincx = 1;            pixelincy = -1;        end        counter = 0;        while(nextmax >= currentmax),            nextmaxx = currentpixelx + pixelincx;            nextmaxy = currentpixely + pixelincy;            if nextmaxx < 1 || (nextmaxx > size(I, 1)) || ...                    (nextmaxy < 1) || (nextmaxy > size(I,2))                break;            end            nextmax = lap_of_gau(nextmaxx, nextmaxy);            counter = counter +1;            if counter > w,                break;            end            currentpixelx = nextmaxx;            currentpixely = nextmaxy;        end        maxx = currentpixelx;        maxy = currentpixely;                currentpixelx = A(i);        currentpixely = B(i);        counter = 0;        while(nextmin <= currentmin),            nextminx = currentpixelx - pixelincx;            nextminy = currentpixely - pixelincy;            if nextminx < 1 || (nextminx > size(I, 1)) || ...                    (nextminy < 1) || (nextminy > size(I,2))                break;            end            nextmin = lap_of_gau(nextminx, nextminy);            counter = counter +1;            if counter > w,                break            end            currentpixelx = nextminx;            currentpixely = nextminy;                    end        minx = currentpixelx;        miny = currentpixely;                d = sqrt((maxx-minx)^2 + (maxy-miny)^2);        temp = sqrt((d/2)^2 - scmap(A(i),B(i))^2);        if isreal(temp)            varargout{2}(A(i),B(i)) = temp;        else            varargout{2}(A(i),B(i)) = 0;        end    end    varargout{2} = varargout{2}(pad+1:end-pad,pad+1:end-pad,:);   endend % end of elderzuckeredge_base%% Subfunctions%%% |GRADEZD2| - Return two matrices the size of |im| that contain the magnitude% and the angle of the intensity gradient of |im| using a gaussian directional% derivative filter of standard deviation |sd1|.% If given, the optional |marker| matrix will be set to |sd1| everywhere the% gradient magnitude exceeds the critical value function of |sd1| and left % alone elsewhere.  This matrix will then be returned.  If no marker matrix% is given as an argument, the function won't return the third value.%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction [mg, ag, marker, crit] = gradEZD2(im,scale,sigma,alphaP, marker)if (nargin > 5)  error('Wrong number of arguments to gradient.');endif (nargin > 4)  if (size(marker) ~= size(im))    error('Marker image not the same size as im.');  endelse  if (nargout > 2)    error('No marker matrix can be returned unless you supply one.');  endend% we want 2 sd on either side of the filter.% this means that in all, our filter is %  4*scale by 4*scaletail = ceil(2 * scale);% construct the filter.[X Y] = meshgrid(-tail:tail);gx = g1x(X, Y, scale);gy = g1x(Y, X, scale);%convolve with the filter.% this becomes very expensive with large sized filters.gimx = conv2(im, gx, 'same');gimy = conv2(im, gy, 'same');ag = angle(gimx + 1i*gimy);mg = steer1(ag, gimx, gimy);abmag = abs(mg);% compute the critical threshold for the gaussian of this scale.% then threshold the magnitude by this value.crit = c1(scale,sigma,alphaP);if (nargin > 4)  list = abmag >= crit;  marker(list) = scale;end% output magnitude and angle of only those points %   with absolute magnitude of gaussian greater than%   the critical threshold.list = find(abmag < crit);mg(list) = 0;ag(list) = 0;end % end of gradEZD2%%% |LAPEZD2| - Return a matrix representing the laplacian of |im| at the% angles given by |gau_ang|. If given, the optional |marker| matrix will be % set to |sd2| everywhere the gradient magnitude exceeds the critical value% function of |sd2| and left alone elsewhere.  This matrix will then be % returned. If no marker matrix is given as an argument, the function won't% return the third value.%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction [lap_of_gau, marker] = lapEZD2(im,sd2, sigma,alphaP, gau_ang, marker)if (nargin > 6)  error('Wrong number of arguments to gradient.');endif (nargin > 5)  if (size(marker) ~= size(im))    error('Marker image not the same size as im.');  endelse  if (nargout > 1)    error('No marker matrix can be returned unless you supply one.');  endend% We want 2 sd on either side.tail = ceil(2 * sd2);[X Y] = meshgrid(-tail:tail);gx = g2x(X, Y, sd2);gy = g2x(Y, X, sd2);gxy= g2xy(X, Y, sd2);gimx = conv2(im, gx, 'same');gimy = conv2(im, gy, 'same');gimxy= conv2(im, gxy, 'same');lap_of_gau = steer2(gau_ang, gimx, gimy, gimxy);ablog = abs(lap_of_gau);crit = c2(sd2,sigma,alphaP);if (nargin > 5)  list = ablog >= crit;  marker(list) = sd2;endlist = ablog < crit;lap_of_gau(list) = 0;end % end of lapEZD2%%% |STEER1|%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction imout = steer1(alpha, x_grad_im, y_grad_im)imout = cos(alpha).*x_grad_im + sin(alpha).*y_grad_im;end % end of steer1%%% |STEER2|%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction imout = steer2(alpha, xgrd_im, ygrd_im, xygrd_im)ca = cos(alpha);sa = sin(alpha);imout =(ca.^2 .* xgrd_im)+(sa.^2 .* ygrd_im)-(2.*ca.*sa.*xygrd_im);end % end of steer2%%% |G1X|%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction g = g1x(x,y,s1)s1sq = s1.^2;g = -(x./(2*pi*s1sq.^2)) .* exp(-(x.^2 + y.^2)./(2*s1sq)); end % end of g1x%%% |G2X|%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction g = g2x(x,y,s2)sdnorm = 1 ./ (2*pi*s2.^4);g = sdnorm .* (((x/s2).^2) - 1) .* exp(-(x.^2 + y.^2)./(2*s2.^2)); end % end of g2x%%% |G2XY|%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction g = g2xy(x,y,s2)g = ((x.*y)./(2*pi*s2.^6)) .* exp(-(x.^2 + y.^2)./(2*s2.^2)); end % end of g2xy%%% |C1|%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction out = c1(sd1,sigma,alphaP)s1 = sigma .* (1 ./ (2.*sqrt(2.*pi).*sd1.^2));out = s1 .* sqrt(-2.*log(alphaP));%out = 5 * out;end % end of c1%%% |C2|%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction out = c2(sd2,sigma,alphaP)s2 = sigma .* ((4.*sqrt(pi/3).*sd2.^3).^-1);out = sqrt(2) .* s2 .* (erfinv(1-alphaP));% best guess threshold% out = (6 * sigma) ./ sd2.^3;end % end of c2%%% |RAD2DEG|%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction degrees = rad2deg(radians)degrees = radians * 180 / pi;end % end of rad2deg##### SOURCE END #####-->  </body></html>