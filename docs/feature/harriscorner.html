<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html>  <head>    <meta content="text/html; charset=UTF-8" http-equiv="content-type">    <title>HARRISCORNER - Corner extraction.</title>    <meta name="generator" content="MATLAB 7.11">    <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">    <meta name="DC.date" content="2011-07-08">    <meta name="DC.source" content="harriscorner.m">    <style type="text/css">body {  background-color: white;  margin:10px;}h1 {  color: #990000;   font-size: x-large;}h2 {  color: #990000;  font-size: medium;}/* Make the text shrink to fit narrow windows, but not stretch too far in wide windows. */ p,h1,h2,div.content div {  max-width: 600px;  /* Hack for IE6 */  width: auto !important; width: 600px;}pre.codeinput {  background: #EEEEEE;  padding: 10px;}@media print {  pre.codeinput {word-wrap:break-word; width:100%;}} span.keyword {color: #0000FF}span.comment {color: #228B22}span.string {color: #A020F0}span.untermstring {color: #B20000}span.syscmd {color: #B28C00}pre.codeoutput {  color: #666666;  padding: 10px;}pre.error {  color: red;}p.footer {  text-align: right;  font-size: xx-small;  font-weight: lighter;  font-style: italic;  color: gray;}  </style>  </head>  <body>    <div class="content">      <h1>HARRISCORNER - Corner extraction.</h1>      <!--introduction--><!--/introduction-->      <h2>Contents</h2>      <div>        <ul>          <li><a href="#1">Description</a></li>          <li><a href="#2">Syntax</a></li>          <li><a href="#3">Inputs</a></li>          <li><a href="#4">Property [propertyname propertyvalues]</a></li>          <li><a href="#5">Outputs</a></li>          <li><a href="#6">References</a></li>          <li><a href="#8">See also</a></li>          <li><a href="#9">Function implementation</a></li>        </ul>      </div>      <h2>Description<a name="1"></a></h2>      <p>Extract keypoints using Harris algorithm (with an improved version).</p>      <h2>Syntax<a name="2"></a></h2>      <pre>   pt = HARRISCORNER(I);   pt = HARRISCORNER(I, sig, rho);   [pt, map] = HARRISCORNER(I, sig, rho, 'Property', propertyvalue, ...);   pt = HARRISCORNER(gx, gy, []);   [pt, map] = HARRISCORNER(gx, gy, rho, 'Property', propertyvalue, ...);   pt = HARRISCORNER(gx2, gy2, gxy);   [pt, map] = HARRISCORNER(gx2, gy2, gxy, 'Property', propertyvalue, ...);</pre>      <h2>Inputs<a name="3"></a></h2>      <p>Harris detector can be applied directly on the image or on already        estimated directional derivates. In the former case, inputs are:</p>      <p><b><tt>I</tt></b> : an input image with size <tt>(X,Y,C)</tt>, where <tt>C=3</tt>        when <tt>I</tt> is multichannel.</p>      <p><b><tt>sig</tt></b> : pre-smoothing width (half-window size in pixels);        this parameter sets the differentiation scale in the case the image is        smoothed through Gaussian filtering prior to the differentiation; typ, <tt>sig</tt>        controls the size of the objects whose orientation has to be estimated;        default: <tt>sig=1</tt>, i.e. Gaussian regularisation is used for        estimating the derivatives.</p>      <p><b><tt>rho</tt></b> : post-smoothing width (half-window size in        pixels); this parameter sets the integration scale for Gaussian        averaging, that controls the size of the neighbourhood in which an        orientation is dominant; it is used for averaging the partial        directional derivatives; default: <tt>rho=1</tt>.</p>      <p>In the latter case, the detector is applied directly on the directional        derivatives instead, so that no redundant calculation is performed, thus        the inputs should be:</p>      <p><b><tt>gx, gy</tt></b> : pre-computed 1st order derivatives; the        calculation of Harris will start from these variables; <tt>rho</tt> can        also be passed as an additional variable for computing the 2nd order        derivatives.</p>      <p><b><tt>gx2, gy2, gxy</tt></b> : pre-computed 2nd order derivatives; the        calculation of Harris will start from these variables.</p>      <h2>Property [propertyname propertyvalues]<a name="4"></a></h2>      <p><b><tt>'method'</tt></b> : string defining the interest point response;        it is either <tt>'har'</tt> if the feature is computed following [HS88]        or <tt>'nob'</tt> if the feature is computed following [Noble89];        default: <tt>method='har'</tt>.</p>      <p><b><tt>'kappa'</tt></b> : optional 'kappa' parameter in the case the        method <tt>'harris'</tt> is selected; default: <tt>kappa=0.06</tt>.</p>      <p><b><tt>'thres'</tt></b> : percentage of the maximum value of the Harris        corner strength used to threshold the maxima of the detector; thres is a        value in <tt>[0,1]</tt>; default: <tt>thres=0.001</tt>.</p>      <p><b><tt>'radius'</tt></b> : size of the neighbourhood used for local        maxima detection; default: <tt>radius=3</tt>.</p>      <h2>Outputs<a name="5"></a></h2>      <p><b><tt>pt</tt></b> : matrix <tt>(n,2)</tt> filled with the coordinates        of the <tt>n</tt> detected corner points.</p>      <p><b><tt>cornmap</tt></b> : binary mask of corner points.</p>      <h2>References<a name="6"></a></h2>      <p>[HS88] C.G. Harris and M.J. Stephens: "A combined corner and edge        detector", Proc. Vision Conference, pp 147-151, 1988. <a href="http://www.bmva.org/bmvc/1988/avc-88-023.pdf">http://www.bmva.org/bmvc/1988/avc-88-023.pdf</a></p>      <p>[Noble89] A. Noble: "Descriptions of image surfaces", PhD thesis, p45,        Oxford University 1989.</p>      <p>[SMB00] C. Schmid, R. Mohrand and C. Bauckhage: "Evaluation of Interest        Point Detectors", International Journal of Computer Vision,        37(2):151-172, 2000. <a href="http://perception.inrialpes.fr/Publications/2000/SMB00/Schmid-ijcv00.pdf">http://perception.inrialpes.fr/Publications/2000/SMB00/Schmid-ijcv00.pdf</a></p>      <h2>See also<a name="8"></a></h2>      <p>Related: <a href="CORNER.html"><tt>CORNER</tt></a>, <a href="EDGECORNER.html"><tt>EDGECORNER</tt></a>,        <a href="SUSANCORNER.html"><tt>SUSANCORNER</tt></a>, <a href="FASTCPDA.html"><tt>FASTCPDA</tt></a>,        <a href="FASTCORNER.html"><tt>FASTCORNER</tt></a>, <a href="COMPASSEDGE.html"><tt>COMPASSEDGE</tt></a>,        <a href="CONGRUENCYEDGE.html"><tt>CONGRUENCYEDGE</tt></a>. Called: <a href="HARRISCORNER_BASE.html"><tt>HARRISCORNER_BASE</tt></a>.</p>      <h2>Function implementation<a name="9"></a></h2>      <pre class="codeinput"><span class="keyword">function</span> [pt,varargout] = harriscorner(I,varargin)</pre>      <p>parsing and checking parameters</p>      <pre class="codeinput">error(nargchk(1, 17, nargin, <span class="string">'struct'</span>));error(nargoutchk(1, 2, nargout, <span class="string">'struct'</span>));<span class="keyword">if</span> ~isnumeric(I)    error(<span class="string">'harriscorner:inputerror'</span>,<span class="string">'a matrix is required in input'</span>);<span class="keyword">end</span>p = createParser(<span class="string">'HARRISCORNER'</span>);<span class="comment">% optional parameters</span>p.addOptional(<span class="string">'V1'</span>, 1, @(x) isempty(x) || isnumeric(x) || <spanclass="keyword">...</span>    (isscalar(x) &amp;&amp; isfloat(x) &amp;&amp; x&gt;0));p.addOptional(<span class="string">'V2'</span>, 1, @(x) isempty(x) || isnumeric(x) || <spanclass="keyword">...</span>    (isscalar(x) &amp;&amp; isfloat(x) &amp;&amp; x&gt;0));p.addParamValue(<span class="string">'method'</span>, <span class="string">'har'</span>, @(x)ischar(x) &amp;&amp; <spanclass="keyword">...</span>    any(strcmpi(x,{<span class="string">'nob'</span>,<span class="string">'har'</span>,<spanclass="string">'for'</span>})));p.addParamValue(<span class="string">'kappa'</span>, 0.06, @(x)isscalar(x) &amp;&amp; isfloat(x) &amp;&amp; x&gt;0 &amp;&amp; x&lt;1);p.addParamValue(<span class="string">'radius'</span>, 3, @(x)isscalar(x) &amp;&amp; round(x)==x &amp;&amp; x&gt;0);p.addParamValue(<span class="string">'thres'</span>, 0.001, @(x)isscalar(x) &amp;&amp; x&gt;=0 &amp;&amp; x&lt;=1);<span class="comment">% parse and validate all input arguments</span>p.parse(varargin{:});p = getvarParser(p);</pre>      <p>checking/setting internal variables</p>      <pre class="codeinput">[X,Y,C] = size(I);<span class="keyword">if</span> ~isscalar(p.V1) &amp;&amp; ~isequal(size(p.V1),size(I))    error(<span class="string">'harriscorner:inputerror'</span>,<span class="string">'input matrices with ame size required'</span>);<span class="keyword">elseif</span> ~isscalar(p.V2) &amp;&amp; ~isequal(size(p.V2),size(I))    error(<span class="string">'harriscorner:inputerror'</span>,<span class="string">'input matrices with ame size required'</span>);<span class="keyword">end</span><span class="keyword">if</span> any(strcmpi(p.method,{<span class="string">'nob'</span>,<spanclass="string">'for'</span>})),    p.kappa = 0;   <spanclass="keyword">end</span>;</pre>      <p>main processing</p>      <pre class="codeinput">pt = harriscorner_base(I, p.V1, p.V2, p.kappa, p.thres, p.radius);</pre>      <p>display</p>      <pre class="codeinput"><span class="keyword">if</span> nargout == 2 || p.disp    tmp = false(size(I));    <span class="keyword">for</span> c=1:C        tmp(pt{c}(:,1) + X*(pt{c}(:,2)-1) + X*Y*(c-1)) = 1;    <span class="keyword">end</span>    <span class="keyword">if</span> nargout==2,  varargout{1}=tmp;  <span class="keyword">end</span>;    <span class="keyword">if</span> p.disp        figure, imagesc(tmp), axis <span class="string">image</span> <span class="string">off</span>, title(<spanclass="string">'Harris corner map'</span>);        <span class="keyword">if</span> size(tmp,3) == 1, colormap <span class="string">gray</span>;  <spanclass="keyword">end</span>;    <span class="keyword">end</span><span class="keyword">end</span> <span class="comment">% end of harriscorner</span></pre> </div>    <!--##### SOURCE BEGIN #####%% HARRISCORNER - Corner extraction.%%% Description% Extract keypoints using Harris algorithm (with an improved version).% %% Syntax%     pt = HARRISCORNER(I);%     pt = HARRISCORNER(I, sig, rho);%     [pt, map] = HARRISCORNER(I, sig, rho, 'Property', propertyvalue, ...);%     pt = HARRISCORNER(gx, gy, []);%     [pt, map] = HARRISCORNER(gx, gy, rho, 'Property', propertyvalue, ...);%     pt = HARRISCORNER(gx2, gy2, gxy);%     [pt, map] = HARRISCORNER(gx2, gy2, gxy, 'Property', propertyvalue, ...);%%% Inputs% Harris detector can be applied directly on the image or on already estimated% directional derivates. In the former case, inputs are:%      % *|I|* : an input image with size |(X,Y,C)|, where |C=3| when |I| is multichannel.%      % *|sig|* : pre-smoothing width (half-window size in pixels); this parameter  %     sets the differentiation scale in the case the image is smoothed%     through Gaussian filtering prior to the differentiation; typ, |sig|  %     controls the size of the objects whose orientation has to be estimated;%     default: |sig=1|, i.e. Gaussian regularisation is used for estimating  %     the derivatives.%% *|rho|* : post-smoothing width (half-window size in pixels); this parameter%     sets the integration scale for Gaussian averaging, that controls the %     size of the neighbourhood in which an orientation is dominant; it is %     used for averaging the partial directional derivatives; default: %     |rho=1|.%      % In the latter case, the detector is applied directly on the directional% derivatives instead, so that no redundant calculation is performed, thus% the inputs should be: %      % *|gx, gy|* : pre-computed 1st order derivatives; the calculation of Harris%     will start from these variables; |rho| can also be passed as an%     additional variable for computing the 2nd order derivatives.%      % *|gx2, gy2, gxy|* : pre-computed 2nd order derivatives; the calculation of%     Harris will start from these variables.%%% Property [propertyname  propertyvalues]% *|'method'|* : string defining the interest point response; it is either%     |'har'| if the feature is computed following [HS88] or |'nob'| if%     the feature is computed following [Noble89]; default: |method='har'|.%      % *|'kappa'|* : optional 'kappa' parameter in the case the method |'harris'|%     is selected; default: |kappa=0.06|.%      % *|'thres'|* : percentage of the maximum value of the Harris corner strength %     used to threshold the maxima of the detector; thres is a value in |[0,1]|;%     default: |thres=0.001|.%      % *|'radius'|* : size of the neighbourhood used for local maxima detection;%     default: |radius=3|.%%% Outputs% *|pt|* : matrix |(n,2)| filled with the coordinates of the |n| detected corner%     points.%      % *|cornmap|* : binary mask of corner points.%%% References% [HS88]  C.G. Harris and M.J. Stephens: "A combined corner and edge %      detector", Proc. Vision Conference, pp 147-151, 1988.%      <http://www.bmva.org/bmvc/1988/avc-88-023.pdf>%      % [Noble89]  A. Noble: "Descriptions of image surfaces", PhD thesis, p45, %      Oxford University 1989.%      % [SMB00]  C. Schmid, R. Mohrand and C. Bauckhage: "Evaluation of Interest%      Point Detectors", International Journal of Computer Vision, %      37(2):151-172, 2000.%      <http://perception.inrialpes.fr/Publications/2000/SMB00/Schmid-ijcv00.pdf>% %% Credit% <mailto:grazzja@lanl.gov J.Grazzini> (ISR-2/LANL)%%% See also% Related:% <CORNER.html |CORNER|>,% <EDGECORNER.html |EDGECORNER|>,% <SUSANCORNER.html |SUSANCORNER|>,% <FASTCPDA.html |FASTCPDA|>,% <FASTCORNER.html |FASTCORNER|>,% <COMPASSEDGE.html |COMPASSEDGE|>,% <CONGRUENCYEDGE.html |CONGRUENCYEDGE|>.% Called: % <HARRISCORNER_BASE.html |HARRISCORNER_BASE|>. %% Function implementationfunction [pt,varargout] = harriscorner(I,varargin)%%% parsing and checking parameterserror(nargchk(1, 17, nargin, 'struct'));error(nargoutchk(1, 2, nargout, 'struct'));if ~isnumeric(I)    error('harriscorner:inputerror','a matrix is required in input'); endp = createParser('HARRISCORNER');   % optional parametersp.addOptional('V1', 1, @(x) isempty(x) || isnumeric(x) || ...    (isscalar(x) && isfloat(x) && x>0));p.addOptional('V2', 1, @(x) isempty(x) || isnumeric(x) || ...    (isscalar(x) && isfloat(x) && x>0));p.addParamValue('method', 'har', @(x)ischar(x) && ...    any(strcmpi(x,{'nob','har','for'})));p.addParamValue('kappa', 0.06, @(x)isscalar(x) && isfloat(x) && x>0 && x<1);p.addParamValue('radius', 3, @(x)isscalar(x) && round(x)==x && x>0);p.addParamValue('thres', 0.001, @(x)isscalar(x) && x>=0 && x<=1);% parse and validate all input argumentsp.parse(varargin{:}); p = getvarParser(p);                                                            %%% checking/setting internal variables[X,Y,C] = size(I);                                                 if ~isscalar(p.V1) && ~isequal(size(p.V1),size(I))    error('harriscorner:inputerror','input matrices with ame size required');elseif ~isscalar(p.V2) && ~isequal(size(p.V2),size(I))    error('harriscorner:inputerror','input matrices with ame size required');endif any(strcmpi(p.method,{'nob','for'})),    p.kappa = 0;   end;%%% main processingpt = harriscorner_base(I, p.V1, p.V2, p.kappa, p.thres, p.radius);%%% displayif nargout == 2 || p.disp    tmp = false(size(I));    for c=1:C        tmp(pt{c}(:,1) + X*(pt{c}(:,2)-1) + X*Y*(c-1)) = 1;    end        if nargout==2,  varargout{1}=tmp;  end;        if p.disp        figure, imagesc(tmp), axis image off, title('Harris corner map');        if size(tmp,3) == 1, colormap gray;  end;    end    end % end of harriscorner##### SOURCE END #####--> </body></html>