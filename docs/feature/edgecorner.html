<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html>  <head>    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">    <title>EDGECORNER - Wrapper function for various edge/corner      detection techniques.</title>    <meta name="generator" content="MATLAB 7.11">    <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">    <meta name="DC.date" content="2011-07-08">    <meta name="DC.source" content="edgecorner.m">    <style type="text/css">body {  background-color: white;  margin:10px;}h1 {  color: #990000;   font-size: x-large;}h2 {  color: #990000;  font-size: medium;}/* Make the text shrink to fit narrow windows, but not stretch too far in wide windows. */ p,h1,h2,div.content div {  max-width: 600px;  /* Hack for IE6 */  width: auto !important; width: 600px;}pre.codeinput {  background: #EEEEEE;  padding: 10px;}@media print {  pre.codeinput {word-wrap:break-word; width:100%;}} span.keyword {color: #0000FF}span.comment {color: #228B22}span.string {color: #A020F0}span.untermstring {color: #B20000}span.syscmd {color: #B28C00}pre.codeoutput {  color: #666666;  padding: 10px;}pre.error {  color: red;}p.footer {  text-align: right;  font-size: xx-small;  font-weight: lighter;  font-style: italic;  color: gray;}  </style>  </head>  <body>    <div class="content">      <h1>EDGECORNER - Wrapper function for various edge/corner        detection techniques.</h1>      <!--introduction--><!--/introduction-->      <h2>Contents</h2>      <div>        <ul>          <li><a href="#1">Syntax</a></li>          <li><a href="#2">Inputs</a></li>          <li><a href="#3">Property [propertyname propertyvalues]</a></li>          <li><a href="#4">Outputs</a></li>          <li><a href="#5">References</a></li>          <li><a href="#6">Credit</a></li>          <li><a href="#7">See also</a></li>          <li><a href="#8">Function implementation</a></li>        </ul>      </div>      <h2>Syntax<a name="1"></a></h2>      <pre>   [Edge, Corner] = EDGECORNER(I);   [Edge, Corner] = EDGECORNER(I, met_edge, met_corner,                               'Property', propertyvalue, ...);</pre>      <h2>Inputs<a name="2"></a></h2>      <p><b><tt>I</tt></b> : an input image with size <tt>(X,Y,C),          where |C&gt;1</tt> when <tt>I</tt> is multichannel.</p>      <p><b><tt>met_edge</tt></b> : logical variable or string setting        the method used for detecting edges; it can be either:</p>      <div>        <ul>          <li><tt>'canny'</tt> or <tt>'log'</tt> when performing Canny            or log-Laplacian edge detection [GW02] with function <tt>EDGE</tt>;            in that case, the detector is applied channel by channel,</li>          <li><tt>'vista'</tt> for detecting edges likewise [PS06], a            slightly variant of the Canny detector implemented in            Matlab,</li>          <li><tt>'black'</tt> for the anisotropic edge detector of            [BSMH98] using the function <tt>ANISOEDGE</tt>,</li>          <li><tt>'rothwell'</tt> for the subpixel edge detector of            [RMHN95] using the function <tt>ROTHWELLEDGE</tt>,</li>          <li><tt>'koethe'</tt> for the tensor-based edge detector of            [Koth03] using the function <tt>KOETHEDGE</tt>,</li>          <li><tt>'compass'</tt> for the compass edge/corner detector of            [RT01] using the function <tt>COMPASSEDGE</tt>,</li>          <li><tt>'elder'</tt> for the blur-based edge detector of            [EZ98] using the function <tt>ELDERZUCKEREDGE</tt>,</li>          <li>any of the strings <tt>'prewitt'</tt>, <tt>'sobel'</tt>,            <tt>'fast'</tt>, <tt>'derivative5'</tt>, <tt>'derivative7'</tt>,            <tt>'fleck'</tt> or <tt>'luengo'</tt> for applying the            corresponding edge detectors using the function <tt>GRDSMOOTH</tt>,</li>          <li><tt>'congrue'</tt> for the edge/corner detection of            [Koves03] based on phase congruency and implemented in <tt>CONGRUENCYEDGE</tt>;</li>        </ul>      </div>      <p>in the case <tt>met_edge</tt> is logical and <tt>false</tt>,        then no edge are estimated, it is expected that corners only are        detected (see variable <tt>met_corner</tt> below); in the case        <tt>met_edge</tt> is logical and <tt>true</tt>, it is assigned        its default value; default: <tt>met_edge='vista'</tt>.</p>      <p><b><tt>met_corner</tt></b> : logical variable or string        defining the method used for extracting corners; it can be        either:</p>      <div>        <ul>          <li><tt>'harris'</tt> or <tt>'noble'</tt> for Harris-Forster            and Noble detections resp. using the function <tt>HARRISCORNER</tt>,</li>          <li><tt>'susan'</tt> for Susan detection [SB97] with function            <tt>SUSANCORNER</tt>,</li>          <li><tt>'fast9'</tt>, <tt>'fast10'</tt>, <tt>'fast11'</tt>,            <tt>'fast12'</tt>, for any FAST corner detection using the            function <tt>FASTCORNER</tt>,</li>          <li><tt>'cpda'</tt> for curvature-based detection [ALFR09]            using the function <tt>FASTCPDA</tt>;</li>        </ul>      </div>      <p>in the case <tt>met_corner</tt> is logical and <tt>false</tt>,        then no corners are extracted, it is expected that edges only        are detected (see variable <tt>met_edge</tt> above); in the        case met_edge is logical and true, it is assigned its default        value; default: <tt>met_corner='harris'</tt>.</p>      <p>Note that in some cases, the implemented edge detectors (see <tt>met_edge</tt>        above) also enable to extract the corners (<tt>'congrue'</tt>, <tt>'compass'</tt>        or <tt>'koethe'</tt>).</p>      <h2>Property [propertyname propertyvalues]<a name="3"></a></h2>      <p><b><tt>'rho'</tt></b> : post-smoothing standard deviation, used        either by either of the detectors <tt>'koethe'</tt> and <tt>'harris'</tt>        (see corresponding functions); default: <tt>rho=1</tt>.</p>      <p><b><tt>'sig'</tt></b> : pre-smoothing standard deviation, used        by various of the methods above.</p>      <p><b><tt>'reduce'</tt></b> : logical value or string defining the        way the different channels of a multispectral image are combined        into the output edge map (see <tt>CANNYEDGE_BASE</tt>); it can        be either:</p>      <div>        <ul>          <li><tt>'igray'</tt>: the input RGB image is converted to a            gray image using function <tt>RGB2GRAY</tt>,</li>          <li><tt>'imax', 'isum'</tt> : the input image (any dimension)            is converted to a gray image by taking the sum and the max            over the different channels resp.,</li>          <li><tt>'gmax'</tt> : gradients are computed for the different            channels and their local pixelwise max is given as a single            input to the edge detector;</li>          <li><tt>'eor'</tt> : calculations are made like for a            multispectral image (as if <tt>reduce=false</tt>), but the            final edge map is taken as the logical <tt>OR</tt> of the            output edge maps of the different channels;</li>        </ul>      </div>      <p>in <tt>true</tt> case, it is set to <tt>'sum'</tt>; default:        <tt>reduce=false</tt>, ie. no 'combination' is used, a        multichannel map is output; this parameter is naturally ignored        when <tt>I</tt> is a scalar image; note that reduce should be        set to <tt>true</tt> when <tt>met_edge='compass'</tt>.</p>      <p><b><tt>'int', 'samp'</tt></b> : parameters used for GST        estimation in the method <tt>'koethe'</tt>; see corresponding        function and <tt>GRD2GST</tt>; default: <tt>int='fast'</tt>        and <tt>samp=1</tt>.</p>      <h2>Outputs<a name="4"></a></h2>      <p><b><tt>Edge</tt></b> : logical map of edges.</p>      <p><b><tt>Corner</tt></b> : logical map of corners.</p>      <p>Note that if <tt>met_edge</tt> is set to <tt>false</tt> and        only one lhs is required, then <tt>Corner</tt> is automatically        passed in the output lhs variable (ie. output variables'        positions of <tt>Edge</tt> and <tt>Corner</tt> are exchanged).</p>      <h2>References<a name="5"></a></h2>      <p>[Canny86] J.F. Canny: "A computational approach to edge        detection", IEEE Trans. on Pattern Analysis and Machine        Intelligence, 8(6):679-698, 1986. <a href="http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=4767851&amp;tag=1">http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=4767851&amp;tag=1</a></p>      <p>[Zenzo86] S. Di Zenzo: "A note on the gradient of a        multi-image", Computer Vision and Graphical Image Processing,        33:116-125, 1986. <a href="http://www.sciencedirect.com/science/article/pii/0734189X86902239">http://www.sciencedirect.com/science/article/pii/0734189X86902239</a></p>      <p>[HS88] C.G. Harris and M.J. Stephens: "A combined corner and        edge detector", Proc. Vision Conference, pp 147-151, 1988. <a href="http://www.bmva.org/bmvc/1988/avc-88-023.pdf">http://www.bmva.org/bmvc/1988/avc-88-023.pdf</a></p>      <p>[RMHN95] C. Rothwell, J. Mundy, B. Hoffman and V.-D. Nguyen:        "Driving Vision by Topology", Techn. report 2444, INRIA, 1995. <a          href="http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=477034&amp;tag=1">http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=477034&amp;tag=1</a></p>      <p>[HSSB97] M. Heath, S. Sarkar, T. Sanocki, T. and K.W. Bowyer:        "A robust visual method for assessing the relative performance        of edge-detection algorithms, IEEE Trans. on Pattern Analysis        and Machine Intelligence, 19(12):1338-1359, 1997. <a href="http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=643893">http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=643893</a></p>      <p>[SB97] S.M. Smith and J.M. Brady: "{SUSAN} - A new approach to        low level image processing", International Journal of Computer        Vision, 23(1):45-78, 1997. <a href="http://www.lems.brown.edu/vision/courses/image-processing/Readings/smith95susan.pdf">http://www.lems.brown.edu/vision/courses/image-processing/Readings/smith95susan.pdf</a></p>      <p>[EZ98] J.H. Elder and S.W. Zucker: "Local scale control for        edge detection and blur Estimation", IEEE Trans. on Pattern        Analysis and Machine Intelligence, 20(7), 1998. <a href="http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=689301&amp;tag=1">http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=689301&amp;tag=1</a></p>      <p>[BSMH98] M. Black, G. Sapiro, D. Marimont and D. Heeger:        "Robust anisotropic Diffusion", IEEE Trans. Image Processing,        7(3,):421-432, 1998. <a href="http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=661192">http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=661192</a></p>      <p>[HSSB98] M. Heath, S. Sarkar, T. Sanocki, and K. Bowyer:        "Comparison of edge detectors: a methodology and initial study",        Computer Vision and Image Understanding, 69(1):38-54, 1998. <a          href="http://www.sciencedirect.com/science/article/pii/S1077314297905877">http://www.sciencedirect.com/science/article/pii/S1077314297905877</a></p>      <p>[RT01] M. Ruzon and C. Tomasi: "Edge, junction, and corner        detection using color distributions", IEEE Transactions on        Pattern Analysis and Machine Intelligence, 23(11):1281-1295,        2001. <a href="http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=969118">http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=969118</a></p>      <p>[GW02] R.C. Gonzales and R.E. Woods: "Digital Image        Processing", Prentice Hall, 2002.</p>      <p>[Koves03] P.D. Kovesi: "Phase congruency detects corners and        edges", Proc. DICTA, pp. 309-318, 2003. <a href="www.csse.uwa.edu.au/%7Epk/research/pkpapers/phasecorners.pdf">www.csse.uwa.edu.au/~pk/research/pkpapers/phasecorners.pdf</a></p>      <p>[Koth03] U. Kothe: "Edge and junction detection with an        improved structure tensor", Proc. of DAGM Symposium, LNCS 2781,        pp. 25-32, Springer, 2003. <a href="http://hci.iwr.uni-heidelberg.de/Staff/ukoethe/papers/structureTensor.pdf">http://hci.iwr.uni-heidelberg.de/Staff/ukoethe/papers/structureTensor.pdf</a></p>      <p>[HY04] X.C. He and N.H.C. Yung: "Curvature scale space corner        detector with adaptive threshold and dynamic region of support",        Proc. ICPR, vol. 2, pp. 791-794, 2004. <a href="http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=1334377">http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=1334377</a></p>      <p>[PS06] L. Prasad and A. Skourikhine: "Vectorized image        segmentation via trixel agglomeration", Pattern Recognition,        39:501-514, 2006. <a href="http://www.sciencedirect.com/science/article/pii/S0031320305003857">http://www.sciencedirect.com/science/article/pii/S0031320305003857</a></p>      <p>[ALFR09] M. Awrangjeb, G. Lu, C.S. Fraser and M. Ravanbakhsh:        "“A Fast Corner Detector Based on the Chord-to-Point Distance        Accumulation Technique", Proc. DICTA, pp. 519-525, 2009. <a href="http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=5384897">http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=5384897</a></p>      <h2>See also<a name="7"></a></h2>      <p><a href="EDGE.html"><tt>EDGE</tt></a>, <a href="CORNER.html"><tt>CORNER</tt></a>,        <a href="CANNYEDGE.html"><tt>CANNYEDGE</tt></a>, <a href="../../../vista/html/CANNYEDGES.html"><tt>CANNYEDGES</tt></a>,        <a href="CANNYEDGEPROD.html"><tt>CANNYEDGEPROD</tt></a>, <a href="CANNYEDGEMAP.html"><tt>CANNYEDGEMAP</tt></a>,        <a href="SDGDEDGE.html"><tt>SDGDEDGE</tt></a>, <a href="CONGRUENCYEDGE.html"><tt>CONGRUENCYEDGE</tt></a>,        <a href="COMPASSEDGE.html"><tt>COMPASSEDGE</tt></a>, <a href="ANISOEDGE.html"><tt>ANISOEDGE</tt></a>,        <a href="ELDERZUCKEREDGE.html"><tt>ELDERZUCKEREDGE</tt></a>, <a          href="KOETHEDGE.html"><tt>KOETHEDGE</tt></a>,        <a href="PETROUEDGE.html"><tt>PETROUEDGE</tt></a>, <a href="SUSANCORNER.html"><tt>SUSANCORNER</tt></a>,        <a href="HARRISCORNER.html"><tt>HARRISCORNER</tt></a>, <a href="FASTCORNER.html"><tt>FASTCORNER</tt></a>,        <a href="FASTCPDA.html"><tt>FASTCPDA</tt></a>. Called: <a href="EDGECORNER_BASE.html"><tt>EDGECORNER_BASE</tt></a>.</p>      <h2>Function implementation<a name="8"></a></h2>      <pre class="codeinput"><span class="keyword">function</span> [Edge, Corner] = edgecorner(I, varargin)</pre>      <p>parsing parameters</p>      <pre class="codeinput">error(nargchk(1, 23, nargin, <span class="string">'struct'</span>));error(nargoutchk(0, 2, nargout, <span class="string">'struct'</span>));<span class="comment">% mandatory parameter</span><span class="keyword">if</span> ~isnumeric(I)    error(<span class="string">'edgecorner:inputerror'</span>,<span class="string">'matrix required in input'</span>);<span class="keyword">end</span>p = createParser(<span class="string">'EDGECORNER'</span>);<span class="comment">% principal optional parameters</span>p.addOptional(<span class="string">'edge'</span>, <span class="string">'vista'</span>, @(x) islogical(x) || (ischar(x) &amp;&amp; <spanclass="keyword">...</span>    any(strcmpi(x,{<span class="string">'canny'</span>,<span class="string">'log'</span>,<spanclass="string">'vista'</span>,<spanclass="string">'koethe'</span>,<spanclass="string">'black'</span>,<spanclass="string">'rothwell'</span>, <spanclass="keyword">...</span>    <span class="string">'sobel'</span>,<span class="string">'prewitt'</span>,<spanclass="string">'congrue'</span>,<spanclass="string">'compass'</span>,<spanclass="string">'elder'</span>, <spanclass="keyword">...</span>    <span class="string">'fast'</span>,<span class="string">'derivative5'</span>,<spanclass="string">'derivative7'</span>,<spanclass="string">'luengo'</span>,<spanclass="string">'fleck'</span>}))));p.addOptional(<span class="string">'corner'</span>, <span class="string">'harris'</span>, @(x) islogical(x) || (ischar(x) &amp;&amp; <spanclass="keyword">...</span>    any(strcmpi(x,{<span class="string">'harris'</span>,<span class="string">'noble'</span>,<spanclass="string">'susan'</span>,<spanclass="string">'cpda'</span>, <spanclass="keyword">...</span>    <span class="string">'fast9'</span>,<span class="string">'fast10'</span>,<spanclass="string">'fast11'</span>,<spanclass="string">'fast12'</span>}))));<span class="comment">% other optional parameters</span>p.addParamValue(<span class="string">'sig'</span>, 0.5, @(x)isscalar(x) &amp;&amp; isfloat(x) &amp;&amp; x&gt;=0);p.addParamValue(<span class="string">'rho'</span>, 1, @(x)isscalar(x) &amp;&amp; isfloat(x) &amp;&amp; x&gt;=0);p.addParamValue(<span class="string">'reduce'</span>, false, @(x)islogical(x) || <spanclass="keyword">...</span>    (ischar(x) &amp;&amp; any(strcmpi(x,{<span class="string">'igray'</span>,<spanclass="string">'imax'</span>,<spanclass="string">'isum'</span>,<spanclass="string">'gmax'</span>,<spanclass="string">'eor'</span>}))));<span class="comment">% used by all corner detections</span>p.addParamValue(<span class="string">'thres'</span>, 1, @(x)(isscalar(x) || numel(x)==2) &amp;&amp; all(x&gt;=0));<span class="comment">% used for method 'Koethe' only</span>p.addParamValue(<span class="string">'int'</span>, <span class="string">'fast'</span>, @(x)islogical(x) || (ischar(x) &amp;&amp; <spanclass="keyword">...</span>    any(strcmpi(x,{<span class="string">'matlab'</span>,<span class="string">'conv'</span>,<spanclass="string">'fast'</span>,<spanclass="string">'ani'</span>}))));p.addParamValue(<span class="string">'samp'</span>, 1, @(x)isscalar(x) &amp;&amp; round(x)==x &amp;&amp; x&gt;=1 &amp;&amp; x&lt;=5);<span class="comment">% parse and validate all input arguments</span>p.parse(varargin{:});p = getvarParser(p);</pre>      <p>check parameters</p>      <pre class="codeinput"><span class="keyword">if</span> islogical(p.edge) &amp;&amp; ~p.edge &amp;&amp; islogical(p.corner) &amp;&amp; ~p.corner    error(<span class="string">'edgecorner:inputerror'</span>, <span class="keyword">...</span>        <span class="string">'at least one of the variables met_corner or met_edge must be defined'</span>);<span class="keyword">end</span><span class="keyword">if</span> islogical(p.edge) &amp;&amp; p.edge    p.edge = <span class="string">'vista'</span>; <span class="comment">% reset to default</span><span class="keyword">end</span><span class="keyword">if</span> islogical(p.corner) &amp;&amp; p.corner    p.corner = <span class="string">'harris'</span>;<span class="keyword">end</span><span class="keyword">if</span> strcmpi(p.edge,<span class="string">'compass'</span>) &amp;&amp; size(I,3)==3 &amp;&amp; <spanclass="keyword">...</span>        ~(islogical(p.reduce) &amp;&amp; p.reduce)    warning(<span class="string">'edgecorner:inputwarning'</span>, <spanclass="keyword">...</span>        [<span class="string">'compass not using full color information like in original method - '</span><spanclass="keyword">...</span>        <span class="string">'set ''reduce'' to true for original approach'</span>]);<span class="keyword">end</span><span class="keyword">if</span> strcmpi(p.edge,<span class="string">'congrue'</span>) &amp;&amp; any(p.thres&gt;1),    warning(<span class="string">'edgecorner:inputwarning'</span>, <spanclass="keyword">...</span>        [<span class="string">'threshold should be in [0,1] ''with congrue'' method - '</span><spanclass="keyword">...</span>        <span class="string">'threshold set to 0.1'</span>]);   p.thres = [0.1 0.1];<span class="keyword">end</span></pre>      <p>main calculation</p>      <pre class="codeinput">[Edge, Corner]  = edgecorner_base(I, p.edge, p.corner, <spanclass="keyword">...</span>    p.rho, p.sig, p.thres, p.reduce, p.int, p.samp);</pre>      <p>display</p>      <pre class="codeinput"><span class="keyword">if</span> p.disp    nout = ~isempty(Edge) + ~isempty(Corner);    figure,    <span class="keyword">if</span> ~isempty(Edge)        subplot(1,nout,1), imagesc(Edge), axis <span class="string">image</span> <spanclass="string">off</span>,        title([<span class="string">'edge map - method '</span> p.edge]);        <span class="keyword">if</span> size(Edge,3)==1,  colormap <spanclass="string">gray</span>;  <spanclass="keyword">end</span>    <span class="keyword">end</span>    <span class="keyword">if</span> ~isempty(Corner)        subplot(1,nout,1+~isempty(Edge)), imagesc(Corner), axis <span class="string">image</span> <spanclass="string">off</span>,        title([<span class="string">'corner map - method '</span> p.corner]);        <span class="keyword">if</span> size(Corner,3)==1,  colormap <spanclass="string">gray</span>;  <spanclass="keyword">end</span>    <span class="keyword">end</span><span class="keyword">end</span></pre>      <p>if only one lhs and Edge is empty, then exchange the variables</p>      <pre class="codeinput"><span class="keyword">if</span> nargout==1 &amp;&amp; isempty(Edge)    Edge = Corner;    Corner = [];<span class="keyword">end</span></pre>      <pre class="codeinput"><span class="keyword">end</span> <span class="comment">% end of edgecorner</span></pre> </div>    <!--##### SOURCE BEGIN #####%% EDGECORNER - Wrapper function for various edge/corner detection techniques.%%% Syntax%     [Edge, Corner] = EDGECORNER(I);%     [Edge, Corner] = EDGECORNER(I, met_edge, met_corner, %                                 'Property', propertyvalue, ...);%%% Inputs% *|I|* : an input image with size |(X,Y,C), where |C>1| when |I| is multichannel.%      % *|met_edge|* : logical variable or string setting the method used for%     detecting edges; it can be either:%      % * |'canny'| or |'log'| when performing Canny or log-Laplacian edge detection%          [GW02] with function |EDGE|; in that case, the detector is applied%          channel by channel,% * |'vista'| for detecting edges likewise [PS06], a slightly variant of the%          Canny detector implemented in Matlab,   % * |'black'| for the anisotropic edge detector of [BSMH98] using the %          function |ANISOEDGE|, % * |'rothwell'| for the subpixel edge detector of [RMHN95] using the%          function |ROTHWELLEDGE|, % * |'koethe'| for the tensor-based edge detector of [Koth03] using the%          function |KOETHEDGE|, % * |'compass'| for the compass edge/corner detector of [RT01] using the%          function |COMPASSEDGE|,% * |'elder'| for the blur-based edge detector of [EZ98] using the function%          |ELDERZUCKEREDGE|,% * any of the strings |'prewitt'|, |'sobel'|, |'fast'|, |'derivative5'|,%          |'derivative7'|, |'fleck'| or |'luengo'| for applying the %          corresponding edge detectors using the function |GRDSMOOTH|,% * |'congrue'| for the edge/corner detection of [Koves03] based on%          phase congruency and implemented in |CONGRUENCYEDGE|;%      % in the case |met_edge| is logical and |false|, then no edge are estimated,%     it is expected that corners only are detected (see variable |met_corner| %     below); in the case |met_edge| is logical and |true|, it is assigned%     its default value; default: |met_edge='vista'|.%      % *|met_corner|* : logical variable or string defining the method used for %     extracting corners; it can be either:%      % * |'harris'| or |'noble'| for Harris-Forster and Noble detections resp. %          using the function |HARRISCORNER|,% * |'susan'| for Susan detection [SB97] with function |SUSANCORNER|,% * |'fast9'|, |'fast10'|, |'fast11'|, |'fast12'|, for any FAST corner%          detection using the function |FASTCORNER|,% * |'cpda'| for curvature-based detection [ALFR09] using the function%          |FASTCPDA|;%      % in the case |met_corner| is logical and |false|, then no corners are%     extracted, it is expected that edges only are detected (see variable%     |met_edge| above); in the case met_edge is logical and true, it is %     assigned its default value; default: |met_corner='harris'|.%      % Note that in some cases, the implemented edge detectors (see |met_edge|% above) also enable to extract the corners (|'congrue'|, |'compass'| or% |'koethe'|).%%% Property [propertyname  propertyvalues]% *|'rho'|* : post-smoothing standard deviation, used either by either of the%     detectors |'koethe'| and |'harris'| (see corresponding functions); %     default: |rho=1|.%      % *|'sig'|* : pre-smoothing standard deviation, used by various of the methods%     above.%      % *|'reduce'|* : logical value or string defining the way the different channels%     of a multispectral image are combined into the output edge map (see%     |CANNYEDGE_BASE|); it can be either:%      % * |'igray'|: the input RGB image is converted to a gray image using %          function |RGB2GRAY|,% * |'imax', 'isum'| : the input image (any dimension) is converted to a%          gray image by taking the sum and the max over the different%          channels resp.,% * |'gmax'| : gradients are computed for the different channels and their%          local pixelwise max is given as a single input to the edge%          detector;% * |'eor'| : calculations are made like for a multispectral image (as if%          |reduce=false|), but the final edge map is taken as the logical %          |OR| of the output edge maps of the different channels;%      % in |true| case, it is set to |'sum'|; default: |reduce=false|, ie. no%     'combination' is used, a multichannel map is output; this parameter%     is naturally ignored when |I| is a scalar image; note that reduce%     should be set to |true| when |met_edge='compass'|.%      % *|'int', 'samp'|* : parameters used for GST estimation in the method%     |'koethe'|; see corresponding function and |GRD2GST|; default: %     |int='fast'| and |samp=1|.% %% Outputs% *|Edge|* : logical map of edges.%      % *|Corner|* : logical map of corners.%      % Note that if |met_edge| is set to |false| and only one lhs is required,% then |Corner| is automatically passed in the output lhs variable (ie. output % variables' positions of |Edge| and |Corner| are exchanged).%%% References% [Canny86]  J.F. Canny: "A computational approach to edge detection",%      IEEE Trans. on Pattern Analysis and Machine Intelligence, 8(6):679-698,%      1986.%      <http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=4767851&tag=1>%      % [Zenzo86]  S. Di Zenzo: "A note on the gradient of a multi-image",%      Computer Vision and Graphical Image Processing, 33:116-125, 1986.%      <http://www.sciencedirect.com/science/article/pii/0734189X86902239>%% [HS88]  C.G. Harris and M.J. Stephens: "A combined corner and edge %      detector", Proc. Vision Conference, pp 147-151, 1988.%      <http://www.bmva.org/bmvc/1988/avc-88-023.pdf>%      % [RMHN95] C. Rothwell, J. Mundy, B. Hoffman and V.-D. Nguyen: "Driving%      Vision by Topology", Techn. report 2444, INRIA, 1995.%      <http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=477034&tag=1>%      % [HSSB97]  M. Heath, S. Sarkar, T. Sanocki, T. and K.W. Bowyer: "A robust%      visual method for assessing the relative performance of edge-detection%      algorithms, IEEE Trans. on Pattern Analysis and Machine Intelligence,%      19(12):1338-1359, 1997.%      <http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=643893>%      % [SB97]  S.M. Smith and J.M. Brady: "{SUSAN} - A new approach to low  %      level image processing", International Journal of Computer Vision,%      23(1):45-78, 1997.%      <http://www.lems.brown.edu/vision/courses/image-processing/Readings/smith95susan.pdf>%      % [EZ98]  J.H. Elder and S.W. Zucker: "Local scale control for edge %      detection and blur Estimation", IEEE Trans. on Pattern Analysis and%      Machine Intelligence, 20(7), 1998.%      <http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=689301&tag=1>%      % [BSMH98] M. Black, G. Sapiro, D. Marimont and D. Heeger: "Robust %      anisotropic Diffusion", IEEE Trans. Image Processing, 7(3,):421-432, %      1998.%      <http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=661192>%      % [HSSB98]  M. Heath, S. Sarkar, T. Sanocki, and K. Bowyer: "Comparison of%     edge detectors: a methodology and initial study",  Computer Vision and%     Image Understanding, 69(1):38-54, 1998.%     <http://www.sciencedirect.com/science/article/pii/S1077314297905877>%% [RT01]  M. Ruzon and C. Tomasi: "Edge, junction, and corner detection%      using color distributions",  IEEE Transactions on Pattern Analysis%      and Machine Intelligence, 23(11):1281-1295, 2001. %      <http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=969118>%      % [GW02]  R.C. Gonzales and R.E. Woods: "Digital Image Processing",      %      Prentice Hall, 2002.%      % [Koves03]  P.D. Kovesi: "Phase congruency detects corners and edges",%      Proc. DICTA, pp. 309-318, 2003. %      <www.csse.uwa.edu.au/~pk/research/pkpapers/phasecorners.pdf>%      % [Koth03]  U. Kothe: "Edge and junction detection with an improved %      structure tensor", Proc. of DAGM Symposium, LNCS 2781, pp. 25-32, %      Springer, 2003.%      <http://hci.iwr.uni-heidelberg.de/Staff/ukoethe/papers/structureTensor.pdf>%      % [HY04]  X.C. He and N.H.C. Yung: "Curvature scale space corner detector%      with adaptive threshold and dynamic region of support", Proc. ICPR,%      vol. 2, pp. 791-794, 2004.%      <http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=1334377>%      % [PS06]  L. Prasad and A. Skourikhine: "Vectorized image segmentation %      via trixel agglomeration", Pattern Recognition, 39:501-514, 2006.%      <http://www.sciencedirect.com/science/article/pii/S0031320305003857>%% [ALFR09]  M. Awrangjeb, G. Lu, C.S. Fraser and M. Ravanbakhsh: "A Fast%      Corner Detector Based on the Chord-to-Point Distance Accumulation %      Technique", Proc. DICTA, pp. 519-525, 2009.%      <http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=5384897>%%% Credit% <mailto:prasad@lanl.gov L.Prasad> & <mailto:grazzja@lanl.gov J.Grazzini> (ISR-2/LANL)% %% See also% <EDGE.html |EDGE|>,% <CORNER.html |CORNER|>,% <CANNYEDGE.html |CANNYEDGE|>,% <../../../vista/html/CANNYEDGES.html |CANNYEDGES|>,% <CANNYEDGEPROD.html |CANNYEDGEPROD|>,% <CANNYEDGEMAP.html |CANNYEDGEMAP|>,% <SDGDEDGE.html |SDGDEDGE|>,% <CONGRUENCYEDGE.html |CONGRUENCYEDGE|>,% <COMPASSEDGE.html |COMPASSEDGE|>,% <ANISOEDGE.html |ANISOEDGE|>,% <ELDERZUCKEREDGE.html |ELDERZUCKEREDGE|>,% <KOETHEDGE.html |KOETHEDGE|>,% <PETROUEDGE.html |PETROUEDGE|>,% <SUSANCORNER.html |SUSANCORNER|>,% <HARRISCORNER.html |HARRISCORNER|>,% <FASTCORNER.html |FASTCORNER|>,% <FASTCPDA.html |FASTCPDA|>.% Called:% <EDGECORNER_BASE.html |EDGECORNER_BASE|>.%% Function implementationfunction [Edge, Corner] = edgecorner(I, varargin)%%% parsing parameterserror(nargchk(1, 23, nargin, 'struct'));error(nargoutchk(0, 2, nargout, 'struct'));% mandatory parameterif ~isnumeric(I)    error('edgecorner:inputerror','matrix required in input'); endp = createParser('EDGECORNER');   % principal optional parametersp.addOptional('edge', 'vista', @(x) islogical(x) || (ischar(x) && ...    any(strcmpi(x,{'canny','log','vista','koethe','black','rothwell', ...    'sobel','prewitt','congrue','compass','elder', ...    'fast','derivative5','derivative7','luengo','fleck'}))));p.addOptional('corner', 'harris', @(x) islogical(x) || (ischar(x) && ...    any(strcmpi(x,{'harris','noble','susan','cpda', ...    'fast9','fast10','fast11','fast12'}))));% other optional parametersp.addParamValue('sig', 0.5, @(x)isscalar(x) && isfloat(x) && x>=0);p.addParamValue('rho', 1, @(x)isscalar(x) && isfloat(x) && x>=0);p.addParamValue('reduce', false, @(x)islogical(x) || ...    (ischar(x) && any(strcmpi(x,{'igray','imax','isum','gmax','eor'}))));% used by all corner detectionsp.addParamValue('thres', 1, @(x)(isscalar(x) || numel(x)==2) && all(x>=0));% used for method 'Koethe' onlyp.addParamValue('int', 'fast', @(x)islogical(x) || (ischar(x) && ...    any(strcmpi(x,{'matlab','conv','fast','ani'}))));p.addParamValue('samp', 1, @(x)isscalar(x) && round(x)==x && x>=1 && x<=5);% parse and validate all input argumentsp.parse(varargin{:}); p = getvarParser(p);                                                            %%% check parametersif islogical(p.edge) && ~p.edge && islogical(p.corner) && ~p.corner    error('edgecorner:inputerror', ...        'at least one of the variables met_corner or met_edge must be defined');endif islogical(p.edge) && p.edge    p.edge = 'vista'; % reset to defaultend    if islogical(p.corner) && p.corner    p.corner = 'harris';    endif strcmpi(p.edge,'compass') && size(I,3)==3 && ...        ~(islogical(p.reduce) && p.reduce)    warning('edgecorner:inputwarning', ...        ['compass not using full color information like in original method - '...        'set ''reduce'' to true for original approach']);endif strcmpi(p.edge,'congrue') && any(p.thres>1),    warning('edgecorner:inputwarning', ...        ['threshold should be in [0,1] ''with congrue'' method - '...        'threshold set to 0.1']);   p.thres = [0.1 0.1]; end%% % main calculation[Edge, Corner]  = edgecorner_base(I, p.edge, p.corner, ...    p.rho, p.sig, p.thres, p.reduce, p.int, p.samp);%%% displayif p.disp    nout = ~isempty(Edge) + ~isempty(Corner);    figure,    if ~isempty(Edge)         subplot(1,nout,1), imagesc(Edge), axis image off,        title(['edge map - method ' p.edge]);        if size(Edge,3)==1,  colormap gray;  end    end    if ~isempty(Corner)        subplot(1,nout,1+~isempty(Edge)), imagesc(Corner), axis image off,        title(['corner map - method ' p.corner]);        if size(Corner,3)==1,  colormap gray;  end    endend%%% if only one lhs and Edge is empty, then exchange the variablesif nargout==1 && isempty(Edge)    Edge = Corner;    Corner = [];endend % end of edgecorner##### SOURCE END #####-->  </body></html>