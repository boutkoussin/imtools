<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html>  <head>    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">    <!--This HTML was auto-generated from MATLAB code.To make changes, update the MATLAB code and republish this document.      -->    <title>LOCALGLCM2D_BASE - Base function for LOCALGLCM2D.</title>    <meta name="generator" content="MATLAB 7.14">    <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">    <meta name="DC.date" content="2012-05-31">    <meta name="DC.source" content="localglcm2d_base.m">    <style type="text/css">html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}html { min-height:100%; margin-bottom:1px; }html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }html body td { vertical-align:top; text-align:left; }h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }a { color:#005fce; text-decoration:none; }a:hover { color:#005fce; text-decoration:underline; }a:visited { color:#004aa0; text-decoration:none; }p { padding:0px; margin:0px 0px 20px; }img { padding:0px; margin:0px 0px 20px; border:none; }p img, pre img, tt img, li img { margin-bottom:0px; } ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }ul li { padding:0px; margin:0px 0px 7px 0px; }ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }ul li ol li { list-style:decimal; }ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }ol li ol li { list-style-type:lower-alpha; }ol li ul { padding-top:7px; }ol li ul li { list-style:square; }.content { font-size:1.2em; line-height:140%; padding: 20px; }pre, tt, code { font-size:12px; }pre { margin:0px 0px 20px; }pre.error { color:red; }pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }span.keyword { color:#0000FF }span.comment { color:#228B22 }span.string { color:#A020F0 }span.untermstring { color:#B20000 }span.syscmd { color:#B28C00 }.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }.footer p { margin:0px; }  </style>  </head>  <body>    <div class="content">      <h1>LOCALGLCM2D_BASE - Base function for LOCALGLCM2D.</h1>      <!--introduction--><!--/introduction-->      <h2>Contents</h2>      <div>        <ul>          <li><a href="#1">Syntax</a></li>          <li><a href="#3">See also</a></li>          <li><a href="#4">Function implementation</a></li>        </ul>      </div>      <h2>Syntax<a name="1"></a></h2>      <pre>   O = LOCALGLCM2D_BASE(I, feat, res, dcar, win, wei, sig, mask);</pre>      <h2>See also<a name="3"></a></h2>      <p>Related: <a href="localglov2d_base.html"><tt>LOCALGLOV2D_BASE</tt></a>,        <a href="LOCALGLSDV2D_BASE.html"><tt>LOCALGLSDV2D_BASE</tt></a>. <a href="../kernel/neiposkernel.html"><tt>NEIPOSKERNEL</tt></a>.        Called: <a href="histcontrast.html"><tt>HISTCONTRAST</tt></a>, <a href="histvariance.html"><tt>HISTVARIANCE</tt></a>,        <a href="histenergy.html"><tt>HISTENERGY</tt></a>, <a href="histmaximum.html"><tt>HISTMAXIMUM</tt></a>,        <a href="histentropy2.html"><tt>HISTENTROPY2</tt></a>, <a href="histentropy10.html"><tt>HISTENTROPY10</tt></a>,        <a href="histdissimilarity.html"><tt>HISTDISSIMILARITY</tt></a>, <a href="histidifference.html"><tt>HISTIDIFFERENCE</tt></a>,        <a href="histcorrelation.html"><tt>HISTCORRELATION</tt></a>, <a href="histhomogeneity.html"><tt>HISTHOMOGENEITY</tt></a>,        <a href="matlab:webpub%28whichpath%28%27ACCUMARRAY%27%29%29"><tt>ACCUMARRAY</tt></a>.</p>      <h2>Function implementation<a name="4"></a></h2>      <pre class="codeinput"><span class="keyword">function</span> O = localglcm2d_base(I, feat, res, dcar, win, wei, sig, mask)</pre>      <p>checking parameters and setting internal variables</p>      <pre class="codeinput">[M,N,C] = size(I);</pre>      <p>ensure that the window size is odd</p>      <pre class="codeinput"><span class="keyword">if</span> mod(win,2)==0,  win = win + 1;  <spanclass="keyword">end</span>ws = floor(win / 2); <span class="comment">% half size window</span></pre>      <p>use the Cartesian representation in the following</p>      <pre class="codeinput">dnorm = sqrt(dcar(:,1).*dcar(:,1) + dcar(:,2).*dcar(:,2));nd = length(dnorm); <span class="comment">% also: size(dcar,1);</span><span class="keyword">if</span> strcmp(feat,<span class="string">'all'</span>),    nfeat = 8;<span class="keyword">else</span>                      nfeat = 1;<span class="keyword">end</span></pre>      <p>dealing with multichannel images</p>      <pre class="codeinput"><span class="keyword">if</span> C&gt;1    O = zeros(M,N,C,nfeat,nd);    <span class="keyword">for</span> c=1:C        O(:,:,c,:,:) = localglcm2d_base(I(:,:,c), feat, res, dcar, win, wei, sig, mask );    <span class="keyword">end</span>    <span class="keyword">return</span>;<span class="keyword">end</span></pre>      <p>computation</p>      <pre class="codeinput"><span class="comment">% pad the input image</span>pad = ws + ceil(max(dnorm));A = padarray(I, [pad pad],<span class="string">'replicate'</span>,<span class="string">'both'</span>);[X,Y] = size(A);A = A(:);<span class="comment">% global normalization &amp; quantization</span><span class="comment">%if strcmp(n,'global');</span>Amin = min(A); Adelt = max(A) - Amin;A = (A - Amin) / Adelt; <span class="comment">% in range [0,1]</span>A = ceil((res-1) * A + 0.5);<span class="comment">%end</span><span class="comment">% indexes</span>pixindex = reshape(1:X*Y,X,Y);pixin = reshape(pixindex(pad+1:pad+M,pad+1:pad+N),1,M*N);<span class="comment">% Index of the centered neighbour window of analysis</span>indI = neipos(ws, X);indI = indI(:);<span class="comment">% indI = -ws:ws;</span><span class="comment">% for i=1:ws</span><span class="comment">%     indI = [ (-i*X-ws):(-i*X+ws), indI, (i*X-ws):(i*X+ws) ];         %#ok</span><span class="comment">% end</span><span class="comment">% indI = indI';</span><span class="comment">% indI = indI(:);</span><span class="comment">% Index of the displaced window(s)</span>indJ = zeros(length(indI),nd);<span class="keyword">for</span> d=1:nd    indt = dcar(d,2)*X + dcar(d,1);    indJ(:,d) = indI + indt;<span class="keyword">end</span></pre>      <p>initialize the set of estimated features and their number</p>      <pre class="codeinput"><span class="keyword">switch</span> feat    <span class="keyword">case</span> <span class="string">'all'</span>        histfeat = @histfeatures;    <span class="keyword">case</span> <span class="string">'var'</span>,           histfeat = @histvariance;    <span class="keyword">case</span> <span class="string">'con'</span>,           histfeat = @histcontrast;    <span class="keyword">case</span> <span class="string">'ene'</span>,           histfeat = @histenergy;    <span class="keyword">case</span> <span class="string">'max'</span>,           histfeat = @histmaximum;    <span class="keyword">case</span> <span class="string">'dis'</span>,           histfeat = @histdissimilarity;    <span class="keyword">case</span> <span class="string">'inv'</span>,           histfeat = @histidifference;    <span class="keyword">case</span> <span class="string">'mean'</span>,          histfeat = @histmean;    <span class="keyword">case</span> {<span class="string">'ent2'</span>,<spanclass="string">'ent'</span>},  histfeat = @histentropy2;    <span class="keyword">case</span> <span class="string">'ent10'</span>,         histfeat = @histentropy10;    <span class="keyword">case</span> <span class="string">'cor'</span>,           histfeat = @histcorrelation;    <span class="keyword">case</span> <span class="string">'hom'</span>,           histfeat = @histhomogeneity;<span class="keyword">end</span></pre>      <p>initialize the weights</p>      <pre class="codeinput"><span class="keyword">switch</span> wei    <span class="keyword">case</span> <span class="string">'ave'</span>        W = fspecial(<span class="string">'average'</span>,win);    <span class="keyword">case</span> <span class="string">'gaus'</span>        W = fspecial(<span class="string">'gaussian'</span>,win,sig);    <span class="keyword">case</span> <span class="string">'inv'</span>        W = euclidkernel([win win], 1, false, true);        W(ws+1,ws+1) = 1;        <span class="keyword">if</span> sig~=1, W = W.^sig; <span class="keyword">end</span><span class="keyword">end</span>W = W(:);W = W / sum(W);</pre>      <p>main computation</p>      <pre class="codeinput">[I,J] = meshgrid(1:res);<span class="comment">% I: index of column [1:res] repeated on res rows</span><span class="comment">%     I = [ 1 2 3...res; 1 2 3...res; ... ; 1 2 3...res ]</span><span class="comment">% J: index of row [1:res] repeated on res columns</span><span class="comment">%     J = [ 1 1 1...1; 2 2 2...2; ... ; res res res...res ]</span>I = I(:); J = J(:);W = [0; W; 0];<span class="comment">% create the (temp) output image</span>O =  zeros(X*Y,nfeat,nd);</pre>      <p>loop over the image</p>      <pre class="codeinput"><span class="keyword">for</span> in=pixin</pre>      <p>extract current values in windows</p>      <pre class="codeinput">    inI = A(indI + in);    <span class="comment">% normalize locally if required</span>    <span class="comment">% if strcmp(n,'local');</span>    <span class="comment">%    mmin = min(inI(:));</span>    <span class="comment">%    inI = (inI - mmin) / (max(inI) - mmin); % in range [0,1]</span>    <span class="comment">% end</span>    <span class="comment">% inI = ceil((res-1) * inI + 0.5); % in range [1,res]</span>    inI = [1; inI; res];                                               <span class="comment">%#ok</span></pre>      <p>loop over the displacement vectors</p>      <pre class="codeinput">    <span class="keyword">for</span> d=1:nd</pre>      <pre class="codeinput">        inJ = A(indJ(:,d) + in);        <span class="comment">%  inJ(:,d) = ceil((res-1) * inJ(:,d) + 0.5);</span>        <span class="comment">% if strcmp(n,'local');</span>        <span class="comment">%    mmin = min(inJ(:,d));</span>        <span class="comment">%    inJ(:,d) = (inJ(:,d) - mmin) / (max(inJ(:,d)) - mmin);</span>        <span class="comment">% end</span></pre>      <p>fast method ensure that the output matrix is of size (res x res) by        padding the greylevels pairs (1,1) and (res,res) with null probability        (see W padding above), so that accumarray take them into account in the        2D array construction</p>      <pre class="codeinput">        inJ = [1; inJ; res];                                           <spanclass="comment">%#ok</span>        <span class="comment">% accumulate using the weights in W to create the 2D matrix of size</span>        <span class="comment">% (res x res)</span>        pIJ = accumarray([inI inJ],W);        <span class="comment">%      pIJ0 = pIJ(:)==0;</span>        <span class="comment">%      pIJ(pIJ0) = [];</span>        <span class="comment">%      II = I; II(pIJ0) = [];</span>        <span class="comment">%      JJ = J; JJ(pIJ0) = [];</span>        <span class="comment">% compute the feature</span>        O(in,:,d) = histfeat(pIJ(:),I,J);        <span class="comment">% elegant method...but slower</span>        <span class="comment">%      pIJ = accumarray([inI inJ],W);</span>        <span class="comment">%      IJ = unique([inI inJ],'rows');</span>        <span class="comment">%      pIJ(pIJ==0) = [];</span>        <span class="comment">%      O(in) =  histvariance(pIJ,IJ(:,1),IJ(:,2));</span></pre>      <pre class="codeinput">    <span class="keyword">end</span></pre>      <pre class="codeinput"><span class="keyword">end</span>O = reshape(O(pixin,:,:),M,N,nfeat,nd);</pre>      <pre class="codeinput"><span class="keyword">end</span> <span class="comment">% end of localglcm2d_base</span></pre></div>    <!--##### SOURCE BEGIN #####%% LOCALGLCM2D_BASE - Base function for LOCALGLCM2D.%%% Syntax%     O = LOCALGLCM2D_BASE(I, feat, res, dcar, win, wei, sig, mask);%%% Credit% <mailto:grazzja@lanl.gov J.Grazzini> (ISR-2/LANL)%%% See also% Related:% <localglov2d_base.html |LOCALGLOV2D_BASE|>,% <LOCALGLSDV2D_BASE.html |LOCALGLSDV2D_BASE|>.% <../kernel/neiposkernel.html |NEIPOSKERNEL|>.% Called:% <histcontrast.html |HISTCONTRAST|>,% <histvariance.html |HISTVARIANCE|>,% <histenergy.html |HISTENERGY|>,% <histmaximum.html |HISTMAXIMUM|>,% <histentropy2.html |HISTENTROPY2|>,% <histentropy10.html |HISTENTROPY10|>,% <histdissimilarity.html |HISTDISSIMILARITY|>,% <histidifference.html |HISTIDIFFERENCE|>,% <histcorrelation.html |HISTCORRELATION|>,% <histhomogeneity.html |HISTHOMOGENEITY|>,% <matlab:webpub(whichpath('ACCUMARRAY')) |ACCUMARRAY|>. %% Function implementationfunction O = localglcm2d_base(I, feat, res, dcar, win, wei, sig, mask)%%% checking parameters and setting internal variables[M,N,C] = size(I);%%% ensure that the window size is oddif mod(win,2)==0,  win = win + 1;  endws = floor(win / 2); % half size window%%% use the Cartesian representation in the followingdnorm = sqrt(dcar(:,1).*dcar(:,1) + dcar(:,2).*dcar(:,2));         nd = length(dnorm); % also: size(dcar,1);if strcmp(feat,'all'),    nfeat = 8;else                      nfeat = 1;end%%% dealing with multichannel imagesif C>1    O = zeros(M,N,C,nfeat,nd);    for c=1:C        O(:,:,c,:,:) = localglcm2d_base(I(:,:,c), feat, res, dcar, win, wei, sig, mask );    end    return;end%%% computation% pad the input imagepad = ws + ceil(max(dnorm));A = padarray(I, [pad pad],'replicate','both'); [X,Y] = size(A);A = A(:);% global normalization & quantization%if strcmp(n,'global');Amin = min(A); Adelt = max(A) - Amin;A = (A - Amin) / Adelt; % in range [0,1]A = ceil((res-1) * A + 0.5);%end% indexespixindex = reshape(1:X*Y,X,Y);pixin = reshape(pixindex(pad+1:pad+M,pad+1:pad+N),1,M*N);% Index of the centered neighbour window of analysis indI = neipos(ws, X);indI = indI(:);% indI = -ws:ws;% for i=1:ws%     indI = [ (-i*X-ws):(-i*X+ws), indI, (i*X-ws):(i*X+ws) ];         %#ok% end% indI = indI';% indI = indI(:);% Index of the displaced window(s)indJ = zeros(length(indI),nd);for d=1:nd    indt = dcar(d,2)*X + dcar(d,1);    indJ(:,d) = indI + indt;end%%% initialize the set of estimated features and their numberswitch feat    case 'all'        histfeat = @histfeatures;    case 'var',           histfeat = @histvariance;    case 'con',           histfeat = @histcontrast;    case 'ene',           histfeat = @histenergy;    case 'max',           histfeat = @histmaximum;    case 'dis',           histfeat = @histdissimilarity;    case 'inv',           histfeat = @histidifference;    case 'mean',          histfeat = @histmean;    case {'ent2','ent'},  histfeat = @histentropy2;    case 'ent10',         histfeat = @histentropy10;    case 'cor',           histfeat = @histcorrelation;    case 'hom',           histfeat = @histhomogeneity;end%%% initialize the weightsswitch wei    case 'ave'        W = fspecial('average',win);    case 'gaus'        W = fspecial('gaussian',win,sig);    case 'inv'        W = euclidkernel([win win], 1, false, true);        W(ws+1,ws+1) = 1;        if sig~=1, W = W.^sig; endendW = W(:);W = W / sum(W);%%% main computation[I,J] = meshgrid(1:res);% I: index of column [1:res] repeated on res rows%     I = [ 1 2 3...res; 1 2 3...res; ... ; 1 2 3...res ]% J: index of row [1:res] repeated on res columns%     J = [ 1 1 1...1; 2 2 2...2; ... ; res res res...res ]I = I(:); J = J(:);W = [0; W; 0];% create the (temp) output imageO =  zeros(X*Y,nfeat,nd);  %% % loop over the imagefor in=pixin    %%    % extract current values in windows    inI = A(indI + in);    % normalize locally if required    % if strcmp(n,'local');    %    mmin = min(inI(:));    %    inI = (inI - mmin) / (max(inI) - mmin); % in range [0,1]    % end    % inI = ceil((res-1) * inI + 0.5); % in range [1,res]    inI = [1; inI; res];                                               %#ok        %%    % loop over the displacement vectors    for d=1:nd        inJ = A(indJ(:,d) + in);        %  inJ(:,d) = ceil((res-1) * inJ(:,d) + 0.5);        % if strcmp(n,'local');        %    mmin = min(inJ(:,d));        %    inJ(:,d) = (inJ(:,d) - mmin) / (max(inJ(:,d)) - mmin);        % end                %%        % fast method        % ensure that the output matrix is of size (res x res) by padding the        % greylevels pairs (1,1) and (res,res) with null probability (see W        % padding above), so that accumarray take them into account in the 2D        % array construction        inJ = [1; inJ; res];                                           %#ok         % accumulate using the weights in W to create the 2D matrix of size        % (res x res)        pIJ = accumarray([inI inJ],W);        %      pIJ0 = pIJ(:)==0;        %      pIJ(pIJ0) = [];        %      II = I; II(pIJ0) = [];        %      JJ = J; JJ(pIJ0) = [];        % compute the feature        O(in,:,d) = histfeat(pIJ(:),I,J);                 % elegant method...but slower        %      pIJ = accumarray([inI inJ],W);        %      IJ = unique([inI inJ],'rows');        %      pIJ(pIJ==0) = [];        %      O(in) =  histvariance(pIJ,IJ(:,1),IJ(:,2));    endendO = reshape(O(pixin,:,:),M,N,nfeat,nd);end % end of localglcm2d_base##### SOURCE END #####-->  </body></html>