<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html>  <head>    <meta content="text/html; charset=utf-8" http-equiv="content-type">    <!--This HTML was auto-generated from MATLAB code.To make changes, update the MATLAB code and republish this document.      -->    <title>CELLSTRSUBTRIM - Trim a set of strings from its matching substrings.</title>    <meta name="generator" content="MATLAB 7.14">    <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">    <meta name="DC.date" content="2012-11-14">    <meta name="DC.source" content="cellstrsubtrim.m">    <style type="text/css">html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}html { min-height:100%; margin-bottom:1px; }html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }html body td { vertical-align:top; text-align:left; }h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }a { color:#005fce; text-decoration:none; }a:hover { color:#005fce; text-decoration:underline; }a:visited { color:#004aa0; text-decoration:none; }p { padding:0px; margin:0px 0px 20px; }img { padding:0px; margin:0px 0px 20px; border:none; }p img, pre img, tt img, li img { margin-bottom:0px; } ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }ul li { padding:0px; margin:0px 0px 7px 0px; }ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }ul li ol li { list-style:decimal; }ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }ol li ol li { list-style-type:lower-alpha; }ol li ul { padding-top:7px; }ol li ul li { list-style:square; }.content { font-size:1.2em; line-height:140%; padding: 20px; }pre, tt, code { font-size:12px; }pre { margin:0px 0px 20px; }pre.error { color:red; }pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }span.keyword { color:#0000FF }span.comment { color:#228B22 }span.string { color:#A020F0 }span.untermstring { color:#B20000 }span.syscmd { color:#B28C00 }.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }.footer p { margin:0px; }  </style>  </head>  <body>    <div class="content">      <h1>CELLSTRSUBTRIM - Trim a set of strings from its matching substrings.</h1>      <!--introduction--><!--/introduction-->      <h2>Contents</h2>      <div>        <ul>          <li><a href="#1">Description</a></li>          <li><a href="#2">Syntax</a></li>          <li><a href="#3">Inputs</a></li>          <li><a href="#4">Outputs</a></li>          <li><a href="#5">Example</a></li>          <li><a href="#7">See also</a></li>          <li><a href="#8">Function implementation</a></li>        </ul>      </div>      <h2>Description<a name="1"></a></h2>      <p>Discard all the strings of a set (array or cell) of strings that match        substrings of longer strings in the same set.</p>      <h2>Syntax<a name="2"></a></h2>      <pre>     [C, I] = CELLSTRSUBTRIM(S);     [C, I] = CELLSTRSUBTRIM(S, traversal, despace, sensitive);</pre>      <h2>Inputs<a name="3"></a></h2>      <p><b><tt>S</tt></b> : cell or array of strings (possibly containing        whitespace characters <tt>' '</tt> that can be ignored, see <tt>despace</tt>        below) from which redundant elements matching substrings of longer        strings are removed.</p>      <p><b><tt>traversal</tt></b> : (optional) flag setting the rule for        defining substrings; a string in <tt>S</tt> is considered as a        substring if it matches a substring of a longer string of <tt>S</tt>:</p>      <div>        <ul>          <li>when reading both of them <b>from left to right</b> in the case <tt>traversal=1</tt>,</li>          <li>when reading both of them <b>from right to left</b> in the case <tt>traversal=-1</tt>,</li>          <li><b>indepently of the order these strings are read</b> in the case            <tt>traversal=0</tt>;</li>        </ul>      </div>      <p>default: <tt>traversal=0</tt>.</p>      <p><b><tt>despace</tt></b> : (optional) logical flag stating if whitespace        characters <tt>' '</tt> should be removed from the strings (where <tt>ISSPACE</tt>        returns <tt>true</tt>); note moreover that leading and trailing        whitespace characters are automatically removed (using <tt>STRTRIM</tt>);        default: <tt>despace=false</tt>.</p>      <p><b><tt>sensitive</tt></b> : (optional) boolean flag defining is the        comparison is case sensitive (<tt>true</tt>, then use <tt>STRCNCMP</tt>)        or not (<tt>false</tt>, then use <tt>STRNCMPI</tt> instead); default: <tt>sensitive=true</tt>.</p>      <h2>Outputs<a name="4"></a></h2>      <p><b><tt>C</tt></b> : output cell (or array, depending on the class of        the input <tt>S</tt>) of strings where the substrings of <tt>S</tt>        have been removed following the rule defined by <tt>traversal</tt> and        <tt>despace</tt>; note that <tt>C</tt> is ordered according to the        length of its strings.</p>      <p><b><tt>I</tt></b> : indices (referring to the input <tt>S</tt>) of the        strings present in the output.</p>      <h2>Example<a name="5"></a></h2>      <pre>a=['fout  ';'piut  ';'pout  ';'meu g ';'meugh ';'tuipl ';  'foutre'];[c,i] = cellstrsubtrim(a)[c,i] = cellstrsubtrim(a,1)[c,i] = cellstrsubtrim(a,-1,true)[c,i] = cellstrsubtrim(a,0,true)a={ ['fout'] ['piut  ']' ['po ut'] ['meu g '] ['   meugh ']' ['tuipl '] ['fou  tre']}[c,i] = cellstrsubtrim(a,1,true)[c,i] = cellstrsubtrim(a,0,true)% both examples should return identical outputs when setting traversal=0% and despace=true</pre>      <h2>See also<a name="7"></a></h2>      <p>Related: <a href="../algebra/CELLNUMSUBTRIM.html"><tt>CELLNUMSUBTRIM</tt></a>.        Called: <a href="matlab:webpub%28whichpath%28%27TRIL%27%29%29"><tt>TRIL</tt></a>,        <a href="matlab:webpub%28whichpath%28%27STRNCMP%27%29%29"><tt>STRNCMP</tt></a>,        <a href="matlab:webpub%28whichpath%28%27STRNCMPI%27%29%29"><tt>STRNCMPI</tt></a>,        <a href="matlab:webpub%28whichpath%28%27STRTRIM%27%29%29"><tt>STRTRIM</tt></a>,        <a href="matlab:webpub%28whichpath%28%27ISSPACE%27%29%29"><tt>ISSPACE</tt></a>,        <a href="matlab:webpub%28whichpath%28%27CELLSTR%27%29%29"><tt>CELLSTR</tt></a>,        <a href="matlab:webpub%28whichpath%28%27CELL2MAT%27%29%29"><tt>CELL2MAT</tt></a>,        <a href="matlab:webpub%28whichpath%28%27CELLFUN%27%29%29"><tt>CELLFUN</tt></a>,        <a href="matlab:webpub%28whichpath%28%27RESHAPE%27%29%29"><tt>RESHAPE</tt></a>.</p>      <h2>Function implementation<a name="8"></a></h2>      <pre class="codeinput"><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> [C, I] = cellstrsubtrim(C, traversal, despace, sensitive)</pre>      <p>check/set variables</p>      <pre class="codeinput"><span class="keyword">if</span> ~iscellstr(C)    <span class="keyword">if</span> ~ischar(C)        error(<span class="string">'cellstrsubtrim:errorinput'</span>, <span class="keyword">...</span>            <span class="string">'input variable ''C'' must be a string array or a cell of strings'</span>);    <span class="keyword">end</span>    isarray = true;    C = cellstr(C);<span class="keyword">else</span>    isarray = false;<span class="keyword">end</span><span class="keyword">if</span> nargin&lt;4,  sensitive = true;    <span class="keyword">if</span> nargin&lt;3,  despace = false;        <span class="keyword">if</span> nargin&lt;2,  traversal = 0;  <span class="keyword">end</span>    <span class="keyword">end</span><span class="keyword">end</span><span class="keyword">if</span> ~(islogical(despace) &amp;&amp; islogical(sensitive))    error(<span class="string">'cellstrsubtrim:errorinput'</span>, <span class="keyword">...</span>        <span class="string">'input variables ''sensitive'' and ''despace'' must be logical'</span>);<span class="keyword">elseif</span> ~isscalar(traversal) || ~ismember(traversal,[0 1 -1])    error(<span class="string">'cellstrsubtrim:errorinput'</span>, <span class="keyword">...</span>        <span class="string">'input variable ''traversal'' takes values in {-1,0,1}'</span>);<span class="keyword">end</span>nC = numel(C);ind = (1:nC);<span class="keyword">if</span> nC==1 <span class="comment">% if one string only, nothing to do</span>    <span class="keyword">if</span> isarray,  C = char(C);  <span class="keyword">end</span>    <span class="keyword">return</span>;<span class="keyword">end</span><span class="keyword">if</span> sensitive,  strcompare = @strncmp;<span class="keyword">else</span>           strcompare = @strncmpi;<span class="keyword">end</span></pre>      <p>we need to ensure that the strings are 'row strings'...</p>      <pre class="codeinput">iscol = cellfun(@(c) size(c,1)&gt;1, C);<span class="keyword">if</span> any(iscol),  C(iscol) = cellfun(@transpose, C(iscol), <spanclass="string">'Uniform'</span>, false);  <spanclass="keyword">end</span></pre>      <p>clean up a bit: first deblank (remove leading and trailing whitespace        characters from string, not optional), then possibly'despace' (trim all        internal whitespaces)</p>      <pre class="codeinput">C = cellfun(@strtrim, C, <span class="string">'Uniform'</span>, false);<span class="keyword">if</span> despace,  C = cellfun(@(c) c(~isspace(c)), C, <spanclass="string">'Uniform'</span>, false);  <spanclass="keyword">end</span></pre>      <p>in general, get rid of empty strings</p>      <pre class="codeinput">I = cellfun(@isempty, C);<span class="comment">% update</span><span class="keyword">if</span> any(I),  C(I) = [];  iscol(I) = [];  ind(I) = [];  nC = numel(C);  <spanclass="keyword">end</span></pre>      <p>check</p>      <pre class="codeinput"><span class="keyword">if</span> nC==1  <span class="comment">% nothing more to do</span>    <span class="keyword">if</span> any(iscol),  C(iscol) = cellfun(@transpose, C(iscol), <spanclass="string">'Uniform'</span>, false);  <spanclass="keyword">end</span>    <span class="keyword">if</span> isarray,  C = char(C);  <span class="keyword">end</span>    <span class="keyword">return</span>;<span class="keyword">end</span></pre>      <p>sort the strings according to their (increasing) length</p>      <pre class="codeinput">[~,I] = sort(cellfun(@length,C));C = C(I);  ind = ind(I);  iscol = iscol(I);</pre>      <p>build the cell of inverted strings</p>      <pre class="codeinput"><span class="keyword">if</span> traversal&lt;=0    flipC = cellfun(@(c) fliplr(c), C, <span class="string">'Uniform'</span>, false);<span class="keyword">end</span><span class="keyword">if</span> traversal==1    I = cellfun(@(c) strcompare(c, C, length(c)), C, <span class="string">'Uniform'</span>, false);<span class="keyword">elseif</span> traversal==-1    I = cellfun(@(flipc) strcompare(flipc, flipC, length(flipc)), <span class="keyword">...</span>        flipC, <span class="string">'Uniform'</span>, false);<span class="keyword">else</span>    I = cellfun(@(c,flipc) <span class="keyword">...</span>        strcompare(c, C, length(c)) | strcompare(flipc, C, length(c)) | <span class="keyword">...</span>        strcompare(c, flipC, length(c)) | strcompare(flipc, flipC, length(c)), <spanclass="keyword">...</span>        C, flipC, <span class="string">'Uniform'</span>, false);    <span class="comment">% note that, in its first occurence, C is used as a constant (and,</span>    <span class="comment">% similarly, flipC), so that every single string of C (second occurrence)</span>    <span class="comment">% is compared with every other strings</span><span class="keyword">end</span>I = reshape(transpose(cell2mat(I)),[nC nC]); <span class="comment">% square matrix</span></pre>      <p>retrieve the lower triangular part of the diagonal; we do not want the        diagonal as it is always true (the substring is compared with itself)        and we do not want the upper triangular part as it means that two        substrings are equal (considering that the strings were initially        ordered according to their length) and one of them only (but not both)        should be discarded</p>      <pre class="codeinput">I = tril(I,-1) ;</pre>      <p>find the strings that are substrings of longer strings already in C:        they are repeated entries given by the indices of the non null columns        of I</p>      <pre class="codeinput">[~,I] = find(I); I = unique(I);</pre>      <p>clean up: get rid of those substrings and reconvert back to the        original format</p>      <pre class="codeinput"><span class="keyword">if</span> any(I),  C(I) = []; iscol(I) = [];  ind(I) = [];  <spanclass="keyword">end</span><span class="keyword">if</span> any(iscol),  C(iscol) = cellfun(@transpose, C(iscol), <spanclass="string">'Uniform'</span>, false);  <spanclass="keyword">end</span>I = ind;</pre>      <p>possibly reconvert back to a matrix</p>      <pre class="codeinput"><span class="keyword">if</span> isarray,  C = char(C);  <spanclass="keyword">end</span></pre>      <pre class="codeinput"><span class="keyword">end</span> <span class="comment">% end of cellstrsubtrim</span></pre></div>    <!--##### SOURCE BEGIN #####%% CELLSTRSUBTRIM - Trim a set of strings from its matching substrings. %%% Description% Discard all the strings of a set (array or cell) of strings that match% substrings of longer strings in the same set.%%% Syntax%       [C, I] = CELLSTRSUBTRIM(S);%       [C, I] = CELLSTRSUBTRIM(S, traversal, despace, sensitive);%%% Inputs% *|S|* : cell or array of strings (possibly containing whitespace characters%     |' '| that can be ignored, see |despace| below) from which redundant%     elements matching substrings of longer strings are removed.%% *|traversal|* : (optional) flag setting the rule for defining substrings;%     a string in |S| is considered as a substring if it matches a substring%     of a longer string of |S|:%  % * when reading both of them *from left to right* in the case |traversal=1|,          % * when reading both of them *from right to left* in the case |traversal=-1|,  % * *indepently of the order these strings are read* in the case |traversal=0|;     %          % default: |traversal=0|.    %% *|despace|* : (optional) logical flag stating if whitespace characters |' '|%     should be removed from the strings (where |ISSPACE| returns |true|);%     note moreover that leading and trailing whitespace characters are %     automatically removed (using |STRTRIM|); default: |despace=false|.%% *|sensitive|* : (optional) boolean flag defining is the comparison is case%     sensitive (|true|, then use |STRCNCMP|) or not (|false|, then use %     |STRNCMPI| instead); default: |sensitive=true|.%%% Outputs% *|C|* : output cell (or array, depending on the class of the input |S|)%     of strings where the substrings of |S| have been removed following the%     rule defined by |traversal| and |despace|; note that |C| is ordered %     according to the length of its strings.%     % *|I|* : indices (referring to the input |S|) of the strings present in the %     output.%     %% Example%  a=['fout  ';'piut  ';'pout  ';'meu g ';'meugh ';'tuipl ';  'foutre'];%  [c,i] = cellstrsubtrim(a)%  [c,i] = cellstrsubtrim(a,1)%  [c,i] = cellstrsubtrim(a,-1,true)%  [c,i] = cellstrsubtrim(a,0,true)%  a={ ['fout'] ['piut  ']' ['po ut'] ['meu g '] ['   meugh ']' ['tuipl '] ['fou  tre']}%  [c,i] = cellstrsubtrim(a,1,true)%  [c,i] = cellstrsubtrim(a,0,true)%  % both examples should return identical outputs when setting traversal=0 %  % and despace=true%%% Credit% <mailto:grazzja@lanl.gov J.Grazzini> (ISR-2/LANL)%%% See also% Related:% <../algebra/CELLNUMSUBTRIM.html |CELLNUMSUBTRIM|>.% Called:% <matlab:webpub(whichpath('TRIL')) |TRIL|>,% <matlab:webpub(whichpath('STRNCMP')) |STRNCMP|>,% <matlab:webpub(whichpath('STRNCMPI')) |STRNCMPI|>,% <matlab:webpub(whichpath('STRTRIM')) |STRTRIM|>,% <matlab:webpub(whichpath('ISSPACE')) |ISSPACE|>,% <matlab:webpub(whichpath('CELLSTR')) |CELLSTR|>,% <matlab:webpub(whichpath('CELL2MAT')) |CELL2MAT|>,% <matlab:webpub(whichpath('CELLFUN')) |CELLFUN|>,% <matlab:webpub(whichpath('RESHAPE')) |RESHAPE|>.%% Function implementation%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction [C, I] = cellstrsubtrim(C, traversal, despace, sensitive)%%% check/set variablesif ~iscellstr(C)    if ~ischar(C)        error('cellstrsubtrim:errorinput', ...            'input variable ''C'' must be a string array or a cell of strings');    end    isarray = true;    C = cellstr(C);else     isarray = false;endif nargin<4,  sensitive = true;    if nargin<3,  despace = false;        if nargin<2,  traversal = 0;  end    endendif ~(islogical(despace) && islogical(sensitive))    error('cellstrsubtrim:errorinput', ...        'input variables ''sensitive'' and ''despace'' must be logical');elseif ~isscalar(traversal) || ~ismember(traversal,[0 1 -1])    error('cellstrsubtrim:errorinput', ...        'input variable ''traversal'' takes values in {-1,0,1}');endnC = numel(C); ind = (1:nC);if nC==1 % if one string only, nothing to do    if isarray,  C = char(C);  end    return;endif sensitive,  strcompare = @strncmp;else           strcompare = @strncmpi;end%%% we need to ensure that the strings are 'row strings'...iscol = cellfun(@(c) size(c,1)>1, C);if any(iscol),  C(iscol) = cellfun(@transpose, C(iscol), 'Uniform', false);  end%%% clean up a bit: first deblank (remove leading and trailing whitespace% characters from string, not optional), then possibly'despace' (trim all% internal whitespaces)C = cellfun(@strtrim, C, 'Uniform', false); if despace,  C = cellfun(@(c) c(~isspace(c)), C, 'Uniform', false);  end%%% in general, get rid of empty stringsI = cellfun(@isempty, C);% updateif any(I),  C(I) = [];  iscol(I) = [];  ind(I) = [];  nC = numel(C);  end%%% checkif nC==1  % nothing more to do    if any(iscol),  C(iscol) = cellfun(@transpose, C(iscol), 'Uniform', false);  end    if isarray,  C = char(C);  end    return;end%%% sort the strings according to their (increasing) length[~,I] = sort(cellfun(@length,C));  C = C(I);  ind = ind(I);  iscol = iscol(I);%%% build the cell of inverted stringsif traversal<=0    flipC = cellfun(@(c) fliplr(c), C, 'Uniform', false);endif traversal==1    I = cellfun(@(c) strcompare(c, C, length(c)), C, 'Uniform', false);elseif traversal==-1    I = cellfun(@(flipc) strcompare(flipc, flipC, length(flipc)), ...        flipC, 'Uniform', false);else    I = cellfun(@(c,flipc) ...        strcompare(c, C, length(c)) | strcompare(flipc, C, length(c)) | ...        strcompare(c, flipC, length(c)) | strcompare(flipc, flipC, length(c)), ...        C, flipC, 'Uniform', false);    % note that, in its first occurence, C is used as a constant (and,    % similarly, flipC), so that every single string of C (second occurrence)    % is compared with every other stringsendI = reshape(transpose(cell2mat(I)),[nC nC]); % square matrix %%% retrieve the lower triangular part of the diagonal; we do not want the% diagonal as it is always true (the substring is compared with itself) and% we do not want the upper triangular part as it means that two substrings% are equal (considering that the strings were initially ordered according% to their length) and one of them only (but not both) should be discardedI = tril(I,-1) ;%%% find the strings that are substrings of longer strings already in C: they% are repeated entries given by the indices of the non null columns of I[~,I] = find(I); I = unique(I);%%% clean up: get rid of those substrings and reconvert back to the original% formatif any(I),  C(I) = []; iscol(I) = [];  ind(I) = [];  endif any(iscol),  C(iscol) = cellfun(@transpose, C(iscol), 'Uniform', false);  endI = ind;%%% possibly reconvert back to a matrixif isarray,  C = char(C);  endend % end of cellstrsubtrim##### SOURCE END #####-->  </body></html>