<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html>  <head>    <meta content="text/html; charset=utf-8" http-equiv="content-type">    <!--This HTML was auto-generated from MATLAB code.To make changes, update the MATLAB code and republish this document.      -->    <title>GSTDECOMP - Eigen decomposition of a tensor field.</title>    <meta name="generator" content="MATLAB 7.11">    <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">    <meta name="DC.date" content="2011-07-08">    <meta name="DC.source" content="gstdecomp.m">    <style type="text/css">body {  background-color: white;  margin:10px;}h1 {  color: #990000;   font-size: x-large;}h2 {  color: #990000;  font-size: medium;}/* Make the text shrink to fit narrow windows, but not stretch too far in wide windows. */ p,h1,h2,div.content div {  max-width: 600px;  /* Hack for IE6 */  width: auto !important; width: 600px;}pre.codeinput {  background: #EEEEEE;  padding: 10px;}@media print {  pre.codeinput {word-wrap:break-word; width:100%;}} span.keyword {color: #0000FF}span.comment {color: #228B22}span.string {color: #A020F0}span.untermstring {color: #B20000}span.syscmd {color: #B28C00}pre.codeoutput {  color: #666666;  padding: 10px;}pre.error {  color: red;}p.footer {  text-align: right;  font-size: xx-small;  font-weight: lighter;  font-style: italic;  color: gray;}  </style>  </head>  <body>    <div class="content">      <h1>GSTDECOMP - Eigen decomposition of a tensor field.</h1>      <!--introduction--><!--/introduction-->      <h2>Contents</h2>      <div>        <ul>          <li><a href="#1">Description</a></li>          <li><a href="#2">Syntax</a></li>          <li><a href="#3">Remarks</a></li>          <li><a href="#4">Credit</a></li>          <li><a href="#5">See also</a></li>          <li><a href="#6">Function implementation</a></li>          <li><a href="#17">Subfunction</a></li>        </ul>      </div>      <h2>Description<a name="1"></a></h2>      <p>Perform the eigen decomposition of a (symmetric) tensor field given by        its entries, or the reconstruction of a tensor field given by its eigen-        decomposition and/or orientation.</p>      <h2>Syntax<a name="2"></a></h2>      <div>        <ul>          <li>Eigen decomposition of the tensor (2, 4 or 5 ouput parameters):</li>        </ul>      </div>      <pre>     [l1,l2] = GSTDECOMP(gx2, gy2, gxy);     [l1,l2,e1,e2] = GSTDECOMP(gx2, gy2, gxy);     [l1,l2,e1,e2,theta] = GSTDECOMP(gx2, gy2, gxy, dblangle);     [l1,l2,e1,e2] = GSTDECOMP(T);     [l1,l2,e1,e2,theta] = GSTDECOMP(T, dblangle);</pre>      <div>        <ul>          <li>Tensor reconstruction (1 or 3 output parameters):</li>        </ul>      </div>      <pre>     [gx2, gy2, gxy] = GSTDECOMP(l1,l2,e1,e2);     T = GSTDECOMP(l1,l2,e1,e2);     [gx2, gy2, gxy] = GSTDECOMP(l1,l2,theta);     T = GSTDECOMP(T, theta);</pre>      <h2>Remarks<a name="3"></a></h2>      <div>        <ul>          <li><tt>dblangle</tt> is a logical flag specifying if theta is given            by the double angle representation or not; default: <tt>dblangle=false</tt>.</li>        </ul>      </div>      <div>        <ul>          <li><tt>e1(i,j,:)</tt> : main eigenvector at location <tt>(i,j)</tt>            in the image associated with the largest eigenvalue <tt>l1(i,j)</tt>;            its x- and y- components are stored in the 1st and 2nd indices of            the 3rd dimension.</li>        </ul>      </div>      <div>        <ul>          <li><tt>e2(i,j,:)</tt> : ibid for second eigenvector at location <tt>(i,j)</tt>            associated with the smallest eigenvalue <tt>l2(i,j)</tt>.</li>        </ul>      </div>      <div>        <ul>          <li>We always have <tt>l1&gt;=l2</tt> (not in absolute value            however).</li>        </ul>      </div>      <p>See Kroon's derivatives library and Koethe's VIGRA library (avaialble        at <a href="http://hci.iwr.uni-heidelberg.de/vigra/doc/vigra/group__TensorImaging.html">http://hci.iwr.uni-heidelberg.de/vigra/doc/vigra/group__TensorImaging.html</a>,        <a href="http://hci.iwr.uni-heidelberg.de/vigra/doc/vigra/tensorutilities_8hxx-source.html%29">http://hci.iwr.uni-heidelberg.de/vigra/doc/vigra/tensorutilities_8hxx-source.html)</a>.</p>      <h2>See also<a name="5"></a></h2>      <p>Related: <a href="GSTSMOOTH.html"><tt>GSTSMOOTH</tt></a>, <a href="EIGENDECOMP2X2SYM.html"><tt>EIGENDECOMP2X2SYM</tt></a>.</p>      <h2>Function implementation<a name="6"></a></h2>      <pre class="codeinput"><span class="keyword">function</span> [out,varargout] = gstdecomp(in, varargin)</pre>      <p>parsing parameters</p>      <pre class="codeinput">error(nargchk(1, 4, nargin, <span class="string">'struct'</span>));error(nargoutchk(1, 5, nargout, <span class="string">'struct'</span>));</pre>      <p>calculation</p>      <pre class="codeinput"><span class="keyword">if</span> (nargout==1 &amp;&amp; nargin&gt;1) || nargout==3</pre>      <div>        <ul>          <li>tensor reconstruction</li>        </ul>      </div>      <pre class="codeinput">    <span class="keyword">switch</span> nargin        <span class="keyword">case</span> 2 <span class="comment">% new tensor from tensor entries and orientation</span>            [l1,l2] = gstdecomp(in);            [gx2, gy2, gxy] = gstrecomp(l1, l2, varargin{1});        <span class="keyword">case</span> 3 <span class="comment">% new tensor from eigenvalues and orientation</span>            l1 = in; l2 = varargin{1};            [gx2, gy2, gxy] = gstrecomp(l1, l2, varargin{2});        <span class="keyword">case</span> 4 <span class="comment">% tensor entries from eigen decomposition</span>            l1 = in;     l2 = varargin{1};            [gx2, gy2, gxy] = gstrecomp(l1, l2, varargin{2}, varargin{3});    <span class="keyword">end</span>    <span class="keyword">switch</span> nargout        <span class="keyword">case</span> 1            out(:,:,1,1) = gx2;            out(:,:,2,2) = gy2;            out(:,:,1,2) = gxy;            out(:,:,2,1) = out(:,:,1,2);        <span class="keyword">case</span> 3            out = gx2;            varargout{1} = gy2;            varargout{2} = gxy;    <span class="keyword">end</span></pre>      <pre class="codeinput"><span class="keyword">elseif</span> (nargin==1&amp;&amp;nargout==1) || nargout==2 || nargout&gt;=4</pre>      <div>        <ul>          <li>eigen decomposition of the tensor</li>        </ul>      </div>      <pre class="codeinput">    dbleangle = false;    <span class="comment">% tensor entries</span>    <span class="keyword">switch</span> nargin        <span class="keyword">case</span> {1,2} <span class="comment">% the tensor has been passed</span>            gy2 = in(:,:,2,2);            gxy = in(:,:,1,2);            gx2 = in(:,:,1,1);            <span class="keyword">if</span> nargin==2, dbleangle = varargin{1};  <spanclass="keyword">end</span>        <span class="keyword">case</span> {3,4}            gx2 = in;            gy2 = varargin{1};            gxy = varargin{2};            <span class="keyword">if</span> nargin==4, dbleangle = varargin{3};  <spanclass="keyword">end</span>    <span class="keyword">end</span>    <span class="comment">% set the method used for estimating the eigenvectors</span>    <span class="keyword">if</span> dbleangle,   method = <span class="string">'koe'</span>;  <spanclass="comment">% 'kro'</span>    <span class="keyword">else</span>            method = <span class="string">'pey'</span>;    <span class="keyword">end</span></pre>      <p><i>(i)</i> compute the eigenvalues</p>      <pre class="codeinput">    <span class="keyword">if</span> any(strcmpi(method,{<spanclass="string">'koe'</span>,<spanclass="string">'kro'</span>}))        <span class="comment">% VIGRA expression: see file tensorutilities.hxx, function</span>        <span class="comment">% tensorEigenRepresentation</span>        <span class="comment">% Kroon expression: see file EigenVectors2D.m</span>        d1 = gx2 + gy2; <span class="comment">%src.getComponent(s,0) + src.getComponent(s,2);</span>        d2 = gx2 - gy2; <span class="comment">%src.getComponent(s,0) - src.getComponent(s,2);</span>        d3 = 2 * gxy;   <span class="comment">%2.0 * src.getComponent(s,1);</span>        d4 = sqrt(d2.^2 + d3.^2); <span class="comment">% hypot(d2, d3)</span>        <span class="comment">% root = d4;</span>        l1 = 0.5 * (d1+d4); <span class="comment">%dest.setComponent(0.5 * (d1 + d4), d, 0);</span>        l2 = 0.5 * (d1-d4); <span class="comment">%dest.setComponent(0.5 * (d1 - d4), d, 1);</span>    <span class="keyword">elseif</span> strcmpi(method,<span class="string">'pey'</span>)        <span class="comment">% another expression for eigenvalues</span>        t = 0.5 * (gx2+gy2);     <span class="comment">% trace/2</span>        a = gx2 - t;  <span class="comment">% a = 0.5 * (gx2-gy2);</span>        ab2 = sqrt(a.^2 + gxy.^2); <span class="comment">% we have root = 2 * ab2; (see above)</span>        l1 = t + ab2;        l2 = t - ab2;    <span class="keyword">end</span>    out = l1;    varargout{1} = l2;</pre>      <p><i>(ii)</i> compute the eigenvectors</p>      <pre class="codeinput">    <span class="keyword">if</span> nargout&gt;2        <span class="keyword">if</span> strcmpi(method,<span class="string">'koe'</span>)            <span class="comment">% double angle representation: theta in [-pi/2,pi/2]</span>            <span class="comment">%    %theta = gstfeature(gx2, gy2, gxy, 'orient');</span>            theta = 0.5 * atan2(d3, d2);            <span class="comment">%dest.setComponent(0.5 * VIGRA_CSTD::atan2(d3, d2), d, 2);</span>            <span class="comment">% note: atan2(0,0)=0</span>            <span class="comment">% principal eigen vector</span>            e1(:,:,1) = cos(theta);            e1(:,:,2) = sin(theta);        <span class="keyword">elseif</span> strcmpi(method,<span class="string">'pey'</span>)            <span class="comment">% atan2 expression for orientation: atan2(l1-gx2,gxy)</span>            theta = atan2( ab2-a, gxy );            e1(:,:,1) = cos(theta);            e1(:,:,2) = sin(theta);        <span class="keyword">elseif</span> strcmpi(method,<span class="string">'kro'</span>)            <span class="comment">% note: no theta computed here</span>            vx = d3;            vy = d4 - d2;            mag = sqrt(vx.^2 + vy.^2);            i = (mag ~= 0);            vx(i) = vx(i)./mag(i);            vy(i) = vy(i)./mag(i);            e1(:,:,1) = vx;            e1(:,:,2) = vy;        <span class="keyword">end</span>        <span class="comment">%  eigenvectors are orthogonal</span>        e2(:,:,1) = -e1(:,:,2);        e2(:,:,2) = e1(:,:,1);        varargout{2} = e1;        varargout{3} = e2;        <span class="keyword">if</span> nargout==5, varargout{4} = theta;  <spanclass="keyword">end</span>    <span class="keyword">end</span></pre>      <pre class="codeinput"><span class="keyword">end</span></pre>      <pre class="codeinput"><span class="keyword">end</span> <span class="comment">% end of gstdecomp</span></pre>      <h2>Subfunction<a name="17"></a></h2>      <p><tt>GSTRECOMP</tt> - Compute the entries of the (symmetric) tensor        field which corresponds to the given eigendecomposition.</p>      <p><tt>e1(i,j,:)</tt> is the main eigenvector at location <tt>(i,j)</tt>        with associated largest eigenvalue <tt>l1(i,j)</tt>. <tt>e2(i,j,:)</tt>        is the second eigenvector at location <tt>(i,j)</tt> with associated        smallest eigenvalue <tt>l2(i,j)</tt>.</p>      <p>Regarding the GST, we have: <img src="gstdecomp_eq06115.png" alt="$T = l_1 e_1 \dot e_1' + l_2 e_2 \dot e_2'$"></p>      <pre class="codeinput"><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> [gx2, gy2, gxy] = gstrecomp(l1,l2,e1,varargin)<span class="keyword">switch</span> nargin    <span class="keyword">case</span> 3        <span class="comment">% then the orientation has been passed</span>        theta = e1;        e1(:,:,1) = cos(theta);        e1(:,:,2) = sin(theta);        e2(:,:,1) = -e1(:,:,2);        e2(:,:,2) = e1(:,:,1);    <span class="keyword">case</span> 4        <span class="comment">% both eigenvectors have been passed</span>        e2 = varargin{1};<span class="keyword">end</span>gx2 = l1.*e1(:,:,1).^2 + l2.*e2(:,:,1).^2;gxy = l1.*e1(:,:,1).*e1(:,:,2) + l2.*e2(:,:,1).*e2(:,:,2);gy2 = l1.*e1(:,:,2).^2 + l2.*e2(:,:,2).^2;<span class="keyword">end</span></pre></div>    <!--##### SOURCE BEGIN #####%% GSTDECOMP - Eigen decomposition of a tensor field.%%% Description% Perform the eigen decomposition of a (symmetric) tensor field given by its% entries, or the reconstruction of a tensor field given by its eigen-% decomposition and/or orientation. %%% Syntax% * Eigen decomposition of the tensor (2, 4 or 5 ouput parameters):%%       [l1,l2] = GSTDECOMP(gx2, gy2, gxy);%       [l1,l2,e1,e2] = GSTDECOMP(gx2, gy2, gxy);%       [l1,l2,e1,e2,theta] = GSTDECOMP(gx2, gy2, gxy, dblangle);%       [l1,l2,e1,e2] = GSTDECOMP(T);%       [l1,l2,e1,e2,theta] = GSTDECOMP(T, dblangle);% % * Tensor reconstruction (1 or 3 output parameters):%%       [gx2, gy2, gxy] = GSTDECOMP(l1,l2,e1,e2);%       T = GSTDECOMP(l1,l2,e1,e2);%       [gx2, gy2, gxy] = GSTDECOMP(l1,l2,theta);%       T = GSTDECOMP(T, theta);% %% Remarks% * |dblangle| is a logical flag specifying if theta is given by the double% angle representation or not; default: |dblangle=false|.%% * |e1(i,j,:)| : main eigenvector at location |(i,j)| in the image associated%    with the largest eigenvalue |l1(i,j)|; its x- and y- components are stored%    in the 1st and 2nd indices of the 3rd dimension.% % * |e2(i,j,:)| : ibid for second eigenvector at location |(i,j)| associated %    with the smallest eigenvalue |l2(i,j)|.%% * We always have |l1>=l2| (not in absolute value however).%% See Kroon's derivatives library and Koethe's VIGRA library (avaialble at% http://hci.iwr.uni-heidelberg.de/vigra/doc/vigra/group__TensorImaging.html,% http://hci.iwr.uni-heidelberg.de/vigra/doc/vigra/tensorutilities_8hxx-source.html).%%% Credit% <mailto:grazzja@lanl.gov J.Grazzini> (ISR-2/LANL)%%% See also  % Related:% <GSTSMOOTH.html |GSTSMOOTH|>,% <EIGENDECOMP2X2SYM.html |EIGENDECOMP2X2SYM|>.%% Function implementationfunction [out,varargout] = gstdecomp(in, varargin)%% % parsing parameterserror(nargchk(1, 4, nargin, 'struct'));error(nargoutchk(1, 5, nargout, 'struct'));%% % calculation if (nargout==1 && nargin>1) || nargout==3    %%    % * tensor reconstruction        switch nargin        case 2 % new tensor from tensor entries and orientation            [l1,l2] = gstdecomp(in);            [gx2, gy2, gxy] = gstrecomp(l1, l2, varargin{1});                    case 3 % new tensor from eigenvalues and orientation            l1 = in; l2 = varargin{1};            [gx2, gy2, gxy] = gstrecomp(l1, l2, varargin{2});                    case 4 % tensor entries from eigen decomposition            l1 = in;     l2 = varargin{1};            [gx2, gy2, gxy] = gstrecomp(l1, l2, varargin{2}, varargin{3});    end        switch nargout        case 1            out(:,:,1,1) = gx2;            out(:,:,2,2) = gy2;            out(:,:,1,2) = gxy;            out(:,:,2,1) = out(:,:,1,2);                    case 3            out = gx2;            varargout{1} = gy2;            varargout{2} = gxy;    end        elseif (nargin==1&&nargout==1) || nargout==2 || nargout>=4        %%    % * eigen decomposition of the tensor        dbleangle = false;        % tensor entries    switch nargin        case {1,2} % the tensor has been passed            gy2 = in(:,:,2,2);            gxy = in(:,:,1,2);            gx2 = in(:,:,1,1);            if nargin==2, dbleangle = varargin{1};  end                        case {3,4}            gx2 = in;            gy2 = varargin{1};            gxy = varargin{2};            if nargin==4, dbleangle = varargin{3};  end    end        % set the method used for estimating the eigenvectors    if dbleangle,   method = 'koe';  % 'kro'    else            method = 'pey';    end        %%    % _(i)_ compute the eigenvalues    if any(strcmpi(method,{'koe','kro'}))        % VIGRA expression: see file tensorutilities.hxx, function        % tensorEigenRepresentation        % Kroon expression: see file EigenVectors2D.m        d1 = gx2 + gy2; %src.getComponent(s,0) + src.getComponent(s,2);        d2 = gx2 - gy2; %src.getComponent(s,0) - src.getComponent(s,2);        d3 = 2 * gxy;   %2.0 * src.getComponent(s,1);        d4 = sqrt(d2.^2 + d3.^2); % hypot(d2, d3)        % root = d4;        l1 = 0.5 * (d1+d4); %dest.setComponent(0.5 * (d1 + d4), d, 0);         l2 = 0.5 * (d1-d4); %dest.setComponent(0.5 * (d1 - d4), d, 1);        elseif strcmpi(method,'pey')        % another expression for eigenvalues        t = 0.5 * (gx2+gy2);     % trace/2        a = gx2 - t;  % a = 0.5 * (gx2-gy2);        ab2 = sqrt(a.^2 + gxy.^2); % we have root = 2 * ab2; (see above)        l1 = t + ab2;        l2 = t - ab2;            end    out = l1;    varargout{1} = l2;        %%    % _(ii)_ compute the eigenvectors    if nargout>2                if strcmpi(method,'koe')            % double angle representation: theta in [-pi/2,pi/2]            %    %theta = gstfeature(gx2, gy2, gxy, 'orient');            theta = 0.5 * atan2(d3, d2);            %dest.setComponent(0.5 * VIGRA_CSTD::atan2(d3, d2), d, 2);            % note: atan2(0,0)=0            % principal eigen vector            e1(:,:,1) = cos(theta);            e1(:,:,2) = sin(theta);                    elseif strcmpi(method,'pey')            % atan2 expression for orientation: atan2(l1-gx2,gxy)            theta = atan2( ab2-a, gxy );            e1(:,:,1) = cos(theta);            e1(:,:,2) = sin(theta);                    elseif strcmpi(method,'kro')            % note: no theta computed here            vx = d3;            vy = d4 - d2;            mag = sqrt(vx.^2 + vy.^2);            i = (mag ~= 0);            vx(i) = vx(i)./mag(i);            vy(i) = vy(i)./mag(i);                        e1(:,:,1) = vx;            e1(:,:,2) = vy;        end                %  eigenvectors are orthogonal        e2(:,:,1) = -e1(:,:,2);        e2(:,:,2) = e1(:,:,1);                varargout{2} = e1;        varargout{3} = e2;        if nargout==5, varargout{4} = theta;  end            endendend % end of gstdecomp%% Subfunction%%% |GSTRECOMP| - Compute the entries of the (symmetric) tensor field which % corresponds to the given eigendecomposition. %% |e1(i,j,:)| is the main eigenvector at location |(i,j)| with associated%       largest eigenvalue |l1(i,j)|.% |e2(i,j,:)| is the second eigenvector at location |(i,j)| with associated%        smallest eigenvalue |l2(i,j)|.%% Regarding the GST, we have:  $T = l_1 e_1 \dot e_1' + l_2 e_2 \dot e_2'$%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction [gx2, gy2, gxy] = gstrecomp(l1,l2,e1,varargin)switch nargin    case 3        % then the orientation has been passed        theta = e1;        e1(:,:,1) = cos(theta);        e1(:,:,2) = sin(theta);        e2(:,:,1) = -e1(:,:,2);        e2(:,:,2) = e1(:,:,1);            case 4        % both eigenvectors have been passed        e2 = varargin{1};endgx2 = l1.*e1(:,:,1).^2 + l2.*e2(:,:,1).^2;gxy = l1.*e1(:,:,1).*e1(:,:,2) + l2.*e2(:,:,1).*e2(:,:,2);gy2 = l1.*e1(:,:,2).^2 + l2.*e2(:,:,2).^2;end##### SOURCE END #####-->  </body></html>