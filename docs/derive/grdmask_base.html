<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html>  <head>    <meta content="text/html; charset=utf-8" http-equiv="content-type">    <!--This HTML was auto-generated from MATLAB code.To make changes, update the MATLAB code and republish this document.      -->    <title>GRDMASK_BASE - Base function for GRDMASK.</title>    <meta name="generator" content="MATLAB 7.11">    <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">    <meta name="DC.date" content="2011-07-08">    <meta name="DC.source" content="grdmask_base.m">    <style type="text/css">body {  background-color: white;  margin:10px;}h1 {  color: #990000;   font-size: x-large;}h2 {  color: #990000;  font-size: medium;}/* Make the text shrink to fit narrow windows, but not stretch too far in wide windows. */ p,h1,h2,div.content div {  max-width: 600px;  /* Hack for IE6 */  width: auto !important; width: 600px;}pre.codeinput {  background: #EEEEEE;  padding: 10px;}@media print {  pre.codeinput {word-wrap:break-word; width:100%;}} span.keyword {color: #0000FF}span.comment {color: #228B22}span.string {color: #A020F0}span.untermstring {color: #B20000}span.syscmd {color: #B28C00}pre.codeoutput {  color: #666666;  padding: 10px;}pre.error {  color: red;}p.footer {  text-align: right;  font-size: xx-small;  font-weight: lighter;  font-style: italic;  color: gray;}  </style>  </head>  <body>    <div class="content">      <h1>GRDMASK_BASE - Base function for GRDMASK.</h1>      <!--introduction--><!--/introduction-->      <h2>Contents</h2>      <div>        <ul>          <li><a href="#1">Syntax</a></li>          <li><a href="#2">Credit</a></li>          <li><a href="#3">See also</a></li>          <li><a href="#4">Function implementation</a></li>          <li><a href="#9">Subfunction</a></li>        </ul>      </div>      <h2>Syntax<a name="1"></a></h2>      <pre> [Gx,Gy] = GRDMASK_BASE(I, method, oaxis)</pre>      <h2>See also<a name="3"></a></h2>      <p>Related: <a href="GRDMASK.html"><tt>GRDMASK</tt></a>, <a href="GRDMASKMAP_BASE.html"><tt>GRDMASKMAP_BASE</tt></a>.        Called: <a href="matlab:webpub%28whichpath%28%27DERGRADIVATIVES%27%29%29"><tt>GRAD</tt></a>,        <a href="matlab:webpub%28whichpath%28%27FSPECIAL%27%29%29"><tt>FSPECIAL</tt></a>,        <a href="matlab:webpub%28whichpath%28%27IMFILTER%27%29%29"><tt>IMFILTER</tt></a>,        <a href="matlab:webpub%28whichpath%28%27GRADIENT%27%29%29"><tt>GRADIENT</tt></a>.</p>      <h2>Function implementation<a name="4"></a></h2>      <pre class="codeinput"><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> [Gx,Gy] = grdmask_base(I, method, oaxis)</pre>      <p>dealing with multispectral image</p>      <pre class="codeinput">C = size(I,3);<span class="keyword">if</span> C&gt;1    Gx = zeros(size(I));    Gy = zeros(size(I));    <span class="keyword">for</span> ic=1:C        [Gx(:,:,ic), Gy(:,:,ic)] = grdmask_base(I(:,:,ic), method, oaxis);    <span class="keyword">end</span>    <span class="keyword">return</span><span class="keyword">end</span></pre>      <p>main computation</p>      <pre class="codeinput"><span class="keyword">switch</span> method    <span class="comment">% define the directional masks</span>    <span class="keyword">case</span> {<span class="string">'sobel'</span>, <spanclass="string">'sob'</span>}        Mx = -fspecial(<span class="string">'sobel'</span>); <span class="comment">% [-1 -2 -1; 0 0 0; 1 2 1]</span>    <span class="keyword">case</span> {<span class="string">'prewitt'</span>, <spanclass="string">'prew'</span>}        Mx = -fspecial(<span class="string">'prewitt'</span>);  <span class="comment">% [-1 -1 -1; 0 0 0; 1 1 1]</span>    <span class="keyword">case</span> {<span class="string">'kirsch'</span>, <spanclass="string">'kir'</span>}        Mx = [-5 -5 -5; 3 0 3; 3 3 3];    <span class="keyword">case</span> {<span class="string">'robinson'</span>, <spanclass="string">'rob'</span>}        Mx = [-1 -1 -1; 1 -2 1; 1 1 1];    <span class="keyword">case</span> {<span class="string">'circular'</span>, <spanclass="string">'circ'</span>}        Mx = [-0.464 -0.959 -0.464; 0 0 0; 0.464 0.959 0.464];    <span class="keyword">case</span> {<span class="string">'optimal'</span>, <spanclass="string">'opt'</span>}        Mx = [-0.112737 -0.274526 -0.112737; 0 0 0; 0.112737 0.274526 0.112737];    <span class="keyword">case</span> {<span class="string">'orientation'</span>, <spanclass="string">'ori'</span>} <spanclass="comment">% optimal filter for orientation</span>        Mx = [-0.0938 -0.3125 -0.0938; 0 0 0; 0.0938 0.3125 0.0938];    <span class="keyword">case</span> {<span class="string">'isotropic'</span>, <spanclass="string">'iso'</span>}        Mx = [-1 -sqrt(2) -1; 0 0 0; 1 sqrt(2) 1];    <span class="keyword">case</span> <span class="string">'roberts'</span>        M45 = [1 0; 0 -1]; <span class="comment">% 45 deg edge responses</span>        M135 = [0 1; -1  0]; <span class="comment">% 135 deg edge responses</span>        Mx = M45; My = M135;   <span class="comment">%#ok</span>    <span class="comment">% or compute directly</span>    <span class="keyword">case</span> {<span class="string">'matlab'</span>, <spanclass="string">'diff'</span>, <spanclass="string">'difference'</span>} <spanclass="comment">% central difference</span>        [Gy,Gx] = gradient(I);    <span class="keyword">case</span> {<span class="string">'backward'</span>, <spanclass="string">'back'</span>}        [Gx,Gy] = grad(I, 1, <span class="string">'sym'</span>);        Gx = Gx/2; Gy = Gy/2;    <span class="keyword">case</span> {<span class="string">'forward'</span>, <spanclass="string">'for'</span>}        [Gx,Gy] = grad(I, 2, <span class="string">'sym'</span>);        Gx = Gx/2; Gy = Gy/2;    <span class="keyword">case</span> {<span class="string">'derivative5'</span>, <spanclass="string">'tap5'</span>}        [Gy,Gx] = derivative5(I, <span class="string">'x'</span>, <span class="string">'y'</span>);    <span class="keyword">case</span> {<span class="string">'derivative7'</span>, <spanclass="string">'tap7'</span>}        [Gy,Gx] = derivative7(I, <span class="string">'x'</span>, <span class="string">'y'</span>);<span class="keyword">end</span><span class="keyword">if</span> ~any(strcmpi(method,{<span class="string">'matlab'</span>,<spanclass="string">'diff'</span>,<spanclass="string">'difference'</span>, <spanclass="string">'backward'</span>,<spanclass="string">'back'</span>, <spanclass="keyword">...</span>        <span class="string">'forward'</span>,<span class="string">'for'</span>, <spanclass="string">'derivative5'</span>,<spanclass="string">'tap5'</span>, <spanclass="string">'derivative7'</span>,<spanclass="string">'tap7'</span>}))    <span class="comment">% define the horizontal mask</span>    My = Mx';    <span class="comment">% filter to get the derivatives</span>    Gx = imfilter(I,Mx/sum(sum(abs(Mx))),<span class="string">'replicate'</span>);  <spanclass="comment">% vertical</span>    Gy = imfilter(I,My/sum(sum(abs(My))),<span class="string">'replicate'</span>); <spanclass="comment">% horizontal</span><span class="keyword">end</span><span class="keyword">if</span> strcmpi(oaxis,<span class="string">'xy'</span>)    tmp = Gx; Gx = Gy; Gy = -tmp;<span class="keyword">end</span></pre>      <pre class="codeinput"><span class="keyword">end</span> <span class="comment">% end of grdmask_base</span></pre>      <h2>Subfunction<a name="9"></a></h2>      <p><tt>GRAD</tt> - gradient, forward and backward differences.</p>      <pre>  [fx,fy,fz] = grad(M, order, bound);  bound : 'per' or 'sym'  order : 1 (backward differences) or 2 (forward differences).</pre>      <p>Assumes that the function is evenly sampled with sampling step 1. Note:        the grad operator is <b>minus</b> the transpose of the div operator.</p>      <pre class="codeinput"><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> [fx,fy,fz] = grad(M, order, bound)<span class="comment">% retrieve number of dimensions</span>nbdims = 2;<span class="keyword">if</span> size(M,1)==1 || size(M,2)==1    nbdims = 1;<span class="keyword">end</span><span class="keyword">if</span> size(M,1)&gt;1 &amp;&amp; size(M,2)&gt;1 &amp;&amp; size(M,3)&gt;1    nbdims = 3;<span class="keyword">end</span><span class="keyword">if</span> strcmp(bound, <span class="string">'sym'</span>)    <span class="keyword">if</span> order==1        fx = M([2:end end],:,:)-M;    <span class="keyword">else</span>        fx = ( M([2:end end],:,:)-M([1 1:end-1],:,:) )/2;        <span class="comment">% boundary</span>        fx(1,:,:) = M(2,:,:)-M(1,:,:);        fx(end,:,:) = M(end,:,:)-M(end-1,:,:);    <span class="keyword">end</span>    <span class="keyword">if</span> nbdims&gt;=2        <span class="keyword">if</span> order==1            fy = M(:,[2:end end],:)-M;        <span class="keyword">else</span>            fy = ( M(:,[2:end end],:)-M(:,[1 1:end-1],:) )/2;            <span class="comment">% boundary</span>            fy(:,1,:) = M(:,2,:)-M(:,1,:);            fy(:,end,:) = M(:,end,:)-M(:,end-1,:);        <span class="keyword">end</span>    <span class="keyword">end</span>    <span class="keyword">if</span> nbdims&gt;=3        <span class="keyword">if</span> order==1            fz = M(:,:,[2:end end])-M;        <span class="keyword">else</span>            fz = ( M(:,:,[2:end end])-M(:,:,[1 1:end-1]) )/2;            <span class="comment">% boundary</span>            fz(:,:,1) = M(:,:,2)-M(:,:,1);            fz(:,:,end) = M(:,:,end)-M(:,:,end-1);        <span class="keyword">end</span>    <span class="keyword">end</span><span class="keyword">else</span>    <span class="keyword">if</span> order==1        fx = M([2:end 1],:,:)-M;    <span class="keyword">else</span>        fx = ( M([2:end 1],:,:)-M([end 1:end-1],:,:) )/2;    <span class="keyword">end</span>    <span class="keyword">if</span> nbdims&gt;=2        <span class="keyword">if</span> order==1            fy = M(:,[2:end 1],:)-M;        <span class="keyword">else</span>            fy = ( M(:,[2:end 1],:)-M(:,[end 1:end-1],:) )/2;        <span class="keyword">end</span>    <span class="keyword">end</span>    <span class="keyword">if</span> nbdims&gt;=3        <span class="keyword">if</span> order==1            fz = M(:,:,[2:end 1])-M;        <span class="keyword">else</span>            fz = ( M(:,:,[2:end 1])-M(:,:,[end 1:end-1]) )/2;        <span class="keyword">end</span>    <span class="keyword">end</span><span class="keyword">end</span><span class="keyword">if</span> nargout==1    <span class="keyword">if</span> nbdims==2        fx = cat(3,fx,fy);    <span class="keyword">elseif</span> nbdims==3        fx = cat(4,fx,fy,fz);    <span class="keyword">end</span><span class="keyword">end</span><span class="keyword">end</span></pre></div>    <!--##### SOURCE BEGIN #####%% GRDMASK_BASE - Base function for GRDMASK.% %% Syntax%   [Gx,Gy] = GRDMASK_BASE(I, method, oaxis)%%% Credit% <mailto:grazzja@lanl.gov J.Grazzini> (ISR-2/LANL)%%% See also  % Related:% <GRDMASK.html |GRDMASK|>,% <GRDMASKMAP_BASE.html |GRDMASKMAP_BASE|>.% Called:% <matlab:webpub(whichpath('DERGRADIVATIVES')) |GRAD|>,% <matlab:webpub(whichpath('FSPECIAL')) |FSPECIAL|>,% <matlab:webpub(whichpath('IMFILTER')) |IMFILTER|>,% <matlab:webpub(whichpath('GRADIENT')) |GRADIENT|>.%% Function implementation%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction [Gx,Gy] = grdmask_base(I, method, oaxis)%%% dealing with multispectral imageC = size(I,3);if C>1    Gx = zeros(size(I));    Gy = zeros(size(I));    for ic=1:C        [Gx(:,:,ic), Gy(:,:,ic)] = grdmask_base(I(:,:,ic), method, oaxis);    end    returnend%% % main computationswitch method     % define the directional masks    case {'sobel', 'sob'}        Mx = -fspecial('sobel'); % [-1 -2 -1; 0 0 0; 1 2 1]      case {'prewitt', 'prew'}        Mx = -fspecial('prewitt');  % [-1 -1 -1; 0 0 0; 1 1 1]            case {'kirsch', 'kir'}        Mx = [-5 -5 -5; 3 0 3; 3 3 3];    case {'robinson', 'rob'}        Mx = [-1 -1 -1; 1 -2 1; 1 1 1];    case {'circular', 'circ'}        Mx = [-0.464 -0.959 -0.464; 0 0 0; 0.464 0.959 0.464];            case {'optimal', 'opt'}        Mx = [-0.112737 -0.274526 -0.112737; 0 0 0; 0.112737 0.274526 0.112737];            case {'orientation', 'ori'} % optimal filter for orientation        Mx = [-0.0938 -0.3125 -0.0938; 0 0 0; 0.0938 0.3125 0.0938];            case {'isotropic', 'iso'}        Mx = [-1 -sqrt(2) -1; 0 0 0; 1 sqrt(2) 1];            case 'roberts'        M45 = [1 0; 0 -1]; % 45 deg edge responses        M135 = [0 1; -1  0]; % 135 deg edge responses        Mx = M45; My = M135;   %#ok       % or compute directly       case {'matlab', 'diff', 'difference'} % central difference        [Gy,Gx] = gradient(I);    case {'backward', 'back'}        [Gx,Gy] = grad(I, 1, 'sym');        Gx = Gx/2; Gy = Gy/2;    case {'forward', 'for'}        [Gx,Gy] = grad(I, 2, 'sym');        Gx = Gx/2; Gy = Gy/2;    case {'derivative5', 'tap5'}        [Gy,Gx] = derivative5(I, 'x', 'y');    case {'derivative7', 'tap7'}        [Gy,Gx] = derivative7(I, 'x', 'y');endif ~any(strcmpi(method,{'matlab','diff','difference', 'backward','back', ...        'forward','for', 'derivative5','tap5', 'derivative7','tap7'}))    % define the horizontal mask    My = Mx';        % filter to get the derivatives    Gx = imfilter(I,Mx/sum(sum(abs(Mx))),'replicate');  % vertical    Gy = imfilter(I,My/sum(sum(abs(My))),'replicate'); % horizontalendif strcmpi(oaxis,'xy')    tmp = Gx; Gx = Gy; Gy = -tmp;endend % end of grdmask_base%% Subfunction%%% |GRAD| - gradient, forward and backward differences.%%    [fx,fy,fz] = grad(M, order, bound);%    bound : 'per' or 'sym'%    order : 1 (backward differences) or 2 (forward differences).%% Assumes that the function is evenly sampled with sampling step 1.% Note: the grad operator is *minus* the transpose of the div operator.%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction [fx,fy,fz] = grad(M, order, bound)% retrieve number of dimensionsnbdims = 2;if size(M,1)==1 || size(M,2)==1    nbdims = 1;endif size(M,1)>1 && size(M,2)>1 && size(M,3)>1    nbdims = 3;endif strcmp(bound, 'sym')        if order==1        fx = M([2:end end],:,:)-M;    else        fx = ( M([2:end end],:,:)-M([1 1:end-1],:,:) )/2;        % boundary        fx(1,:,:) = M(2,:,:)-M(1,:,:);        fx(end,:,:) = M(end,:,:)-M(end-1,:,:);    end    if nbdims>=2        if order==1            fy = M(:,[2:end end],:)-M;        else            fy = ( M(:,[2:end end],:)-M(:,[1 1:end-1],:) )/2;            % boundary            fy(:,1,:) = M(:,2,:)-M(:,1,:);            fy(:,end,:) = M(:,end,:)-M(:,end-1,:);        end    end    if nbdims>=3        if order==1            fz = M(:,:,[2:end end])-M;        else            fz = ( M(:,:,[2:end end])-M(:,:,[1 1:end-1]) )/2;            % boundary            fz(:,:,1) = M(:,:,2)-M(:,:,1);            fz(:,:,end) = M(:,:,end)-M(:,:,end-1);        end    endelse    if order==1        fx = M([2:end 1],:,:)-M;    else        fx = ( M([2:end 1],:,:)-M([end 1:end-1],:,:) )/2;    end    if nbdims>=2        if order==1            fy = M(:,[2:end 1],:)-M;        else            fy = ( M(:,[2:end 1],:)-M(:,[end 1:end-1],:) )/2;        end    end    if nbdims>=3        if order==1            fz = M(:,:,[2:end 1])-M;        else            fz = ( M(:,:,[2:end 1])-M(:,:,[end 1:end-1]) )/2;        end    endendif nargout==1    if nbdims==2        fx = cat(3,fx,fy);    elseif nbdims==3        fx = cat(4,fx,fy,fz);    endendend##### SOURCE END #####-->  </body></html>