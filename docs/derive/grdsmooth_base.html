<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html>  <head>    <meta content="text/html; charset=utf-8" http-equiv="content-type">    <!--This HTML was auto-generated from MATLAB code.To make changes, update the MATLAB code and republish this document.      -->    <title>GRDSMOOTH_BASE - BASE function for GRDSMOOTH.</title>    <meta name="generator" content="MATLAB 7.14">    <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">    <meta name="DC.date" content="2012-11-14">    <meta name="DC.source" content="grdsmooth_base.m">    <style type="text/css">html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}html { min-height:100%; margin-bottom:1px; }html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }html body td { vertical-align:top; text-align:left; }h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }a { color:#005fce; text-decoration:none; }a:hover { color:#005fce; text-decoration:underline; }a:visited { color:#004aa0; text-decoration:none; }p { padding:0px; margin:0px 0px 20px; }img { padding:0px; margin:0px 0px 20px; border:none; }p img, pre img, tt img, li img { margin-bottom:0px; } ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }ul li { padding:0px; margin:0px 0px 7px 0px; }ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }ul li ol li { list-style:decimal; }ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }ol li ol li { list-style-type:lower-alpha; }ol li ul { padding-top:7px; }ol li ul li { list-style:square; }.content { font-size:1.2em; line-height:140%; padding: 20px; }pre, tt, code { font-size:12px; }pre { margin:0px 0px 20px; }pre.error { color:red; }pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }span.keyword { color:#0000FF }span.comment { color:#228B22 }span.string { color:#A020F0 }span.untermstring { color:#B20000 }span.syscmd { color:#B28C00 }.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }.footer p { margin:0px; }  </style>  </head>  <body>    <div class="content">      <h1>GRDSMOOTH_BASE - BASE function for GRDSMOOTH.</h1>      <!--introduction--><!--/introduction-->      <h2>Contents</h2>      <div>        <ul>          <li><a href="#1">Syntax</a></li>          <li><a href="#2">Acknowledgment</a></li>          <li><a href="#3">Remarks</a></li>          <li><a href="#5">See also</a></li>          <li><a href="#6">Function implementation</a></li>          <li><a href="#12">Subfunctions</a></li>        </ul>      </div>      <h2>Syntax<a name="1"></a></h2>      <pre>    [gx, gy] = GRDSMOOTH_BASE(I, sigma, der, hsize, axis);    [gx, gy, mag, or] = GRDSMOOTH_BASE(I, sigma, der, hsize, axis);</pre>      <h2>Acknowledgment<a name="2"></a></h2>      <p>This function is a copy/paste and crop of several proposed functions        implemented for smoothing and differentiation following Canny's        principles.</p>      <h2>Remarks<a name="3"></a></h2>      <div>        <ul>          <li>See C.Luengo discussion on Gaussian filtering and Gaussian            derivation: <a href="http://www.cb.uu.se/%7Ecris/blog/index.php/archives/22">http://www.cb.uu.se/~cris/blog/index.php/archives/22</a>            <a href="http://www.cb.uu.se/%7Ecris/blog/index.php/archives/150#more-150">http://www.cb.uu.se/~cris/blog/index.php/archives/150#more-150</a></li>        </ul>      </div>      <div>        <ul>          <li>See P.Kovesi toolbox on improvements for local gradient            estimation: <a href="http://www.csse.uwa.edu.au/%7Epk/Research/MatlabFns/">http://www.csse.uwa.edu.au/~pk/Research/MatlabFns/</a></li>        </ul>      </div>      <h2>See also<a name="5"></a></h2>      <p>Related: <a href="grdsmooth.html"><tt>GRDSMOOTH</tt></a>. Called: <a          href="../kernel/gausskernel.html"><tt>GAUSSKERNEL</tt></a>,        <a href="../filter/convolution.html"><tt>CONVOLUTION</tt></a>, <a          href="matlab:webpub%28whichpath%28%27DERIVATIVES%27%29%29"><tt>DERIVATIVES</tt></a>,        <a href="matlab:webpub%28whichpath%28%27IMGAUSSIAN%27%29%29"><tt>IMGAUSSIAN</tt></a>,        <a href="matlab:webpub%28whichpath%28%27FSPECIAL%27%29%29"><tt>FSPECIAL</tt></a>,        <a href="matlab:webpub%28whichpath%28%27IMFILTER%27%29%29"><tt>IMFILTER</tt></a>,        <a href="matlab:webpub%28whichpath%28%27FILTER2%27%29%29"><tt>FILTER2</tt></a>,        <a href="matlab:webpub%28whichpath%28%27GRADIENT%27%29%29"><tt>GRADIENT</tt></a>.</p>      <h2>Function implementation<a name="6"></a></h2>      <pre class="codeinput"><span class="keyword">function</span> [gx,gy,varargout] = grdsmooth_base(I, sigma, der, hsize, axis)</pre>      <p>dealing with multispectral images</p>      <pre class="codeinput">C = size(I,3);<span class="keyword">if</span> C&gt;1    gx = zeros(size(I)); gy = zeros(size(I));    <span class="keyword">for</span> i=1:nargout-2        varargout{i} = zeros(size(I));    <span class="keyword">end</span>    <span class="keyword">for</span> c=1:C        [gx(:,:,c) gy(:,:,c), tmpmag, tmpor] = <span class="keyword">...</span>                grdsmooth_base(I(:,:,c), sigma, der, hsize, axis);        <span class="keyword">if</span> nargout&gt;=3,  varargout{1}(:,:,c) = tmpmag;  <spanclass="keyword">end</span>        <span class="keyword">if</span> nargout==4,  varargout{2}(:,:,c) = tmpor;  <spanclass="keyword">end</span>    <span class="keyword">end</span>    <span class="keyword">return</span>;<span class="keyword">end</span></pre>      <p>handling the function</p>      <pre class="codeinput"><span class="comment">% define the string der containing the method and convert it to the</span><span class="comment">% function handle</span>der = [<span class="string">'grdsmooth_'</span> der];der = str2func(der);</pre>      <p>main computation</p>      <pre class="codeinput"><span class="comment">% estimation of the directional derivatives</span>[gx,gy] = der(I,sigma,hsize);                                          <span class="comment">%#ok</span><span class="keyword">if</span> strcmp(axis,<span class="string">'xy'</span>)    <span class="comment">% take the vector orthogonal to the output gradient to get the 'real'</span>    <span class="comment">% gradient</span>    tmp = gx; gx = gy;    <span class="comment">% negate the second component of the vector in order to turn a left handed</span>    <span class="comment">% vector (the usual result of the gradient filter, because gy runs from</span>    <span class="comment">% top to bottom) into a right handed tensor</span>    gy = -tmp;<span class="keyword">end</span><span class="keyword">if</span> nargout&gt;=3    <span class="comment">% norm of the gradient (Combining the I and Y directional derivatives)</span>    mag = hypot(gx,gy);    magmax = max(mag(:));    <span class="keyword">if</span> magmax&gt;0        mag = mag / magmax;   <span class="comment">% normalize</span>    <span class="keyword">end</span>    varargout{1} = mag;    <span class="keyword">if</span> nargout==4        <span class="comment">% orientation</span>        <span class="keyword">if</span> strcmp(axis,<span class="string">'xy'</span>),  orien = atan2(gy, gx);        <span class="keyword">else</span>                   orien = atan2(-gx, gy);        <span class="keyword">end</span>  <span class="comment">% angles -pi to + pi.</span>        <span class="comment">% neg = orien&lt;0;</span>        <span class="comment">% varargout{2} = orien.*~neg + (orien+pi).*neg; % map angles to 0-pi.</span>        <span class="comment">% orien = orien*180/pi;               % convert to degrees.</span>        varargout{2} = orien;    <span class="keyword">end</span><span class="keyword">end</span></pre>      <pre class="codeinput"><span class="keyword">end</span> <span class="comment">% end of grdsmooth_base</span></pre>      <h2>Subfunctions<a name="12"></a></h2>      <p><tt>GRDSMOOTH_MATLAB</tt> - The directional gradients' estimation using        the 2D Gaussian filtering of the image with <tt>IMFILTER</tt> prior to        its differentiation with <tt>GRADIENT</tt>.</p>      <pre class="codeinput"><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> [gx,gy] = grdsmooth_matlab(I, sigma, hsize)                   <spanclass="comment">%#ok</span><span class="keyword">if</span> sigma&gt;0.05    <span class="keyword">if</span> isempty(hsize)        hsize = round(6*sigma)+1;   <span class="comment">% the filter size.</span>    <span class="keyword">end</span>    <span class="comment">% smooth the image out</span>    gaussian = fspecial(<span class="string">'gaussian'</span>,hsize,sigma);    Isigma = imfilter(I, gaussian);<span class="keyword">else</span>    Isigma = I;<span class="keyword">end</span><span class="comment">% calculate the derivatives</span>[gy,gx] = gradient(Isigma);<span class="comment">% % other approach:</span><span class="comment">% Isobel = fspecial('sobel');</span><span class="comment">% gx = -imfilter(I,Isobel);</span><span class="comment">% gy = -imfilter(I,Isobel');</span><span class="keyword">end</span></pre>      <p><tt>GRDSMOOTH_FAST</tt> - The directional gradients' estimation using a        fast 2D Gaussian convolution of the image with <tt>IMGAUSSIAN</tt>        prior to its differentiation with <tt>DERIVATIVES</tt>.</p>      <pre class="codeinput"><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> [gx,gy] = grdsmooth_kroon(I, sigma, hsize)                   <spanclass="comment">%#ok</span>[gx,gy] = grdsmooth_fast(I, sigma, hsize);<span class="keyword">end</span> <span class="comment">% here for convenience (in some calls of the function GRDSMOOTH_BASE)</span><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> [ux,uy] = grdsmooth_fast(I, sigma, hsize)<span class="keyword">if</span> sigma&gt;0.05    <span class="keyword">if</span> isempty(hsize)        hsize = round(6*sigma);   <span class="comment">% the filter size.</span>    <span class="keyword">end</span>    <span class="comment">% smooth the image out</span>    Isigma = imgaussian(I,sigma,hsize);<span class="keyword">else</span>    Isigma = I;<span class="keyword">end</span><span class="comment">% calculate the derivatives</span>ux = derivatives(Isigma,<span class="string">'x'</span>);uy = derivatives(Isigma,<span class="string">'y'</span>);<span class="keyword">end</span></pre>      <p><tt>GRDSMOOTH_CONV</tt>(OLUTION) - The directional gradients'        estimation using a fast 2D Gaussian convolution of the image with <tt>CONVOLUTION</tt>        prior to its differentiation with <tt>GRADIENT</tt>.</p>      <pre class="codeinput"><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> [gx,gy] = grdsmooth_conv(I, sigma, hsize)                     <spanclass="comment">%#ok</span>lambda = 3;<span class="keyword">if</span> sigma&gt;0.05    <span class="keyword">if</span> isempty(hsize)        hsize = max(1 + round(sigma)*2,7);    <span class="keyword">end</span>    <span class="comment">% smooth the image out</span>    [X,Y] = size(I);    h = gausskernel([hsize hsize], sigma/(lambda*sqrt(X*Y)), [X Y]);    Ismooth = convolution_base(I, h, <span class="string">'sym'</span>);<span class="keyword">else</span>    Ismooth = I;<span class="keyword">end</span><span class="comment">% calculate the gradient</span>[gy,gx] = gradient(Ismooth);<span class="keyword">end</span></pre>      <p><tt>GRDSMOOTH_VISTA</tt> - The directional gradients' estimation        performed in both <tt>EDGE</tt> and <tt>CANNYEDGES</tt> functions,        using Gaussian filter separability for performing directional 1D        convolutions.</p>      <pre class="codeinput"><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> [gx,gy] = grdsmooth_vista(I, sigma, hsize)                   <spanclass="comment">%#ok</span><span class="keyword">if</span> sigma&gt;0.05    ssq = sigma^2;    <span class="keyword">if</span> isempty(hsize)        GaussianDieOff = .0001;        pw = 1:30; <span class="comment">% possible hsize</span>        hsize = find(exp(-(pw.*pw)/(2*ssq))&gt;GaussianDieOff,1,<span class="string">'last'</span>);        <span class="keyword">if</span> isempty(hsize) <span class="comment">% still..</span>            hsize = 1;  <span class="comment">% a really small sigma was provided</span>        <span class="keyword">end</span>    <span class="keyword">end</span>    <span class="comment">% design the filters - a Gaussian and its derivative</span>    t = (-hsize:hsize);    gau = exp(-(t.*t)/(2*ssq))/(2*pi*ssq);     <span class="comment">% the gaussian 1D filter</span>    <span class="comment">% Find the directional derivative of 2D Gaussian (along I-axis)</span>    <span class="comment">% Since the result is symmetric along I, we can get the derivative along</span>    <span class="comment">% J-axis simply by transposing the result for I direction.</span>    [x,y] = meshgrid(-hsize:hsize,-hsize:hsize);    dgau2D = -x.*exp(-(x.*x+y.*y)/(2*ssq))/(pi*ssq);    <span class="comment">% Convolve the filters with the image in each direction</span>    <span class="comment">% The canny edge detector first requires convolution with</span>    <span class="comment">% 2D gaussian, and then with the derivitave of a gaussian.</span>    <span class="comment">% Since gaussian filter is separable, for smoothing, we can use</span>    <span class="comment">% two 1D convolutions in order to achieve the effect of convolving</span>    <span class="comment">% with 2D Gaussian.  We convolve along rows and then columns.</span>    <span class="comment">%smooth the image out</span>    ISmooth = imfilter(I,gau,<span class="string">'conv'</span>,<span class="string">'replicate'</span>); <spanclass="comment">% run the filter across rows</span>    ISmooth = imfilter(ISmooth,gau',<span class="string">'conv'</span>,<span class="string">'replicate'</span>); <spanclass="comment">% then across columns</span><span class="keyword">else</span>    ISmooth = I;<span class="keyword">end</span><span class="comment">%apply directional derivatives</span>gy = imfilter(ISmooth, dgau2D, <span class="string">'conv'</span>,<span class="string">'replicate'</span>);gx = imfilter(ISmooth, dgau2D', <span class="string">'conv'</span>,<span class="string">'replicate'</span>);<span class="comment">% Note: using the associativity of convolution and the fact the both the</span><span class="comment">% Gaussian and the derivative of a Gaussian operations are linear, the first</span><span class="comment">% derivative of the image function convolved with a Gaussian function is</span><span class="comment">% equivalent to the image function convolved with the first derivative of</span><span class="comment">% a Gaussian function. In addition, separability can be used to perform</span><span class="comment">% convolution on the I and J axes separately.</span><span class="comment">% Each of the two two-dimensional directional derivatives has to be convolved</span><span class="comment">% with the image. Using the separability property, two 1D convolutions</span><span class="comment">% instead of one costly 2D convolution. That is, the first 1D derivative of</span><span class="comment">% a Gaussian function convolved with a 1D Gaussian blur function convolved</span><span class="comment">% with the image function, is equivalent to the image function convolved</span><span class="comment">% with the first derivative of a 2D Gaussian function.</span><span class="keyword">end</span></pre>      <p><tt>GRDSMOOTH_FLECK</tt> - The directional gradients' estimation        implemented following the recommandations of [Fleck92] M.M. Fleck: "Some        defects in finite-difference edge finders".</p>      <pre class="codeinput"><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> [gv,gh] = grdsmooth_fleck(I, sigma, hsize)                    <spanclass="comment">%#ok</span><span class="keyword">if</span> sigma&gt;0.05    <span class="keyword">if</span> isempty(hsize)        hsize = round(6*sigma)+1;  <span class="comment">% the filter size.</span>    <span class="keyword">end</span>    <span class="comment">% smooth the image</span>    gaussian = fspecial(<span class="string">'gaussian'</span>,hsize,sigma);    G = filter2(gaussian,I); <span class="comment">% imfilter(I, gaussian);</span><span class="keyword">else</span>    G = I;<span class="keyword">end</span><span class="comment">% differentiate</span>[rows, cols] = size(I);h =  [  G(:,2:cols)  zeros(rows,1) ] - [  zeros(rows,1)  G(:,1:cols-1)  ];v =  [  G(2:rows,:); zeros(1,cols) ] - [  zeros(1,cols); G(1:rows-1,:)  ];d1 = [  G(2:rows,2:cols) zeros(rows-1,1); zeros(1,cols) ] - <span class="keyword">...</span>    [ zeros(1,cols); zeros(rows-1,1) G(1:rows-1,1:cols-1)  ];d2 = [  zeros(1,cols); G(1:rows-1,2:cols) zeros(rows-1,1);  ] - <span class="keyword">...</span>    [ zeros(rows-1,1) G(2:rows,1:cols-1); zeros(1,cols)   ];gh = h + (d1 + d2)/2.0;gv = v + (d1 - d2)/2.0;<span class="keyword">end</span></pre>      <p><tt>GRDSMOOTH_LUE(NGO)</tt> - Gaussian derivation recommanded by Luengo        using the analytical forms of the Gaussian filters and the separability        property to avoid redundant computations: <a href="http://www.cb.uu.se/%7Ecris/blog/index.php/archives/150#more-150">http://www.cb.uu.se/~cris/blog/index.php/archives/150#more-150</a>        <a href="http://www.cb.uu.se/%7Ecris/blog/index.php/archives/22">http://www.cb.uu.se/~cris/blog/index.php/archives/22</a></p>      <p>Compare with the method of 'edge': "that code that nicely smoothed the        image with a 1D Gaussian first along rows and then along columns, and        then computed the x and y derivatives by applying full 2D convolutions        with 2D Gaussian derivatives [is] wasting a lot of computer clock        cycles. Skip the first blurring, [it is not neededd], and compute the        gradient as the separable convolution that it is."</p>      <pre class="codeinput"><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> [gx,gy] = grdsmooth_luengo(I, sigma, hsize)                   <spanclass="comment">%#ok</span>[gx,gy] = grdsmooth_lue(I, sigma, hsize);<span class="keyword">end</span> <span class="comment">% here for convenience (in some calls of the function GRDSMOOTH_BASE)</span><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> [gx,gy] = grdsmooth_lue(I, sigma, hsize)<span class="keyword">if</span> isempty(hsize)    hsize = 2*ceil(3*sigma)+1;<span class="keyword">end</span>cutoff = floor(hsize/2);<span class="comment">% compute the exact derivative of the Gaussian, and convolve with that</span>h = fspecial(<span class="string">'gaussian'</span>,[1,hsize],sigma);dh = h .* (-cutoff:cutoff) / (-sigma^2);<span class="comment">% I- direction edge detection</span>gx = conv2(dh,h,I,<span class="string">'same'</span>);<span class="comment">% y- direction edge detection</span>gy = conv2(dh,h,I',<span class="string">'same'</span>); gy=gy';<span class="keyword">end</span></pre>      <p><tt>GRDSMOOTH_ANA</tt>(LYTIC) - The directional gradients' estimation        based on an analytical form for the Gaussian filter, its derivative and        the final 2D detector used to convolve the image.</p>      <pre class="codeinput"><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> [gx,gy] = grdsmooth_ana(I, sigma, hsize)                      <spanclass="comment">%#ok</span><span class="keyword">if</span> isempty(hsize)    hsize = round(6*sigma)+1;<span class="keyword">end</span><span class="comment">% J- direction edge detection</span>fy = d2dgauss(hsize,sigma,hsize,sigma,pi/2);gy = conv2(I,fy,<span class="string">'same'</span>);    <span class="comment">% imfilter(I,fy,'replicate','conv');</span><span class="comment">% I- direction edge detection</span>fx = d2dgauss(hsize,sigma,hsize,sigma,0);gx = conv2(I,fx,<span class="string">'same'</span>);<span class="keyword">end</span></pre>      <p><tt>D2DGAUSS</tt> - Return a 2D edge detector (first order derivative        of a 2D Gaussian function) with size n1*n2; theta is the angle that the        detector rotated counter clockwise; and sigma1 and sigma2 are the        standard deviations of the Gaussian function.</p>      <pre class="codeinput"><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> h = d2dgauss(n1,sigma1,n2,sigma2,theta)r=[cos(theta) -sin(theta);   sin(theta)  cos(theta)];<span class="comment">% function for 1D Gaussian filter</span>gauss = @(x,std) exp(-x^2/(2*std^2)) / (std*sqrt(2*pi));dgauss = @(x,std) -x * gauss(x,std) / std^2;h = zeros(n2,n1);<span class="keyword">for</span> i = 1 : n2    <span class="keyword">for</span> j = 1 : n1        u = r * [j-(n1+1)/2 i-(n2+1)/2]';         h(i,j) = gauss(u(1),sigma1) * dgauss(u(2),sigma2);        <span class="comment">% -u(2) * gauss(u(2),sigma2) * gauss(u(1),sigma1) / sigma2^2;</span>    <span class="keyword">end</span><span class="keyword">end</span>h = h / sqrt(sum(sum(abs(h).*abs(h))));<span class="keyword">end</span></pre>      <p><tt>GRDSMOOTH_MASK</tt> - The directional gradients' estimation using a        fast 2D Gaussian convolution of the image with <tt>IMGAUSSIAN</tt>        prior to its differentiation using directional masks with <tt>GRDMASK</tt>.</p>      <p>See other functions below.</p>      <pre class="codeinput"><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> [gx,gy] = grdsmooth_mask(I, sigma, hsize, der)<span class="keyword">if</span> sigma&gt;0.05    <span class="keyword">if</span> isempty(hsize)        hsize = round(6*sigma)+1;   <span class="comment">% the filter size.</span>    <span class="keyword">end</span>    <span class="comment">% smooth the image out</span>    Isigma = imgaussian(I,sigma,hsize);<span class="keyword">else</span>    Isigma = I;<span class="keyword">end</span>[gx,gy] = grdmask_base(Isigma, der, <span class="string">'ij'</span>);<span class="keyword">end</span><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> [gx,gy] = grdsmooth_sobel(I, sigma, hsize)                    <spanclass="comment">%#ok</span>[gx,gy] = grdsmooth_sob(I, sigma, hsize);<span class="keyword">end</span> <span class="comment">% here for convenience (in some calls of the function GRDSMOOTH_BASE)</span><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> [gx,gy] = grdsmooth_sob(I, sigma, hsize)[gx,gy] = grdsmooth_mask(I, sigma, hsize, <span class="string">'sobel'</span>);<span class="keyword">end</span><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> [gx,gy] = grdsmooth_prewitt(I, sigma, hsize)                  <spanclass="comment">%#ok</span>[gx,gy] = grdsmooth_prew(I, sigma, hsize);<span class="keyword">end</span><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> [gx,gy] = grdsmooth_prew(I, sigma, hsize)[gx,gy] = grdsmooth_mask(I, sigma, hsize, <span class="string">'prewitt'</span>);<span class="keyword">end</span><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> [gx,gy] = grdsmooth_opt(I, sigma, hsize)                      <spanclass="comment">%#ok</span>[gx,gy] = grdsmooth_mask(I, sigma, hsize, <span class="string">'optimal'</span>);<span class="keyword">end</span><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> [gx,gy] = grdsmooth_circ(I, sigma, hsize)                     <spanclass="comment">%#ok</span>[gx,gy] = grdsmooth_mask(I, sigma, hsize, <span class="string">'circular'</span>);<span class="keyword">end</span></pre>      <p><tt>GRDSMOOTH_DERIVATIVE5</tt> - The 1st derivatives of the image are        estimated using the 5-tap coefficients given by Farid and Simoncelli.        The results are significantly more accurate than MATLAB's <tt>GRADIENT</tt>        function on edges that are at angles other than vertical or horizontal.</p>      <pre class="codeinput"><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> [gx,gy] = grdsmooth_kovesi(I, sigma, hsize)                   <spanclass="comment">%#ok</span>[gx,gy] = grdsmooth_tap5(I, sigma, hsize);<span class="keyword">end</span>   <span class="comment">% for convenience with some calls with 'kovesi' option</span><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> [gx,gy] = grdsmooth_derivative5(I, sigma, hsize)              <spanclass="comment">%#ok</span>[gx,gy] = grdsmooth_tap5(I, sigma, hsize);<span class="keyword">end</span><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> [gx,gy] = grdsmooth_tap5(I, sigma, hsize)[gx,gy] = grdsmooth_mask(I, sigma, hsize, <span class="string">'derivative5'</span>);<span class="keyword">end</span><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> [gx,gy] = grdsmooth_derivative7(I, sigma, hsize)              <spanclass="comment">%#ok</span>[gx,gy] = grdsmooth_tap7(I, sigma, hsize);<span class="keyword">end</span><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> [gx,gy] = grdsmooth_tap7(I, sigma, hsize)[gx,gy] = grdsmooth_mask(I, sigma, hsize, <span class="string">'derivative7'</span>);<span class="keyword">end</span></pre></div>    <!--##### SOURCE BEGIN #####%% GRDSMOOTH_BASE - BASE function for GRDSMOOTH. %%% Syntax%      [gx, gy] = GRDSMOOTH_BASE(I, sigma, der, hsize, axis);%      [gx, gy, mag, or] = GRDSMOOTH_BASE(I, sigma, der, hsize, axis);%%% Acknowledgment% This function is a copy/paste and crop of several proposed functions % implemented for smoothing and differentiation following Canny's principles.%%% Remarks% * See C.Luengo discussion on Gaussian filtering and Gaussian derivation:%    http://www.cb.uu.se/~cris/blog/index.php/archives/22%    http://www.cb.uu.se/~cris/blog/index.php/archives/150#more-150%% * See P.Kovesi toolbox on improvements for local gradient estimation:%    http://www.csse.uwa.edu.au/~pk/Research/MatlabFns/%%% Credit% <mailto:grazzja@lanl.gov J.Grazzini> (ISR-2/LANL)%%% See also  % Related:% <grdsmooth.html |GRDSMOOTH|>.% Called:% <../kernel/gausskernel.html |GAUSSKERNEL|>,% <../filter/convolution.html |CONVOLUTION|>,% <matlab:webpub(whichpath('DERIVATIVES')) |DERIVATIVES|>,% <matlab:webpub(whichpath('IMGAUSSIAN')) |IMGAUSSIAN|>,% <matlab:webpub(whichpath('FSPECIAL')) |FSPECIAL|>,% <matlab:webpub(whichpath('IMFILTER')) |IMFILTER|>,% <matlab:webpub(whichpath('FILTER2')) |FILTER2|>,% <matlab:webpub(whichpath('GRADIENT')) |GRADIENT|>.%% Function implementationfunction [gx,gy,varargout] = grdsmooth_base(I, sigma, der, hsize, axis)%%% dealing with multispectral imagesC = size(I,3);if C>1    gx = zeros(size(I)); gy = zeros(size(I));    for i=1:nargout-2        varargout{i} = zeros(size(I));    end    for c=1:C        [gx(:,:,c) gy(:,:,c), tmpmag, tmpor] = ...                grdsmooth_base(I(:,:,c), sigma, der, hsize, axis);        if nargout>=3,  varargout{1}(:,:,c) = tmpmag;  end        if nargout==4,  varargout{2}(:,:,c) = tmpor;  end    end    return;end%% % handling the function% define the string der containing the method and convert it to the % function handleder = ['grdsmooth_' der];der = str2func(der);%%% main computation% estimation of the directional derivatives[gx,gy] = der(I,sigma,hsize);                                          %#ok if strcmp(axis,'xy')    % take the vector orthogonal to the output gradient to get the 'real'     % gradient    tmp = gx; gx = gy;     % negate the second component of the vector in order to turn a left handed    % vector (the usual result of the gradient filter, because gy runs from    % top to bottom) into a right handed tensor    gy = -tmp;endif nargout>=3    % norm of the gradient (Combining the I and Y directional derivatives)    mag = hypot(gx,gy);    magmax = max(mag(:));    if magmax>0        mag = mag / magmax;   % normalize    end    varargout{1} = mag;        if nargout==4        % orientation        if strcmp(axis,'xy'),  orien = atan2(gy, gx);                   else                   orien = atan2(-gx, gy);         end  % angles -pi to + pi.        % neg = orien<0;                           % varargout{2} = orien.*~neg + (orien+pi).*neg; % map angles to 0-pi.        % orien = orien*180/pi;               % convert to degrees.        varargout{2} = orien;    endendend % end of grdsmooth_base%% Subfunctions%%% |GRDSMOOTH_MATLAB| - The directional gradients' estimation using the 2D% Gaussian filtering of the image with |IMFILTER| prior to its differentiation% with |GRADIENT|.%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction [gx,gy] = grdsmooth_matlab(I, sigma, hsize)                   %#okif sigma>0.05    if isempty(hsize)        hsize = round(6*sigma)+1;   % the filter size.    end        % smooth the image out    gaussian = fspecial('gaussian',hsize,sigma);    Isigma = imfilter(I, gaussian);    else    Isigma = I;end% calculate the derivatives[gy,gx] = gradient(Isigma);% % other approach:% Isobel = fspecial('sobel');% gx = -imfilter(I,Isobel);% gy = -imfilter(I,Isobel');end%%% |GRDSMOOTH_FAST| - The directional gradients' estimation using a fast% 2D Gaussian convolution of the image with |IMGAUSSIAN| prior to its% differentiation with |DERIVATIVES|.%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction [gx,gy] = grdsmooth_kroon(I, sigma, hsize)                   %#ok[gx,gy] = grdsmooth_fast(I, sigma, hsize);end % here for convenience (in some calls of the function GRDSMOOTH_BASE)%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction [ux,uy] = grdsmooth_fast(I, sigma, hsize)                   if sigma>0.05    if isempty(hsize)        hsize = round(6*sigma);   % the filter size.    end        % smooth the image out    Isigma = imgaussian(I,sigma,hsize);else    Isigma = I;end% calculate the derivativesux = derivatives(Isigma,'x');uy = derivatives(Isigma,'y');end%%% |GRDSMOOTH_CONV|(OLUTION) - The directional gradients' estimation using a% fast 2D Gaussian convolution of the image with |CONVOLUTION| prior to its% differentiation with |GRADIENT|.%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction [gx,gy] = grdsmooth_conv(I, sigma, hsize)                     %#oklambda = 3;if sigma>0.05    if isempty(hsize)        hsize = max(1 + round(sigma)*2,7);    end        % smooth the image out    [X,Y] = size(I);    h = gausskernel([hsize hsize], sigma/(lambda*sqrt(X*Y)), [X Y]);    Ismooth = convolution_base(I, h, 'sym');else    Ismooth = I;end% calculate the gradient[gy,gx] = gradient(Ismooth); end%%% |GRDSMOOTH_VISTA| - The directional gradients' estimation performed in both% |EDGE| and |CANNYEDGES| functions, using Gaussian filter separability for% performing directional 1D convolutions.%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction [gx,gy] = grdsmooth_vista(I, sigma, hsize)                   %#okif sigma>0.05    ssq = sigma^2;    if isempty(hsize)        GaussianDieOff = .0001;        pw = 1:30; % possible hsize        hsize = find(exp(-(pw.*pw)/(2*ssq))>GaussianDieOff,1,'last');        if isempty(hsize) % still..            hsize = 1;  % a really small sigma was provided        end    end        % design the filters - a Gaussian and its derivative    t = (-hsize:hsize);    gau = exp(-(t.*t)/(2*ssq))/(2*pi*ssq);     % the gaussian 1D filter        % Find the directional derivative of 2D Gaussian (along I-axis)    % Since the result is symmetric along I, we can get the derivative along    % J-axis simply by transposing the result for I direction.    [x,y] = meshgrid(-hsize:hsize,-hsize:hsize);    dgau2D = -x.*exp(-(x.*x+y.*y)/(2*ssq))/(pi*ssq);        % Convolve the filters with the image in each direction    % The canny edge detector first requires convolution with    % 2D gaussian, and then with the derivitave of a gaussian.    % Since gaussian filter is separable, for smoothing, we can use    % two 1D convolutions in order to achieve the effect of convolving    % with 2D Gaussian.  We convolve along rows and then columns.        %smooth the image out    ISmooth = imfilter(I,gau,'conv','replicate'); % run the filter across rows    ISmooth = imfilter(ISmooth,gau','conv','replicate'); % then across columns    else    ISmooth = I;end%apply directional derivativesgy = imfilter(ISmooth, dgau2D, 'conv','replicate');gx = imfilter(ISmooth, dgau2D', 'conv','replicate');% Note: using the associativity of convolution and the fact the both the% Gaussian and the derivative of a Gaussian operations are linear, the first% derivative of the image function convolved with a Gaussian function is% equivalent to the image function convolved with the first derivative of% a Gaussian function. In addition, separability can be used to perform% convolution on the I and J axes separately.% Each of the two two-dimensional directional derivatives has to be convolved% with the image. Using the separability property, two 1D convolutions % instead of one costly 2D convolution. That is, the first 1D derivative of% a Gaussian function convolved with a 1D Gaussian blur function convolved% with the image function, is equivalent to the image function convolved% with the first derivative of a 2D Gaussian function. end%%% |GRDSMOOTH_FLECK| - The directional gradients' estimation implemented% following the recommandations of [Fleck92] M.M. Fleck: "Some defects in % finite-difference edge finders".%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction [gv,gh] = grdsmooth_fleck(I, sigma, hsize)                    %#ok               if sigma>0.05    if isempty(hsize)        hsize = round(6*sigma)+1;  % the filter size.    end        % smooth the image    gaussian = fspecial('gaussian',hsize,sigma);    G = filter2(gaussian,I); % imfilter(I, gaussian);else    G = I;end% differentiate[rows, cols] = size(I);h =  [  G(:,2:cols)  zeros(rows,1) ] - [  zeros(rows,1)  G(:,1:cols-1)  ];v =  [  G(2:rows,:); zeros(1,cols) ] - [  zeros(1,cols); G(1:rows-1,:)  ];d1 = [  G(2:rows,2:cols) zeros(rows-1,1); zeros(1,cols) ] - ...    [ zeros(1,cols); zeros(rows-1,1) G(1:rows-1,1:cols-1)  ];d2 = [  zeros(1,cols); G(1:rows-1,2:cols) zeros(rows-1,1);  ] - ...    [ zeros(rows-1,1) G(2:rows,1:cols-1); zeros(1,cols)   ];gh = h + (d1 + d2)/2.0;gv = v + (d1 - d2)/2.0;end%%% |GRDSMOOTH_LUE(NGO)| - Gaussian derivation recommanded by Luengo using the% analytical forms of the Gaussian filters and the separability property to% avoid redundant computations:%     http://www.cb.uu.se/~cris/blog/index.php/archives/150#more-150%     http://www.cb.uu.se/~cris/blog/index.php/archives/22%% Compare with the method of 'edge': "that code that nicely smoothed the % image with a 1D Gaussian first along rows and then along columns, and then% computed the x and y derivatives by applying full 2D convolutions with 2D % Gaussian derivatives [is] wasting a lot of computer clock cycles. Skip the % first blurring, [it is not neededd], and compute the gradient as the % separable convolution that it is."%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction [gx,gy] = grdsmooth_luengo(I, sigma, hsize)                   %#ok[gx,gy] = grdsmooth_lue(I, sigma, hsize);end % here for convenience (in some calls of the function GRDSMOOTH_BASE)%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction [gx,gy] = grdsmooth_lue(I, sigma, hsize)                   if isempty(hsize)    hsize = 2*ceil(3*sigma)+1;endcutoff = floor(hsize/2);% compute the exact derivative of the Gaussian, and convolve with thath = fspecial('gaussian',[1,hsize],sigma);dh = h .* (-cutoff:cutoff) / (-sigma^2);% I- direction edge detectiongx = conv2(dh,h,I,'same');% y- direction edge detectiongy = conv2(dh,h,I','same'); gy=gy';end%%% |GRDSMOOTH_ANA|(LYTIC) - The directional gradients' estimation based on an% analytical form for the Gaussian filter, its derivative and the final 2D% detector used to convolve the image.%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction [gx,gy] = grdsmooth_ana(I, sigma, hsize)                      %#okif isempty(hsize)    hsize = round(6*sigma)+1;end% J- direction edge detectionfy = d2dgauss(hsize,sigma,hsize,sigma,pi/2);gy = conv2(I,fy,'same');    % imfilter(I,fy,'replicate','conv');% I- direction edge detectionfx = d2dgauss(hsize,sigma,hsize,sigma,0);gx = conv2(I,fx,'same'); end%%% |D2DGAUSS| - Return a 2D edge detector (first order derivative of a 2D % Gaussian function) with size n1*n2; theta is the angle that the detector % rotated counter clockwise; and sigma1 and sigma2 are the standard% deviations of the Gaussian function.%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction h = d2dgauss(n1,sigma1,n2,sigma2,theta)r=[cos(theta) -sin(theta);   sin(theta)  cos(theta)];% function for 1D Gaussian filter gauss = @(x,std) exp(-x^2/(2*std^2)) / (std*sqrt(2*pi));dgauss = @(x,std) -x * gauss(x,std) / std^2;                           h = zeros(n2,n1);for i = 1 : n2     for j = 1 : n1        u = r * [j-(n1+1)/2 i-(n2+1)/2]';         h(i,j) = gauss(u(1),sigma1) * dgauss(u(2),sigma2);        % -u(2) * gauss(u(2),sigma2) * gauss(u(1),sigma1) / sigma2^2;    endendh = h / sqrt(sum(sum(abs(h).*abs(h))));end%%% |GRDSMOOTH_MASK| - The directional gradients' estimation using a fast% 2D Gaussian convolution of the image with |IMGAUSSIAN| prior to its% differentiation using directional masks with |GRDMASK|.%% See other functions below.%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction [gx,gy] = grdsmooth_mask(I, sigma, hsize, der)   if sigma>0.05    if isempty(hsize)        hsize = round(6*sigma)+1;   % the filter size.    end        % smooth the image out    Isigma = imgaussian(I,sigma,hsize);else    Isigma = I;end[gx,gy] = grdmask_base(Isigma, der, 'ij');  end%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction [gx,gy] = grdsmooth_sobel(I, sigma, hsize)                    %#ok[gx,gy] = grdsmooth_sob(I, sigma, hsize);end % here for convenience (in some calls of the function GRDSMOOTH_BASE)%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction [gx,gy] = grdsmooth_sob(I, sigma, hsize)                      [gx,gy] = grdsmooth_mask(I, sigma, hsize, 'sobel');end%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction [gx,gy] = grdsmooth_prewitt(I, sigma, hsize)                  %#ok[gx,gy] = grdsmooth_prew(I, sigma, hsize);end%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction [gx,gy] = grdsmooth_prew(I, sigma, hsize)                 [gx,gy] = grdsmooth_mask(I, sigma, hsize, 'prewitt');end%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction [gx,gy] = grdsmooth_opt(I, sigma, hsize)                      %#ok[gx,gy] = grdsmooth_mask(I, sigma, hsize, 'optimal');end%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction [gx,gy] = grdsmooth_circ(I, sigma, hsize)                     %#ok[gx,gy] = grdsmooth_mask(I, sigma, hsize, 'circular');end%%% |GRDSMOOTH_DERIVATIVE5| - The 1st derivatives of the image are estimated % using the 5-tap coefficients given by Farid and Simoncelli.  The results % are significantly more accurate than MATLAB's |GRADIENT| function on edges% that are at angles other than vertical or horizontal. %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction [gx,gy] = grdsmooth_kovesi(I, sigma, hsize)                   %#ok[gx,gy] = grdsmooth_tap5(I, sigma, hsize);end   % for convenience with some calls with 'kovesi' option%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction [gx,gy] = grdsmooth_derivative5(I, sigma, hsize)              %#ok[gx,gy] = grdsmooth_tap5(I, sigma, hsize);end%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction [gx,gy] = grdsmooth_tap5(I, sigma, hsize)                   [gx,gy] = grdsmooth_mask(I, sigma, hsize, 'derivative5');end%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction [gx,gy] = grdsmooth_derivative7(I, sigma, hsize)              %#ok[gx,gy] = grdsmooth_tap7(I, sigma, hsize);end%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction [gx,gy] = grdsmooth_tap7(I, sigma, hsize)                 [gx,gy] = grdsmooth_mask(I, sigma, hsize, 'derivative7');end##### SOURCE END #####--></body></html>