<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html>  <head>    <meta content="text/html; charset=utf-8" http-equiv="content-type">    <!--This HTML was auto-generated from MATLAB code.To make changes, update the MATLAB code and republish this document.      -->    <title>GSTFEATURE_BASE - Base function for GSTFEATURE.</title>    <meta name="generator" content="MATLAB 7.14">    <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">    <meta name="DC.date" content="2012-11-14">    <meta name="DC.source" content="gstfeature_base.m">    <style type="text/css">html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}html { min-height:100%; margin-bottom:1px; }html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }html body td { vertical-align:top; text-align:left; }h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }a { color:#005fce; text-decoration:none; }a:hover { color:#005fce; text-decoration:underline; }a:visited { color:#004aa0; text-decoration:none; }p { padding:0px; margin:0px 0px 20px; }img { padding:0px; margin:0px 0px 20px; border:none; }p img, pre img, tt img, li img { margin-bottom:0px; } ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }ul li { padding:0px; margin:0px 0px 7px 0px; }ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }ul li ol li { list-style:decimal; }ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }ol li ol li { list-style-type:lower-alpha; }ol li ul { padding-top:7px; }ol li ul li { list-style:square; }.content { font-size:1.2em; line-height:140%; padding: 20px; }pre, tt, code { font-size:12px; }pre { margin:0px 0px 20px; }pre.error { color:red; }pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }span.keyword { color:#0000FF }span.comment { color:#228B22 }span.string { color:#A020F0 }span.untermstring { color:#B20000 }span.syscmd { color:#B28C00 }.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }.footer p { margin:0px; }  </style>  </head>  <body>    <div class="content">      <h1>GSTFEATURE_BASE - Base function for GSTFEATURE.</h1>      <!--introduction--><!--/introduction-->      <h2>Contents</h2>      <div>        <ul>          <li><a href="#1">Syntax</a></li>          <li><a href="#3">See also</a></li>          <li><a href="#4">Function implementation</a></li>          <li><a href="#9">Subfunctions</a></li>        </ul>      </div>      <h2>Syntax<a name="1"></a></h2>      <pre>    [f1, f2, ...] = GSTFEATURE_BASE(gx2, gy2, gxy, lfeature, eign, ex, ey);</pre>      <h2>See also<a name="3"></a></h2>      <p>Related: <a href="gstfeature.html"><tt>GSTFEATURE</tt></a>. Called: <a          href="gstdecomp.html"><tt>GSTDECOMP</tt></a>.</p>      <h2>Function implementation<a name="4"></a></h2>      <pre class="codeinput"><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> varargout = gstfeature_base(gx2, gy2, gxy, lfeat, eign, ex, ey)</pre>      <p>internal variables and further testing</p>      <pre class="codeinput"><span class="comment">% create the list of feature names</span><span class="keyword">if</span> ischar(lfeat),  lfeat = {lfeat};  <span class="keyword">end</span>nfeat = numel(lfeat);</pre>      <p>main computation</p>      <pre class="codeinput"><span class="keyword">if</span> any(strcmp(<span class="string">'eigenorm'</span>,lfeat)) || any(strcmp(<spanclass="string">'norm'</span>,lfeat)) || <spanclass="keyword">...</span>        any(strcmp(<span class="string">'coherence'</span>,lfeat)) || any(strcmp(<spanclass="string">'coher'</span>,lfeat)) || <spanclass="keyword">...</span>        any(strcmp(<span class="string">'vectorial'</span>,lfeat)) || any(strcmp(<spanclass="string">'orvec'</span>,lfeat))    [l1,l2,~,e2] = gstdecomp(gx2, gy2, gxy);<span class="keyword">end</span><span class="keyword">for</span> i=1:nfeat    <span class="keyword">switch</span> strtrim(lfeat{i})        <span class="keyword">case</span> {<span class="string">'norm'</span>,<spanclass="string">'eigenorm'</span>}            varargout{i} = gstnorm(l1,l2,eign);        <span class="keyword">case</span> {<span class="string">'frob'</span>,<spanclass="string">'frobenius'</span>}            varargout{i} = gstfrob(gx2, gy2, gxy);        <span class="keyword">case</span> {<span class="string">'orient'</span>,<spanclass="string">'orientation'</span>}            varargout{i} = gstorient(gx2, gy2, gxy);        <span class="keyword">case</span> {<span class="string">'orvec'</span>,<spanclass="string">'vectorial'</span>}            theta = gstorient(gx2, gy2, gxy);            varargout{i} = gstreorient(theta,e2,ex,ey);        <span class="keyword">case</span> {<span class="string">'ordir'</span>,<spanclass="string">'direction'</span>}            varargout{i} = gstorientdir(gx2, gy2, gxy);        <span class="keyword">case</span> {<span class="string">'inert'</span>,<spanclass="string">'inertia'</span>}            varargout{i} = gstinertia(gx2, gy2, gxy);        <span class="keyword">otherwise</span> <span class="comment">% case {'coher','coherence'}</span>            varargout{i} = gstcoherence(l1,l2);    <span class="keyword">end</span><span class="keyword">end</span></pre>      <pre class="codeinput"><span class="keyword">end</span> <span class="comment">% end of gstfeature</span></pre>      <h2>Subfunctions<a name="9"></a></h2>      <p><tt>GSTNORM</tt> - compute the representative value for the norm.</p>      <pre class="codeinput"><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> tn = gstnorm(l1, l2, eigenmethod)<span class="comment">% initiazilation</span><span class="keyword">if</span> any(strcmp(eigenmethod,{<span class="string">'ni'</span>,<spanclass="string">'ndi'</span>}))    tn = zeros(l1);    ir = (l1+l2~=0);    l1 = l1(ir); l2 = l2(ir);<span class="keyword">end</span><span class="keyword">switch</span> eigenmethod    <span class="keyword">case</span> <span class="string">'abs'</span>        tn = abs(l1);    <span class="keyword">case</span> {<span class="string">'zen'</span>,<span class="string">'l1'</span>}        tn = sqrt(l1);    <span class="keyword">case</span> {<span class="string">'sap'</span>,<span class="string">'sum'</span>}        tn = sqrt(l1+l2);    <span class="keyword">case</span> {<span class="string">'dif'</span>,<span class="string">'koe'</span>} <spanclass="comment">% difference</span>        tn = sqrt(l1-l2);    <span class="keyword">case</span> <span class="string">'ndi'</span> <span class="comment">% normalized difference</span>        tn(ir) = (l1 - l2) ./ sqrt(l1+l2);    <span class="keyword">case</span> <span class="string">'ni'</span>        tn(ir) = l1 ./ sqrt(l1+l2);<span class="keyword">end</span><span class="keyword">end</span></pre>      <p><tt>GSTORIENT</tt> - Compute the orientation of the tensor using double        angle representation of Wilson's approach. The direction of the first        eigenvector lambda1 indicates the prominent local orientation, which is        equal to the orientation in the image with maximum change.</p>      <pre>  A. Cumani: "Edge detection in multispectral images" - EQ.(5)  S. di Zenzo: "A note on the gradient of a multi-image"  A. Koschan: "A comparative study on color edge detection"  L. van Vliet and P. Verbeek: "Estimators for orientation and anisotropy      in digitized images" - EQ.(5)</pre>      <p>The orientation of the tensor is given in mathematical positive        (counter- clockwise) orientation, starting at the (horizontal) X-axis.</p>      <pre class="codeinput"><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> theta = gstorient(gx2, gy2, gxy)<span class="comment">%ir = abs(gx2-gy2) &lt; eps;</span><span class="comment">%theta = zeros(size(gx2));</span><span class="comment">%theta(~ir) = .5 * atan2(2*gxy(~ir), gx2(~ir) - gy2(~ir));</span>theta = .5 * atan2(2*gxy, gx2 - gy2);<span class="comment">% indetermination exists when gxy==0, ie. in :</span><span class="comment">%   gy==0 &amp; gx~=0  as gx2-gy2 is always &gt;0</span><span class="comment">%   gx==0 &amp; gy~=0  as gx2-gy2 is always &lt;0</span><span class="comment">% theta is in the range [-pi/2,pi/2]</span><span class="comment">%theta(ir &amp; gxy&gt;0) = pi/4;</span><span class="comment">%theta(ir &amp; gxy&lt;0) = -pi/4;</span><span class="comment">%theta(ir &amp; gxy==0) = 0;</span><span class="comment">% all assigments/tests through ir are already performed with atan2</span><span class="comment">% w is the average value of the magnitude square of the gradient estimate</span><span class="comment">% w = mean(gx2+gy2);</span><span class="keyword">end</span></pre>      <p><tt>GSTORIENTDIR</tt> - Compute the orientation of the tensor. Tensor        orientation estimation from the main eigenvector coordinates recomputed        from the tensor partial derivatives</p>      <pre>  A. Cumani: "Efficient contour extraction in color images" - EQ.(5)</pre>      <pre class="codeinput"><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> theta = gstorientdir(gx2, gy2, gxy)v1 = gx2 - gy2;v2 = 2 * gxy;v12 = v1*v1 + v2*v2;v1 = v1 ./ (sqrt(v12)+eps);  <span class="comment">% avoid dividing by 0</span>theta = atan2(sqrtf(0.5 * (1-v1)) * sign(v2), sqrt(0.5 * (1-v1)));<span class="keyword">end</span></pre>      <p>Analytic solution of principal direction</p>      <pre>    den = sqrt(gxy.^2 + (gxx - gyy).^2);</pre>      <p>Sine and cosine of doubled angles</p>      <pre>    sin2theta = gxy/den;    cos2theta = (gxx-gyy)/den;</pre>      <p>The minimum inertia can be estimated as the area moment about the        orientation axis:</p>      <pre>     imin = 0.5( (gy2+gx2) - (gx2-gy2)*cos2theta - gxy*sin2theta);</pre>      <p>The maximum inertia can be found on the perpendicular axis:</p>      <pre>     imax = gy2 + gx2 - imin;</pre>      <p>The reliability measure of orientation data is given by</p>      <pre>     1.0 - min_inertia/max_inertia.</pre>      <p>The reasoning being that if the ratio of the minimum to maximum inertia        is close to 1 we have little orientation information.</p>      <p><tt>GSTREORIENT</tt> - Repeals the undermination in the orientation of        the tensor using Scheunders approach. Consistent orientation is given by        the vector field [ex,ey].</p>      <pre class="codeinput"><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> theta = gstreorient(theta, e2, ex, ey)<span class="comment">% change the direction of the gradient vector:</span><span class="comment">%   - if the angle (orientation) is &lt;pi (lower part of the quadrant), ADD</span><span class="comment">%     PI,</span><span class="comment">%   - if the angle (orientation) is &gt;pi (upper part of the quadrant),</span><span class="comment">%     SUBSTRACT PI</span><span class="comment">% this depends on the sign of evy</span><span class="comment">% ir = ex.*cos(theta) + ey.*evy&lt;0;</span><span class="comment">% theta(ir) = theta(ir) - pi*sign(evy(ir));</span>s = sign(e2(:,:,2)) - (e2(:,:,2)==0);theta = theta - pi * s .* (ex.*e2(:,:,1) + ey.*e2(:,:,2)&lt;0);<span class="keyword">end</span></pre>      <p><tt>GSTFROB</tt> - Compute the Frobenius norm, ie the sum of the        squares of the tensor entries.</p>      <pre class="codeinput"><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> frob = gstfrob(gx2, gy2, gxy)frob = sqrt(gx2 .^ 2 + gy2 .^ 2 + 2 * gxy.^2);<span class="keyword">end</span></pre>      <p><tt>GSTINTERTIA</tt> - Compute the maximum contrast in the tensor        direction</p>      <pre class="codeinput"><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> inertia = gstinertia(gx2, gy2, gxy)den = (gxy * gxy + (gx2-gy2)*(gx2-gy2)+eps);inertia =   0.5 * (gx2 + gy2 + (gx2-gy2).^2/den + (gxy*gxy)/den);<span class="keyword">end</span></pre>      <p><tt>GSTCOHERENCE</tt> - Compute the coherence (aka anisotropy) index.        The coherence is a value capable of distinguishing between the isotropic        and uniform cases; it is obtained as a function of the eigenvalues. See        H. Wang et al.: "Gradient adaptive image restoration and enhancement".</p>      <pre class="codeinput"><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> coherence = gstcoherence(l1,l2)coherence = (l1 - l2) ./ (l1+l2+eps);<span class="keyword">end</span></pre></div>    <!--##### SOURCE BEGIN #####%% GSTFEATURE_BASE - Base function for GSTFEATURE.% %% Syntax%      [f1, f2, ...] = GSTFEATURE_BASE(gx2, gy2, gxy, lfeature, eign, ex, ey);%%% Credit% <mailto:grazzja@lanl.gov J.Grazzini> (ISR-2/LANL)%%% See also% Related:% <gstfeature.html |GSTFEATURE|>.% Called:% <gstdecomp.html |GSTDECOMP|>.%% Function implementation%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction varargout = gstfeature_base(gx2, gy2, gxy, lfeat, eign, ex, ey)%% % internal variables and further testing% create the list of feature namesif ischar(lfeat),  lfeat = {lfeat};  endnfeat = numel(lfeat);%% % main computationif any(strcmp('eigenorm',lfeat)) || any(strcmp('norm',lfeat)) || ...        any(strcmp('coherence',lfeat)) || any(strcmp('coher',lfeat)) || ...        any(strcmp('vectorial',lfeat)) || any(strcmp('orvec',lfeat))    [l1,l2,~,e2] = gstdecomp(gx2, gy2, gxy);         endfor i=1:nfeat    switch strtrim(lfeat{i})        case {'norm','eigenorm'}            varargout{i} = gstnorm(l1,l2,eign);        case {'frob','frobenius'}            varargout{i} = gstfrob(gx2, gy2, gxy);        case {'orient','orientation'}            varargout{i} = gstorient(gx2, gy2, gxy);        case {'orvec','vectorial'}            theta = gstorient(gx2, gy2, gxy);            varargout{i} = gstreorient(theta,e2,ex,ey);        case {'ordir','direction'}            varargout{i} = gstorientdir(gx2, gy2, gxy);        case {'inert','inertia'}            varargout{i} = gstinertia(gx2, gy2, gxy);        otherwise % case {'coher','coherence'}            varargout{i} = gstcoherence(l1,l2);    endendend % end of gstfeature%% Subfunctions%%% |GSTNORM| - compute the representative value for the norm.%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction tn = gstnorm(l1, l2, eigenmethod)% initiazilationif any(strcmp(eigenmethod,{'ni','ndi'}))    tn = zeros(l1);    ir = (l1+l2~=0);    l1 = l1(ir); l2 = l2(ir);endswitch eigenmethod    case 'abs'        tn = abs(l1);    case {'zen','l1'}        tn = sqrt(l1);        case {'sap','sum'}        tn = sqrt(l1+l2);     case {'dif','koe'} % difference        tn = sqrt(l1-l2);    case 'ndi' % normalized difference        tn(ir) = (l1 - l2) ./ sqrt(l1+l2);    case 'ni'        tn(ir) = l1 ./ sqrt(l1+l2);endend        %%% |GSTORIENT| - Compute the orientation of the tensor using double angle % representation of Wilson's approach.% The direction of the first eigenvector lambda1 indicates the prominent % local orientation, which is equal to the orientation in the image with% maximum change.%%    A. Cumani: "Edge detection in multispectral images" - EQ.(5)  %    S. di Zenzo: "A note on the gradient of a multi-image"%    A. Koschan: "A comparative study on color edge detection"%    L. van Vliet and P. Verbeek: "Estimators for orientation and anisotropy %        in digitized images" - EQ.(5)%% The orientation of the tensor is given in mathematical positive (counter-% clockwise) orientation, starting at the (horizontal) X-axis.%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction theta = gstorient(gx2, gy2, gxy)%ir = abs(gx2-gy2) < eps;%theta = zeros(size(gx2));%theta(~ir) = .5 * atan2(2*gxy(~ir), gx2(~ir) - gy2(~ir));theta = .5 * atan2(2*gxy, gx2 - gy2);% indetermination exists when gxy==0, ie. in :%   gy==0 & gx~=0  as gx2-gy2 is always >0 %   gx==0 & gy~=0  as gx2-gy2 is always <0 % theta is in the range [-pi/2,pi/2]%theta(ir & gxy>0) = pi/4; %theta(ir & gxy<0) = -pi/4;%theta(ir & gxy==0) = 0;% all assigments/tests through ir are already performed with atan2% w is the average value of the magnitude square of the gradient estimate% w = mean(gx2+gy2);end%%% |GSTORIENTDIR| - Compute the orientation of the tensor.% Tensor orientation estimation from the main eigenvector coordinates% recomputed from the tensor partial derivatives %%    A. Cumani: "Efficient contour extraction in color images" - EQ.(5) %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction theta = gstorientdir(gx2, gy2, gxy)v1 = gx2 - gy2;v2 = 2 * gxy;v12 = v1*v1 + v2*v2;v1 = v1 ./ (sqrt(v12)+eps);  % avoid dividing by 0theta = atan2(sqrtf(0.5 * (1-v1)) * sign(v2), sqrt(0.5 * (1-v1)));end%%% Analytic solution of principal direction%%      den = sqrt(gxy.^2 + (gxx - gyy).^2);%% Sine and cosine of doubled angles%%      sin2theta = gxy/den;           %      cos2theta = (gxx-gyy)/den;%% The minimum inertia can be estimated as the area moment about the % orientation axis:%%       imin = 0.5( (gy2+gx2) - (gx2-gy2)*cos2theta - gxy*sin2theta);%% The maximum inertia can be found on the perpendicular axis:%%       imax = gy2 + gx2 - imin;%% The reliability measure of orientation data is given by %%       1.0 - min_inertia/max_inertia.  %% The reasoning being that if the ratio of the minimum to maximum inertia % is close to 1 we have little orientation information.  %%% |GSTREORIENT| - Repeals the undermination in the orientation of the tensor% using Scheunders approach. Consistent orientation is given by the vector% field [ex,ey].%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction theta = gstreorient(theta, e2, ex, ey) % change the direction of the gradient vector:%   - if the angle (orientation) is <pi (lower part of the quadrant), ADD%     PI,%   - if the angle (orientation) is >pi (upper part of the quadrant),%     SUBSTRACT PI% this depends on the sign of evy% ir = ex.*cos(theta) + ey.*evy<0;% theta(ir) = theta(ir) - pi*sign(evy(ir)); s = sign(e2(:,:,2)) - (e2(:,:,2)==0);theta = theta - pi * s .* (ex.*e2(:,:,1) + ey.*e2(:,:,2)<0);end%%% |GSTFROB| - Compute the Frobenius norm, ie the sum of the squares of the % tensor entries.%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction frob = gstfrob(gx2, gy2, gxy)                                 frob = sqrt(gx2 .^ 2 + gy2 .^ 2 + 2 * gxy.^2); end%%% |GSTINTERTIA| - Compute the maximum contrast in the tensor direction %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction inertia = gstinertia(gx2, gy2, gxy) den = (gxy * gxy + (gx2-gy2)*(gx2-gy2)+eps);inertia =   0.5 * (gx2 + gy2 + (gx2-gy2).^2/den + (gxy*gxy)/den); end%%% |GSTCOHERENCE| - Compute the coherence (aka anisotropy) index.% The coherence is a value capable of distinguishing between the isotropic% and uniform cases; it is obtained as a function of the eigenvalues.% See H. Wang et al.: "Gradient adaptive image restoration and% enhancement".%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction coherence = gstcoherence(l1,l2) coherence = (l1 - l2) ./ (l1+l2+eps);end##### SOURCE END #####--></body></html>