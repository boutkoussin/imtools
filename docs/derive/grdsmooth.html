<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html>  <head>    <meta content="text/html; charset=utf-8" http-equiv="content-type">    <!--This HTML was auto-generated from MATLAB code.To make changes, update the MATLAB code and republish this document.      -->    <title>GRDSMOOTH - Smoothed directional derivatives of an image.</title>    <meta name="generator" content="MATLAB 7.11">    <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">    <meta name="DC.date" content="2011-07-08">    <meta name="DC.source" content="grdsmooth.m">    <style type="text/css">body {  background-color: white;  margin:10px;}h1 {  color: #990000;   font-size: x-large;}h2 {  color: #990000;  font-size: medium;}/* Make the text shrink to fit narrow windows, but not stretch too far in wide windows. */ p,h1,h2,div.content div {  max-width: 600px;  /* Hack for IE6 */  width: auto !important; width: 600px;}pre.codeinput {  background: #EEEEEE;  padding: 10px;}@media print {  pre.codeinput {word-wrap:break-word; width:100%;}} span.keyword {color: #0000FF}span.comment {color: #228B22}span.string {color: #A020F0}span.untermstring {color: #B20000}span.syscmd {color: #B28C00}pre.codeoutput {  color: #666666;  padding: 10px;}pre.error {  color: red;}p.footer {  text-align: right;  font-size: xx-small;  font-weight: lighter;  font-style: italic;  color: gray;}  </style>  </head>  <body>    <div class="content">      <h1>GRDSMOOTH - Smoothed directional derivatives of an image.</h1>      <!--introduction--><!--/introduction-->      <h2>Contents</h2>      <div>        <ul>          <li><a href="#1">Description</a></li>          <li><a href="#2">Syntax</a></li>          <li><a href="#3">Inputs</a></li>          <li><a href="#4">Property [propertyname propertyvalues]</a></li>          <li><a href="#5">Outputs</a></li>          <li><a href="#6">References</a></li>          <li><a href="#7">Remarks</a></li>          <li><a href="#8">Credit</a></li>          <li><a href="#9">See also</a></li>          <li><a href="#10">Function implementation</a></li>        </ul>      </div>      <h2>Description<a name="1"></a></h2>      <p>Perform a Gaussian smoothing prior to the image differentiation,        following Canny's principles.</p>      <h2>Syntax<a name="2"></a></h2>      <pre>    [gx, gy] = GRDSMOOTH(I);    [gx, gy, mag, or] = GRDSMOOTH(I, sigma, der,...                                  'Property', propertyvalue, ...);</pre>      <h2>Inputs<a name="3"></a></h2>      <p><b><tt>I</tt></b> : input image of size <tt>(X,Y,C)</tt>, possibly        multichannel with <tt>C&gt;1</tt>.</p>      <p><b><tt>sigma</tt></b> : optional standard deviation of the Gaussian        filter used for smoothing of the image; default: <tt>sigma=1</tt>.</p>      <p><b><tt>der</tt></b> : optional string setting the method used for        (Canny-like) smoothing and differentiating the image; it can be:</p>      <div>        <ul>          <li><tt>'matlab'</tt> for a direct implementation of the 2D smoothing            with <tt>IMFILTER</tt> and the 2D derivation with <tt>GRADIENT</tt>,</li>          <li><tt>'vista'</tt> for the use of 1D convolutions based on the            separability of the Gaussian kernel, similar to the computation in <tt>EDGE</tt>            and <tt>CANNYEDGES</tt> functions (see <tt>VISTA_RADIUS</tt>            function),</li>          <li><tt>'fleck'</tt> for the CANNY function implemented taking into            account the improvements for finite difference suggested in            [Fleck92],</li>          <li><tt>'fast'</tt> for the (fast) implementation proposed by D.Kroon            [Kro09], using a 2D Gaussian smoothing with <tt>IMGAUSSIAN</tt> and            Sobel-like directional differentiations with <tt>DERIVATIVES</tt>,</li>          <li><tt>'conv'</tt> for the implementation consisting also in direct            2D Gaussian filtering with <tt>CONVOLUTION</tt>, followed by 2D            gradient estimation with <tt>GRADIENT</tt>,</li>          <li><tt>'sob'</tt> (<tt>'sobel'</tt>), <tt>'prew'</tt> (<tt>'prewitt'</tt>),            <tt>'circ'</tt> or <tt>'opt'</tt> for applying the 2D smoothing            with <tt>IMGAUSSIAN</tt> and the derivation using the function <tt>GRDMASK</tt>            [GW02],</li>          <li><tt>'tap5'</tt> (<tt>'derivative5'</tt> or <tt>kovesi</tt>) or <tt>'tap7'</tt>            (<tt>'derivative7'</tt>) for improved finite differences estimation            according to [FS04], using <tt>IMGAUSSIAN</tt> and <tt>GRDMASK</tt>            as well [KOVESI],</li>          <li><tt>'ana'</tt> for running the approach based on the convolution            with 1D directional Gaussian kernels,</li>          <li><tt>'lue'</tt> (<tt>'luengo'</tt>) for running an optimized            approach based on the analytical forms of the Gaussian filter and            its derivative, and the separable property;</li>        </ul>      </div>      <p>default: <tt>der='fast'</tt>.</p>      <h2>Property [propertyname propertyvalues]<a name="4"></a></h2>      <p><b><tt>'hsize'</tt></b> : optional filter size; default: estimated        depending on sigma, typically <tt>hsize=6*sigma+1</tt>.</p>      <p><b><tt>'axis'</tt></b> : string indicating the direction/orientation of        the output directional derivatives (see below), it is either <tt>'ij'</tt>        or <tt>'xy'</tt>; default: <tt>axis='ij'</tt> (right-handed coordinate        system), ie. the vector orthogonal to the (real) gradient is output: <tt>gx</tt>        is in that case the vertical derivative and <tt>gy</tt>, the horizontal        derivative.</p>      <h2>Outputs<a name="5"></a></h2>      <p><b><tt>gx, gy</tt></b> : directional derivatives with same dimension <tt>(X,Y,C)</tt>,        estimated by differentiating the Gaussian filter of the input image;        depending on parameter <tt>axis</tt> (see above), the outputs <tt>gx</tt>        and <tt>gy</tt> are either:</p>      <div>        <ul>          <li>the derivatives in I-(vertical oriented NS) and J-(horizontal            oriented OE) resp. when <tt>axis='ij'</tt>, or</li>          <li>the derivatives in X-(horizontal oriented OE) and Y-(vertical            oriented SN) directions when <tt>axis='xy'</tt>.</li>        </ul>      </div>      <p><b><tt>mag</tt></b> : (optional) magnitude of the gradient.</p>      <p><b><tt>or</tt></b> : (optional) orientation of the gradient (mapped in        <img src="grdsmooth_eq69980.png" alt="$[0,\pi]$">).</p>      <h2>References<a name="6"></a></h2>      <p>[Fleck92] M.M. Fleck: "Some defects in finite-difference edge finders",        IEEE Trans. Pattern Analysis and Machine Intelligence, 14(3):337-345,        1992.</p>      <p>[GW02] R.C. Gonzales and R.E. Woods: "Digital Image Processing",        Prentice Hall, 2002.</p>      <p>[FS04] H. Farid and E. Simoncelli: "Differentiation of discrete        multi-dimensional signals", IEEE Trans. Image Processing, 13(4):496-508,        2004.</p>      <p>[Kro09] D.J. Kroon: "Numerical optimization of kernel based image        derivatives", University of Twente, 2009. <a href="http://www.mathworks.com/matlabcentral/fileexchange/25397-imgaussian">http://www.mathworks.com/matlabcentral/fileexchange/25397-imgaussian</a></p>      <p>[KOVESI] P.D. Kovesi: "MATLAB and Octave Functions for Computer Vision        and Image Processing", The University of Western Australia, available        at: <a href="http://www.csse.uwa.edu.au/%7Epk/research/matlabfns/">http://www.csse.uwa.edu.au/~pk/research/matlabfns/</a></p>      <h2>Remarks<a name="7"></a></h2>      <p>direction/orientation of the outputs of common functions used for        gradient estimation:</p>      <pre>                                                           ------&gt;  gy [gx,gy] = grdmask(a,'method','axis','ij');                | [gx,gy] = grad(a);                                   gx   | [gx,gy] = GRDSMOOTH(a,'der',&lt;any&gt;,'axis','ij');          \|/</pre>      <pre>                                                           ------&gt;  gx                                                           | [gx,gy] = gradient(a);                               gy   |                                                          \|/</pre>      <pre>                                                          /|\ [gx,gy] = grdmask(a,'method','axis','xy');           gy   | [gx,gy] = GRDSMOOTH(a,'der',&lt;any&gt;,'axis','xy');           |                                                           ------&gt;  gx</pre>      <p>See C.Luengo discussion on Gaussian filtering and Gaussian derivation:        <a href="http://www.cb.uu.se/%7Ecris/blog/index.php/archives/22">http://www.cb.uu.se/~cris/blog/index.php/archives/22</a>        <a href="http://www.cb.uu.se/%7Ecris/blog/index.php/archives/150#more-150">http://www.cb.uu.se/~cris/blog/index.php/archives/150#more-150</a></p>      <h2>See also<a name="9"></a></h2>      <p>Related: <a href="GRDMASK.html"><tt>GRDMASK</tt></a>, <a href="GSTSMOOTH.html"><tt>GSTSMOOTH</tt></a>,        <a href="../../filter/html/SMOOTHFILT.html"><tt>SMOOTHFILT</tt></a>, <a          href="matlab:web%28whichpath%28%27GRADIENT%27%29%29"><tt>GRADIENT</tt></a>.        Called: <a href="GRDSMOOTH_BASE.html"><tt>GRDSMOOTH_BASE</tt></a>.</p>      <h2>Function implementation<a name="10"></a></h2>      <pre class="codeinput"><span class="keyword">function</span> [gx,gy,varargout] = grdsmooth(I,varargin)</pre>      <p>parsing and checking parameters</p>      <pre class="codeinput">error(nargchk(1, 16, nargin, <span class="string">'struct'</span>));error(nargoutchk(1, 4, nargout, <span class="string">'struct'</span>));<span class="comment">% mandatory parameter</span><span class="keyword">if</span> ~isnumeric(I)    error(<span class="string">'grdsmooth:inputerror'</span>,<span class="string">'a matrix is required in input'</span>);<span class="keyword">end</span>p = createParser(<span class="string">'GRDSMOOTH'</span>);   <span class="comment">% create an instance of the inputParser class.</span><span class="comment">% optional parameters</span>p.addOptional(<span class="string">'sigma'</span>,1., @(x)x&gt;=0); <span class="comment">% just for testing</span>p.addOptional(<span class="string">'der'</span>, <span class="string">'fast'</span>, @(x)ischar(x) &amp;&amp; <spanclass="keyword">...</span>    any(strcmpi(x,{<span class="string">'matlab'</span>,<span class="string">'vista'</span>,<spanclass="string">'kroon'</span>,<spanclass="string">'kovesi'</span>,<spanclass="string">'fast'</span>,<spanclass="string">'conv'</span>,<spanclass="string">'fleck'</span>, <spanclass="keyword">...</span>    <span class="string">'opt'</span>, <span class="string">'tap5'</span>,<spanclass="string">'tap7'</span>,<spanclass="string">'sob'</span>,<spanclass="string">'sobel'</span>,<spanclass="string">'prew'</span>,<spanclass="string">'opt'</span>,<spanclass="string">'circ'</span>,<spanclass="string">'ana'</span>,<spanclass="string">'lue'</span>})));p.addParamValue(<span class="string">'hsize'</span>,[], @(x)isscalar(x) || isempty(x));p.addParamValue(<span class="string">'axis'</span>,<span class="string">'ij'</span>,@(x)ischar(x) &amp;&amp; any(strcmpi(x,{<spanclass="string">'ij'</span>,<spanclass="string">'xy'</span>})));<span class="comment">% parse and validate all input arguments</span>p.parse(varargin{:});p = getvarParser(p);</pre>      <p>checking variables</p>      <pre class="codeinput"><span class="comment">% prior checking for external called functions</span><span class="keyword">if</span> (strcmp(p.der,<span class="string">'ana'</span>) || strcmp(p.der,<spanclass="string">'vista'</span>) || <spanclass="keyword">...</span>        strcmp(p.der,<span class="string">'lue'</span>)) &amp;&amp; p.sigma==0    error(<span class="string">'grdsmooth:incompatible'</span>,[ p.der <span class="string">' incompatible with sigma=0'</span>]);<span class="keyword">elseif</span> any(strcmp(p.der,{<span class="string">'kroon'</span>,<spanclass="string">'fast'</span>})) &amp;&amp; <spanclass="keyword">...</span>        (~exist(<span class="string">'imgaussian'</span>,<span class="string">'file'</span>) || ~exist(<spanclass="string">'derivatives'</span>,<spanclass="string">'file'</span>))    error(<span class="string">'grdsmooth:unknownfunction'</span>,<span class="string">'Kroon''s toolbox to be loaded'</span>);<span class="keyword">elseif</span> any(strcmp(p.der,{<span class="string">'kovesi'</span>,<spanclass="string">'tap5'</span>,<spanclass="string">'tap7'</span>})) &amp;&amp; <spanclass="keyword">...</span>        (~exist(<span class="string">'derivative5'</span>,<span class="string">'file'</span>) || ~exist(<spanclass="string">'derivative7'</span>,<spanclass="string">'file'</span>))    error(<span class="string">'grdsmooth:unknownfunction'</span>,<span class="string">'Kovesi''s toolbox to be loaded'</span>);<span class="keyword">end</span></pre>      <p>main computation</p>      <pre class="codeinput">[gx, gy, mag, or] = grdsmooth_base(I, p.sigma, p.der, p.hsize, p.axis);<span class="keyword">if</span> nargout&gt;=3    varargout{1} = mag;    <span class="keyword">if</span> nargout==4, varargout{2} = or;  <span class="keyword">end</span>;<span class="keyword">end</span></pre>      <p>display</p>      <pre class="codeinput"><span class="keyword">if</span> p.disp    figure,    ncols = 2; <span class="keyword">if</span> nargout&gt;=3, nrows = 2; <span class="keyword">else</span> nrows = 1;  <spanclass="keyword">end</span>    subplot(nrows,ncols,1), imagesc(rescale(gx,0,1)), axis <span class="string">image</span> <spanclass="string">off</span>    title([<span class="string">'gx - axis '''</span> p.axis <span class="string">''''</span>]); <spanclass="keyword">if</span> size(gx,3)==1,  colormap <spanclass="string">gray</span>,  <spanclass="keyword">end</span>;    subplot(nrows,ncols,2), imagesc(rescale(gy,0,1)), axis <span class="string">image</span> <spanclass="string">off</span>    title([<span class="string">'gy - axis '''</span> p.axis <span class="string">''''</span>]); <spanclass="keyword">if</span> size(gy,3)==1,  colormap <spanclass="string">gray</span>,  <spanclass="keyword">end</span>;    <span class="keyword">if</span> nargout&gt;=3        subplot(2,2,3), imagesc(rescale(mag,0,1)), axis <span class="string">image</span> <spanclass="string">off</span>        title(<span class="string">'mag'</span>); <span class="keyword">if</span> size(mag,3)==1,  colormap <spanclass="string">gray</span>,  <spanclass="keyword">end</span>;        <span class="keyword">if</span> nargout==4            subplot(2,2,4), imagesc(rescale(or,0,1)), axis <span class="string">image</span> <spanclass="string">off</span>            title(<span class="string">'orient'</span>); <span class="keyword">if</span> size(or,3)==1,  colormap <spanclass="string">gray</span>,  <spanclass="keyword">end</span>;        <span class="keyword">end</span>    <span class="keyword">end</span><span class="keyword">end</span></pre>      <pre class="codeinput"><span class="keyword">end</span> <span class="comment">% end of grdsmooth</span></pre></div>    <!--##### SOURCE BEGIN #####%% GRDSMOOTH - Smoothed directional derivatives of an image.%%% Description% Perform a Gaussian smoothing prior to the image differentiation, following% Canny's principles.%%% Syntax%      [gx, gy] = GRDSMOOTH(I);%      [gx, gy, mag, or] = GRDSMOOTH(I, sigma, der,...%                                    'Property', propertyvalue, ...);%%% Inputs% *|I|* : input image of size |(X,Y,C)|, possibly multichannel with |C>1|.%% *|sigma|* : optional standard deviation of the Gaussian filter used for%      smoothing of the image; default: |sigma=1|.%% *|der|* : optional string setting the method used for (Canny-like)%      smoothing and differentiating the image; it can be:%% * |'matlab'| for a direct implementation of the 2D smoothing with%          |IMFILTER| and the 2D derivation with |GRADIENT|,% * |'vista'| for the use of 1D convolutions based on the separability   %          of the Gaussian kernel, similar to the computation in |EDGE| and%          |CANNYEDGES| functions (see |VISTA_RADIUS| function),% * |'fleck'| for the CANNY function implemented taking into account%          the improvements for finite difference suggested in [Fleck92],% * |'fast'| for the (fast) implementation proposed by D.Kroon [Kro09], %          using a 2D Gaussian smoothing with |IMGAUSSIAN| and Sobel-like%          directional differentiations with |DERIVATIVES|,% * |'conv'| for the implementation consisting also in direct 2D%          Gaussian filtering with |CONVOLUTION|, followed by 2D gradient%          estimation with |GRADIENT|, % * |'sob'| (|'sobel'|), |'prew'| (|'prewitt'|), |'circ'| or |'opt'| for%          applying the 2D smoothing with |IMGAUSSIAN| and the derivation%          using the function |GRDMASK| [GW02],% * |'tap5'| (|'derivative5'| or |kovesi|) or |'tap7'| (|'derivative7'|) for %          improved finite differences estimation according to [FS04], using %          |IMGAUSSIAN| and |GRDMASK| as well [KOVESI],% * |'ana'| for running the approach based on the convolution with 1D %          directional Gaussian kernels,% * |'lue'| (|'luengo'|) for running an optimized approach based on the%          analytical forms of the Gaussian filter and its derivative, and%          the separable property;%% default: |der='fast'|.%%% Property [propertyname  propertyvalues]%% *|'hsize'|* : optional filter size; default: estimated depending on sigma, %      typically |hsize=6*sigma+1|.%% *|'axis'|* : string indicating the direction/orientation of the output%      directional derivatives (see below), it is either |'ij'| or |'xy'|;%      default: |axis='ij'| (right-handed coordinate system), ie. the vector%      orthogonal to the (real) gradient is output: |gx| is in that case the%      vertical derivative and |gy|, the horizontal derivative.%%% Outputs% *|gx, gy|* : directional derivatives with same dimension |(X,Y,C)|, estimated%      by differentiating the Gaussian filter of the input image; depending%      on parameter |axis| (see above), the outputs |gx| and |gy| are either:%% * the derivatives in I-(vertical oriented NS) and J-(horizontal oriented%          OE) resp. when |axis='ij'|, or% * the derivatives in X-(horizontal oriented OE) and Y-(vertical oriented%          SN) directions when |axis='xy'|.%% *|mag|* : (optional) magnitude of the gradient.%% *|or|* : (optional) orientation of the gradient (mapped in $[0,\pi]$).%%% References% [Fleck92] M.M. Fleck: "Some defects in finite-difference edge finders",%      IEEE Trans. Pattern Analysis and Machine Intelligence, 14(3):337-345,%      1992.%% [GW02]  R.C. Gonzales and R.E. Woods: "Digital Image Processing",      %      Prentice Hall, 2002.%% [FS04]  H. Farid and E. Simoncelli: "Differentiation of discrete%      multi-dimensional signals", IEEE Trans. Image Processing, 13(4):496-508,%      2004.%% [Kro09]  D.J. Kroon: "Numerical optimization of kernel based image %      derivatives", University of Twente, 2009.%      http://www.mathworks.com/matlabcentral/fileexchange/25397-imgaussian%% [KOVESI]  P.D. Kovesi: "MATLAB and Octave Functions for Computer Vision%      and Image Processing", The University of Western Australia, available%      at:               http://www.csse.uwa.edu.au/~pk/research/matlabfns/%%% Remarks% direction/orientation of the outputs of common functions used for gradient% estimation:%%                                                             REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH>  gy%   [gx,gy] = grdmask(a,'method','axis','ij');                |%   [gx,gy] = grad(a);                                   gx   |%   [gx,gy] = GRDSMOOTH(a,'der',<any>,'axis','ij');          \|/%    %                                                             REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH>  gx%                                                             |%   [gx,gy] = gradient(a);                               gy   |%                                                            \|/%%                                                            /|\%   [gx,gy] = grdmask(a,'method','axis','xy');           gy   |%   [gx,gy] = GRDSMOOTH(a,'der',<any>,'axis','xy');           |%                                                             REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH>  gx%% See C.Luengo discussion on Gaussian filtering and Gaussian derivation:%    http://www.cb.uu.se/~cris/blog/index.php/archives/22%    http://www.cb.uu.se/~cris/blog/index.php/archives/150#more-150%%% Credit% <mailto:grazzja@lanl.gov J.Grazzini> (ISR-2/LANL)%%% See also% Related:% <GRDMASK.html |GRDMASK|>,% <GSTSMOOTH.html |GSTSMOOTH|>,% <../../filter/html/SMOOTHFILT.html |SMOOTHFILT|>,% <matlab:web(whichpath('GRADIENT')) |GRADIENT|>.% Called:% <GRDSMOOTH_BASE.html |GRDSMOOTH_BASE|>.%% Function implementationfunction [gx,gy,varargout] = grdsmooth(I,varargin)%% % parsing and checking parameterserror(nargchk(1, 16, nargin, 'struct'));error(nargoutchk(1, 4, nargout, 'struct'));% mandatory parameterif ~isnumeric(I)    error('grdsmooth:inputerror','a matrix is required in input'); endp = createParser('GRDSMOOTH');   % create an instance of the inputParser class.% optional parametersp.addOptional('sigma',1., @(x)x>=0); % just for testingp.addOptional('der', 'fast', @(x)ischar(x) && ...    any(strcmpi(x,{'matlab','vista','kroon','kovesi','fast','conv','fleck', ...    'opt', 'tap5','tap7','sob','sobel','prew','opt','circ','ana','lue'})));p.addParamValue('hsize',[], @(x)isscalar(x) || isempty(x));p.addParamValue('axis','ij',@(x)ischar(x) && any(strcmpi(x,{'ij','xy'})));% parse and validate all input argumentsp.parse(varargin{:}); p = getvarParser(p);                                                            %%% checking variables% prior checking for external called functionsif (strcmp(p.der,'ana') || strcmp(p.der,'vista') || ...        strcmp(p.der,'lue')) && p.sigma==0                                     error('grdsmooth:incompatible',[ p.der ' incompatible with sigma=0']);elseif any(strcmp(p.der,{'kroon','fast'})) && ...                            (~exist('imgaussian','file') || ~exist('derivatives','file'))    error('grdsmooth:unknownfunction','Kroon''s toolbox to be loaded');elseif any(strcmp(p.der,{'kovesi','tap5','tap7'})) && ...                            (~exist('derivative5','file') || ~exist('derivative7','file'))    error('grdsmooth:unknownfunction','Kovesi''s toolbox to be loaded');end%%% main computation[gx, gy, mag, or] = grdsmooth_base(I, p.sigma, p.der, p.hsize, p.axis);if nargout>=3    varargout{1} = mag;    if nargout==4, varargout{2} = or;  end;end%%% displayif p.disp    figure,    ncols = 2; if nargout>=3, nrows = 2; else nrows = 1;  end    subplot(nrows,ncols,1), imagesc(rescale(gx,0,1)), axis image off    title(['gx - axis ''' p.axis '''']); if size(gx,3)==1,  colormap gray,  end;    subplot(nrows,ncols,2), imagesc(rescale(gy,0,1)), axis image off    title(['gy - axis ''' p.axis '''']); if size(gy,3)==1,  colormap gray,  end;    if nargout>=3        subplot(2,2,3), imagesc(rescale(mag,0,1)), axis image off        title('mag'); if size(mag,3)==1,  colormap gray,  end;        if nargout==4            subplot(2,2,4), imagesc(rescale(or,0,1)), axis image off            title('orient'); if size(or,3)==1,  colormap gray,  end;        end    endendend % end of grdsmooth##### SOURCE END #####-->  </body></html>