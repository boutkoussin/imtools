<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html>  <head>    <meta content="text/html; charset=utf-8" http-equiv="content-type">    <!--This HTML was auto-generated from MATLAB code.To make changes, update the MATLAB code and republish this document.      -->    <title>GRD2HESS - Hessian matrix from directional derivatives.</title>    <meta name="generator" content="MATLAB 7.11">    <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">    <meta name="DC.date" content="2011-07-08">    <meta name="DC.source" content="grd2hess.m">    <style type="text/css">body {  background-color: white;  margin:10px;}h1 {  color: #990000;   font-size: x-large;}h2 {  color: #990000;  font-size: medium;}/* Make the text shrink to fit narrow windows, but not stretch too far in wide windows. */ p,h1,h2,div.content div {  max-width: 600px;  /* Hack for IE6 */  width: auto !important; width: 600px;}pre.codeinput {  background: #EEEEEE;  padding: 10px;}@media print {  pre.codeinput {word-wrap:break-word; width:100%;}} span.keyword {color: #0000FF}span.comment {color: #228B22}span.string {color: #A020F0}span.untermstring {color: #B20000}span.syscmd {color: #B28C00}pre.codeoutput {  color: #666666;  padding: 10px;}pre.error {  color: red;}p.footer {  text-align: right;  font-size: xx-small;  font-weight: lighter;  font-style: italic;  color: gray;}  </style>  </head>  <body>    <div class="content">      <h1>GRD2HESS - Hessian matrix from directional derivatives.</h1>      <!--introduction--><!--/introduction-->      <h2>Contents</h2>      <div>        <ul>          <li><a href="#1">Syntax</a></li>          <li><a href="#2">Inputs</a></li>          <li><a href="#3">Property [propertyname propertyvalues]</a></li>          <li><a href="#4">Outputs</a></li>          <li><a href="#5">Credit</a></li>          <li><a href="#6">See also</a></li>          <li><a href="#7">Function implementation</a></li>        </ul>      </div>      <h2>Syntax<a name="1"></a></h2>      <pre>     [gxx, gyy, gxy] = GRD2HESS(gx, gy);     [gxx, gyy, gxy] = GRD2HESS(gx, gy, rho);     [gxx, gyy, gxy] = GRD2HESS(gx, gy, rho, ...                                        'Property', propertyvalue, ...);</pre>      <h2>Inputs<a name="2"></a></h2>      <p><b><tt>I</tt></b> : an input image with size <tt>(X,Y,C)</tt>, with <tt>C&gt;1</tt>        for multispectral image.</p>      <p><b><tt>gx, gy</tt></b> : directional derivatives; depending on        parameter <tt>axis</tt> (see below), <tt>gx</tt> and <tt>gy</tt> are        either:</p>      <div>        <ul>          <li>the derivatives in I-(vertical oriented NS) and J-(horizontal            oriented OE), like matlab coordinates, when <tt>axis='ij'</tt>            (default), or</li>          <li>the derivatives in X-(horizontal oriented OE) and Y-(vertical            oriented SN) directions when <tt>axis='xy'</tt>;</li>        </ul>      </div>      <p>typically, derivatives can be estimated using <tt>[gy,gx]=GRADIENT(I)</tt>        or <tt>[gx,gy]=GRDSMOOTH(I,...,'axis','ij')</tt>.</p>      <p><b><tt>rho</tt></b> : post-smoothing standard deviation; this parameter        sets the integration scale for spatial averaging, that controls the size        of the neighbourhood in which an orientation is dominant; it is used for        averaging the partial directional derivatives; if <tt>rho&lt;0.05</tt>,        then no smoothing is performed; default: <tt>rho=1</tt>.</p>      <p><b><tt>der</tt></b> : optional string setting the method used for        (Canny-like) smoothing and differentiating the image; it can be:</p>      <div>        <ul>          <li><tt>'matlab'</tt> for a direct implementation of the 2D smoothing            with <tt>IMFILTER</tt> and the 2D derivation with <tt>GRADIENT</tt>,</li>          <li><tt>'vista'</tt> for the use of 1D convolutions based on the            separability of the Gaussian kernel, similar to the computation in <tt>EDGE</tt>            and <tt>CANNYEDGES</tt> functions (see <tt>VISTA_RADIUS</tt>            function),</li>          <li><tt>'fleck'</tt> for the CANNY function implemented taking into            account the improvements for finite difference suggested in            [Fleck92],</li>          <li><tt>'fast'</tt> for the (fast) implementation proposed by D.Kroon            [Kro09], using a 2D Gaussian smoothing with <tt>IMGAUSSIAN</tt> and            Sobel-like directional differentiations with <tt>DERIVATIVES</tt>,</li>          <li><tt>'conv'</tt> for the implementation consisting also in direct            2D Gaussian filtering with <tt>CONVOLUTION</tt>, followed by 2D            gradient estimation with <tt>GRADIENT</tt>,</li>          <li><tt>'sob'</tt> (<tt>'sobel'</tt>), <tt>'prew'</tt> (<tt>'prewitt'</tt>),            <tt>'circ'</tt> or <tt>'opt'</tt> for applying the 2D smoothing            with <tt>IMGAUSSIAN</tt> and the derivation using the function <tt>GRDMASK</tt>            [GW02],</li>          <li><tt>'tap5'</tt> (<tt>'derivative5'</tt>) or <tt>'tap7'</tt> (<tt>'derivative7'</tt>)            for improved finite differences estimation according to [FS04],            using <tt>IMGAUSSIAN</tt> and <tt>GRDMASK</tt> as well [KOVESI],</li>          <li><tt>'ana'</tt> for running the approach based on the convolution            with 1D directional Gaussian kernels,</li>          <li><tt>'lue'</tt> (<tt>'luengo'</tt>) for running an optimized            approach based on the analytical forms of the Gaussian filter and            its derivative, and the separable property;</li>        </ul>      </div>      <p>default: <tt>der='fast'</tt>.</p>      <p><b><tt>int</tt></b> : optional string setting the method used for        integrating (spatially averaging) the GST; smoothing is performed, which        can be either isotropic, performed in local isotropic neighbourhoods, by        setting it to:</p>      <div>        <ul>          <li><tt>'fast'</tt> for the (fast) 2D Gaussian smoothing with <tt>IMGAUSSIAN</tt>,</li>          <li><tt>'conv'</tt> for the 2D Gaussian filtering with <tt>GAUSSKERNEL</tt>            and <tt>CONVOLUTION</tt>,</li>          <li><tt>'matlab'</tt> for a Matlab-like implementation of the 2D            smoothing with <tt>FSPECIAL</tt> and <tt>IMFILTER</tt>,</li>        </ul>      </div>      <p>or anisotropic, to better capture edges anisotropy, by setting it to:</p>      <div>        <ul>          <li><tt>'ani'</tt> for anisotropic Gaussian filtering along the edges            with <tt>HOUGLASSKERNEL</tt> for defining hourglass shaped Gaussian            kernels;</li>        </ul>      </div>      <p>if no smoothing needs to be performed, <tt>int</tt> can be set to <tt>false</tt>:        this is equivalent to setting <tt>rho=0</tt>; default: <tt>int='fast'</tt>        or, equivalently, <tt>int=true</tt>; see function <tt>SMOOTHFILT</tt>.</p>      <h2>Property [propertyname propertyvalues]<a name="3"></a></h2>      <p><b><tt>'axis'</tt></b> : string indicating the direction/orientation of        the input directional derivatives (see above); in particular, calls to <tt>GRD2GST(gx,gy,...,'axis','ij')</tt>        and <tt>GRD2GST(gy,-gx,...,'axis','xy')</tt> are equivalent; default: <tt>axis='ij'</tt>,        ie. the vector orthogonal to the (real) gradient is passed.</p>      <p><b><tt>'hsize'</tt></b> : optional filter size; default: estimated        depending on sigma, typically <tt>hsize=6*sigma+1</tt>.</p>      <p><b><tt>'samp'</tt></b> : if the gradients are interpolated gradients to        avoid aliasing, the filters need to be adapted using this sampling        factor; default: <tt>samp=1</tt>.</p>      <p><b><tt>'thez', 'sigt'</tt></b> : parameters used by the anisotropic        filtering with hour-glass filters (see <tt>HOURGLASSKERNEL</tt>);        default: <tt>thez=16, sigt=.4</tt>.</p>      <p><b><tt>'tn'</tt></b> : optional flag (<tt>true</tt> or <tt>false</tt>)        to normalize the tensor prior to its smoothing; default: <tt>tn=false</tt>.</p>      <h2>Outputs<a name="4"></a></h2>      <p><b><tt>gxx, gyy, gxy</tt></b> : matrices storing the entries of the        Hessian:</p>      <pre>                | gxx   gxy |          H  =  |           |                | gxy   gyy |</pre>      <h2>See also<a name="6"></a></h2>      <p>Related: <a href="GRD2GST.html"><tt>GRD2GST</tt></a>. Called: <a href="GRD2HESS_BASE.html"><tt>GRD2HESS_BASE</tt></a>.</p>      <h2>Function implementation<a name="7"></a></h2>      <pre class="codeinput"><span class="keyword">function</span> [gxx, gyy, gxy] = grd2hess(gx, gy, varargin)</pre>      <p>parsing and checking parameters</p>      <pre class="codeinput">error(nargchk(2, 25, nargin, <span class="string">'struct'</span>));error(nargoutchk(3, 3, nargout, <span class="string">'struct'</span>));<span class="keyword">if</span> ~(isnumeric(gx) &amp;&amp; isnumeric(gy))    error(<span class="string">'grd2hess:inputerror'</span>,<span class="string">'matrices are required in input'</span>);<span class="keyword">end</span>p = createParser(<span class="string">'GRD2HESS'</span>);   <span class="comment">% create an instance of the inputParser class.</span><span class="comment">% optional parameters</span>p.addOptional(<span class="string">'rho'</span>,1., @(x)x&gt;=0);p.addOptional(<span class="string">'der'</span>, <span class="string">'fast'</span>, @(x)islogical(x) || (ischar(x) &amp;&amp; <spanclass="keyword">...</span>    any(strcmpi(x,{<span class="string">'matlab'</span>,<span class="string">'vista'</span>,<spanclass="string">'fast'</span>,<spanclass="string">'conv'</span>,<spanclass="string">'diag'</span>, <spanclass="keyword">...</span>    <span class="string">'tap5'</span>,<span class="string">'sob'</span>,<span class="string">'opt'</span>,<spanclass="string">'ana'</span>}))));p.addOptional(<span class="string">'int'</span>, <span class="string">'fast'</span>, @(x)islogical(x) || (ischar(x) &amp;&amp; <spanclass="keyword">...</span>    any(strcmpi(x,{<span class="string">'matlab'</span>,<span class="string">'conv'</span>,<spanclass="string">'fast'</span>,<spanclass="string">'ani'</span>}))));p.addParamValue(<span class="string">'hsize'</span>,[], @(x)isscalar(x) || isempty(x));p.addParamValue(<span class="string">'samp'</span>,1, @(x)isscalar(x) &amp;&amp; round(x)==x &amp;&amp; x&gt;=1);p.addParamValue(<span class="string">'tn'</span>, false, @(x)islogical(x));p.addParamValue(<span class="string">'thez'</span>, 16, @(x)isscalar(x) &amp;&amp; round(x)==x);p.addParamValue(<span class="string">'sigt'</span>, .4, @(x)isscalar(x) &amp;&amp; isfloat(x) &amp;&amp; x&gt;0);p.addParamValue(<span class="string">'axis'</span>,<span class="string">'ij'</span>,@(x)ischar(x) &amp;&amp; any(strcmpi(x,{<spanclass="string">'ij'</span>,<spanclass="string">'xy'</span>})));<span class="comment">% parse and validate all input arguments</span>p.parse(varargin{:});p = getvarParser(p);</pre>      <p>checking parameters and setting variable</p>      <pre class="codeinput"><span class="keyword">if</span> size(gx) ~= size(gy)    error(<span class="string">'grd2hess:inputerror'</span>,<span class="string">'matrices must have same dimensions'</span>);<span class="keyword">end</span><span class="keyword">if</span> strcmp(p.axis,<span class="string">'ij'</span>)    <span class="comment">% take the vector orthogonal to the input gradient</span>    tmp = gx; gx = gy; gy = -tmp;    <span class="comment">% otherwise: horizontal OE and vertical SN derivatives have been passed</span>    <span class="comment">% in gx and gy resp.</span><span class="keyword">end</span></pre>      <p>main computation</p>      <pre class="codeinput">[gxx, gyy, gxy] = grd2hess_base(gx, gy, p.rho, p.der, p.int, <spanclass="keyword">...</span>    p.hsize, p.samp, p.tn, p.thez, p.sigt);</pre>      <pre class="codeinput"><span class="keyword">end</span> <span class="comment">%  end of grd2hess</span></pre></div>    <!--##### SOURCE BEGIN #####%% GRD2HESS - Hessian matrix from directional derivatives.% %% Syntax%       [gxx, gyy, gxy] = GRD2HESS(gx, gy);%       [gxx, gyy, gxy] = GRD2HESS(gx, gy, rho);%       [gxx, gyy, gxy] = GRD2HESS(gx, gy, rho, ...%                                          'Property', propertyvalue, ...);% %% Inputs%% *|I|* : an input image with size |(X,Y,C)|, with |C>1| for multispectral image.%% *|gx, gy|* : directional derivatives; depending on parameter |axis| (see%       below), |gx| and |gy| are either:%% * the derivatives in I-(vertical oriented NS) and J-(horizontal oriented %          OE), like matlab coordinates, when |axis='ij'| (default), or% * the derivatives in X-(horizontal oriented OE) and Y-(vertical oriented %          SN) directions when |axis='xy'|; %% typically, derivatives can be estimated using |[gy,gx]=GRADIENT(I)| or%       |[gx,gy]=GRDSMOOTH(I,...,'axis','ij')|.%% *|rho|* : post-smoothing standard deviation; this parameter sets the%      integration scale for spatial averaging, that controls the size of %      the neighbourhood in which an orientation is dominant; it is used for %      averaging the partial directional derivatives; if |rho<0.05|, then no%      smoothing is performed; default: |rho=1|.%% *|der|* : optional string setting the method used for (Canny-like)%       smoothing and differentiating the image; it can be:%% * |'matlab'| for a direct implementation of the 2D smoothing with%          |IMFILTER| and the 2D derivation with |GRADIENT|,% * |'vista'| for the use of 1D convolutions based on the separability   %          of the Gaussian kernel, similar to the computation in |EDGE| and%          |CANNYEDGES| functions (see |VISTA_RADIUS| function),% * |'fleck'| for the CANNY function implemented taking into account%          the improvements for finite difference suggested in [Fleck92],% * |'fast'| for the (fast) implementation proposed by D.Kroon [Kro09], %          using a 2D Gaussian smoothing with |IMGAUSSIAN| and Sobel-like%          directional differentiations with |DERIVATIVES|,% * |'conv'| for the implementation consisting also in direct 2D%          Gaussian filtering with |CONVOLUTION|, followed by 2D gradient%          estimation with |GRADIENT|, % * |'sob'| (|'sobel'|), |'prew'| (|'prewitt'|), |'circ'| or |'opt'| for%          applying the 2D smoothing with |IMGAUSSIAN| and the derivation%          using the function |GRDMASK| [GW02],% * |'tap5'| (|'derivative5'|) or |'tap7'| (|'derivative7'|) for improved %          finite differences estimation according to [FS04], using %          |IMGAUSSIAN| and |GRDMASK| as well [KOVESI],% * |'ana'| for running the approach based on the convolution with 1D %          directional Gaussian kernels,% * |'lue'| (|'luengo'|) for running an optimized approach based on the%          analytical forms of the Gaussian filter and its derivative, and%          the separable property;%% default: |der='fast'|.%% *|int|* : optional string setting the method used for integrating (spatially%       averaging) the GST; smoothing is performed, which can be either%       isotropic, performed in local isotropic neighbourhoods, by setting%       it to:%% * |'fast'| for the (fast) 2D Gaussian smoothing with |IMGAUSSIAN|,% * |'conv'| for the 2D Gaussian filtering with |GAUSSKERNEL| and |CONVOLUTION|, % * |'matlab'| for a Matlab-like implementation of the 2D smoothing with%          |FSPECIAL| and |IMFILTER|,%% or anisotropic, to better capture edges anisotropy, by setting it to:% % * |'ani'| for anisotropic Gaussian filtering along the edges with%          |HOUGLASSKERNEL| for defining hourglass shaped Gaussian kernels;%% if no smoothing needs to be performed, |int| can be set to |false|: this%     is equivalent to setting |rho=0|; default: |int='fast'| or, equivalently,%     |int=true|; see function |SMOOTHFILT|.% %% Property [propertyname  propertyvalues]%% *|'axis'|* : string indicating the direction/orientation of the input%       directional derivatives (see above); in particular, calls to%       |GRD2GST(gx,gy,...,'axis','ij')| and |GRD2GST(gy,-gx,...,'axis','xy')| %       are equivalent; default: |axis='ij'|, ie. the vector orthogonal to%       the (real) gradient is passed.%% *|'hsize'|* : optional filter size; default: estimated depending on sigma, %       typically |hsize=6*sigma+1|.%% *|'samp'|* : if the gradients are interpolated gradients to avoid aliasing,%       the filters need to be adapted using this sampling factor; default: %       |samp=1|.%% *|'thez', 'sigt'|* : parameters used by the anisotropic filtering with%       hour-glass filters (see |HOURGLASSKERNEL|); default: |thez=16, sigt=.4|.%% *|'tn'|* : optional flag (|true| or |false|) to normalize the tensor prior to %     its smoothing; default: |tn=false|.% %% Outputs% *|gxx, gyy, gxy|* : matrices storing the entries of the Hessian: %%                  | gxx   gxy |%            H  =  |           |     %                  | gxy   gyy |%%% Credit% <mailto:grazzja@lanl.gov J.Grazzini> (ISR-2/LANL)%%% See also  % Related:% <GRD2GST.html |GRD2GST|>.% Called:% <GRD2HESS_BASE.html |GRD2HESS_BASE|>.%% Function implementationfunction [gxx, gyy, gxy] = grd2hess(gx, gy, varargin)%% % parsing and checking parameterserror(nargchk(2, 25, nargin, 'struct'));error(nargoutchk(3, 3, nargout, 'struct'));if ~(isnumeric(gx) && isnumeric(gy))    error('grd2hess:inputerror','matrices are required in input');endp = createParser('GRD2HESS');   % create an instance of the inputParser class.% optional parametersp.addOptional('rho',1., @(x)x>=0); p.addOptional('der', 'fast', @(x)islogical(x) || (ischar(x) && ...    any(strcmpi(x,{'matlab','vista','fast','conv','diag', ...    'tap5','sob','opt','ana'}))));p.addOptional('int', 'fast', @(x)islogical(x) || (ischar(x) && ...    any(strcmpi(x,{'matlab','conv','fast','ani'}))));p.addParamValue('hsize',[], @(x)isscalar(x) || isempty(x));p.addParamValue('samp',1, @(x)isscalar(x) && round(x)==x && x>=1);p.addParamValue('tn', false, @(x)islogical(x));p.addParamValue('thez', 16, @(x)isscalar(x) && round(x)==x);p.addParamValue('sigt', .4, @(x)isscalar(x) && isfloat(x) && x>0);p.addParamValue('axis','ij',@(x)ischar(x) && any(strcmpi(x,{'ij','xy'})));% parse and validate all input argumentsp.parse(varargin{:}); p = getvarParser(p);                                                            %% % checking parameters and setting variableif size(gx) ~= size(gy)    error('grd2hess:inputerror','matrices must have same dimensions');endif strcmp(p.axis,'ij')    % take the vector orthogonal to the input gradient    tmp = gx; gx = gy; gy = -tmp;    % otherwise: horizontal OE and vertical SN derivatives have been passed    % in gx and gy resp.end%% % main computation   [gxx, gyy, gxy] = grd2hess_base(gx, gy, p.rho, p.der, p.int, ...    p.hsize, p.samp, p.tn, p.thez, p.sigt);    end %  end of grd2hess##### SOURCE END #####-->  </body></html>