<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html>  <head>    <meta content="text/html; charset=utf-8" http-equiv="content-type">    <!--This HTML was auto-generated from MATLAB code.To make changes, update the MATLAB code and republish this document.      -->    <title>GRD2HESS - Hessian matrix from directional derivatives.</title>    <meta name="generator" content="MATLAB 7.14">    <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">    <meta name="DC.date" content="2012-11-14">    <meta name="DC.source" content="grd2hess.m">    <style type="text/css">html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}html { min-height:100%; margin-bottom:1px; }html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }html body td { vertical-align:top; text-align:left; }h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }a { color:#005fce; text-decoration:none; }a:hover { color:#005fce; text-decoration:underline; }a:visited { color:#004aa0; text-decoration:none; }p { padding:0px; margin:0px 0px 20px; }img { padding:0px; margin:0px 0px 20px; border:none; }p img, pre img, tt img, li img { margin-bottom:0px; } ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }ul li { padding:0px; margin:0px 0px 7px 0px; }ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }ul li ol li { list-style:decimal; }ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }ol li ol li { list-style-type:lower-alpha; }ol li ul { padding-top:7px; }ol li ul li { list-style:square; }.content { font-size:1.2em; line-height:140%; padding: 20px; }pre, tt, code { font-size:12px; }pre { margin:0px 0px 20px; }pre.error { color:red; }pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }span.keyword { color:#0000FF }span.comment { color:#228B22 }span.string { color:#A020F0 }span.untermstring { color:#B20000 }span.syscmd { color:#B28C00 }.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }.footer p { margin:0px; }  </style>  </head>  <body>    <div class="content">      <h1>GRD2HESS - Hessian matrix from directional derivatives.</h1>      <!--introduction--><!--/introduction-->      <h2>Contents</h2>      <div>        <ul>          <li><a href="#1">Syntax</a></li>          <li><a href="#2">Inputs</a></li>          <li><a href="#3">Property [propertyname propertyvalues]</a></li>          <li><a href="#4">Outputs</a></li>          <li><a href="#6">See also</a></li>          <li><a href="#7">Function implementation</a></li>        </ul>      </div>      <h2>Syntax<a name="1"></a></h2>      <pre>     [gxx, gyy, gxy] = GRD2HESS(gx, gy);     [gxx, gyy, gxy] = GRD2HESS(gx, gy, rho);     [gxx, gyy, gxy] = GRD2HESS(gx, gy, rho, ...                                        'Property', propertyvalue, ...);</pre>      <h2>Inputs<a name="2"></a></h2>      <p><b><tt>I</tt></b> : an input image with size <tt>(X,Y,C)</tt>, with <tt>C&gt;1</tt>        for multispectral image.</p>      <p><b><tt>gx, gy</tt></b> : directional derivatives; depending on        parameter <tt>axis</tt> (see below), <tt>gx</tt> and <tt>gy</tt> are        either:</p>      <div>        <ul>          <li>the derivatives in I-(vertical oriented NS) and J-(horizontal            oriented OE), like matlab coordinates, when <tt>axis='ij'</tt>            (default), or</li>          <li>the derivatives in X-(horizontal oriented OE) and Y-(vertical            oriented SN) directions when <tt>axis='xy'</tt>;</li>        </ul>      </div>      <p>typically, derivatives can be estimated using <tt>[gy,gx]=GRADIENT(I)</tt>        or <tt>[gx,gy]=GRDSMOOTH(I,...,'axis','ij')</tt>.</p>      <p><b><tt>rho</tt></b> : post-smoothing standard deviation; this parameter        sets the integration scale for spatial averaging, that controls the size        of the neighbourhood in which an orientation is dominant; it is used for        averaging the partial directional derivatives; if <tt>rho&lt;0.05</tt>,        then no smoothing is performed; default: <tt>rho=1</tt>.</p>      <p><b><tt>der</tt></b> : optional string setting the method used for        (Canny-like) smoothing and differentiating the image; it can be:</p>      <div>        <ul>          <li><tt>'matlab'</tt> for a direct implementation of the 2D smoothing            with <tt>IMFILTER</tt> and the 2D derivation with <tt>GRADIENT</tt>,</li>          <li><tt>'vista'</tt> for the use of 1D convolutions based on the            separability of the Gaussian kernel, similar to the computation in <tt>EDGE</tt>            and <tt>CANNYEDGES</tt> functions (see <tt>VISTA_RADIUS</tt>            function),</li>          <li><tt>'fleck'</tt> for the CANNY function implemented taking into            account the improvements for finite difference suggested in            [Fleck92],</li>          <li><tt>'fast'</tt> for the (fast) implementation proposed by D.Kroon            [Kro09], using a 2D Gaussian smoothing with <tt>IMGAUSSIAN</tt> and            Sobel-like directional differentiations with <tt>DERIVATIVES</tt>,</li>          <li><tt>'conv'</tt> for the implementation consisting also in direct            2D Gaussian filtering with <tt>CONVOLUTION</tt>, followed by 2D            gradient estimation with <tt>GRADIENT</tt>,</li>          <li><tt>'sob'</tt> (<tt>'sobel'</tt>), <tt>'prew'</tt> (<tt>'prewitt'</tt>),            <tt>'circ'</tt> or <tt>'opt'</tt> for applying the 2D smoothing            with <tt>IMGAUSSIAN</tt> and the derivation using the function <tt>GRDMASK</tt>            [GW02],</li>          <li><tt>'tap5'</tt> (<tt>'derivative5'</tt>) or <tt>'tap7'</tt> (<tt>'derivative7'</tt>)            for improved finite differences estimation according to [FS04],            using <tt>IMGAUSSIAN</tt> and <tt>GRDMASK</tt> as well [KOVESI],</li>          <li><tt>'ana'</tt> for running the approach based on the convolution            with 1D directional Gaussian kernels,</li>          <li><tt>'lue'</tt> (<tt>'luengo'</tt>) for running an optimized            approach based on the analytical forms of the Gaussian filter and            its derivative, and the separable property;</li>        </ul>      </div>      <p>default: <tt>der='fast'</tt>.</p>      <p><b><tt>int</tt></b> : optional string setting the method used for        integrating (spatially averaging) the GST; smoothing is performed, which        can be either isotropic, performed in local isotropic neighbourhoods, by        setting it to:</p>      <div>        <ul>          <li><tt>'fast'</tt> for the (fast) 2D Gaussian smoothing with <tt>IMGAUSSIAN</tt>,</li>          <li><tt>'conv'</tt> for the 2D Gaussian filtering with <tt>GAUSSKERNEL</tt>            and <tt>CONVOLUTION</tt>,</li>          <li><tt>'matlab'</tt> for a Matlab-like implementation of the 2D            smoothing with <tt>FSPECIAL</tt> and <tt>IMFILTER</tt>,</li>        </ul>      </div>      <p>or anisotropic, to better capture edges anisotropy, by setting it to:</p>      <div>        <ul>          <li><tt>'ani'</tt> for anisotropic Gaussian filtering along the edges            with <tt>HOUGLASSKERNEL</tt> for defining hourglass shaped Gaussian            kernels;</li>        </ul>      </div>      <p>if no smoothing needs to be performed, <tt>int</tt> can be set to <tt>false</tt>:        this is equivalent to setting <tt>rho=0</tt>; default: <tt>int='fast'</tt>        or, equivalently, <tt>int=true</tt>; see function <tt>SMOOTHFILT</tt>.</p>      <h2>Property [propertyname propertyvalues]<a name="3"></a></h2>      <p><b><tt>'axis'</tt></b> : string indicating the direction/orientation of        the input directional derivatives (see above); in particular, calls to <tt>GRD2GST(gx,gy,...,'axis','ij')</tt>        and <tt>GRD2GST(gy,-gx,...,'axis','xy')</tt> are equivalent; default: <tt>axis='ij'</tt>,        ie. the vector orthogonal to the (real) gradient is passed.</p>      <p><b><tt>'hsize'</tt></b> : optional filter size; default: estimated        depending on sigma, typically <tt>hsize=6*sigma+1</tt>.</p>      <p><b><tt>'samp'</tt></b> : if the gradients are interpolated gradients to        avoid aliasing, the filters need to be adapted using this sampling        factor; default: <tt>samp=1</tt>.</p>      <p><b><tt>'thez', 'sigt'</tt></b> : parameters used by the anisotropic        filtering with hour-glass filters (see <tt>HOURGLASSKERNEL</tt>);        default: <tt>thez=16, sigt=.4</tt>.</p>      <p><b><tt>'tn'</tt></b> : optional flag (<tt>true</tt> or <tt>false</tt>)        to normalize the tensor prior to its smoothing; default: <tt>tn=false</tt>.</p>      <h2>Outputs<a name="4"></a></h2>      <p><b><tt>gxx, gyy, gxy</tt></b> : matrices storing the entries of the        Hessian:</p>      <pre>                | gxx   gxy |          H  =  |           |                | gxy   gyy |</pre>      <h2>See also<a name="6"></a></h2>      <p>Related: <a href="grd2gst.html"><tt>GRD2GST</tt></a>. Called: <a href="grd2hess_base.html"><tt>GRD2HESS_BASE</tt></a>.</p>      <h2>Function implementation<a name="7"></a></h2>      <pre class="codeinput"><span class="keyword">function</span> [gxx, gyy, gxy] = grd2hess(gx, gy, varargin)</pre>      <p>parsing and checking parameters</p>      <pre class="codeinput">error(nargchk(2, 25, nargin, <span class="string">'struct'</span>));error(nargoutchk(3, 3, nargout, <span class="string">'struct'</span>));<span class="keyword">if</span> ~(isnumeric(gx) &amp;&amp; isnumeric(gy))    error(<span class="string">'grd2hess:inputerror'</span>,<span class="string">'matrices are required in input'</span>);<span class="keyword">end</span>p = createParser(<span class="string">'GRD2HESS'</span>);   <span class="comment">% create an instance of the inputParser class.</span><span class="comment">% optional parameters</span>p.addOptional(<span class="string">'rho'</span>,1., @(x)x&gt;=0);p.addOptional(<span class="string">'der'</span>, <span class="string">'fast'</span>, @(x)islogical(x) || (ischar(x) &amp;&amp; <spanclass="keyword">...</span>    any(strcmpi(x,{<span class="string">'matlab'</span>,<span class="string">'vista'</span>,<spanclass="string">'fast'</span>,<spanclass="string">'conv'</span>,<spanclass="string">'diag'</span>, <spanclass="keyword">...</span>    <span class="string">'tap5'</span>,<span class="string">'sob'</span>,<span class="string">'opt'</span>,<spanclass="string">'ana'</span>}))));p.addOptional(<span class="string">'int'</span>, <span class="string">'fast'</span>, @(x)islogical(x) || (ischar(x) &amp;&amp; <spanclass="keyword">...</span>    any(strcmpi(x,{<span class="string">'matlab'</span>,<span class="string">'conv'</span>,<spanclass="string">'fast'</span>,<spanclass="string">'ani'</span>}))));p.addParamValue(<span class="string">'hsize'</span>,[], @(x)isscalar(x) || isempty(x));p.addParamValue(<span class="string">'samp'</span>,1, @(x)isscalar(x) &amp;&amp; round(x)==x &amp;&amp; x&gt;=1);p.addParamValue(<span class="string">'tn'</span>, false, @(x)islogical(x));p.addParamValue(<span class="string">'thez'</span>, 16, @(x)isscalar(x) &amp;&amp; round(x)==x);p.addParamValue(<span class="string">'sigt'</span>, .4, @(x)isscalar(x) &amp;&amp; isfloat(x) &amp;&amp; x&gt;0);p.addParamValue(<span class="string">'axis'</span>,<span class="string">'ij'</span>,@(x)ischar(x) &amp;&amp; any(strcmpi(x,{<spanclass="string">'ij'</span>,<spanclass="string">'xy'</span>})));<span class="comment">% parse and validate all input arguments</span>p.parse(varargin{:});p = getvarParser(p);</pre>      <p>checking parameters and setting variable</p>      <pre class="codeinput"><span class="keyword">if</span> size(gx) ~= size(gy)    error(<span class="string">'grd2hess:inputerror'</span>,<span class="string">'matrices must have same dimensions'</span>);<span class="keyword">end</span><span class="keyword">if</span> strcmp(p.axis,<span class="string">'ij'</span>)    <span class="comment">% take the vector orthogonal to the input gradient</span>    tmp = gx; gx = gy; gy = -tmp;    <span class="comment">% otherwise: horizontal OE and vertical SN derivatives have been passed</span>    <span class="comment">% in gx and gy resp.</span><span class="keyword">end</span></pre>      <p>main computation</p>      <pre class="codeinput">[gxx, gyy, gxy] = grd2hess_base(gx, gy, p.rho, p.der, p.int, <spanclass="keyword">...</span>    p.hsize, p.samp, p.tn, p.thez, p.sigt);</pre>      <pre class="codeinput"><span class="keyword">end</span> <span class="comment">%  end of grd2hess</span></pre></div>    <!--##### SOURCE BEGIN #####%% GRD2HESS - Hessian matrix from directional derivatives.% %% Syntax%       [gxx, gyy, gxy] = GRD2HESS(gx, gy);%       [gxx, gyy, gxy] = GRD2HESS(gx, gy, rho);%       [gxx, gyy, gxy] = GRD2HESS(gx, gy, rho, ...%                                          'Property', propertyvalue, ...);% %% Inputs%% *|I|* : an input image with size |(X,Y,C)|, with |C>1| for multispectral image.%% *|gx, gy|* : directional derivatives; depending on parameter |axis| (see%       below), |gx| and |gy| are either:%% * the derivatives in I-(vertical oriented NS) and J-(horizontal oriented %          OE), like matlab coordinates, when |axis='ij'| (default), or% * the derivatives in X-(horizontal oriented OE) and Y-(vertical oriented %          SN) directions when |axis='xy'|; %% typically, derivatives can be estimated using |[gy,gx]=GRADIENT(I)| or%       |[gx,gy]=GRDSMOOTH(I,...,'axis','ij')|.%% *|rho|* : post-smoothing standard deviation; this parameter sets the%      integration scale for spatial averaging, that controls the size of %      the neighbourhood in which an orientation is dominant; it is used for %      averaging the partial directional derivatives; if |rho<0.05|, then no%      smoothing is performed; default: |rho=1|.%% *|der|* : optional string setting the method used for (Canny-like)%       smoothing and differentiating the image; it can be:%% * |'matlab'| for a direct implementation of the 2D smoothing with%          |IMFILTER| and the 2D derivation with |GRADIENT|,% * |'vista'| for the use of 1D convolutions based on the separability   %          of the Gaussian kernel, similar to the computation in |EDGE| and%          |CANNYEDGES| functions (see |VISTA_RADIUS| function),% * |'fleck'| for the CANNY function implemented taking into account%          the improvements for finite difference suggested in [Fleck92],% * |'fast'| for the (fast) implementation proposed by D.Kroon [Kro09], %          using a 2D Gaussian smoothing with |IMGAUSSIAN| and Sobel-like%          directional differentiations with |DERIVATIVES|,% * |'conv'| for the implementation consisting also in direct 2D%          Gaussian filtering with |CONVOLUTION|, followed by 2D gradient%          estimation with |GRADIENT|, % * |'sob'| (|'sobel'|), |'prew'| (|'prewitt'|), |'circ'| or |'opt'| for%          applying the 2D smoothing with |IMGAUSSIAN| and the derivation%          using the function |GRDMASK| [GW02],% * |'tap5'| (|'derivative5'|) or |'tap7'| (|'derivative7'|) for improved %          finite differences estimation according to [FS04], using %          |IMGAUSSIAN| and |GRDMASK| as well [KOVESI],% * |'ana'| for running the approach based on the convolution with 1D %          directional Gaussian kernels,% * |'lue'| (|'luengo'|) for running an optimized approach based on the%          analytical forms of the Gaussian filter and its derivative, and%          the separable property;%% default: |der='fast'|.%% *|int|* : optional string setting the method used for integrating (spatially%       averaging) the GST; smoothing is performed, which can be either%       isotropic, performed in local isotropic neighbourhoods, by setting%       it to:%% * |'fast'| for the (fast) 2D Gaussian smoothing with |IMGAUSSIAN|,% * |'conv'| for the 2D Gaussian filtering with |GAUSSKERNEL| and |CONVOLUTION|, % * |'matlab'| for a Matlab-like implementation of the 2D smoothing with%          |FSPECIAL| and |IMFILTER|,%% or anisotropic, to better capture edges anisotropy, by setting it to:% % * |'ani'| for anisotropic Gaussian filtering along the edges with%          |HOUGLASSKERNEL| for defining hourglass shaped Gaussian kernels;%% if no smoothing needs to be performed, |int| can be set to |false|: this%     is equivalent to setting |rho=0|; default: |int='fast'| or, equivalently,%     |int=true|; see function |SMOOTHFILT|.% %% Property [propertyname  propertyvalues]%% *|'axis'|* : string indicating the direction/orientation of the input%       directional derivatives (see above); in particular, calls to%       |GRD2GST(gx,gy,...,'axis','ij')| and |GRD2GST(gy,-gx,...,'axis','xy')| %       are equivalent; default: |axis='ij'|, ie. the vector orthogonal to%       the (real) gradient is passed.%% *|'hsize'|* : optional filter size; default: estimated depending on sigma, %       typically |hsize=6*sigma+1|.%% *|'samp'|* : if the gradients are interpolated gradients to avoid aliasing,%       the filters need to be adapted using this sampling factor; default: %       |samp=1|.%% *|'thez', 'sigt'|* : parameters used by the anisotropic filtering with%       hour-glass filters (see |HOURGLASSKERNEL|); default: |thez=16, sigt=.4|.%% *|'tn'|* : optional flag (|true| or |false|) to normalize the tensor prior to %     its smoothing; default: |tn=false|.% %% Outputs% *|gxx, gyy, gxy|* : matrices storing the entries of the Hessian: %%                  | gxx   gxy |%            H  =  |           |     %                  | gxy   gyy |%%% Credit% <mailto:grazzja@lanl.gov J.Grazzini> (ISR-2/LANL)%%% See also  % Related:% <grd2gst.html |GRD2GST|>.% Called:% <grd2hess_base.html |GRD2HESS_BASE|>.%% Function implementationfunction [gxx, gyy, gxy] = grd2hess(gx, gy, varargin)%% % parsing and checking parameterserror(nargchk(2, 25, nargin, 'struct'));error(nargoutchk(3, 3, nargout, 'struct'));if ~(isnumeric(gx) && isnumeric(gy))    error('grd2hess:inputerror','matrices are required in input');endp = createParser('GRD2HESS');   % create an instance of the inputParser class.% optional parametersp.addOptional('rho',1., @(x)x>=0); p.addOptional('der', 'fast', @(x)islogical(x) || (ischar(x) && ...    any(strcmpi(x,{'matlab','vista','fast','conv','diag', ...    'tap5','sob','opt','ana'}))));p.addOptional('int', 'fast', @(x)islogical(x) || (ischar(x) && ...    any(strcmpi(x,{'matlab','conv','fast','ani'}))));p.addParamValue('hsize',[], @(x)isscalar(x) || isempty(x));p.addParamValue('samp',1, @(x)isscalar(x) && round(x)==x && x>=1);p.addParamValue('tn', false, @(x)islogical(x));p.addParamValue('thez', 16, @(x)isscalar(x) && round(x)==x);p.addParamValue('sigt', .4, @(x)isscalar(x) && isfloat(x) && x>0);p.addParamValue('axis','ij',@(x)ischar(x) && any(strcmpi(x,{'ij','xy'})));% parse and validate all input argumentsp.parse(varargin{:}); p = getvarParser(p);                                                            %% % checking parameters and setting variableif size(gx) ~= size(gy)    error('grd2hess:inputerror','matrices must have same dimensions');endif strcmp(p.axis,'ij')    % take the vector orthogonal to the input gradient    tmp = gx; gx = gy; gy = -tmp;    % otherwise: horizontal OE and vertical SN derivatives have been passed    % in gx and gy resp.end%% % main computation   [gxx, gyy, gxy] = grd2hess_base(gx, gy, p.rho, p.der, p.int, ...    p.hsize, p.samp, p.tn, p.thez, p.sigt);    end %  end of grd2hess##### SOURCE END #####-->  </body></html>