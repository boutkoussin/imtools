<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html>  <head>    <meta content="text/html; charset=utf-8" http-equiv="content-type">    <!--This HTML was auto-generated from MATLAB code.To make changes, update the MATLAB code and republish this document.      -->    <title>GSTFEATURE - Feature representation of a tensor field.</title>    <meta name="generator" content="MATLAB 7.14">    <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">    <meta name="DC.date" content="2012-11-14">    <meta name="DC.source" content="gstfeature.m">    <style type="text/css">html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}html { min-height:100%; margin-bottom:1px; }html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }html body td { vertical-align:top; text-align:left; }h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }a { color:#005fce; text-decoration:none; }a:hover { color:#005fce; text-decoration:underline; }a:visited { color:#004aa0; text-decoration:none; }p { padding:0px; margin:0px 0px 20px; }img { padding:0px; margin:0px 0px 20px; border:none; }p img, pre img, tt img, li img { margin-bottom:0px; } ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }ul li { padding:0px; margin:0px 0px 7px 0px; }ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }ul li ol li { list-style:decimal; }ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }ol li ol li { list-style-type:lower-alpha; }ol li ul { padding-top:7px; }ol li ul li { list-style:square; }.content { font-size:1.2em; line-height:140%; padding: 20px; }pre, tt, code { font-size:12px; }pre { margin:0px 0px 20px; }pre.error { color:red; }pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }span.keyword { color:#0000FF }span.comment { color:#228B22 }span.string { color:#A020F0 }span.untermstring { color:#B20000 }span.syscmd { color:#B28C00 }.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }.footer p { margin:0px; }  </style>  </head>  <body>    <div class="content">      <h1>GSTFEATURE - Feature representation of a tensor field.</h1>      <!--introduction--><!--/introduction-->      <h2>Contents</h2>      <div>        <ul>          <li><a href="#1">Description</a></li>          <li><a href="#2">Syntax</a></li>          <li><a href="#3">Inputs</a></li>          <li><a href="#4">Property [propertyname propertyvalues]</a></li>          <li><a href="#5">Output</a></li>          <li><a href="#6">References</a></li>          <li><a href="#8">See also</a></li>          <li><a href="#9">Function implementation</a></li>        </ul>      </div>      <h2>Description<a name="1"></a></h2>      <p>Derive features like norm, orientation, coherence, inertia... from        tensor representation.</p>      <h2>Syntax<a name="2"></a></h2>      <pre>    f = GSTFEATURE(gx2, gy2, gxy);    [f1, f2, ...] = GSTFEATURE(gx2, gy2, gxy, feature,                   'Property', propertyvalue, ...);    F = GSTFEATURE(gx2, gy2, gxy, feature, 'Property', propertyvalue, ...);</pre>      <h2>Inputs<a name="3"></a></h2>      <p><b><tt>gx2, gy2, gxy</tt></b> : components of a symmetric (structure)        tensor <tt>T</tt>.</p>      <p><b><tt>feature</tt></b> : optional string or cell of strings setting        the feature to be estimated; it is one of the following:</p>      <div>        <ul>          <li><tt>'norm'</tt> for the approximated norm based on the eigenvalues            of the tensor <tt>T</tt>,</li>          <li><tt>'frob'</tt> for the Frobenius norm of the tensor <tt>T</tt>,</li>          <li><tt>'orient'</tt> for the double angle representation of the            tensor <tt>T</tt>,</li>          <li><tt>'orvec'</tt> reoriented field for consistency with the            vectorial field provided by the additional parameters <tt>[ex,ey]</tt>            (see below),</li>          <li><tt>'ordir'</tt> for the direction,</li>          <li><tt>'inert'</tt> for the inertia of the tensor <tt>T</tt>,</li>          <li><tt>'coher'</tt> for computing the coherence (aka anisotropy)            index of the tensor <tt>T</tt>;</li>        </ul>      </div>      <p>or any cell combining those strings (order has no importance); default:        <tt>feature='norm'</tt>.</p>      <h2>Property [propertyname propertyvalues]<a name="4"></a></h2>      <p><b><tt>'eign'</tt></b> : optional string defining the method used for        the tensor's norm approximation; it is either:</p>      <div>        <ul>          <li><tt>'zen'</tt> (or <tt>'l1'</tt>) for the square root of the            largest eigenvalue: <img src="gstfeature_eq62012.png" alt="$\sqrt{l_1}$">,</li>          <li><tt>'sap'</tt> (or <tt>'sum'</tt>) for the sum of the            eigenvalues: <img src="gstfeature_eq32720.png" alt="$\sqrt{l_1+l_2}$">,</li>          <li><tt>'koe'</tt> (or <tt>'dif'</tt>) for the difference of the            eigenvalues: <img src="gstfeature_eq89852.png" alt="$\sqrt{l_1-l_2}$">,</li>          <li><tt>'ndi'</tt> for the normalized difference of the eigenvalues: <img              src="gstfeature_eq27751.png"              alt="$\sqrt{\frac{l_1-l_2}{l_1+l_2}}$">;</li>        </ul>      </div>      <p>default: <tt>eign='l1'</tt>.</p>      <p><b><tt>'ex', 'ey'</tt></b> : optional vectorial field provided by the        vectors <tt>[ex,ey]</tt> used for computing the feature <tt>'orvec'</tt>;        default: <tt>ex=ey=[]</tt>.</p>      <h2>Output<a name="5"></a></h2>      <p><b><tt>f</tt></b> : matrices of features derived from the GST; in the        case one output only is provided and several features are computed, the        features are concatenated into the single output.</p>      <h2>References<a name="6"></a></h2>      <p>[Zenzo86] S. Di Zenzo: "A note on the gradient of a multi-image",        CVGIP, 33:116-125, 1986. <a href="http://www.sciencedirect.com/science/article/pii/0734189X86902239">http://www.sciencedirect.com/science/article/pii/0734189X86902239</a></p>      <p>[Cuma91] A. Cumani: "Edge detection in multispectral images", CVGIP:        Graphical Models and Image Processing, 53(1):40-51, 1991. <a href="http://www.sciencedirect.com/science/article/pii/104996529190018F">http://www.sciencedirect.com/science/article/pii/104996529190018F</a></p>      <p>[VV95] L. van Vliet and P. Verbeek: "Estimators for orientation and        anisotropy in digitized images", Proc. ASCI, pp. 442-450, 1995. <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.104.8552">http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.104.8552</a></p>      <p>[Kosch95] A. Koschan: "A comparative study on color edge detection",        Proc. ACCV, pp. 574-578, 1995. <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.31.2648">http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.31.2648</a></p>      <p>[Cuma98] A. Cumani: "Efficient contour extraction in color images",        Proc. ACCV, pp. 582-589, LNCS 1351, 1998. <a href="http://www.springerlink.com/content/c1750730487puqm0/">http://www.springerlink.com/content/c1750730487puqm0/</a></p>      <p>[Weick98] J. Weickert: "Anisotropic Diffusion in Image Processing",        Teubner-Verlag, Stuttgart (Germany), 1998.</p>      <p>[Kothe03] U. Koethe: "Integrated edge and junction detection with the        boundary tensor", Proc. IEEE ICCV, vol. 1, pp. 424?431, 2003. <a href="http://hci.iwr.uni-heidelberg.de/Staff/ukoethe/papers/polarfilters.pdf">http://hci.iwr.uni-heidelberg.de/Staff/ukoethe/papers/polarfilters.pdf</a></p>      <p>[Scheun03] P. Scheunders: "A wavelet representation of multispectral        images", Frontiers of Remote Sensing Information Processing, pp.        197?224. World Scientific, 2003. <a href="http://ebooks.worldscinet.com/ISBN/9789812796752/9789812796752_0009.html">http://ebooks.worldscinet.com/ISBN/9789812796752/9789812796752_0009.html</a></p>      <p>[Tschum06] D. Tschumperle: "Fast anisotropic smoothing of multivalued        images using curvature-preserving PDE?s", International Journal of        Computer Vision, 68(1):65?82, 2006. <a href="http://www.springerlink.com/content/5217329131181uh4/">http://www.springerlink.com/content/5217329131181uh4/</a></p>      <p>[WCFTA06] H. Wang, Y. Chen, T. Fang, J. Tyan and N. Ahuja: "Gradient        adaptive image restoration and enhancement", Proc. ICIP, vol. 2, pp.        893-896, 2006. <a href="http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=4107174">http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=4107174</a></p>      <h2>See also<a name="8"></a></h2>      <p>Related: <a href="gstsmooth.html"><tt>GSTSMOOTH</tt></a>, <a href="grd2gst.html"><tt>GRD2GST</tt></a>,        <a href="gstdecomp.html"><tt>GSTDECOMP</tt></a>. Called: <a href="gstfeature_base.html"><tt>GSTFEATURE_BASE</tt></a>.</p>      <h2>Function implementation<a name="9"></a></h2>      <pre class="codeinput"><span class="keyword">function</span> varargout = gstfeature(gx2, gy2, gxy, varargin)</pre>      <p>parsing parameters</p>      <pre class="codeinput">error(nargchk(1, 18, nargin, <span class="string">'struct'</span>));error(nargoutchk(1, 7, nargout, <span class="string">'struct'</span>));<span class="keyword">if</span> ~(isnumeric(gx2) &amp;&amp; isnumeric(gy2) &amp;&amp; isnumeric(gxy))    error(<span class="string">'gstfeature:inputerror'</span>,<span class="string">'matrices are required in input'</span>);<span class="keyword">end</span>p = createParser(<span class="string">'GSTFEATURE'</span>);   <span class="comment">% create an instance of the inputParser class.</span>p.addOptional(<span class="string">'f'</span>,<span class="string">'norm'</span>, @(x)ischar(x) || iscell(x));<span class="comment">% any(strcmpi(x,{'norm','frob','orient','ordir','reorient','inert','coher'});</span>p.addParamValue(<span class="string">'eign'</span>,[],@(x)ischar(x) &amp;&amp; <spanclass="keyword">...</span>    any(strcmpi(x,{<span class="string">'abs'</span>,<span class="string">'zen'</span>,<spanclass="string">'l1'</span>,<spanclass="string">'sap'</span>,<spanclass="string">'sum'</span>,<spanclass="string">'ndi'</span>,<spanclass="string">'dif'</span>,<spanclass="string">'koe'</span>})));p.addParamValue(<span class="string">'ex'</span>,[],@(x)isnumeric(x));p.addParamValue(<span class="string">'ey'</span>,[],@(x)isnumeric(x));<span class="comment">% parse and validate all input arguments</span>p.parse(varargin{:});p = getvarParser(p);</pre>      <p>internal variables and further testing</p>      <pre class="codeinput"><span class="comment">% check the compatibility of the input parameters</span><span class="keyword">if</span> any(size(gx2)~=size(gy2)) || any(size(gx2)~=size(gxy))    error(<span class="string">'gstfeature:inputerror'</span>,<span class="string">'matrices must have same dimensions'</span>);<span class="keyword">end</span><span class="comment">% % create the list of feature names</span><span class="comment">% if nb_dims(p.f)==2 % then already an array of feature names has been passed</span><span class="comment">%     lfeat = p.f;</span><span class="comment">%</span><span class="comment">% else   % let's create such an array from the concatenate string</span><span class="comment">%     lfeat = str2vsubstr(p.f, ...</span><span class="comment">%         strvcat('eigenorm','norm','frobenius','frob','orientation', ...</span><span class="comment">%         'orient','direction','ordir','vectorial','orvec', ...</span><span class="comment">%         'inertia','inert','coherence','coher'));                       %#ok</span><span class="comment">% end</span><span class="keyword">if</span> ischar(p.f),  p.f = {p.f};  <span class="keyword">end</span>nfeat = numel(p.f);<span class="keyword">if</span> nargout~=1 &amp;&amp; nargout~=nfeat    error(<span class="string">'gstfeature:inputerror'</span>, <span class="keyword">...</span>        [<span class="string">'the no. of output arguments must be 1 or equal to the no. '</span> <spanclass="keyword">...</span>        <span class="string">'of computed features must be equal'</span>]);<span class="keyword">end</span><span class="keyword">if</span> ~any(strncmp(<span class="string">'norm'</span>,p.f,4)) &amp;&amp; ~any(strncmp(<spanclass="string">'eigenorm'</span>,p.f,4)) &amp;&amp; <spanclass="keyword">...</span>        ~isempty(p.eign)        warning(<span class="string">'gstfeature:incompatibleparameter'</span>,<spanclass="keyword">...</span>            <span class="string">'parameter eign ignored for features other than norm'</span>);<span class="keyword">else</span>    p.eign = <span class="string">'zen'</span>; <span class="comment">% default value, may be unused</span><span class="keyword">end</span>test = ~any(strncmp(<span class="string">'orvec'</span>,p.f,4)) &amp;&amp; ~any(strncmp(<spanclass="string">'vectorial'</span>,p.f,4));<span class="keyword">if</span> test &amp;&amp; (~isempty(p.ex) || ~isempty(p.ey))    warning(<span class="string">'gstfeature_base:incompatibleparameter'</span>,<spanclass="keyword">...</span>        <span class="string">'parameters ex,ey ignored for features other than orvec'</span>);<span class="keyword">elseif</span> ~test &amp;&amp; isempty(p.ex) &amp;&amp; isempty(p.ey)    error(<span class="string">'gstfeature_base:incompatibleparameter'</span>,<spanclass="keyword">...</span>        <span class="string">'parameters ex,ey need to be passed with feature orvec'</span>);<span class="keyword">end</span></pre>      <p>main computation</p>      <pre class="codeinput">varargout{1} = [];<span class="keyword">for</span> i=1:nfeat    F = gstfeature_base(gx2, gy2, gxy, p.f{i}, p.eign, p.ex, p.ey);    <span class="keyword">if</span> nargout==1,  varargout{1} = cat(3, varargout{1}, F);    <span class="keyword">else</span>            varargout{i} = F;                        <spanclass="keyword">end</span><span class="keyword">end</span></pre>      <p>display</p>      <pre class="codeinput"><span class="keyword">if</span> p.disp    figure,    ncols = min(3,nfeat); nrows = ceil(nfeat/ncols);    <span class="keyword">for</span> i=1:nfeat        subplot(nrows,ncols,i), imagesc(varargout{i}), axis <span class="string">image</span> <spanclass="string">off</span>;        title(p.f(i,:)), colormap <span class="string">gray</span>;    <span class="keyword">end</span><span class="keyword">end</span></pre>      <pre class="codeinput"><span class="keyword">end</span> <span class="comment">% end of gstfeature</span></pre></div>    <!--##### SOURCE BEGIN #####%% GSTFEATURE - Feature representation of a tensor field.%%% Description% Derive features like norm, orientation, coherence, inertia... from tensor% representation.% %% Syntax%      f = GSTFEATURE(gx2, gy2, gxy);%      [f1, f2, ...] = GSTFEATURE(gx2, gy2, gxy, feature,%                     'Property', propertyvalue, ...);%      F = GSTFEATURE(gx2, gy2, gxy, feature, 'Property', propertyvalue, ...);%%% Inputs% *|gx2, gy2, gxy|* : components of a symmetric (structure) tensor |T|.%% *|feature|* : optional string or cell of strings setting the feature to be%      estimated; it is one of the following: % % * |'norm'| for the approximated norm based on the eigenvalues of the tensor%          |T|,% * |'frob'| for the Frobenius norm of the tensor |T|,% * |'orient'| for the double angle representation of the tensor |T|,% * |'orvec'| reoriented field for consistency with the vectorial field provided%          by the additional parameters |[ex,ey]| (see below),% * |'ordir'| for the direction,% * |'inert'| for the inertia of the tensor |T|,% * |'coher'| for computing the coherence (aka anisotropy) index of the tensor%          |T|;% % or any cell combining those strings (order has no importance); default:%      |feature='norm'|.%%% Property [propertyname  propertyvalues]% *|'eign'|* : optional string defining the method used for the tensor's norm%      approximation; it is either:% % * |'zen'| (or |'l1'|) for the square root of the largest eigenvalue: $\sqrt{l_1}$,% * |'sap'| (or |'sum'|) for the sum of the eigenvalues: $\sqrt{l_1+l_2}$,% * |'koe'| (or |'dif'|) for the difference of the eigenvalues: $\sqrt{l_1-l_2}$,% * |'ndi'| for the normalized difference of the eigenvalues: %            $\sqrt{\frac{l_1-l_2}{l_1+l_2}}$;%% default: |eign='l1'|. %% *|'ex', 'ey'|* : optional vectorial field provided by the vectors |[ex,ey]|%      used for computing the feature |'orvec'|; default: |ex=ey=[]|. %%% Output% *|f|* : matrices of features derived from the GST; in the case one output%     only is provided and several features are computed, the features are%     concatenated into the single output.%%% References% [Zenzo86]  S. Di Zenzo: "A note on the gradient of a multi-image",%      CVGIP, 33:116-125, 1986.%      <http://www.sciencedirect.com/science/article/pii/0734189X86902239>%% [Cuma91]  A. Cumani: "Edge detection in multispectral images", CVGIP:%      Graphical Models and Image Processing, 53(1):40-51, 1991.  %      <http://www.sciencedirect.com/science/article/pii/104996529190018F>%% [VV95]   L. van Vliet and P. Verbeek: "Estimators for orientation and %      anisotropy in digitized images", Proc. ASCI, pp. 442-450, 1995. %      <http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.104.8552>%% [Kosch95]  A. Koschan: "A comparative study on color edge detection",%      Proc. ACCV, pp. 574-578, 1995.%      <http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.31.2648>%% [Cuma98]  A. Cumani: "Efficient contour extraction in color images", %      Proc. ACCV, pp. 582-589, LNCS 1351, 1998.%      <http://www.springerlink.com/content/c1750730487puqm0/>%% [Weick98]  J. Weickert: "Anisotropic Diffusion in Image Processing",%      Teubner-Verlag, Stuttgart (Germany), 1998.%% [Kothe03]  U. Koethe: "Integrated edge and junction detection with%      the boundary tensor", Proc. IEEE ICCV, vol. 1, pp. 424?431, 2003.%      <http://hci.iwr.uni-heidelberg.de/Staff/ukoethe/papers/polarfilters.pdf>%% [Scheun03]  P. Scheunders: "A wavelet representation of multispectral%      images", Frontiers of Remote Sensing Information Processing, pp.%      197?224. World Scientific, 2003.%      <http://ebooks.worldscinet.com/ISBN/9789812796752/9789812796752_0009.html>%% [Tschum06]  D. Tschumperle: "Fast anisotropic smoothing of multivalued%      images using curvature-preserving PDE?s", International Journal of%      Computer Vision, 68(1):65?82, 2006.%      <http://www.springerlink.com/content/5217329131181uh4/>%% [WCFTA06]  H. Wang, Y. Chen, T. Fang, J. Tyan and N. Ahuja: "Gradient %      adaptive image restoration and enhancement", Proc. ICIP, vol. 2, %      pp. 893-896, 2006.%      <http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=4107174>%%% Credit% <mailto:grazzja@lanl.gov J.Grazzini> (ISR-2/LANL)%%% See also% Related:% <gstsmooth.html |GSTSMOOTH|>,% <grd2gst.html |GRD2GST|>,% <gstdecomp.html |GSTDECOMP|>.% Called:% <gstfeature_base.html |GSTFEATURE_BASE|>.%% Function implementationfunction varargout = gstfeature(gx2, gy2, gxy, varargin)%%% parsing parameterserror(nargchk(1, 18, nargin, 'struct'));error(nargoutchk(1, 7, nargout, 'struct'));if ~(isnumeric(gx2) && isnumeric(gy2) && isnumeric(gxy))    error('gstfeature:inputerror','matrices are required in input');endp = createParser('GSTFEATURE');   % create an instance of the inputParser class.p.addOptional('f','norm', @(x)ischar(x) || iscell(x)); % any(strcmpi(x,{'norm','frob','orient','ordir','reorient','inert','coher'});p.addParamValue('eign',[],@(x)ischar(x) && ...    any(strcmpi(x,{'abs','zen','l1','sap','sum','ndi','dif','koe'})));p.addParamValue('ex',[],@(x)isnumeric(x));p.addParamValue('ey',[],@(x)isnumeric(x));% parse and validate all input argumentsp.parse(varargin{:}); p = getvarParser(p);                                                            %% % internal variables and further testing% check the compatibility of the input parametersif any(size(gx2)~=size(gy2)) || any(size(gx2)~=size(gxy))    error('gstfeature:inputerror','matrices must have same dimensions');end% % create the list of feature names% if nb_dims(p.f)==2 % then already an array of feature names has been passed%     lfeat = p.f;%     % else   % let's create such an array from the concatenate string%     lfeat = str2vsubstr(p.f, ...%         strvcat('eigenorm','norm','frobenius','frob','orientation', ...%         'orient','direction','ordir','vectorial','orvec', ...%         'inertia','inert','coherence','coher'));                       %#ok% endif ischar(p.f),  p.f = {p.f};  endnfeat = numel(p.f);if nargout~=1 && nargout~=nfeat    error('gstfeature:inputerror', ...        ['the no. of output arguments must be 1 or equal to the no. ' ...        'of computed features must be equal']);endif ~any(strncmp('norm',p.f,4)) && ~any(strncmp('eigenorm',p.f,4)) && ...        ~isempty(p.eign)        warning('gstfeature:incompatibleparameter',...            'parameter eign ignored for features other than norm');else    p.eign = 'zen'; % default value, may be unusedendtest = ~any(strncmp('orvec',p.f,4)) && ~any(strncmp('vectorial',p.f,4));if test && (~isempty(p.ex) || ~isempty(p.ey))    warning('gstfeature_base:incompatibleparameter',...        'parameters ex,ey ignored for features other than orvec');elseif ~test && isempty(p.ex) && isempty(p.ey)    error('gstfeature_base:incompatibleparameter',...        'parameters ex,ey need to be passed with feature orvec');end%% % main computationvarargout{1} = [];for i=1:nfeat    F = gstfeature_base(gx2, gy2, gxy, p.f{i}, p.eign, p.ex, p.ey);    if nargout==1,  varargout{1} = cat(3, varargout{1}, F);    else            varargout{i} = F;                        endend%%% displayif p.disp    figure,    ncols = min(3,nfeat); nrows = ceil(nfeat/ncols);     for i=1:nfeat        subplot(nrows,ncols,i), imagesc(varargout{i}), axis image off;        title(p.f(i,:)), colormap gray;    endendend % end of gstfeature##### SOURCE END #####-->  </body></html>