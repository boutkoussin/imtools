<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html>  <head>    <meta content="text/html; charset=utf-8" http-equiv="content-type">    <!--This HTML was auto-generated from MATLAB code.To make changes, update the MATLAB code and republish this document.      -->    <title>GSTFEATURE - Feature representation of a tensor field.</title>    <meta name="generator" content="MATLAB 7.11">    <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">    <meta name="DC.date" content="2011-07-08">    <meta name="DC.source" content="gstfeature.m">    <style type="text/css">body {  background-color: white;  margin:10px;}h1 {  color: #990000;   font-size: x-large;}h2 {  color: #990000;  font-size: medium;}/* Make the text shrink to fit narrow windows, but not stretch too far in wide windows. */ p,h1,h2,div.content div {  max-width: 600px;  /* Hack for IE6 */  width: auto !important; width: 600px;}pre.codeinput {  background: #EEEEEE;  padding: 10px;}@media print {  pre.codeinput {word-wrap:break-word; width:100%;}} span.keyword {color: #0000FF}span.comment {color: #228B22}span.string {color: #A020F0}span.untermstring {color: #B20000}span.syscmd {color: #B28C00}pre.codeoutput {  color: #666666;  padding: 10px;}pre.error {  color: red;}p.footer {  text-align: right;  font-size: xx-small;  font-weight: lighter;  font-style: italic;  color: gray;}  </style>  </head>  <body>    <div class="content">      <h1>GSTFEATURE - Feature representation of a tensor field.</h1>      <!--introduction--><!--/introduction-->      <h2>Contents</h2>      <div>        <ul>          <li><a href="#1">Description</a></li>          <li><a href="#2">Syntax</a></li>          <li><a href="#3">Inputs</a></li>          <li><a href="#4">Property [propertyname propertyvalues]</a></li>          <li><a href="#5">Output</a></li>          <li><a href="#6">References</a></li>          <li><a href="#7">Credit</a></li>          <li><a href="#8">See also</a></li>          <li><a href="#9">Function implementation</a></li>        </ul>      </div>      <h2>Description<a name="1"></a></h2>      <p>Derive features like norm, orientation, coherence, inertia... from        tensor representation.</p>      <h2>Syntax<a name="2"></a></h2>      <pre>    f = GSTFEATURE(gx2, gy2, gxy);    [f1, f2, ...] = GSTFEATURE(gx2, gy2, gxy, feature,                   'Property', propertyvalue, ...);    F = GSTFEATURE(gx2, gy2, gxy, feature, 'Property', propertyvalue, ...);</pre>      <h2>Inputs<a name="3"></a></h2>      <p><b><tt>gx2, gy2, gxy</tt></b> : components of a symmetric (structure)        tensor <tt>T</tt>.</p>      <p><b><tt>feature</tt></b> : optional string or cell of strings setting        the feature to be estimated; it is one of the following:</p>      <div>        <ul>          <li><tt>'norm'</tt> for the approximated norm based on the eigenvalues            of the tensor <tt>T</tt>,</li>          <li><tt>'frob'</tt> for the Frobenius norm of the tensor <tt>T</tt>,</li>          <li><tt>'orient'</tt> for the double angle representation of the            tensor <tt>T</tt>,</li>          <li><tt>'orvec'</tt> reoriented field for consistency with the            vectorial field provided by the additional parameters <tt>[ex,ey]</tt>            (see below),</li>          <li><tt>'ordir'</tt> for the direction,</li>          <li><tt>'inert'</tt> for the inertia of the tensor <tt>T</tt>,</li>          <li><tt>'coher'</tt> for computing the coherence (aka anisotropy)            index of the tensor <tt>T</tt>;</li>        </ul>      </div>      <p>or any cell combining those strings (order has no importance); default:        <tt>feature='norm'</tt>.</p>      <h2>Property [propertyname propertyvalues]<a name="4"></a></h2>      <p><b><tt>'eign'</tt></b> : optional string defining the method used for        the tensor's norm approximation; it is either:</p>      <div>        <ul>          <li><tt>'zen'</tt> (or <tt>'l1'</tt>) for the square root of the            largest eigenvalue: <img src="gstfeature_eq62012.png" alt="$\sqrt{l_1}$">,</li>          <li><tt>'sap'</tt> (or <tt>'sum'</tt>) for the sum of the            eigenvalues: <img src="gstfeature_eq32720.png" alt="$\sqrt{l_1+l_2}$">,</li>          <li><tt>'koe'</tt> (or <tt>'dif'</tt>) for the difference of the            eigenvalues: <img src="gstfeature_eq89852.png" alt="$\sqrt{l_1-l_2}$">,</li>          <li><tt>'ndi'</tt> for the normalized difference of the eigenvalues: <img              src="gstfeature_eq27751.png"              alt="$\sqrt{\frac{l_1-l_2}{l_1+l_2}}$">;</li>        </ul>      </div>      <p>default: <tt>eign='l1'</tt>.</p>      <p><b><tt>'ex', 'ey'</tt></b> : optional vectorial field provided by the        vectors <tt>[ex,ey]</tt> used for computing the feature <tt>'orvec'</tt>;        default: <tt>ex=ey=[]</tt>.</p>      <h2>Output<a name="5"></a></h2>      <p><b><tt>f</tt></b> : matrices of features derived from the GST; in the        case one output only is provided and several features are computed, the        features are concatenated into the single output.</p>      <h2>References<a name="6"></a></h2>      <p>[Zenzo86] S. Di Zenzo: "A note on the gradient of a multi-image",        CVGIP, 33:116-125, 1986.</p>      <p>[Cuma91] A. Cumani: "Edge detection in multispectral images", CVGIP:        Graphical Models and Image Processing, 53(1):40-51, 1991.</p>      <p>[VV95] L. van Vliet and P. Verbeek: "Estimators for orientation and        anisotropy in digitized images", Proc. ASCI, pp. 442-450, 1995. <a href="http://reference.kfupm.edu.sa/content/e/s/estimators_for_orientation_and_anisotrop_57847.pdf">http://reference.kfupm.edu.sa/content/e/s/estimators_for_orientation_and_anisotrop_57847.pdf</a></p>      <p>[Kosch95] A. Koschan: "A comparative study on color edge detection",        Proc. ACCV, pp. 574-578, 1995.</p>      <p>[Cuma98] A. Cumani: "Efficient contour extraction in color images",        Proc. ACCV, pp. 582-589, LNCS 1351, 1998.</p>      <p>[Weick98] J. Weickert: "Anisotropic Diffusion in Image Processing",        Teubner-Verlag, Stuttgart (Germany), 1998.</p>      <p>[Kothe03] U. Koethe: "Integrated edge and junction detection with the        boundary tensor", Proc. IEEE ICCV, vol. 1, pp. 424?431, 2003.</p>      <p>[Scheun03] P. Scheunders: "A wavelet representation of multispectral        images", Frontiers of Remote Sensing Information Processing, pp.        197?224. World Scientific, 2003.</p>      <p>[Tschum06] D. Tschumperle: "Fast anisotropic smoothing of multivalued        images using curvature-preserving PDE?s", International Journal of        Computer Vision, 68(1):65?82, 2006.</p>      <p>[WCFTA06] H. Wang, Y. Chen, T. Fang, J. Tyan and N. Ahuja: "Gradient        adaptive image restoration and enhancement", Proc. ICIP, vol. 2, pp.        893-896, 2006.</p>      <h2>See also<a name="8"></a></h2>      <p>Related: <a href="GSTSMOOTH.html"><tt>GSTSMOOTH</tt></a>, <a href="GRD2GST.html"><tt>GRD2GST</tt></a>,        <a href="GSTDECOMP.html"><tt>GSTDECOMP</tt></a>. Called: <a href="GSTFEATURE_BASE.html"><tt>GSTFEATURE_BASE</tt></a>.</p>      <h2>Function implementation<a name="9"></a></h2>      <pre class="codeinput"><span class="keyword">function</span> varargout = gstfeature(gx2, gy2, gxy, varargin)</pre>      <p>parsing parameters</p>      <pre class="codeinput">error(nargchk(1, 18, nargin, <span class="string">'struct'</span>));error(nargoutchk(1, 7, nargout, <span class="string">'struct'</span>));<span class="keyword">if</span> ~(isnumeric(gx2) &amp;&amp; isnumeric(gy2) &amp;&amp; isnumeric(gxy))    error(<span class="string">'gstfeature:inputerror'</span>,<span class="string">'matrices are required in input'</span>);<span class="keyword">end</span>p = createParser(<span class="string">'GSTFEATURE'</span>);   <span class="comment">% create an instance of the inputParser class.</span>p.addOptional(<span class="string">'f'</span>,<span class="string">'norm'</span>, @(x)ischar(x) || iscell(x));<span class="comment">% any(strcmpi(x,{'norm','frob','orient','ordir','reorient','inert','coher'});</span>p.addParamValue(<span class="string">'eign'</span>,[],@(x)ischar(x) &amp;&amp; <spanclass="keyword">...</span>    any(strcmpi(x,{<span class="string">'abs'</span>,<span class="string">'zen'</span>,<spanclass="string">'l1'</span>,<spanclass="string">'sap'</span>,<spanclass="string">'sum'</span>,<spanclass="string">'ndi'</span>,<spanclass="string">'dif'</span>,<spanclass="string">'koe'</span>})));p.addParamValue(<span class="string">'ex'</span>,[],@(x)isnumeric(x));p.addParamValue(<span class="string">'ey'</span>,[],@(x)isnumeric(x));<span class="comment">% parse and validate all input arguments</span>p.parse(varargin{:});p = getvarParser(p);</pre>      <p>internal variables and further testing</p>      <pre class="codeinput"><span class="comment">% check the compatibility of the input parameters</span><span class="keyword">if</span> any(size(gx2)~=size(gy2)) || any(size(gx2)~=size(gxy))    error(<span class="string">'gstfeature:inputerror'</span>,<span class="string">'matrices must have same dimensions'</span>);<span class="keyword">end</span><span class="comment">% % create the list of feature names</span><span class="comment">% if nb_dims(p.f)==2 % then already an array of feature names has been passed</span><span class="comment">%     lfeat = p.f;</span><span class="comment">%</span><span class="comment">% else   % let's create such an array from the concatenate string</span><span class="comment">%     lfeat = str2vsubstr(p.f, ...</span><span class="comment">%         strvcat('eigenorm','norm','frobenius','frob','orientation', ...</span><span class="comment">%         'orient','direction','ordir','vectorial','orvec', ...</span><span class="comment">%         'inertia','inert','coherence','coher'));                       %#ok</span><span class="comment">% end</span><span class="keyword">if</span> ischar(p.f),  p.f = {p.f};  <span class="keyword">end</span>nfeat = numel(p.f);<span class="keyword">if</span> nargout~=1 &amp;&amp; nargout~=nfeat    error(<span class="string">'gstfeature:inputerror'</span>, <span class="keyword">...</span>        [<span class="string">'the no. of output arguments must be 1 or equal to the no. '</span> <spanclass="keyword">...</span>        <span class="string">'of computed features must be equal'</span>]);<span class="keyword">end</span><span class="keyword">if</span> ~any(strncmp(<span class="string">'norm'</span>,p.f,4)) &amp;&amp; ~any(strncmp(<spanclass="string">'eigenorm'</span>,p.f,4)) &amp;&amp; <spanclass="keyword">...</span>        ~isempty(p.eign)        warning(<span class="string">'gstfeature:incompatibleparameter'</span>,<spanclass="keyword">...</span>            <span class="string">'parameter eign ignored for features other than norm'</span>);<span class="keyword">else</span>    p.eign = <span class="string">'zen'</span>; <span class="comment">% default value, may be unused</span><span class="keyword">end</span>test = ~any(strncmp(<span class="string">'orvec'</span>,p.f,4)) &amp;&amp; ~any(strncmp(<spanclass="string">'vectorial'</span>,p.f,4));<span class="keyword">if</span> test &amp;&amp; (~isempty(p.ex) || ~isempty(p.ey))    warning(<span class="string">'gstfeature_base:incompatibleparameter'</span>,<spanclass="keyword">...</span>        <span class="string">'parameters ex,ey ignored for features other than orvec'</span>);<span class="keyword">elseif</span> ~test &amp;&amp; isempty(p.ex) &amp;&amp; isempty(p.ey)    error(<span class="string">'gstfeature_base:incompatibleparameter'</span>,<spanclass="keyword">...</span>        <span class="string">'parameters ex,ey need to be passed with feature orvec'</span>);<span class="keyword">end</span></pre>      <p>main computation</p>      <pre class="codeinput">varargout{1} = [];<span class="keyword">for</span> i=1:nfeat    F = gstfeature_base(gx2, gy2, gxy, p.f{i}, p.eign, p.ex, p.ey);    <span class="keyword">if</span> nargout==1,  varargout{1} = cat(3, varargout{1}, F);    <span class="keyword">else</span>            varargout{i} = F;                        <spanclass="keyword">end</span><span class="keyword">end</span></pre>      <p>display</p>      <pre class="codeinput"><span class="keyword">if</span> p.disp    figure,    ncols = min(3,nfeat); nrows = ceil(nfeat/ncols);    <span class="keyword">for</span> i=1:nfeat        subplot(nrows,ncols,i), imagesc(varargout{i}), axis <span class="string">image</span> <spanclass="string">off</span>;        title(p.f(i,:)), colormap <span class="string">gray</span>;    <span class="keyword">end</span><span class="keyword">end</span></pre>      <pre class="codeinput"><span class="keyword">end</span> <span class="comment">% end of gstfeature</span></pre></div>    <!--##### SOURCE BEGIN #####%% GSTFEATURE - Feature representation of a tensor field.%%% Description% Derive features like norm, orientation, coherence, inertia... from tensor% representation.% %% Syntax%      f = GSTFEATURE(gx2, gy2, gxy);%      [f1, f2, ...] = GSTFEATURE(gx2, gy2, gxy, feature,%                     'Property', propertyvalue, ...);%      F = GSTFEATURE(gx2, gy2, gxy, feature, 'Property', propertyvalue, ...);%%% Inputs% *|gx2, gy2, gxy|* : components of a symmetric (structure) tensor |T|.%% *|feature|* : optional string or cell of strings setting the feature to be%      estimated; it is one of the following: % % * |'norm'| for the approximated norm based on the eigenvalues of the tensor%          |T|,% * |'frob'| for the Frobenius norm of the tensor |T|,% * |'orient'| for the double angle representation of the tensor |T|,% * |'orvec'| reoriented field for consistency with the vectorial field provided%          by the additional parameters |[ex,ey]| (see below),% * |'ordir'| for the direction,% * |'inert'| for the inertia of the tensor |T|,% * |'coher'| for computing the coherence (aka anisotropy) index of the tensor%          |T|;% % or any cell combining those strings (order has no importance); default:%      |feature='norm'|.%%% Property [propertyname  propertyvalues]% *|'eign'|* : optional string defining the method used for the tensor's norm%      approximation; it is either:% % * |'zen'| (or |'l1'|) for the square root of the largest eigenvalue: $\sqrt{l_1}$,% * |'sap'| (or |'sum'|) for the sum of the eigenvalues: $\sqrt{l_1+l_2}$,% * |'koe'| (or |'dif'|) for the difference of the eigenvalues: $\sqrt{l_1-l_2}$,% * |'ndi'| for the normalized difference of the eigenvalues: %            $\sqrt{\frac{l_1-l_2}{l_1+l_2}}$;%% default: |eign='l1'|. %% *|'ex', 'ey'|* : optional vectorial field provided by the vectors |[ex,ey]|%      used for computing the feature |'orvec'|; default: |ex=ey=[]|. %%% Output% *|f|* : matrices of features derived from the GST; in the case one output%     only is provided and several features are computed, the features are%     concatenated into the single output.%%% References% [Zenzo86]  S. Di Zenzo: "A note on the gradient of a multi-image",%      CVGIP, 33:116-125, 1986.%% [Cuma91]  A. Cumani: "Edge detection in multispectral images", CVGIP:%      Graphical Models and Image Processing, 53(1):40-51, 1991.  %% [VV95]   L. van Vliet and P. Verbeek: "Estimators for orientation and %      anisotropy in digitized images", Proc. ASCI, pp. 442-450, 1995. %      http://reference.kfupm.edu.sa/content/e/s/estimators_for_orientation_and_anisotrop_57847.pdf%% [Kosch95]  A. Koschan: "A comparative study on color edge detection",%      Proc. ACCV, pp. 574-578, 1995.%% [Cuma98]  A. Cumani: "Efficient contour extraction in color images", %      Proc. ACCV, pp. 582-589, LNCS 1351, 1998.%% [Weick98]  J. Weickert: "Anisotropic Diffusion in Image Processing",%      Teubner-Verlag, Stuttgart (Germany), 1998.%% [Kothe03]  U. Koethe: "Integrated edge and junction detection with%      the boundary tensor", Proc. IEEE ICCV, vol. 1, pp. 424?431, 2003.%% [Scheun03]  P. Scheunders: "A wavelet representation of multispectral%      images", Frontiers of Remote Sensing Information Processing, pp.%      197?224. World Scientific, 2003.%% [Tschum06]  D. Tschumperle: "Fast anisotropic smoothing of multivalued%      images using curvature-preserving PDE?s", International Journal of%      Computer Vision, 68(1):65?82, 2006.%% [WCFTA06]  H. Wang, Y. Chen, T. Fang, J. Tyan and N. Ahuja: "Gradient %      adaptive image restoration and enhancement", Proc. ICIP, vol. 2, %      pp. 893-896, 2006.%%% Credit% <mailto:grazzja@lanl.gov J.Grazzini> (ISR-2/LANL)%%% See also% Related:% <GSTSMOOTH.html |GSTSMOOTH|>,% <GRD2GST.html |GRD2GST|>,% <GSTDECOMP.html |GSTDECOMP|>.% Called:% <GSTFEATURE_BASE.html |GSTFEATURE_BASE|>.%% Function implementationfunction varargout = gstfeature(gx2, gy2, gxy, varargin)%%% parsing parameterserror(nargchk(1, 18, nargin, 'struct'));error(nargoutchk(1, 7, nargout, 'struct'));if ~(isnumeric(gx2) && isnumeric(gy2) && isnumeric(gxy))    error('gstfeature:inputerror','matrices are required in input');endp = createParser('GSTFEATURE');   % create an instance of the inputParser class.p.addOptional('f','norm', @(x)ischar(x) || iscell(x)); % any(strcmpi(x,{'norm','frob','orient','ordir','reorient','inert','coher'});p.addParamValue('eign',[],@(x)ischar(x) && ...    any(strcmpi(x,{'abs','zen','l1','sap','sum','ndi','dif','koe'})));p.addParamValue('ex',[],@(x)isnumeric(x));p.addParamValue('ey',[],@(x)isnumeric(x));% parse and validate all input argumentsp.parse(varargin{:}); p = getvarParser(p);                                                            %% % internal variables and further testing% check the compatibility of the input parametersif any(size(gx2)~=size(gy2)) || any(size(gx2)~=size(gxy))    error('gstfeature:inputerror','matrices must have same dimensions');end% % create the list of feature names% if nb_dims(p.f)==2 % then already an array of feature names has been passed%     lfeat = p.f;%     % else   % let's create such an array from the concatenate string%     lfeat = str2vsubstr(p.f, ...%         strvcat('eigenorm','norm','frobenius','frob','orientation', ...%         'orient','direction','ordir','vectorial','orvec', ...%         'inertia','inert','coherence','coher'));                       %#ok% endif ischar(p.f),  p.f = {p.f};  endnfeat = numel(p.f);if nargout~=1 && nargout~=nfeat    error('gstfeature:inputerror', ...        ['the no. of output arguments must be 1 or equal to the no. ' ...        'of computed features must be equal']);endif ~any(strncmp('norm',p.f,4)) && ~any(strncmp('eigenorm',p.f,4)) && ...        ~isempty(p.eign)        warning('gstfeature:incompatibleparameter',...            'parameter eign ignored for features other than norm');else    p.eign = 'zen'; % default value, may be unusedendtest = ~any(strncmp('orvec',p.f,4)) && ~any(strncmp('vectorial',p.f,4));if test && (~isempty(p.ex) || ~isempty(p.ey))    warning('gstfeature_base:incompatibleparameter',...        'parameters ex,ey ignored for features other than orvec');elseif ~test && isempty(p.ex) && isempty(p.ey)    error('gstfeature_base:incompatibleparameter',...        'parameters ex,ey need to be passed with feature orvec');end%% % main computationvarargout{1} = [];for i=1:nfeat    F = gstfeature_base(gx2, gy2, gxy, p.f{i}, p.eign, p.ex, p.ey);    if nargout==1,  varargout{1} = cat(3, varargout{1}, F);    else            varargout{i} = F;                        endend%%% displayif p.disp    figure,    ncols = min(3,nfeat); nrows = ceil(nfeat/ncols);     for i=1:nfeat        subplot(nrows,ncols,i), imagesc(varargout{i}), axis image off;        title(p.f(i,:)), colormap gray;    endendend % end of gstfeature##### SOURCE END #####-->  </body></html>