<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html>  <head>    <meta content="text/html; charset=utf-8" http-equiv="content-type">    <!--This HTML was auto-generated from MATLAB code.To make changes, update the MATLAB code and republish this document.      -->    <title>GRD2GST - Gradient Structure Tensor from directional derivatives.</title>    <meta name="generator" content="MATLAB 7.14">    <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">    <meta name="DC.date" content="2012-11-14">    <meta name="DC.source" content="grd2gst.m">    <style type="text/css">html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}html { min-height:100%; margin-bottom:1px; }html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }html body td { vertical-align:top; text-align:left; }h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }a { color:#005fce; text-decoration:none; }a:hover { color:#005fce; text-decoration:underline; }a:visited { color:#004aa0; text-decoration:none; }p { padding:0px; margin:0px 0px 20px; }img { padding:0px; margin:0px 0px 20px; border:none; }p img, pre img, tt img, li img { margin-bottom:0px; } ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }ul li { padding:0px; margin:0px 0px 7px 0px; }ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }ul li ol li { list-style:decimal; }ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }ol li ol li { list-style-type:lower-alpha; }ol li ul { padding-top:7px; }ol li ul li { list-style:square; }.content { font-size:1.2em; line-height:140%; padding: 20px; }pre, tt, code { font-size:12px; }pre { margin:0px 0px 20px; }pre.error { color:red; }pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }span.keyword { color:#0000FF }span.comment { color:#228B22 }span.string { color:#A020F0 }span.untermstring { color:#B20000 }span.syscmd { color:#B28C00 }.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }.footer p { margin:0px; }  </style>  </head>  <body>    <div class="content">      <h1>GRD2GST - Gradient Structure Tensor from directional derivatives.</h1>      <!--introduction--><!--/introduction-->      <h2>Contents</h2>      <div>        <ul>          <li><a href="#1">Description</a></li>          <li><a href="#2">Syntax</a></li>          <li><a href="#3">Inputs</a></li>          <li><a href="#4">Property [propertyname propertyvalues]</a></li>          <li><a href="#5">Outputs</a></li>          <li><a href="#6">References</a></li>          <li><a href="#8">See also</a></li>          <li><a href="#9">Function implementation</a></li>        </ul>      </div>      <h2>Description<a name="1"></a></h2>      <p>Compute the entries of a (symmetric) gradient structure tensor (GST,        aka second moment matrix, scatter matrix, Forstner interest operator) of        an image from its directional derivatives:</p>      <pre>     GST = conv ( G(rho), grad(I) * grad(I)^T )</pre>      <p>where grad(I) is given by [gx,gy] and G(rho) is a (possibly        anisotropic) Gaussian kernel of scale rho.</p>      <h2>Syntax<a name="2"></a></h2>      <pre>     [gx2, gy2, gxy] = GRD2GST(gx, gy);     [gx2, gy2, gxy] = GRD2GST(gx, gy, rho, int);     [gx2, gy2, gxy, mag, or] = ...               GRD2GST(gx, gy, rho, int, 'Property',propertyvalue, ...);</pre>      <h2>Inputs<a name="3"></a></h2>      <p><b><tt>I</tt></b> : an image with size <tt>(X,Y,C)</tt>, where <tt>C&gt;1</tt>        when <tt>I</tt> is multichannel.</p>      <p><b><tt>gx, gy</tt></b> : directional derivatives; depending on        parameter <tt>axis</tt> (see below), <tt>gx</tt> and <tt>gy</tt> are        either:</p>      <div>        <ul>          <li>the derivatives in I-(vertical oriented NS) and J-(horizontal            oriented OE), like matlab coordinates, when <tt>axis='ij'</tt>            (default), or</li>          <li>the derivatives in X-(horizontal oriented OE) and Y-(vertical            oriented SN) directions when <tt>axis='xy'</tt>;</li>        </ul>      </div>      <p>typically, derivatives can be estimated using <tt>[gy,gx]=GRADIENT(I)</tt>        or <tt>[gx,gy]=GRDSMOOTH(I,...,'axis','ij')</tt>.</p>      <p><b><tt>rho</tt></b> : post-smoothing standard deviation; this parameter        sets the integration scale for spatial averaging, that controls the size        of the neigxbourhood in which an orientation is dominant; it is used for        averaging the partial directional derivatives of the tensor with a        Gaussian kernel; if <tt>rho&lt;0.05</tt>, then no smoothing is        performed; default: <tt>rho=1</tt>.</p>      <p><b><tt>int</tt></b> : optional string setting the method used for        integrating (spatially averaging) the GST; smoothing is applied, which        can be either isotropic, performed in local isotropic neighbourhoods, by        setting it to:</p>      <div>        <ul>          <li><tt>'fast'</tt> for the (fast) 2D Gaussian smoothing with <tt>IMGAUSSIAN</tt>,</li>          <li><tt>'conv'</tt> for the 2D Gaussian filtering with <tt>GAUSSKERNEL</tt>            and <tt>CONVOLUTION</tt>,</li>          <li><tt>'matlab'</tt> for a Matlab-like implementation of the 2D            smoothing with <tt>FSPECIAL</tt> and <tt>IMFILTER</tt>,</li>        </ul>      </div>      <p>or anisotropic, to better capture edges anisotropy, by setting it to:</p>      <div>        <ul>          <li><tt>'ani'</tt> for anisotropic Gaussian filtering along the edges            with <tt>HOURGLASSKERNEL</tt> for defining hourglass shaped            Gaussian kernels;</li>        </ul>      </div>      <p>if no smoothing needs to be performed, <tt>int</tt> can be set to <tt>false</tt>:        this is equivalent to setting <tt>rho=0</tt>; default: <tt>int='fast'</tt>        or, equivalently, <tt>int=true</tt>; see function <tt>SMOOTHFILT</tt>.</p>      <h2>Property [propertyname propertyvalues]<a name="4"></a></h2>      <p><b><tt>'axis'</tt></b> : string indicating the direction/orientation of        the input directional derivatives (see above); in particular, calls to <tt>GRD2GST(gx,gy,...,'axis','ij')</tt>        and <tt>GRD2GST(gy,-gx,...,'axis','xy')</tt> are equivalent; default: <tt>axis='ij'</tt>,        ie. the vector orthogonal to the (real) gradient is passed.</p>      <p><b><tt>'hsize'</tt></b> : optional filter size; it is estimated        depending on <tt>rho</tt>, typically <tt>hsize=6*rho+1</tt>; default:        <tt>hsize=[]</tt>, calculated later on.</p>      <p><b><tt>'samp'</tt></b> : if the gradients are interpolated to avoid        aliasing the filters, need to be adapted using this sampling factor;        default: <tt>samp=1</tt>.</p>      <p><b><tt>'eign'</tt></b> : in the case the tensor norm estimated from the        eigenvalues (l1 and l2, with l1&gt;l2) is returned (<tt>nargin&gt;=3</tt>),        the string <tt>eign</tt> defines the method used for its approximation;        it is either (see <tt>GSTFEATURE</tt>): <tt>'abs'</tt>, <tt>'l1'</tt>        (or <tt>'zen'</tt>), <tt>'sum'</tt> (or <tt>'sap'</tt>), <tt>'dif'</tt>        (or <tt>'koe'</tt>) or <tt>'ndi'</tt>; default: <tt>eign='l1'</tt>.</p>      <p><b><tt>'thez', 'sigt'</tt></b> : parameters used by the anisotropic        filtering with hourglass filters (see <tt>HOUGLASSKERNEL</tt>);        default: <tt>thez=8</tt>, <tt>sigt=.4</tt>.</p>      <p><b><tt>'tn'</tt></b> : optional flag (<tt>true</tt> or <tt>false</tt>)        to normalize the tensor prior to its smoothing; default: <tt>tn=false</tt>.</p>      <h2>Outputs<a name="5"></a></h2>      <p><b><tt>gx2, gy2, gxy</tt></b> : matrices storing the entries of the        GST:</p>      <pre>                 | gx2   gxy |         GST  =  |           |                 | gxy   gy2 |</pre>      <p><b><tt>mag</tt></b> : optional output providing the norm of the tensor.</p>      <p><b><tt>or</tt></b> : optional output storing the orientation of the        tensor; the double angle representation is used, therefore or in <img src="grd2gst_eq00487.png"          alt="$[-\pi/2,\pi/2]$">.</p>      <h2>References<a name="6"></a></h2>      <p>[Zenzo86] S. Di Zenzo: "A note on the gradient of a multi-image",        CVGIP, 33:116-125, 1986. <a href="http://www.sciencedirect.com/science/article/pii/0734189X86902239">http://www.sciencedirect.com/science/article/pii/0734189X86902239</a></p>      <p>[Cuma91] A. Cumani: "Edge detection in multispectral images", CVGIP:        Graphical Models and Image Processing, 53(1):40-51, 1991. <a href="http://www.sciencedirect.com/science/article/pii/104996529190018F">http://www.sciencedirect.com/science/article/pii/104996529190018F</a></p>      <p>[VV95] L. van Vliet and P. Verbeek: "Estimators for orientation and        anisotropy in digitized images", Proc. ASCI, pp. 442-450, 1995. <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.104.8552">http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.104.8552</a></p>      <p>[Kosch95] A. Koschan: "A comparative study on color edge detection",        Proc. ACCV, pp. 574-578, 1995. <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.31.2648">http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.31.2648</a></p>      <p>[Cuma98] A. Cumani: "Efficient contour extraction in color images",        Proc. ACCV, pp. 582-589, LNCS 1351, 1998. <a href="http://www.springerlink.com/content/c1750730487puqm0/">http://www.springerlink.com/content/c1750730487puqm0/</a></p>      <p>[TD01] D. Tschumperle and R. Deriche: "Constrained and unconstrained        PDE's for vector image restoration", Proc. SCIA, pp. 153-160, 2001. <a          href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.22.4098">http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.22.4098</a></p>      <p>[TD02] D. Tschumperle and R. Deriche: "Diffusion PDE's on vector-valued        images", IEEE Signal Processing Magazine, 19(5):16-25, 2002. <a href="http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=1028349">http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=1028349</a></p>      <p>[Scheun03] P. Scheunders: "A wavelet representation of multispectral        images", Frontiers of Remote Sensing Information Processing, pp.        197-224. World Scientific, 2003. <a href="http://ebooks.worldscinet.com/ISBN/9789812796752/9789812796752_0009.html">http://ebooks.worldscinet.com/ISBN/9789812796752/9789812796752_0009.html</a></p>      <p>[Tschum06] D. Tschumperle: "Fast anisotropic smoothing of multivalued        images using curvature-preserving PDE's", International Journal of        Computer Vision, 68(1):65-82, 2006. <a href="http://www.springerlink.com/content/5217329131181uh4/">http://www.springerlink.com/content/5217329131181uh4/</a></p>      <h2>See also<a name="8"></a></h2>      <p>Related: <a href="GRDSMOOTH.html"><tt>GRDSMOOTH</tt></a>, <a href="GSTSMOOTH.html"><tt>GSTSMOOTH</tt></a>,        <a href="../../filter/html/SMOOTHFILT.html"><tt>SMOOTHFILT</tt></a>.        Called: <a href="GRD2GST_BASE.html"><tt>GRD2GST_BASE</tt></a>.</p>      <h2>Function implementation<a name="9"></a></h2>      <pre class="codeinput"><span class="keyword">function</span> [gx2, gy2, gxy, varargout] = grd2gst(gx, gy, varargin)</pre>      <p>parsing and checking parameters</p>      <pre class="codeinput">error(nargchk(2, 26, nargin, <span class="string">'struct'</span>));error(nargoutchk(3, 5, nargout, <span class="string">'struct'</span>));<span class="keyword">if</span> ~(isnumeric(gx) &amp;&amp; isnumeric(gy))    error(<span class="string">'grd2gst:inputerror'</span>,<span class="string">'matrices are required in input'</span>);<span class="keyword">end</span>p = createParser(<span class="string">'GRD2GST'</span>);   <span class="comment">% create an instance of the inputParser class.</span><span class="comment">% optional parameters</span>p.addOptional(<span class="string">'rho'</span>,1., @(x)x&gt;=0); <span class="comment">% just for testing</span>p.addOptional(<span class="string">'int'</span>, <span class="string">'fast'</span>, @(x)islogical(x) || (ischar(x) &amp;&amp; <spanclass="keyword">...</span>    any(strcmpi(x,{<span class="string">'matlab'</span>,<span class="string">'conv'</span>,<spanclass="string">'fast'</span>,<spanclass="string">'ani'</span>}))));p.addParamValue(<span class="string">'hsize'</span>,[], @(x)isscalar(x) || isempty(x));p.addParamValue(<span class="string">'samp'</span>,1, @(x)isscalar(x) &amp;&amp; round(x)==x &amp;&amp; x&gt;=1);p.addParamValue(<span class="string">'tn'</span>, false, @(x)islogical(x));p.addParamValue(<span class="string">'thez'</span>, 8, @(x)isscalar(x) &amp;&amp; round(x)==x);p.addParamValue(<span class="string">'sigt'</span>, .4, @(x)isscalar(x) &amp;&amp; isfloat(x) &amp;&amp; x&gt;0);p.addParamValue(<span class="string">'axis'</span>,<span class="string">'ij'</span>,@(x)ischar(x) &amp;&amp; any(strcmpi(x,{<spanclass="string">'ij'</span>,<spanclass="string">'xy'</span>})));p.addParamValue(<span class="string">'eign'</span>,<span class="string">'l1'</span>,@(x)ischar(x) &amp;&amp; <spanclass="keyword">...</span>    any(strcmpi(x,{<span class="string">'abs'</span>,<span class="string">'zen'</span>,<spanclass="string">'l1'</span>,<spanclass="string">'sap'</span>,<spanclass="string">'sum'</span>,<spanclass="string">'ndi'</span>,<spanclass="string">'dif'</span>,<spanclass="string">'koe'</span>})));<span class="comment">% parse and validate all input arguments</span>p.parse(varargin{:});p = getvarParser(p);</pre>      <p>checking parameters and setting variable</p>      <pre class="codeinput"><span class="keyword">if</span> size(gx) ~= size(gy)    error(<span class="string">'grd2gst:inputerror'</span>,<span class="string">'matrices must have same dimensions'</span>);<span class="keyword">end</span><span class="keyword">if</span> strcmp(p.axis,<span class="string">'ij'</span>)    <span class="comment">% take the vector orthogonal to the input gradient</span>    tmp = gx; gx = gy; gy = -tmp;    <span class="comment">% otherwise: horizontal OE and vertical SN derivatives have been passed</span>    <span class="comment">% in gx and gy resp.</span><span class="keyword">end</span><span class="keyword">if</span> islogical(p.int) &amp;&amp; p.int,  p.int = <spanclass="string">'fast'</span>;  <spanclass="keyword">end</span> <spanclass="comment">% reset to default</span></pre>      <p>main computation</p>      <pre class="codeinput"><span class="keyword">if</span> nargout == 3    [gx2, gy2, gxy] = grd2gst_base(gx, gy, p.rho, p.int, p.hsize, <span class="keyword">...</span>        p.samp, p.tn, p.thez, p.sigt, p.eign);<span class="keyword">else</span>    [gx2, gy2, gxy, mag, or] = grd2gst_base(gx, gy, p.rho, p.int, p.hsize, <spanclass="keyword">...</span>        p.samp, p.tn, p.thez, p.sigt, p.eign);    varargout{1} = mag;    <span class="keyword">if</span> nargout == 5, varargout{2} = or;  <span class="keyword">end</span>;<span class="keyword">end</span></pre>      <p>display</p>      <pre class="codeinput"><span class="keyword">if</span> p.disp    figure,    ncols = 3; <span class="keyword">if</span> nargout==3,  nrows = 1; <span class="keyword">else</span> nrows = 2;  <spanclass="keyword">end</span>    subplot(nrows,ncols,1), imagesc(rescale(gx2,0,1)), axis <span class="string">image</span> <spanclass="string">off</span>,    title([<span class="string">'g_x^2 - axis '''</span> p.axis <span class="string">''''</span>]); colormap <spanclass="string">gray</span>;    subplot(nrows,ncols,2), imagesc(rescale(gy2,0,1)), axis <span class="string">image</span> <spanclass="string">off</span>,    title([<span class="string">'g_y^2 - axis '''</span> p.axis <span class="string">''''</span>]); colormap <spanclass="string">gray</span>;    subplot(nrows,ncols,3), imagesc(rescale(gxy,0,1)), axis <span class="string">image</span> <spanclass="string">off</span>,    title([<span class="string">'g_x \cdot g_y - axis '''</span> p.axis <span class="string">''''</span>]); colormap <spanclass="string">gray</span>;    <span class="keyword">if</span> nargout&gt;=4        subplot(nrows,ncols,4), imagesc(rescale(mag,0,1)), axis <span class="string">image</span> <spanclass="string">off</span>,        title(<span class="string">'mag'</span>), colormap <span class="string">gray</span>        subplot(2,3,5), imagesc(rescale(or,0,1)), axis <span class="string">image</span> <spanclass="string">off</span>,        title(<span class="string">'or'</span>), colormap <span class="string">gray</span>    <span class="keyword">end</span><span class="keyword">end</span></pre>      <pre class="codeinput"><span class="keyword">end</span> <span class="comment">% end of grd2gst</span></pre></div>    <!--##### SOURCE BEGIN #####%% GRD2GST - Gradient Structure Tensor from directional derivatives.%%% Description% Compute the entries of a (symmetric) gradient structure tensor (GST, aka% second moment matrix, scatter matrix, Forstner interest operator) of an% image from its directional derivatives:%%       GST = conv ( G(rho), grad(I) * grad(I)^T )%% where grad(I) is given by [gx,gy] and G(rho) is a (possibly anisotropic)% Gaussian kernel of scale rho.% %% Syntax%       [gx2, gy2, gxy] = GRD2GST(gx, gy);%       [gx2, gy2, gxy] = GRD2GST(gx, gy, rho, int);%       [gx2, gy2, gxy, mag, or] = ...%                 GRD2GST(gx, gy, rho, int, 'Property',propertyvalue, ...);% %% Inputs% *|I|* : an image with size |(X,Y,C)|, where |C>1| when |I| is multichannel.%% *|gx, gy|* : directional derivatives; depending on parameter |axis| (see%      below), |gx| and |gy| are either:%% * the derivatives in I-(vertical oriented NS) and J-(horizontal oriented %          OE), like matlab coordinates, when |axis='ij'| (default), or% * the derivatives in X-(horizontal oriented OE) and Y-(vertical oriented %          SN) directions when |axis='xy'|; % % typically, derivatives can be estimated using |[gy,gx]=GRADIENT(I)| or %      |[gx,gy]=GRDSMOOTH(I,...,'axis','ij')|.%% *|rho|* : post-smoothing standard deviation; this parameter sets the%     integration scale for spatial averaging, that controls the size of %     the neigxbourhood in which an orientation is dominant; it is used for %     averaging the partial directional derivatives of the tensor with a%     Gaussian kernel; if |rho<0.05|, then no smoothing is performed; default: %     |rho=1|.%% *|int|* : optional string setting the method used for integrating (spatially%     averaging) the GST; smoothing is applied, which can be either isotropic,%     performed in local isotropic neighbourhoods, by setting it to:%% * |'fast'| for the (fast) 2D Gaussian smoothing with |IMGAUSSIAN|,% * |'conv'| for the 2D Gaussian filtering with |GAUSSKERNEL| and |CONVOLUTION|, % * |'matlab'| for a Matlab-like implementation of the 2D smoothing with%          |FSPECIAL| and |IMFILTER|,%% or anisotropic, to better capture edges anisotropy, by setting it to:% % * |'ani'| for anisotropic Gaussian filtering along the edges with%          |HOURGLASSKERNEL| for defining hourglass shaped Gaussian kernels;%% if no smoothing needs to be performed, |int| can be set to |false|: this%     is equivalent to setting |rho=0|; default: |int='fast'| or, equivalently,%     |int=true|; see function |SMOOTHFILT|.% %% Property [propertyname  propertyvalues]% *|'axis'|* : string indicating the direction/orientation of the input%     directional derivatives (see above); in particular, calls to%     |GRD2GST(gx,gy,...,'axis','ij')| and |GRD2GST(gy,-gx,...,'axis','xy')| %     are equivalent; default: |axis='ij'|, ie. the vector orthogonal to the%     (real) gradient is passed.%% *|'hsize'|* : optional filter size; it is estimated depending on |rho|, %     typically |hsize=6*rho+1|; default: |hsize=[]|, calculated later on.%   % *|'samp'|* : if the gradients are interpolated to avoid aliasing the filters,%     need to be adapted using this sampling factor; default: |samp=1|.%% *|'eign'|* : in the case the tensor norm estimated from the eigenvalues (l1%     and l2, with l1>l2) is returned (|nargin>=3|), the string |eign| defines%     the method used for its approximation; it is either (see |GSTFEATURE|):  %     |'abs'|, |'l1'| (or |'zen'|), |'sum'| (or |'sap'|), |'dif'| (or |'koe'|)%     or |'ndi'|; default: |eign='l1'|. %% *|'thez', 'sigt'|* : parameters used by the anisotropic filtering with%     hourglass filters (see |HOUGLASSKERNEL|); default: |thez=8|, |sigt=.4|.%% *|'tn'|* : optional flag (|true| or |false|) to normalize the tensor prior%     to its smoothing; default: |tn=false|.% %% Outputs% *|gx2, gy2, gxy|* : matrices storing the entries of the GST: %%                   | gx2   gxy |%           GST  =  |           |     %                   | gxy   gy2 |%% *|mag|* : optional output providing the norm of the tensor.%% *|or|* : optional output storing the orientation of the tensor; the double%      angle representation is used, therefore or in $[-\pi/2,\pi/2]$.%%% References% [Zenzo86]  S. Di Zenzo: "A note on the gradient of a multi-image",%      CVGIP, 33:116-125, 1986.%      <http://www.sciencedirect.com/science/article/pii/0734189X86902239>%% [Cuma91]  A. Cumani: "Edge detection in multispectral images", CVGIP:%      Graphical Models and Image Processing, 53(1):40-51, 1991.  %      <http://www.sciencedirect.com/science/article/pii/104996529190018F>%% [VV95]   L. van Vliet and P. Verbeek: "Estimators for orientation and %      anisotropy in digitized images", Proc. ASCI, pp. 442-450, 1995. %      <http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.104.8552>%% [Kosch95]  A. Koschan: "A comparative study on color edge detection",%      Proc. ACCV, pp. 574-578, 1995.%      <http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.31.2648>%% [Cuma98]  A. Cumani: "Efficient contour extraction in color images", %      Proc. ACCV, pp. 582-589, LNCS 1351, 1998.%      <http://www.springerlink.com/content/c1750730487puqm0/>%% [TD01]  D. Tschumperle and R. Deriche: "Constrained and unconstrained%      PDE's for vector image restoration", Proc. SCIA, pp. 153-160, 2001.%      <http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.22.4098>%% [TD02]  D. Tschumperle and R. Deriche: "Diffusion PDE's on vector-valued%      images", IEEE Signal Processing Magazine, 19(5):16-25, 2002. %      <http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=1028349>%% [Scheun03]  P. Scheunders: "A wavelet representation of multispectral%      images", Frontiers of Remote Sensing Information Processing, pp.%      197-224. World Scientific, 2003.%      <http://ebooks.worldscinet.com/ISBN/9789812796752/9789812796752_0009.html>%% [Tschum06]  D. Tschumperle: "Fast anisotropic smoothing of multivalued%      images using curvature-preserving PDE's", International Journal of%      Computer Vision, 68(1):65-82, 2006.%      <http://www.springerlink.com/content/5217329131181uh4/>%%% Credit% <mailto:grazzja@lanl.gov J.Grazzini> (ISR-2/LANL)%%% See also  % Related:% <GRDSMOOTH.html |GRDSMOOTH|>,% <GSTSMOOTH.html |GSTSMOOTH|>,% <../../filter/html/SMOOTHFILT.html |SMOOTHFILT|>.% Called:% <GRD2GST_BASE.html |GRD2GST_BASE|>.%% Function implementationfunction [gx2, gy2, gxy, varargout] = grd2gst(gx, gy, varargin)%%% parsing and checking parameterserror(nargchk(2, 26, nargin, 'struct'));error(nargoutchk(3, 5, nargout, 'struct'));if ~(isnumeric(gx) && isnumeric(gy))    error('grd2gst:inputerror','matrices are required in input');endp = createParser('GRD2GST');   % create an instance of the inputParser class.% optional parametersp.addOptional('rho',1., @(x)x>=0); % just for testingp.addOptional('int', 'fast', @(x)islogical(x) || (ischar(x) && ...    any(strcmpi(x,{'matlab','conv','fast','ani'}))));p.addParamValue('hsize',[], @(x)isscalar(x) || isempty(x));p.addParamValue('samp',1, @(x)isscalar(x) && round(x)==x && x>=1);p.addParamValue('tn', false, @(x)islogical(x));p.addParamValue('thez', 8, @(x)isscalar(x) && round(x)==x);p.addParamValue('sigt', .4, @(x)isscalar(x) && isfloat(x) && x>0);p.addParamValue('axis','ij',@(x)ischar(x) && any(strcmpi(x,{'ij','xy'})));p.addParamValue('eign','l1',@(x)ischar(x) && ...    any(strcmpi(x,{'abs','zen','l1','sap','sum','ndi','dif','koe'})));% parse and validate all input argumentsp.parse(varargin{:}); p = getvarParser(p);                                                            %% % checking parameters and setting variableif size(gx) ~= size(gy)    error('grd2gst:inputerror','matrices must have same dimensions');endif strcmp(p.axis,'ij')    % take the vector orthogonal to the input gradient    tmp = gx; gx = gy; gy = -tmp;    % otherwise: horizontal OE and vertical SN derivatives have been passed    % in gx and gy resp.endif islogical(p.int) && p.int,  p.int = 'fast';  end % reset to default%% % main computationif nargout == 3    [gx2, gy2, gxy] = grd2gst_base(gx, gy, p.rho, p.int, p.hsize, ...        p.samp, p.tn, p.thez, p.sigt, p.eign);else        [gx2, gy2, gxy, mag, or] = grd2gst_base(gx, gy, p.rho, p.int, p.hsize, ...        p.samp, p.tn, p.thez, p.sigt, p.eign);    varargout{1} = mag;    if nargout == 5, varargout{2} = or;  end;    end%%% displayif p.disp    figure,    ncols = 3; if nargout==3,  nrows = 1; else nrows = 2;  end    subplot(nrows,ncols,1), imagesc(rescale(gx2,0,1)), axis image off,    title(['g_x^2 - axis ''' p.axis '''']); colormap gray;    subplot(nrows,ncols,2), imagesc(rescale(gy2,0,1)), axis image off,    title(['g_y^2 - axis ''' p.axis '''']); colormap gray;    subplot(nrows,ncols,3), imagesc(rescale(gxy,0,1)), axis image off,    title(['g_x \cdot g_y - axis ''' p.axis '''']); colormap gray;    if nargout>=4        subplot(nrows,ncols,4), imagesc(rescale(mag,0,1)), axis image off,        title('mag'), colormap gray        subplot(2,3,5), imagesc(rescale(or,0,1)), axis image off,        title('or'), colormap gray    endendend % end of grd2gst##### SOURCE END #####-->  </body></html>