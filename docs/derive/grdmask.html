<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html>  <head>    <meta content="text/html; charset=utf-8" http-equiv="content-type">    <!--This HTML was auto-generated from MATLAB code.To make changes, update the MATLAB code and republish this document.      -->    <title>GRDMASK - Mask-based directional derivatives of an image.</title>    <meta name="generator" content="MATLAB 7.11">    <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">    <meta name="DC.date" content="2011-07-08">    <meta name="DC.source" content="grdmask.m">    <style type="text/css">body {  background-color: white;  margin:10px;}h1 {  color: #990000;   font-size: x-large;}h2 {  color: #990000;  font-size: medium;}/* Make the text shrink to fit narrow windows, but not stretch too far in wide windows. */ p,h1,h2,div.content div {  max-width: 600px;  /* Hack for IE6 */  width: auto !important; width: 600px;}pre.codeinput {  background: #EEEEEE;  padding: 10px;}@media print {  pre.codeinput {word-wrap:break-word; width:100%;}} span.keyword {color: #0000FF}span.comment {color: #228B22}span.string {color: #A020F0}span.untermstring {color: #B20000}span.syscmd {color: #B28C00}pre.codeoutput {  color: #666666;  padding: 10px;}pre.error {  color: red;}p.footer {  text-align: right;  font-size: xx-small;  font-weight: lighter;  font-style: italic;  color: gray;}  </style>  </head>  <body>    <div class="content">      <h1>GRDMASK - Mask-based directional derivatives of an image.</h1>      <!--introduction--><!--/introduction-->      <h2>Contents</h2>      <div>        <ul>          <li><a href="#1">Description</a></li>          <li><a href="#2">Syntax</a></li>          <li><a href="#3">Inputs</a></li>          <li><a href="#4">Outputs</a></li>          <li><a href="#5">References</a></li>          <li><a href="#6">Acknowledgments:</a></li>          <li><a href="#7">Credit</a></li>          <li><a href="#8">See also</a></li>          <li><a href="#9">Function implementation</a></li>        </ul>      </div>      <h2>Description<a name="1"></a></h2>      <p>Apply classical gradient operators using local difference masks.</p>      <h2>Syntax<a name="2"></a></h2>      <pre>  [Gx,Gy] = GRDMASK(I);  [Gx,Gy] = GRDMASK(I, method, map, axis);</pre>      <h2>Inputs<a name="3"></a></h2>      <p><b><tt>I</tt></b> : input 2D image with size <tt>(X,Y,C)</tt>, with <tt>C&gt;1</tt>        for multispectral image.</p>      <p><b><tt>method</tt></b> : (optional) parameter defining the original <tt>(3,3)</tt>        gradient mask used for estimating the directional derivatives [GW02];        classical masks include: * <tt>'sob'</tt> or <tt>'sobel'</tt> for        Sobel masks in i- and j-directions (see option <tt>axis</tt> below), *        <tt>'kir'</tt> or <tt>'kirsch'</tt> for Kirsch mask, * <tt>'prew'</tt>        or <tt>'prewitt'</tt> for Prewitt mask, * <tt>'iso'</tt> or <tt>'isotropic'</tt>        for Frei-Chen's isotropic mask, * <tt>'opt'</tt> or <tt>'optimal'</tt>        for Ando's optimal mask, * <tt>'ori'</tt> or <tt>'orientation'</tt>        for optimized orientation invariant filter, * <tt>'circ'</tt> or <tt>'circular'</tt>        for Davies' circular mask, * <tt>'rob'</tt> or <tt>'robinson'</tt> for        Robinson mask,</p>      <p>finite difference schemes are also implemented as:</p>      <div>        <ul>          <li><tt>'matlab', 'diff'</tt> or <tt>'difference'</tt> when central            differences are computed (using Matlab function <tt>GRADIENT</tt>),</li>          <li><tt>'for'</tt> or <tt>'forward'</tt> for forward differences,</li>          <li><tt>'back'</tt> or <tt>'kackward'</tt> for backward differences,</li>        </ul>      </div>      <p>but are not very accurate when further used for the detection of edges        that are at angles other than vertical or horizontal [Fleck92],        therefore improvements have been proposed in [FS04] and are here        implemented through the call to P.Kovesi's functions [KOVESI] as:</p>      <div>        <ul>          <li><tt>'tap5'</tt> or <tt>'derivative5'</tt> using 5-tap            coefficients,</li>          <li><tt>'tap7'</tt> or <tt>'derivative7'</tt> using 7-tap            coefficients;</li>        </ul>      </div>      <pre>    default: |method='sob'|.</pre>      <p><b><tt>map</tt></b> : (optional) logical map (with size <tt>(X,Y)</tt>)        defining the pixels of the input image domain where the gradient is to        be computed; set to false where no gradient needs to be output; in this        case, the function <tt>GRDMASKMAP_BASE</tt> is called; default: <tt>map=[]</tt>,        ie. considered to be true everywhere and the function <tt>GRDMASK_BASE</tt>        is called.</p>      <p><b><tt>axis</tt></b> : (optional) string indicating the        direction/orientation of the output directional derivatives, it is        either <tt>'ij'</tt> or <tt>'xy'</tt>; default: <tt>axis='ij'</tt>        (right-handed coordinate system), ie. the vector orthogonal to the        (real) gradient is output: <tt>gx</tt> is in that case the vertical        derivative, and <tt>gy</tt>, the horizontal derivative.</p>      <h2>Outputs<a name="4"></a></h2>      <p><b><tt>Gx, Gy</tt></b> : directional derivatives in vertical and        horizontal directions resp. in the case <tt>axis='ij'</tt>, the        opposite in the case <tt>axis='xy'</tt>.</p>      <h2>References<a name="5"></a></h2>      <p>[Fleck92] M.M. Fleck: "Some defects in finite-difference edge finders",        IEEE Trans. Pattern Analysis and Machine Intelligence, 14(3):337-345,        1992.</p>      <p>[GW02] R.C. Gonzales and R.E. Woods: "Digital Image Processing",        Prentice Hall, 2002.</p>      <p>[FS04] H. Farid and E. Simoncelli: "Differentiation of discrete        multi-dimensional signals", IEEE Trans. Image Processing, 13(4):496-508,        2004.</p>      <p>[KOVESI] P.D. Kovesi: "MATLAB and Octave Functions for Computer Vision        and Image Processing", The University of Western Australia, available        at: <a href="http://www.csse.uwa.edu.au/%7Epk/research/matlabfns/">http://www.csse.uwa.edu.au/~pk/research/matlabfns/</a></p>      <h2>Acknowledgments:<a name="6"></a></h2>      <p>Options <tt>'derivative5'</tt> and <tt>'derivative7'</tt> call the        resp. functions of P.Kovesi's toolboox available at: <a href="http://www.csse.uwa.edu.au/%7Epk/Research/MatlabFns/">http://www.csse.uwa.edu.au/~pk/Research/MatlabFns/</a>.</p>      <h2>See also<a name="8"></a></h2>      <p>Related: <a href="GRDSMOOTH.html"><tt>GRDSMOOTH</tt></a>, <a href="matlab:webpub%28whichpath%28%27GRADIENT%27%29%29"><tt>GRADIENT</tt></a>.        Called: <a href="GRDMASK_BASE.html"><tt>GRDMASK_BASE</tt></a>, <a href="GRDMASKMAP_BASE.html"><tt>GRDMASKMAP_BASE</tt></a>.</p>      <h2>Function implementation<a name="9"></a></h2>      <pre class="codeinput"><span class="keyword">function</span> [Gx,Gy] = grdmask(I, varargin)</pre>      <p>parsing parameters</p>      <pre class="codeinput">error(nargchk(1, 12, nargin, <span class="string">'struct'</span>));error(nargoutchk(1, 2, nargout, <span class="string">'struct'</span>));<span class="keyword">if</span> ~isnumeric(I)    error(<span class="string">'grdmask:inputerror'</span>,<span class="string">'a matrix is required in input'</span>);<span class="keyword">end</span>p = createParser(<span class="string">'GRDMASK'</span>);p.addOptional(<span class="string">'method'</span>, <span class="string">'sobel'</span>, @(x)ischar(x) &amp;&amp; <spanclass="keyword">...</span>    any(strcmpi(x,{<span class="string">'matlab'</span>,<span class="string">'diff'</span>,<spanclass="string">'difference'</span>, <spanclass="string">'backward'</span>,<spanclass="string">'back'</span>, <spanclass="string">'forward'</span>,<spanclass="string">'for'</span>,<spanclass="keyword">...</span>    <span class="string">'prewitt'</span>,<span class="string">'prew'</span>, <spanclass="string">'kirsch'</span>,<spanclass="string">'kir'</span>, <spanclass="string">'robinson'</span>,<spanclass="string">'rob'</span>, <spanclass="string">'circular'</span>,<spanclass="string">'circ'</span>,<spanclass="keyword">...</span>    <span class="string">'optimal'</span>,<span class="string">'opt'</span>, <spanclass="string">'ori'</span>,<spanclass="string">'orientation'</span>, <spanclass="string">'isotropic'</span>,<spanclass="string">'iso'</span>, <spanclass="string">'sobel'</span>,<spanclass="string">'sob'</span>, <spanclass="keyword">...</span>    <span class="string">'roberts'</span>, <span class="string">'derivative5'</span>,<spanclass="string">'tap5'</span>, <spanclass="string">'derivative7'</span>,<spanclass="string">'tap7'</span>})));p.addOptional(<span class="string">'map'</span>,[],@(x)isnumeric(x) || islogical(x));p.addOptional(<span class="string">'axis'</span>,<span class="string">'ij'</span>,@(x)ischar(x) &amp;&amp; any(strcmpi(x,{<spanclass="string">'ij'</span>,<spanclass="string">'xy'</span>})));<span class="comment">% parse and validate all input arguments</span>p.parse(varargin{:});p = getvarParser(p);</pre>      <p>check parameters</p>      <pre class="codeinput"><span class="keyword">if</span> any(strcmpi(p.method,{<spanclass="string">'derivative5'</span>,<spanclass="string">'tap5'</span>, <spanclass="string">'derivative7'</span>,<spanclass="string">'tap7'</span>}))    error(<span class="string">'grdmask:methoderror'</span>, <span class="keyword">...</span>        <span class="string">'Kovesi''s library required with tap coefficients'</span>);<span class="keyword">elseif</span> ~isempty(p.map) &amp;&amp; ~isequal(size(p.map),size(I(:,:,1)))    error(<span class="string">'grdmask:inputerror'</span>, <span class="keyword">...</span>        <span class="string">'input map must be same size as the input image domain'</span>);<span class="keyword">end</span></pre>      <p>main computation</p>      <pre class="codeinput">[X,Y,C] = size(I);<span class="keyword">if</span> isempty(p.map) || all(p.map(:))    [Gx,Gy] = grdmask_base(I, p.method, p.axis);<span class="keyword">else</span>    [Gx,Gy] = grdmaskmap_base(I, p.map, p.method, p.axis);<span class="keyword">end</span></pre>      <p>display</p>      <pre class="codeinput"><span class="keyword">if</span> p.disp    figure,    subplot(1,2,1), imagesc(rescale(Gx,0,1)), axis <span class="string">image</span> <spanclass="string">off</span>,    title([<span class="string">'gx - axis '''</span> p.axis <span class="string">''''</span>]); <spanclass="keyword">if</span> C==1,  colormap <spanclass="string">gray</span>;  <spanclass="keyword">end</span>    subplot(1,2,2), imagesc(rescale(Gy,0,1)), axis <span class="string">image</span> <spanclass="string">off</span>,    title([<span class="string">'gy - axis '''</span> p.axis <span class="string">''''</span>]); <spanclass="keyword">if</span> C==1,  colormap <spanclass="string">gray</span>;  <spanclass="keyword">end</span>    figure,    imagesc(rescale(I,0,1)), axis <span class="string">image</span> <span class="string">off</span>;    hold <spanclass="string">on</span>;    <span class="keyword">if</span> C==1,  colormap <span class="string">gray</span>;  <spanclass="keyword">end</span>    [X,Y] = meshgrid(3:10:X-2,3:10:Y-2);    <span class="keyword">if</span> strcmpi(p.axis,<span class="string">'ij'</span>)        quiver(X, Y, max(Gy(X(1,:),Y(:,1),:),[],3), max(Gx(X(1,:),Y(:,1),:),[],3));    <span class="keyword">else</span>        quiver(X, Y, Gx(X(1,:),Y(:,1)), -Gy(X(1,:),Y(:,1)));    <span class="keyword">end</span>    hold <span class="string">off</span>; title(<span class="string">'gradient field'</span>)<span class="keyword">end</span></pre>      <pre class="codeinput"><span class="keyword">end</span> <span class="comment">% end of grdmask</span></pre></div>    <!--##### SOURCE BEGIN #####%% GRDMASK - Mask-based directional derivatives of an image.%%% Description% Apply classical gradient operators using local difference masks.%%% Syntax%    [Gx,Gy] = GRDMASK(I);%    [Gx,Gy] = GRDMASK(I, method, map, axis);%%% Inputs% *|I|* : input 2D image with size |(X,Y,C)|, with |C>1| for multispectral image.%% *|method|* : (optional) parameter defining the original |(3,3)| gradient %      mask used for estimating the directional derivatives [GW02]; classical%      masks include:% * |'sob'| or |'sobel'| for Sobel masks in i- and j-directions (see option%          |axis| below),% * |'kir'| or |'kirsch'| for Kirsch mask,% * |'prew'| or |'prewitt'| for Prewitt mask,% * |'iso'| or |'isotropic'| for Frei-Chen's isotropic mask,% * |'opt'| or |'optimal'| for Ando's optimal mask,% * |'ori'| or |'orientation'| for optimized orientation invariant filter,% * |'circ'| or |'circular'| for Davies' circular mask,% * |'rob'| or |'robinson'| for Robinson mask,%% finite difference schemes are also implemented as:%% * |'matlab', 'diff'| or |'difference'|  when central differences are%          computed (using Matlab function |GRADIENT|),% * |'for'| or |'forward'|  for forward differences,% * |'back'| or |'kackward'|  for backward differences,% % but are not very accurate when further used for the detection of edges %      that are at angles other than vertical or horizontal [Fleck92],%      therefore improvements have been proposed in [FS04] and are here%      implemented through the call to P.Kovesi's functions [KOVESI] as:%% * |'tap5'| or |'derivative5'| using 5-tap coefficients,% * |'tap7'| or |'derivative7'| using 7-tap coefficients;%%      default: |method='sob'|. %% *|map|* : (optional) logical map (with size |(X,Y)|) defining the pixels of%      the input image domain where the gradient is to be computed; set to%      false where no gradient needs to be output; in this case, the function%      |GRDMASKMAP_BASE| is called; default: |map=[]|, ie. considered to be%      true everywhere and the function |GRDMASK_BASE| is called.%% *|axis|* : (optional) string indicating the direction/orientation of the output%      directional derivatives, it is either |'ij'| or |'xy'|; default: |axis='ij'|%      (right-handed coordinate system), ie. the vector orthogonal to the%      (real) gradient is output: |gx| is in that case the vertical derivative,%      and |gy|, the horizontal derivative.%%% Outputs% *|Gx, Gy|* : directional derivatives in vertical and horizontal directions %      resp. in the case |axis='ij'|, the opposite in the case |axis='xy'|.%%% References% [Fleck92] M.M. Fleck: "Some defects in finite-difference edge finders",%      IEEE Trans. Pattern Analysis and Machine Intelligence, 14(3):337-345,%      1992.%% [GW02]  R.C. Gonzales and R.E. Woods: "Digital Image Processing", Prentice     %      Hall, 2002.%% [FS04]  H. Farid and E. Simoncelli: "Differentiation of discrete%      multi-dimensional signals", IEEE Trans. Image Processing, 13(4):496-508,%      2004.%% [KOVESI]  P.D. Kovesi: "MATLAB and Octave Functions for Computer Vision%      and Image Processing", The University of Western Australia, available%      at:               http://www.csse.uwa.edu.au/~pk/research/matlabfns/%%% Acknowledgments: % Options |'derivative5'| and |'derivative7'| call the resp. functions of% P.Kovesi's toolboox available at:%        http://www.csse.uwa.edu.au/~pk/Research/MatlabFns/.%%% Credit% <mailto:grazzja@lanl.gov J.Grazzini> (ISR-2/LANL)%%% See also  % Related:% <GRDSMOOTH.html |GRDSMOOTH|>,% <matlab:webpub(whichpath('GRADIENT')) |GRADIENT|>.% Called:% <GRDMASK_BASE.html |GRDMASK_BASE|>,% <GRDMASKMAP_BASE.html |GRDMASKMAP_BASE|>.%% Function implementationfunction [Gx,Gy] = grdmask(I, varargin)%% % parsing parameters error(nargchk(1, 12, nargin, 'struct'));error(nargoutchk(1, 2, nargout, 'struct'));if ~isnumeric(I)    error('grdmask:inputerror','a matrix is required in input'); endp = createParser('GRDMASK');   p.addOptional('method', 'sobel', @(x)ischar(x) && ...    any(strcmpi(x,{'matlab','diff','difference', 'backward','back', 'forward','for',...    'prewitt','prew', 'kirsch','kir', 'robinson','rob', 'circular','circ',...    'optimal','opt', 'ori','orientation', 'isotropic','iso', 'sobel','sob', ...    'roberts', 'derivative5','tap5', 'derivative7','tap7'})));p.addOptional('map',[],@(x)isnumeric(x) || islogical(x));p.addOptional('axis','ij',@(x)ischar(x) && any(strcmpi(x,{'ij','xy'})));% parse and validate all input argumentsp.parse(varargin{:}); p = getvarParser(p); %% % check parametersif any(strcmpi(p.method,{'derivative5','tap5', 'derivative7','tap7'}))    error('grdmask:methoderror', ...        'Kovesi''s library required with tap coefficients');elseif ~isempty(p.map) && ~isequal(size(p.map),size(I(:,:,1)))    error('grdmask:inputerror', ...        'input map must be same size as the input image domain');end%% % main computation[X,Y,C] = size(I);if isempty(p.map) || all(p.map(:))    [Gx,Gy] = grdmask_base(I, p.method, p.axis);else    [Gx,Gy] = grdmaskmap_base(I, p.map, p.method, p.axis);end%%% displayif p.disp    figure,     subplot(1,2,1), imagesc(rescale(Gx,0,1)), axis image off,     title(['gx - axis ''' p.axis '''']); if C==1,  colormap gray;  end    subplot(1,2,2), imagesc(rescale(Gy,0,1)), axis image off,     title(['gy - axis ''' p.axis '''']); if C==1,  colormap gray;  end    figure,    imagesc(rescale(I,0,1)), axis image off;    hold on;    if C==1,  colormap gray;  end    [X,Y] = meshgrid(3:10:X-2,3:10:Y-2);    if strcmpi(p.axis,'ij')        quiver(X, Y, max(Gy(X(1,:),Y(:,1),:),[],3), max(Gx(X(1,:),Y(:,1),:),[],3));    else        quiver(X, Y, Gx(X(1,:),Y(:,1)), -Gy(X(1,:),Y(:,1)));    end    hold off; title('gradient field')endend % end of grdmask##### SOURCE END #####--></body></html>