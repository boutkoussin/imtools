<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html>  <head>    <meta content="text/html; charset=utf-8" http-equiv="content-type">    <!--This HTML was auto-generated from MATLAB code.To make changes, update the MATLAB code and republish this document.      -->    <title>LOCAL3X3KERNEL - Compute local kernels defined by zones and levels.</title>    <meta name="generator" content="MATLAB 7.14">    <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">    <meta name="DC.date" content="2012-11-14">    <meta name="DC.source" content="local3x3kernel.m">    <style type="text/css">html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}html { min-height:100%; margin-bottom:1px; }html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }html body td { vertical-align:top; text-align:left; }h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }a { color:#005fce; text-decoration:none; }a:hover { color:#005fce; text-decoration:underline; }a:visited { color:#004aa0; text-decoration:none; }p { padding:0px; margin:0px 0px 20px; }img { padding:0px; margin:0px 0px 20px; border:none; }p img, pre img, tt img, li img { margin-bottom:0px; } ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }ul li { padding:0px; margin:0px 0px 7px 0px; }ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }ul li ol li { list-style:decimal; }ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }ol li ol li { list-style-type:lower-alpha; }ol li ul { padding-top:7px; }ol li ul li { list-style:square; }.content { font-size:1.2em; line-height:140%; padding: 20px; }pre, tt, code { font-size:12px; }pre { margin:0px 0px 20px; }pre.error { color:red; }pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }span.keyword { color:#0000FF }span.comment { color:#228B22 }span.string { color:#A020F0 }span.untermstring { color:#B20000 }span.syscmd { color:#B28C00 }.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }.footer p { margin:0px; }  </style>  </head>  <body>    <div class="content">      <h1>LOCAL3X3KERNEL - Compute local kernels defined by zones and levels.</h1>      <!--introduction--><!--/introduction-->      <h2>Contents</h2>      <div>        <ul>          <li><a href="#1">Description</a></li>          <li><a href="#2">Syntax</a></li>          <li><a href="#3">Property [propertyname propertyvalues]</a></li>          <li><a href="#4">Output</a></li>          <li><a href="#5">References</a></li>          <li><a href="#7">Function implementation</a></li>          <li><a href="#15">Subfunctions:</a></li>        </ul>      </div>      <h2>Description<a name="1"></a></h2>      <p>Define a set of local <tt>(3,3)</tt> directional kernels following the        approach of [Leu00].</p>      <h2>Syntax<a name="2"></a></h2>      <pre>     Kernel = LOCAL3X3KERNEL('Property', propertyvalue, ...);</pre>      <h2>Property [propertyname propertyvalues]<a name="3"></a></h2>      <p><b><tt>'ker'</tt></b> : optional string for default kernel definition;        <tt>ker</tt> is indeed either: <tt>'i0'</tt>, <tt>'i1'</tt>, <tt>'g0'</tt>,        or <tt>'g1'</tt>, where the first letter stands for intensity (<tt>'i'</tt>)        or gradient (<tt>'g'</tt>), and the second for the original definition        of [Leu00] (<tt>'0'</tt>) or new weights'definition (<tt>'1'</tt>); for        instance, if <tt>ker='g0'</tt>, and no other option is passed, then the        weights for the gradient indices as defined in [Leu00] will be used;        default (no arguments passed): <tt>ker = 'i0'</tt>.</p>      <p><b><tt>'nz'</tt></b> : number of zones to divide the range <img src="local3x3kernel_eq13028.png"          alt="$[-\pi,\pi]$">;        it is either 8 or 16, where the following representation for the        orientation is used:</p>      <pre>    |nz=8|:        ---------------         -------------        | NW | N | NE |         | 4 | 3 | 2 |        ---------------         -------------        | W  |   | E  |    =&gt;   | 5 |   | 1 |        ---------------         -------------        | SW | S | SE |         | 6 | 7 | 8 |        ---------------         -------------</pre>      <pre>    |nz=16|:        -----------------------         -----------------        |  \ NNW | N | NNE /  |         | \ 6 | 5 | 4 / |        |   NW   |   |   NE   |         |  7  |   |  3  |        | WNW \  |   |  / ENE |         | 8 \ |   | / 2 |        -----------------------         -----------------        |  W     |   |     E  |    =&gt;   | 9   |   |   1 |        -----------------------         -----------------        | WSW /  |   |  \ ESE |         | 10/ |   | \16 |            SW   |   |   SE   |         |  11 |   | 15  |        |  / SSW | S | SSE \  |         | / 12| 13|14 \ |        -----------------------         -----------------</pre>      <p>but these settings can be changed by passing different kernels for the        position indexes (see <tt>'ik'</tt> below); in default cases (<tt>'ker'</tt>        provided), <tt>nz=8</tt>.</p>      <p><b><tt>'nl'</tt></b> : number of levels, as defined by [Leu00]; in        default cases (<tt>'ker'</tt> provided), <tt>nl=3</tt>.</p>      <p><b><tt>'ik'</tt></b> : optional <tt>(3,3)</tt> matrix (filled with        integer values) setting the positions of the weights for the <tt>nl</tt>        different levels and for the first (in general 2) zone(s); the position        for all other zones will be derived by rotation of <tt>ik</tt>; if <tt>nl</tt>        is not provided, it is set to the max of the values in <tt>ik</tt>.</p>      <p><b><tt>'vk'</tt></b> : optional <tt>(3,3)</tt> matrix setting the        weigths values for all possible levels and for the first (in general 2)        zone(s); it can be passed with the option <tt>'ker'</tt> to change the        weights used in the kernel definition.</p>      <p><b><tt>'norm'</tt></b> : optional boolean flag for normalizing the        output kernels; default: <tt>norm=true</tt>, ie. the sum of the weights        in the various kernels is equal to 1.</p>      <h2>Output<a name="4"></a></h2>      <p><b><tt>Kernel</tt></b> : a matrix of dimension 4 with size <tt>(3,3,nl,nz)</tt>        setting zone- and level-dependent weight kernels.</p>      <h2>References<a name="5"></a></h2>      <p>[Leu00] J.G. Leu: "Edge sharpening through ramd width reduction", Image        and Vision Computing, 18:501-514, 2000. <a href="http://www.sciencedirect.com/science/article/pii/S0262885699000414">http://www.sciencedirect.com/science/article/pii/S0262885699000414</a></p>      <p>[GS10] J. Grazzini and P. Soille: "Iterative ramp sharpening for        structure/signature-preserving simplification of images", Proc. ICPR,        pp. 4586-4589, 2010. <a href="http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=5597348">http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=5597348</a></p>      <h2>Function implementation<a name="7"></a></h2>      <pre class="codeinput"><span class="keyword">function</span> [Kernel,varargout] = local3x3kernel(varargin)</pre>      <p>parsing parameters</p>      <pre class="codeinput">error(nargchk(1, 13, nargin, <span class="string">'struct'</span>));error(nargoutchk(1, 2, nargout, <span class="string">'struct'</span>));p = createParser(<span class="string">'LOCAL3X3KERNEL'</span>);<span class="comment">% only optional parameters</span>p.addParamValue(<span class="string">'ker'</span>, [], @(x)ischar(x) &amp;&amp; <spanclass="keyword">...</span>    any(strcmpi(x,{<span class="string">'i0'</span>, <span class="string">'ileu'</span>, <spanclass="string">'i1'</span>, <spanclass="string">'g0'</span>, <spanclass="string">'gleu'</span>, <spanclass="string">'g1'</span>,<spanclass="string">'glass'</span>})));p.addParamValue(<span class="string">'nz'</span>, [], @(x)x==8 || x==16);p.addParamValue(<span class="string">'nl'</span>, [], @(x)isscalar(x) &amp;&amp; x&gt;0);p.addParamValue(<span class="string">'ik'</span>, [], @(x)isnumeric(x) &amp;&amp; floor(x)==x &amp;&amp; <spanclass="keyword">...</span>    size(x,1)==3 &amp;&amp; size(x,2) == 3);p.addParamValue(<span class="string">'vk'</span>, [], @(x)isnumeric(x) &amp;&amp; size(x,1)==3 &amp;&amp; size(x,2) == 3);p.addParamValue(<span class="string">'norm'</span>, true, @islogical);<span class="comment">% parse and validate all input arguments</span>p.parse(varargin{:});p = getvarParser(p);</pre>      <p>checking compatibility and setting default</p>      <pre class="codeinput"><span class="keyword">if</span> ~isempty(p.ker)    <span class="keyword">if</span> ~isempty(p.nl) || ~isempty(p.nz)        disp(<span class="string">'properties nz and nl incompatible with ker: they are ignored'</span>);    <span class="keyword">end</span>    p.nz = 8; p.nl = 3;    <span class="keyword">if</span> max(unique(p.ik)) &gt; p.nl, error(<span class="string">'incompatible ker and ik provided'</span>); <spanclass="keyword">end</span><span class="keyword">else</span>    <span class="keyword">if</span> ~(isempty(p.nl) &amp;&amp; isempty(p.nz)) &amp;&amp; (isempty(p.vk) || isempty(p.ik))        error(<span class="string">'incomplete setting of the input parameters'</span>);    <span class="keyword">end</span>    <span class="keyword">if</span> ~isempty(p.ik)        <span class="keyword">if</span> isempty(p.nl), p.nl = max(unique(p.ik));        <span class="keyword">elseif</span> max(unique(p.ik)) &gt; p.nl, error(<spanclass="string">'incompatible nl and ik provided'</span>);        <span class="keyword">end</span>        <span class="keyword">if</span> isempty(p.nz), p.nz = 8; <span class="keyword">end</span>    <span class="keyword">elseif</span> ~isempty(p.vk) <span class="comment">% &amp;&amp; isempty(ik)</span>        p.nz = 8; p.nl = 3;    <span class="keyword">end</span><span class="keyword">end</span></pre>      <div>        <ul>          <li>compute the position kernel initialize</li>        </ul>      </div>      <pre class="codeinput"><span class="keyword">if</span> ~isempty(p.ker) || isempty(p.ik)    [p.ik, level_indices] = defaultpkernelfirstzone();    p.nl = length(fieldnames(level_indices));<span class="keyword">end</span><span class="comment">% compute the position indexes in the local (3 x 3) neighbourhoods for all</span><span class="comment">% possible zones</span>p.ik = rotkernelperzone(p.ik,p.nz);</pre>      <div>        <ul>          <li>compute the weighting kernel initialize</li>        </ul>      </div>      <pre class="codeinput"><span class="keyword">if</span> ~isempty(p.ker) || isempty(p.vk)    p.vk = defaultkernelfirstzone(p.ker, p.nz);<span class="keyword">end</span><span class="comment">% compute for all possible zones</span>p.vk = rotkernelperzone(p.vk,p.nz);</pre>      <div>        <ul>          <li>create the (nlevels x nzones) matrices of size (3 x 3) used for            computing the different indices for every single level and zone</li>        </ul>      </div>      <pre class="codeinput">Kernel = kernelperzoneperlevel(p.ik, p.vk, p.nl, p.nz, p.norm);<span class="comment">% mote: Kernel is indexed by [x,y,zone,level]</span><span class="keyword">if</span> nargout==2, varargout{1} = level_indices; <spanclass="keyword">end</span></pre>      <pre class="codeinput"><span class="keyword">end</span><span class="comment">% end of local3x3kernel</span></pre>      <h2>Subfunctions:<a name="15"></a></h2>      <div>        <ul>          <li>functions for deriving kernels for different positions</li>        </ul>      </div>      <p><tt>ROTKERNELPERZONE</tt> - Zone-by kernel definition through rotation.-------------------------------------------------------------------------</p>      <pre class="codeinput"><span class="keyword">function</span> KernelPerZone = rotkernelperzone(KernelFirstZone, nzones)[x y nfirst] = size(KernelFirstZone);<span class="keyword">if</span> nfirst == nzones    KernelPerZone = KernelFirstZone;    <span class="keyword">return</span>;<span class="keyword">end</span><span class="comment">% initialize the output rotated kernels</span>KernelPerZone = zeros(x,y,nzones);<span class="comment">% initialize with values in firstZone</span>KernelPerZone(:,:,1:nfirst) = KernelFirstZone;<span class="comment">% rotate the matrices for all positions</span><span class="keyword">for</span> z=3:nzones    KernelPerZone(:,:,z) = rot90(KernelPerZone(:,:,z-nfirst));<span class="keyword">end</span><span class="keyword">end</span><span class="comment">% end of rotkernelperzone</span></pre>      <p><tt>KERNELPERZONEPERLEVEL</tt> - Zone-by level-by kernel definition.        -------------------------------------------------------------------------</p>      <pre class="codeinput"><span class="keyword">function</span> KernelPerZonePerLevel = <spanclass="keyword">...</span>    kernelperzoneperlevel(Levels, KernelPerZone, nlevels, nzones, norm)[x y] = size(Levels(:,:,1));<span class="comment">% nlevels = lenght(unique(Levels));</span><span class="comment">% nzones = size(KernelPerZone,3);</span><span class="comment">% initialize the output matrix</span>KernelPerZonePerLevel = zeros(x,y,nzones,nlevels);<span class="comment">% estimate the masks used for the different zones and levels</span><span class="keyword">for</span> l = 1:nlevels    <span class="keyword">for</span> z = 1:nzones        KernelPerZonePerLevel(:,:,z,l) = <span class="keyword">...</span>            (Levels(:,:,z)==l) .* KernelPerZone(:,:,z);        <span class="keyword">if</span> norm            s = sum(sum(KernelPerZonePerLevel(:,:,z,l)));            <span class="keyword">if</span> abs(s) &gt; 0                KernelPerZonePerLevel(:,:,z,l) = <span class="keyword">...</span>                    KernelPerZonePerLevel(:,:,z,l) / s;            <span class="keyword">end</span>        <span class="keyword">end</span>    <span class="keyword">end</span><span class="keyword">end</span><span class="keyword">end</span> <span class="comment">% end of findkernelperzoneperlevel</span></pre>      <div>        <ul>          <li>functions for default kernels' initialization</li>        </ul>      </div>      <p><tt>DEFAULTPKERNELFIRSTZONE</tt> - Default definition of the <tt>L</tt>,        <tt>M</tt> and <tt>H</tt> positions in local <tt>(3,3)</tt>        neighbourhoods for the two first zones: (a) <tt>zone=1</tt> and (b) <tt>zone=2</tt>-------------------------------------------------------------------------</p>      <pre class="codeinput"><span class="keyword">function</span> [ik, level_indices] = defaultpkernelfirstzone()<span class="comment">%         4(a)             5(a)             4(b)             5(b)</span><span class="comment">%    -------------    -------------    -------------    -------------</span><span class="comment">%    | L | M | H |    |   |   |   |    | M | H | H |    |   | H | H |</span><span class="comment">%    -------------    -------------    -------------    -------------</span><span class="comment">%    | L | M | H |    | L | M | H |    | L | M | H |    | L | M | H |</span><span class="comment">%    -------------    -------------    -------------    -------------</span><span class="comment">%    | L | M | H |    |   |   |   |    | L | L | M |    | L | L |   |</span><span class="comment">%    -------------    -------------    -------------    -------------</span>level_indices = struct( <span class="string">'L'</span>, 1, <span class="string">'M'</span>, 2, <spanclass="string">'H'</span>, 3);L = level_indices.(<span class="string">'L'</span>); M = level_indices.(<span class="string">'M'</span>); H = level_indices.(<spanclass="string">'H'</span>);<span class="comment">% nlevels = length(fieldnames(level_indices));</span><span class="comment">% zone 1 (0&lt;=theta&lt;pi/4) : 5(a)</span>ik(:,:,1) = [ L M H; L M H; L M H ];<span class="comment">%ikI=ik; ikG(:,:,1) = [ 0 0 0 ; L M H; 0 0 0 ];</span><span class="comment">% zone 2 (pi/4&lt;=theta&lt;pi/2) : 5(b)</span>ik(:,:,2) = [ M H H; L M H; L L M ];<span class="comment">%ikI= ik; ikG(:,:,2) = [ 0 H H ; L M H; L L 0 ];</span><span class="keyword">end</span><span class="comment">% end of defaultpkernelfirstzone</span></pre>      <p><tt>DEFAULTKERNELFIRSTZONE</tt> - Default definition of the intensity        and gradient weighting kernels in local <tt>(3,3)</tt> neighbourhoods        for the two first zones as they were defined in [Leu00]        -------------------------------------------------------------------------</p>      <pre class="codeinput"><span class="keyword">function</span> vk = defaultkernelfirstzone(ker, nzones)<span class="keyword">if</span> ~any(strcmp(ker,{<span class="string">'i0'</span>,<spanclass="string">'ileu'</span>,<spanclass="string">'i1'</span>,<spanclass="string">'g0'</span>,<spanclass="string">'gleu'</span>,<spanclass="string">'g1'</span>,<spanclass="string">'glass'</span>}))    disp(<span class="string">'in DEFAULTKERNELFIRSTZONE : unknown default mask definition'</span>);    ker = <span class="string">'i0'</span>;<span class="keyword">elseif</span> isempty(ker)    ker = <span class="string">'i0'</span>; <span class="comment">% intensity masks defined by Leu</span><span class="keyword">end</span><span class="keyword">switch</span> ker   <span class="comment">% default kernels of intensity masks values</span>     <span class="keyword">case</span> {<span class="string">'i0'</span>,<span class="string">'ileu'</span>}        <span class="comment">% original weights for intensity indices: figures 4(a) and 4(b) in</span>        <span class="comment">% [Leu00]</span>        <span class="comment">%    -------------    -------------</span>        <span class="comment">%    | 1 | 1 | 1 |    | 1 | 1 | 0 |</span>        <span class="comment">%    -------------    -------------</span>        <span class="comment">%    | 2 | 2 | 2 |    | 1 | 2 | 1 |</span>        <span class="comment">%    -------------    -------------</span>        <span class="comment">%    | 1 | 1 | 1 |    | 0 | 1 | 1 |</span>        <span class="comment">%    -------------    -------------</span>        vk(:,:,1) = [ 1 1 1; 2 2 2; 1 1 1];  <span class="comment">% zone 1 (0&lt;=theta&lt;pi/4)</span>        vk(:,:,2) = [ 1 1 0; 1 2 1; 0 1 1];  <span class="comment">% zone 2 (pi/4&lt;=theta&lt;pi/2)</span>    <span class="keyword">case</span> <span class="string">'i1'</span>        <span class="comment">% new proposed weights for intensity indices</span>        <span class="comment">%    -------------    -------------</span>        <span class="comment">%    | 1 | 1 | 1 |    | 1 | 2 | 1 |</span>        <span class="comment">%    -------------    -------------</span>        <span class="comment">%    | 2 | 2 | 2 |    | 2 | 2 | 2 |</span>        <span class="comment">%    -------------    -------------</span>        <span class="comment">%    | 1 | 1 | 1 |    | 1 | 2 | 1 |</span>        <span class="comment">%    -------------    -------------</span>        vk(:,:,1) = [ 1 1 1; 2 2 2; 1 1 1];        vk(:,:,2) = [ 1 2 1; 2 2 2; 1 2 1];    <span class="comment">% default kernels of gradient masks values</span>    <span class="keyword">case</span> {<span class="string">'g0'</span>,<span class="string">'gleu'</span>}         <span class="comment">% original weights for gradient indices: figures 5(a) and 5(b) in</span>        <span class="comment">% [Leu00]</span>        <span class="comment">%    -------------    -------------</span>        <span class="comment">%    | 0 | 0 | 0 |    | 0 | 1 | 0 |</span>        <span class="comment">%    -------------    -------------</span>        <span class="comment">%    | 1 | 1 | 1 |    | 1 | 1 | 1 |</span>        <span class="comment">%    -------------    -------------</span>        <span class="comment">%    | 0 | 0 | 0 |    | 0 | 1 | 0 |</span>        <span class="comment">%    -------------    -------------</span>        vk(:,:,1) = [ 0 0 0; 1 1 1; 0 0 0];        vk(:,:,2) = [ 0 1 0; 1 1 1; 0 1 0];    <span class="keyword">case</span> <span class="string">'g1'</span>        <span class="comment">% new proposed weights for gradient indices</span>        <span class="comment">%    -------------    -------------</span>        <span class="comment">%    | 0 | 0 | 0 |    | 0 | 2 | 1 |</span>        <span class="comment">%    -------------    -------------</span>        <span class="comment">%    | 1 | 1 | 1 |    | 2 | 1 | 2 |</span>        <span class="comment">%    -------------    -------------</span>        <span class="comment">%    | 0 | 0 | 0 |    | 1 | 2 | 0 |</span>        <span class="comment">%    -------------    -------------</span>        vk(:,:,1) = [ 0 0 0; 1 1 1; 0 0 0];        vk(:,:,2) = [ 0 2 1; 2 1 2; 1 2 0];    <span class="keyword">case</span> <span class="string">'glass'</span>        theta = linspace(pi/2, 5*pi/2, nzones+1);        vk = hourglasskernel([3 3],1,0.4,[2 2],theta);        vk = vk(:,:,1:nzones);<span class="keyword">end</span><span class="keyword">end</span> <span class="comment">% end of defaultkernelfirstzone</span></pre></div>    <!--##### SOURCE BEGIN #####%% LOCAL3X3KERNEL - Compute local kernels defined by zones and levels.%%% Description% Define a set of local |(3,3)| directional kernels following the approach% of [Leu00]. % %% Syntax%       Kernel = LOCAL3X3KERNEL('Property', propertyvalue, ...);% %% Property [propertyname  propertyvalues]% *|'ker'|* : optional string for default kernel definition; |ker| is indeed%      either: |'i0'|, |'i1'|, |'g0'|, or |'g1'|, where the first letter%      stands for intensity (|'i'|) or gradient (|'g'|), and the second for%      the original definition of [Leu00] (|'0'|) or new weights'definition %      (|'1'|); for instance, if |ker='g0'|, and no other option is passed, %      then the weights for the gradient indices as defined in [Leu00] will%      be used; default (no arguments passed): |ker = 'i0'|.%% *|'nz'|* : number of zones to divide the range $[-\pi,\pi]$; it is either%      8 or 16, where the following representation for the orientation is used:%%      |nz=8|:%          REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-         REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-%          | NW | N | NE |         | 4 | 3 | 2 |%          REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-         REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-%          | W  |   | E  |    =>   | 5 |   | 1 |%          REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-         REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-%          | SW | S | SE |         | 6 | 7 | 8 |%          REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-         REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-%%      |nz=16|:%          REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-         REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-%          |  \ NNW | N | NNE /  |         | \ 6 | 5 | 4 / |%          |   NW   |   |   NE   |         |  7  |   |  3  |%          | WNW \  |   |  / ENE |         | 8 \ |   | / 2 |%          REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-         REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-%          |  W     |   |     E  |    =>   | 9   |   |   1 |%          REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-         REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-%          | WSW /  |   |  \ ESE |         | 10/ |   | \16 |%              SW   |   |   SE   |         |  11 |   | 15  |%          |  / SSW | S | SSE \  |         | / 12| 13|14 \ |%          REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-         REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-%% but these settings can be changed by passing different kernels for the%      position indexes (see |'ik'| below); in default cases (|'ker'|%      provided), |nz=8|.%% *|'nl'|* : number of levels, as defined by [Leu00]; in default cases (|'ker'|%      provided), |nl=3|.%% *|'ik'|* : optional |(3,3)| matrix (filled with integer values) setting the%      positions of the weights for the |nl| different levels and for the %      first (in general 2) zone(s); the position for all other zones will%      be derived by rotation of |ik|; if |nl| is not provided, it is set to%      the max of the values in |ik|.%% *|'vk'|* : optional |(3,3)| matrix setting the weigths values for all%      possible levels and for the first (in general 2) zone(s); it can be%      passed with the option |'ker'| to change the weights used in the %      kernel definition.%% *|'norm'|* : optional boolean flag for normalizing the output kernels;%      default: |norm=true|, ie. the sum of the weights in the various kernels%      is equal to 1.% %% Output% *|Kernel|* : a matrix of dimension 4 with size |(3,3,nl,nz)| setting zone- %      and level-dependent weight kernels.%%% References% [Leu00] J.G. Leu: "Edge sharpening through ramd width reduction", Image%      and Vision Computing, 18:501-514, 2000.%      <http://www.sciencedirect.com/science/article/pii/S0262885699000414>%% [GS10]  J. Grazzini and P. Soille: "Iterative ramp sharpening for %      structure/signature-preserving simplification of images", Proc.%      ICPR, pp. 4586-4589, 2010.%      <http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=5597348>%%% Credit% <mailto:grazzja@lanl.gov J.Grazzini> (ISR-2/LANL)%% Function implementationfunction [Kernel,varargout] = local3x3kernel(varargin)%%% parsing parameterserror(nargchk(1, 13, nargin, 'struct'));error(nargoutchk(1, 2, nargout, 'struct'));p = createParser('LOCAL3X3KERNEL');   % only optional parametersp.addParamValue('ker', [], @(x)ischar(x) && ...    any(strcmpi(x,{'i0', 'ileu', 'i1', 'g0', 'gleu', 'g1','glass'})));p.addParamValue('nz', [], @(x)x==8 || x==16);p.addParamValue('nl', [], @(x)isscalar(x) && x>0);p.addParamValue('ik', [], @(x)isnumeric(x) && floor(x)==x && ...    size(x,1)==3 && size(x,2) == 3);p.addParamValue('vk', [], @(x)isnumeric(x) && size(x,1)==3 && size(x,2) == 3);p.addParamValue('norm', true, @islogical);% parse and validate all input argumentsp.parse(varargin{:}); p = getvarParser(p);                                                            %% % checking compatibility and setting defaultif ~isempty(p.ker)     if ~isempty(p.nl) || ~isempty(p.nz)        disp('properties nz and nl incompatible with ker: they are ignored');    end    p.nz = 8; p.nl = 3;    if max(unique(p.ik)) > p.nl, error('incompatible ker and ik provided'); end    else    if ~(isempty(p.nl) && isempty(p.nz)) && (isempty(p.vk) || isempty(p.ik))        error('incomplete setting of the input parameters');    end    if ~isempty(p.ik)        if isempty(p.nl), p.nl = max(unique(p.ik));        elseif max(unique(p.ik)) > p.nl, error('incompatible nl and ik provided');        end        if isempty(p.nz), p.nz = 8; end    elseif ~isempty(p.vk) % && isempty(ik)        p.nz = 8; p.nl = 3;    endend%%% * compute the position kernel% initializeif ~isempty(p.ker) || isempty(p.ik)    [p.ik, level_indices] = defaultpkernelfirstzone();    p.nl = length(fieldnames(level_indices));end% compute the position indexes in the local (3 x 3) neighbourhoods for all% possible zonesp.ik = rotkernelperzone(p.ik,p.nz);%%% * compute the weighting kernel% initializeif ~isempty(p.ker) || isempty(p.vk)    p.vk = defaultkernelfirstzone(p.ker, p.nz);end% compute for all possible zonesp.vk = rotkernelperzone(p.vk,p.nz);%% % * create the (nlevels x nzones) matrices of size (3 x 3) used for computing% the different indices for every single level and zoneKernel = kernelperzoneperlevel(p.ik, p.vk, p.nl, p.nz, p.norm);% mote: Kernel is indexed by [x,y,zone,level]if nargout==2, varargout{1} = level_indices; endend% end of local3x3kernel%% Subfunctions:% * functions for deriving kernels for different positions%%% |ROTKERNELPERZONE| - Zone-by kernel definition through rotation.% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-function KernelPerZone = rotkernelperzone(KernelFirstZone, nzones)[x y nfirst] = size(KernelFirstZone);if nfirst == nzones    KernelPerZone = KernelFirstZone;    return;end% initialize the output rotated kernelsKernelPerZone = zeros(x,y,nzones);% initialize with values in firstZoneKernelPerZone(:,:,1:nfirst) = KernelFirstZone;% rotate the matrices for all positionsfor z=3:nzones    KernelPerZone(:,:,z) = rot90(KernelPerZone(:,:,z-nfirst));endend% end of rotkernelperzone%%% |KERNELPERZONEPERLEVEL| - Zone-by level-by kernel definition. % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-function KernelPerZonePerLevel = ...    kernelperzoneperlevel(Levels, KernelPerZone, nlevels, nzones, norm)[x y] = size(Levels(:,:,1));% nlevels = lenght(unique(Levels));% nzones = size(KernelPerZone,3);% initialize the output matrixKernelPerZonePerLevel = zeros(x,y,nzones,nlevels); % estimate the masks used for the different zones and levelsfor l = 1:nlevels    for z = 1:nzones        KernelPerZonePerLevel(:,:,z,l) = ...            (Levels(:,:,z)==l) .* KernelPerZone(:,:,z);        if norm            s = sum(sum(KernelPerZonePerLevel(:,:,z,l)));            if abs(s) > 0                KernelPerZonePerLevel(:,:,z,l) = ...                    KernelPerZonePerLevel(:,:,z,l) / s;            end        end    endendend % end of findkernelperzoneperlevel%% % * functions for default kernels' initialization%%% |DEFAULTPKERNELFIRSTZONE| - Default definition of  the |L|, |M| and |H|% positions in local |(3,3)| neighbourhoods for the two first zones: % (a) |zone=1| and (b) |zone=2|% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-function [ik, level_indices] = defaultpkernelfirstzone()%         4(a)             5(a)             4(b)             5(b)%    REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-    REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-    REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-    REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-%    | L | M | H |    |   |   |   |    | M | H | H |    |   | H | H |%    REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-    REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-    REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-    REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-%    | L | M | H |    | L | M | H |    | L | M | H |    | L | M | H |%    REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-    REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-    REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-    REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-%    | L | M | H |    |   |   |   |    | L | L | M |    | L | L |   |%    REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-    REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-    REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-    REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-level_indices = struct( 'L', 1, 'M', 2, 'H', 3);L = level_indices.('L'); M = level_indices.('M'); H = level_indices.('H');% nlevels = length(fieldnames(level_indices));% zone 1 (0<=theta<pi/4) : 5(a)ik(:,:,1) = [ L M H; L M H; L M H ];%ikI=ik; ikG(:,:,1) = [ 0 0 0 ; L M H; 0 0 0 ];% zone 2 (pi/4<=theta<pi/2) : 5(b)ik(:,:,2) = [ M H H; L M H; L L M ];%ikI= ik; ikG(:,:,2) = [ 0 H H ; L M H; L L 0 ];   end% end of defaultpkernelfirstzone%%% |DEFAULTKERNELFIRSTZONE| - Default definition of the intensity and gradient% weighting kernels in local |(3,3)| neighbourhoods for the two first zones% as they were defined in [Leu00]% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-function vk = defaultkernelfirstzone(ker, nzones)if ~any(strcmp(ker,{'i0','ileu','i1','g0','gleu','g1','glass'}))    disp('in DEFAULTKERNELFIRSTZONE : unknown default mask definition');    ker = 'i0';    elseif isempty(ker)    ker = 'i0'; % intensity masks defined by Leuendswitch ker       % default kernels of intensity masks values     case {'i0','ileu'}        % original weights for intensity indices: figures 4(a) and 4(b) in        % [Leu00]        %    REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-    REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-        %    | 1 | 1 | 1 |    | 1 | 1 | 0 |        %    REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-    REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-        %    | 2 | 2 | 2 |    | 1 | 2 | 1 |        %    REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-    REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-        %    | 1 | 1 | 1 |    | 0 | 1 | 1 |        %    REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-    REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-        vk(:,:,1) = [ 1 1 1; 2 2 2; 1 1 1];  % zone 1 (0<=theta<pi/4)         vk(:,:,2) = [ 1 1 0; 1 2 1; 0 1 1];  % zone 2 (pi/4<=theta<pi/2)            case 'i1'        % new proposed weights for intensity indices        %    REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-    REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-        %    | 1 | 1 | 1 |    | 1 | 2 | 1 |        %    REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-    REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-        %    | 2 | 2 | 2 |    | 2 | 2 | 2 |        %    REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-    REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-        %    | 1 | 1 | 1 |    | 1 | 2 | 1 |        %    REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-    REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-        vk(:,:,1) = [ 1 1 1; 2 2 2; 1 1 1];        vk(:,:,2) = [ 1 2 1; 2 2 2; 1 2 1];     % default kernels of gradient masks values    case {'g0','gleu'}         % original weights for gradient indices: figures 5(a) and 5(b) in        % [Leu00]        %    REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-    REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-        %    | 0 | 0 | 0 |    | 0 | 1 | 0 |        %    REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-    REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-        %    | 1 | 1 | 1 |    | 1 | 1 | 1 |        %    REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-    REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-        %    | 0 | 0 | 0 |    | 0 | 1 | 0 |        %    REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-    REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-        vk(:,:,1) = [ 0 0 0; 1 1 1; 0 0 0];        vk(:,:,2) = [ 0 1 0; 1 1 1; 0 1 0];        case 'g1'        % new proposed weights for gradient indices        %    REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-    REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-        %    | 0 | 0 | 0 |    | 0 | 2 | 1 |        %    REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-    REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-        %    | 1 | 1 | 1 |    | 2 | 1 | 2 |        %    REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-    REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-        %    | 0 | 0 | 0 |    | 1 | 2 | 0 |        %    REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-    REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-        vk(:,:,1) = [ 0 0 0; 1 1 1; 0 0 0];        vk(:,:,2) = [ 0 2 1; 2 1 2; 1 2 0];            case 'glass'        theta = linspace(pi/2, 5*pi/2, nzones+1);        vk = hourglasskernel([3 3],1,0.4,[2 2],theta);        vk = vk(:,:,1:nzones);endend % end of defaultkernelfirstzone##### SOURCE END #####--></body></html>