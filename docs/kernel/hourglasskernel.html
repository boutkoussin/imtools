<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html>  <head>    <meta content="text/html; charset=utf-8" http-equiv="content-type">    <!--This HTML was auto-generated from MATLAB code.To make changes, update the MATLAB code and republish this document.      -->    <title>HOURGLASSKERNEL - Oriented non-linear spatial hourglass filter.</title>    <meta name="generator" content="MATLAB 7.14">    <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">    <meta name="DC.date" content="2012-11-14">    <meta name="DC.source" content="hourglasskernel.m">    <style type="text/css">html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}html { min-height:100%; margin-bottom:1px; }html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }html body td { vertical-align:top; text-align:left; }h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }a { color:#005fce; text-decoration:none; }a:hover { color:#005fce; text-decoration:underline; }a:visited { color:#004aa0; text-decoration:none; }p { padding:0px; margin:0px 0px 20px; }img { padding:0px; margin:0px 0px 20px; border:none; }p img, pre img, tt img, li img { margin-bottom:0px; } ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }ul li { padding:0px; margin:0px 0px 7px 0px; }ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }ul li ol li { list-style:decimal; }ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }ol li ol li { list-style-type:lower-alpha; }ol li ul { padding-top:7px; }ol li ul li { list-style:square; }.content { font-size:1.2em; line-height:140%; padding: 20px; }pre, tt, code { font-size:12px; }pre { margin:0px 0px 20px; }pre.error { color:red; }pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }span.keyword { color:#0000FF }span.comment { color:#228B22 }span.string { color:#A020F0 }span.untermstring { color:#B20000 }span.syscmd { color:#B28C00 }.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }.footer p { margin:0px; }  </style>  </head>  <body>    <div class="content">      <h1>HOURGLASSKERNEL - Oriented non-linear spatial hourglass filter.</h1>      <!--introduction--><!--/introduction-->      <h2>Contents</h2>      <div>        <ul>          <li><a href="#1">Description</a></li>          <li><a href="#2">Syntax</a></li>          <li><a href="#3">Inputs</a></li>          <li><a href="#4">Output</a></li>          <li><a href="#5">Remarks</a></li>          <li><a href="#6">References</a></li>          <li><a href="#8">See also</a></li>          <li><a href="#9">Function implementation</a></li>        </ul>      </div>      <h2>Description<a name="1"></a></h2>      <p>Compute the oriented non-linear spatial hourglass filter proposed in        [Koht03] and also implemented in [VIGRA].</p>      <h2>Syntax<a name="2"></a></h2>      <pre>      f = HOURGLASSKERNEL( m, sigr, sigt, d, theta );</pre>      <h2>Inputs<a name="3"></a></h2>      <p><b><tt>m</tt></b> : size of the output filter.</p>      <p><b><tt>sigr</tt></b> : variance in radial direction (in pixels); <tt>sigr</tt>=4        is a typical choice.</p>      <p><b><tt>sigt</tt></b> : variance in angular direction (in radian); <tt>sigt</tt>=0.4        is a typical choice.</p>      <p><b><tt>d</tt></b> : dimension of the relative input data.</p>      <p><b><tt>theta</tt></b> : vector (of length p) with the sampled        orientations used for computing the filters.</p>      <h2>Output<a name="4"></a></h2>      <p><b><tt>f</tt></b> : (array of) matrix(ces) (all with size [m m])        storing the p oriented non-linear spatial filters that look like        hourglasses.</p>      <h2>Remarks<a name="5"></a></h2>      <p>The hourglass kernel is defined as a polar separable function, where        the radial part is a Gaussian, but the angular part modulates the        Gaussian so that it becomes zero perpendicular to the local edge        direction. The output of the filter at point <img src="hourglasskernel_eq57428.png"          alt="$(x,y)$">        is given by the following equation:</p>      <p><img src="hourglasskernel_eq64633.png" alt="$$   f_{\sigma,\rho}(r,\nu,\phi) =      \left\{      \begin{array}{ll}      \frac{1}{N}  &amp;    \mbox{if } r==0    \\      \frac{1}{N} \exp(\frac{-r^2}{2 sig^2})      \exp(- \frac{\tan(\nu - \phi)}{2*\rho^2}      &amp; \mbox{otherwise}      \end{array}      \right.$$"></p>      <p>where <img src="hourglasskernel_eq25861.png" alt="$r$"> and <img src="hourglasskernel_eq69196.png"          alt="$\nu$">        are the polar coordinates of the point <img src="hourglasskernel_eq57428.png"          alt="$(x,y)$">:</p>      <p><img src="hourglasskernel_eq70242.png" alt="$$         r = \sqrt(x^2+y^2)  \qquad       \nu = \tan^{-1} (y/x)$$"></p>      <p><img src="hourglasskernel_eq20099.png" alt="$\rho$"> defines the width        of the hourglass filter, the larger the value of <img src="hourglasskernel_eq20099.png"          alt="$\rho$">        the more the filter tends to become uniform, and <img src="hourglasskernel_eq05153.png"          alt="$N$">        is a normalization factor constant that makes the kernel integrate to        unity.</p>      <p>The dimension of the hourglass scale-space is defined by an initial        scale <img src="hourglasskernel_eq89160.png" alt="$\sigma_0$">, a final        scale <img src="hourglasskernel_eq37844.png" alt="$\sigma_f$">, and a        factor <img src="hourglasskernel_eq86607.png" alt="$k$"> of scale        change between successive levels. At each scale level <img src="hourglasskernel_eq24873.png"          alt="$\sigma$">,        a local direction <img src="hourglasskernel_eq26509.png" alt="$\phi$">        is calculated for each point in the image using a simple derivative        function. Next the hourglass kernel is rotated according to the local        edge orientation defined by <img src="hourglasskernel_eq36740.png" alt="$\phi(x,y)$">        and applied to the point, so that smoothing only occurs along the edge.</p>      <p>The hourglass filter is typically applied to a gradient tensor, i.e.        the Euclidean product of the gradient with itself. The hourglass shape        of the filter can be interpreted as indicating the likely continuations        of a local edge element. The parameter sigma determines the radius of        the hourglass (i.e. how far the influence of the edge element reaches),        and rho controls its opening angle (i.e. how narrow the edge orientation        os followed). Recommended values are <img src="hourglasskernel_eq24873.png"          alt="$\sigma$">        = 1.4 (or, more generally, two to three times the scale of the gradient        operator used in the first step), and <img src="hourglasskernel_eq20099.png"          alt="$\rho$">        = 0.4 which corresponds to an opening angle of 22.5 degrees to either        side of the edge [VIGRA].</p>      <h2>References<a name="6"></a></h2>      <p>[Koht03] U. Kothe: "Edge and junction detection with an improved        structure tensor", Proc. of DAGM Symposium, LNCS 2781, pp. 25-32,        Springer, 2003. <a href="http://hci.iwr.uni-heidelberg.de/Staff/ukoethe/papers/structureTensor.pdf">http://hci.iwr.uni-heidelberg.de/Staff/ukoethe/papers/structureTensor.pdf</a></p>      <p>[Koht03b] U. Kothe: "Integrated edge and junction detection with the        boundary tensor", Proc. IEEE ICCV, 2003. <a href="http://hci.iwr.uni-heidelberg.de/Staff/ukoethe/papers/polarfilters.pdf">http://hci.iwr.uni-heidelberg.de/Staff/ukoethe/papers/polarfilters.pdf</a></p>      <p>[VIGRA] Source code and documentation available at <a href="http://hci.iwr.uni-heidelberg.de/vigra/doc/vigra/group__TensorImaging.html">http://hci.iwr.uni-heidelberg.de/vigra/doc/vigra/group__TensorImaging.html</a>        <a href="http://hci.iwr.uni-heidelberg.de/vigra/doc/vigra/orientedtensorfilters_8hxx-source.html">http://hci.iwr.uni-heidelberg.de/vigra/doc/vigra/orientedtensorfilters_8hxx-source.html</a></p>      <h2>See also<a name="8"></a></h2>      <p>Related: <a href="GAUSSKERNEL.html"><tt>GAUSSKERNEL</tt></a>, <a href="DIRGAUSSKERNEL.html"><tt>DIRGAUSSKERNEL</tt></a>,        <a href="EUCLIDKERNEL.html"><tt>EUCLIDKERNEL</tt></a>, <a href="../../filter/html/CONVOLUTION.html"><tt>CONVOLUTION</tt></a>.        Called: <a href="matlab:web%28whichpath%28%27MESHGRID%27%29%29"><tt>MESHGRID</tt></a>.</p>      <h2>Function implementation<a name="9"></a></h2>      <pre class="codeinput"><span class="keyword">function</span> f = hourglasskernel( m, sigmar, sigmat, d, theta )</pre>      <p>parsing parameters</p>      <pre class="codeinput">error(nargchk(5, 5, nargin, <span class="string">'struct'</span>));error(nargoutchk(1, 1, nargout, <span class="string">'struct'</span>));</pre>      <p>calculation</p>      <pre class="codeinput"><span class="keyword">if</span> length(theta)&gt;1    f = zeros(m,m,length(theta));    <span class="keyword">for</span> i=1:length(theta)        f(:,:,i) = hourglasskernel(m, sigmar, sigmat, d, theta(i));    <span class="keyword">end</span>    <span class="keyword">return</span>;<span class="keyword">end</span>x = ((0:m(1)-1)-(m(1)-1)/2) / d(1);y = ((0:m(2)-1)-(m(2)-1)/2) / d(2);<span class="comment">% in the (X,Y) plane [X,Y] = meshgrid(x,y);</span>[Y,X] = meshgrid(x,y);r = sqrt(X.^2 + Y.^2);phi = atan2(Y,X);f = exp( - r.^2 / (2*sigmar^2) );f = f .* exp( - tan(phi-theta).^2 / (2*sigmat^2) );f = f / sum(f(:));</pre>      <pre class="codeinput"><span class="keyword">end</span> <span class="comment">% end of hourglasskernel</span></pre></div>    <!--##### SOURCE BEGIN #####%% HOURGLASSKERNEL - Oriented non-linear spatial hourglass filter.%%% Description% Compute the oriented non-linear spatial hourglass filter proposed in [Koht03]% and also implemented in [VIGRA].%%% Syntax%        f = HOURGLASSKERNEL( m, sigr, sigt, d, theta );%     %% Inputs% *|m|* : size of the output filter.% % *|sigr|* : variance in radial direction (in pixels); |sigr|=4 is a typical%      choice.%% *|sigt|* : variance in angular direction (in radian); |sigt|=0.4 is a typical%      choice.%% *|d|* : dimension of the relative input data.%% *|theta|* : vector (of length p) with the sampled orientations used for%      computing the filters.%%% Output% *|f|* : (array of) matrix(ces) (all with size [m m]) storing the p oriented%      non-linear spatial filters that look like hourglasses.%%% Remarks% The hourglass kernel is defined as a polar separable function, where the % radial part is a Gaussian, but the angular part modulates the Gaussian so % that it becomes zero perpendicular to the local edge direction. The% output of the filter at point $(x,y)$ is given by the following equation:%% $$%    f_{\sigma,\rho}(r,\nu,\phi) = %       \left\{%       \begin{array}{ll}%       \frac{1}{N}  &    \mbox{if } r==0    \\                %       \frac{1}{N} \exp(\frac{-r^2}{2 sig^2})%       \exp(- \frac{\tan(\nu - \phi)}{2*\rho^2}%       & \mbox{otherwise}%       \end{array}%       \right.% $$%% where $r$ and $\nu$ are the polar coordinates of the point $(x,y)$:%% $$  %          r = \sqrt(x^2+y^2)  \qquad       \nu = \tan^{-1} (y/x)% $$%% $\rho$ defines the width of the hourglass filter, the larger the value of% $\rho$ the more the filter tends to become uniform, and $N$ is a normalization % factor constant that makes the kernel integrate to unity.  %% The dimension of the hourglass scale-space is defined by an initial scale% $\sigma_0$, a final scale $\sigma_f$, and a factor $k$ of scale change% between successive levels. At each scale level $\sigma$, a local direction% $\phi$ is calculated for each point in the image using a simple derivative % function. Next the hourglass kernel is rotated according to the local edge% orientation defined by $\phi(x,y)$ and applied to the point, so that % smoothing only occurs along the edge.%% The hourglass filter is typically applied to a gradient tensor, i.e. the% Euclidean product of the gradient with itself. The hourglass shape of the% filter can be interpreted as indicating the likely continuations of a local% edge element. The parameter sigma determines the radius of the hourglass % (i.e. how far the influence of the edge element reaches), and rho controls % its opening angle (i.e. how narrow the edge orientation os followed). % Recommended values are $\sigma$ = 1.4 (or, more generally, two to three times % the scale of the gradient operator used in the first step), and $\rho$ = 0.4 % which corresponds to an opening angle of 22.5 degrees to either side of % the edge [VIGRA].%  %% References% [Koht03]  U. Kothe: "Edge and junction detection with an improved structure %      tensor", Proc. of DAGM Symposium, LNCS 2781, pp. 25-32, Springer, 2003.%      <http://hci.iwr.uni-heidelberg.de/Staff/ukoethe/papers/structureTensor.pdf>%% [Koht03b]  U. Kothe: "Integrated edge and junction detection with the %      boundary tensor", Proc. IEEE ICCV, 2003.%      <http://hci.iwr.uni-heidelberg.de/Staff/ukoethe/papers/polarfilters.pdf>%% [VIGRA]  Source code and documentation available at%      <http://hci.iwr.uni-heidelberg.de/vigra/doc/vigra/group__TensorImaging.html>%      <http://hci.iwr.uni-heidelberg.de/vigra/doc/vigra/orientedtensorfilters_8hxx-source.html>%%% Credit% <mailto:grazzja@lanl.gov J.Grazzini> (ISR-2/LANL)%%% See also  % Related:% <GAUSSKERNEL.html |GAUSSKERNEL|>,% <DIRGAUSSKERNEL.html |DIRGAUSSKERNEL|>,% <EUCLIDKERNEL.html |EUCLIDKERNEL|>,% <../../filter/html/CONVOLUTION.html |CONVOLUTION|>.% Called:% <matlab:web(whichpath('MESHGRID')) |MESHGRID|>.%% Function implementationfunction f = hourglasskernel( m, sigmar, sigmat, d, theta )%% % parsing parameterserror(nargchk(5, 5, nargin, 'struct'));error(nargoutchk(1, 1, nargout, 'struct'));%% % calculationif length(theta)>1    f = zeros(m,m,length(theta));    for i=1:length(theta)        f(:,:,i) = hourglasskernel(m, sigmar, sigmat, d, theta(i));    end    return;endx = ((0:m(1)-1)-(m(1)-1)/2) / d(1);y = ((0:m(2)-1)-(m(2)-1)/2) / d(2);% in the (X,Y) plane [X,Y] = meshgrid(x,y);[Y,X] = meshgrid(x,y);r = sqrt(X.^2 + Y.^2);phi = atan2(Y,X);f = exp( - r.^2 / (2*sigmar^2) );f = f .* exp( - tan(phi-theta).^2 / (2*sigmat^2) );f = f / sum(f(:));end % end of hourglasskernel##### SOURCE END #####-->  </body></html>