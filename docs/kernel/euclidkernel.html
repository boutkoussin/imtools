<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html>  <head>    <meta content="text/html; charset=utf-8" http-equiv="content-type">    <!--This HTML was auto-generated from MATLAB code.To make changes, update the MATLAB code and republish this document.      -->    <title>EUCLIDKERNEL - Euclidean distance weighted kernel.</title>    <meta name="generator" content="MATLAB 7.14">    <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">    <meta name="DC.date" content="2012-11-14">    <meta name="DC.source" content="euclidkernel.m">    <style type="text/css">html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}html { min-height:100%; margin-bottom:1px; }html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }html body td { vertical-align:top; text-align:left; }h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }a { color:#005fce; text-decoration:none; }a:hover { color:#005fce; text-decoration:underline; }a:visited { color:#004aa0; text-decoration:none; }p { padding:0px; margin:0px 0px 20px; }img { padding:0px; margin:0px 0px 20px; border:none; }p img, pre img, tt img, li img { margin-bottom:0px; } ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }ul li { padding:0px; margin:0px 0px 7px 0px; }ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }ul li ol li { list-style:decimal; }ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }ol li ol li { list-style-type:lower-alpha; }ol li ul { padding-top:7px; }ol li ul li { list-style:square; }.content { font-size:1.2em; line-height:140%; padding: 20px; }pre, tt, code { font-size:12px; }pre { margin:0px 0px 20px; }pre.error { color:red; }pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }span.keyword { color:#0000FF }span.comment { color:#228B22 }span.string { color:#A020F0 }span.untermstring { color:#B20000 }span.syscmd { color:#B28C00 }.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }.footer p { margin:0px; }  </style>  </head>  <body>    <div class="content">      <h1>EUCLIDKERNEL - Euclidean distance weighted kernel.</h1>      <!--introduction--><!--/introduction-->      <h2>Contents</h2>      <div>        <ul>          <li><a href="#1">Description</a></li>          <li><a href="#2">Syntax</a></li>          <li><a href="#3">Inputs</a></li>          <li><a href="#4">Output</a></li>          <li><a href="#6">See also</a></li>          <li><a href="#7">Function implementation</a></li>        </ul>      </div>      <h2>Description<a name="1"></a></h2>      <p>Create a kernel spatially weighted with the (posibly inverse) Euclidean        distance to a point (typically, belonging to the kernel) this is        equivalent to a 'moving-window' style matrix with distance to centroid        cell weighted.</p>      <h2>Syntax<a name="2"></a></h2>      <pre>     W = EUCLIDKERNEL([wsx wsy]);     W = EUCLIDKERNEL([wsx wsy cind], [dy dx], norm, inverse );     W = EUCLIDKERNEL([wsx wsy cx cy], [dy dx], norm, inverse );</pre>      <h2>Inputs<a name="3"></a></h2>      <p><b><tt>wsx, wsy</tt></b> : vector of the (X,Y) dimension of the kernel        window.</p>      <p><b><tt>cind</tt></b> or <b><tt>cx, cy</tt></b> : coordinates (passed        as an integer &gt;=1 matrix location index or a couple of real &gt;=0        (X,Y) position values) of the centroid of the kernel, ie. the point to        which Euclidean distances are computed; note that this point can also be        set outside the kernel, however in the case it is passed as an index, it        is not garanteed that it will be positioned as desired (no domain        information is available); in the case the coordinates of the centroid        are not passed, it is set to a central position of the kernel (with some        arbitrary when the kernel dimensions are even).</p>      <p><b><tt>d</tt></b> : vector <tt>[dy dx]</tt> of the cellspacing in        (X,Y) direction (typically, <tt>d=1</tt>); default: <tt>d=1</tt>.</p>      <p><b><tt>norm</tt></b> : logical flag specifying if the weight matrix is        to be normalized; default: <tt>norm=false</tt>.</p>      <p><b><tt>inverse</tt></b> : logical flag setting if the inverse of the        euclidean distance is to be computed or not; default: <tt>inverse=false</tt>,        ie. the weights are given by the Euclidean distance.</p>      <h2>Output<a name="4"></a></h2>      <p><b><tt>W</tt></b> : matrix with weights for every cell except center;        weights are the (inverse of the) Euclidean distance to the center cell;        center cell weight is 0.</p>      <h2>See also<a name="6"></a></h2>      <p>Related: <a href="DIRGAUSSKERNEL.html"><tt>DIRGAUSSKERNEL</tt></a>, <a          href="GAUSSKERNEL.html"><tt>GAUSSKERNEL</tt></a>,        <a href="HOURGLASSKERNEL.html"><tt>HOURGLASSKERNEL</tt></a>. Called: <a          href="matlab:web%28whichpath%28%27MESHGRID%27%29%29"><tt>MESHGRID</tt></a>.</p>      <h2>Function implementation<a name="7"></a></h2>      <pre class="codeinput"><span class="keyword">function</span> W = euclidkernel(ws, d, n, inv)</pre>      <p>parsing parameters</p>      <pre class="codeinput">error(nargchk(1, 4, nargin, <span class="string">'struct'</span>));<span class="comment">% we allow for a variable number of entries</span><span class="keyword">if</span> nargin&lt;4,  inv = false;    <span class="keyword">if</span> nargin&lt;3,  n = false;        <span class="keyword">if</span> nargin&lt;2,  d = 1;  <span class="keyword">end</span>    <span class="keyword">end</span><span class="keyword">end</span></pre>      <p>setting parameters</p>      <pre class="codeinput"><span class="keyword">if</span> length(ws)&lt;=2    <span class="keyword">if</span> length(ws)==1, ws = [ws ws];  <span class="keyword">end</span>    <span class="comment">% if mod(ws(1),2)==0,  ws(1) = ws(1)+1;  end</span>    <span class="comment">% if mod(ws(2),2)==0,  ws(2) = ws(2)+1;  end</span>    cx = ceil(ws(1)/2); cy = ceil(ws(2)/2);<span class="keyword">elseif</span> length(ws)==3    [cx cy] = ind2sub([ws(1) ws(2)], ws(3));<span class="keyword">elseif</span> length(ws)==4    cx = ws(3); cy = ws(4);<span class="keyword">else</span>    error(<span class="string">'euclidkernel:inputerror'</span>,<span class="keyword">...</span>        <span class="string">'input dimension vector ws must be of dimension &gt;=2 and &lt;=4'</span>);<span class="keyword">end</span><span class="keyword">if</span> cx&gt;ws(1) || cy&gt;ws(2)    warning(<span class="string">'euclidkernel:inputwarning'</span>,<span class="keyword">...</span>        <span class="string">'centroid outside kernel: its position may be different than what expected'</span>);<span class="keyword">end</span><span class="keyword">if</span> length(d)==1    d = [d d];<span class="keyword">elseif</span> length(d)~=2    error(<span class="string">'euclidkernel:inputerror'</span>,<span class="keyword">...</span>        <span class="string">'input cellspacing vector must be of dimension &lt;=2'</span>);<span class="keyword">end</span></pre>      <p>create a meshgrid centered around the passed centroid</p>      <pre class="codeinput">[X,Y] = meshgrid(-cy+1:1:ws(2)-cy,-cx+1:1:ws(1)-cx);X = X * d(2);Y = Y * d(1);W = sqrt(X.^2 + Y.^2);</pre>      <p>inverse the weights</p>      <pre class="codeinput"><span class="keyword">if</span> inv   W(cx,cy) = 1; <span class="comment">%set center to 1 to avoid division by zero error</span>   W = 1./W; <span class="comment">% get inverse distance</span>   W(cx,cy) = 0; <span class="comment">%set center weight to zero</span><span class="keyword">end</span></pre>      <p>normalize</p>      <pre class="codeinput"><span class="keyword">if</span> n    s = sum(W(:));    <span class="keyword">if</span> s~=0,   W = W ./ s;  <span class="keyword">end</span><span class="keyword">end</span></pre>      <pre class="codeinput"><span class="keyword">end</span> <span class="comment">% end of euclidkernel</span></pre></div>    <!--##### SOURCE BEGIN #####%% EUCLIDKERNEL - Euclidean distance weighted kernel.%%% Description% Create a kernel spatially weighted with the (posibly inverse) Euclidean% distance to a point (typically, belonging to the kernel) this is equivalent% to a 'moving-window' style matrix with distance to centroid cell weighted.% %% Syntax%       W = EUCLIDKERNEL([wsx wsy]);%       W = EUCLIDKERNEL([wsx wsy cind], [dy dx], norm, inverse );%       W = EUCLIDKERNEL([wsx wsy cx cy], [dy dx], norm, inverse );% %% Inputs% *|wsx, wsy|* : vector of the (X,Y) dimension of the kernel window.%% *|cind|* or *|cx, cy|* : coordinates (passed as an integer >=1 matrix location%     index or a couple of real >=0 (X,Y) position values) of the centroid %     of the kernel, ie. the point to which Euclidean distances are computed;%     note that this point can also be set outside the kernel, however in the%     case it is passed as an index, it is not garanteed that it will be%     positioned as desired (no domain information is available); in the case%     the coordinates of the centroid are not passed, it is set to a central%     position of the kernel (with some arbitrary when the kernel dimensions %     are even).%% *|d|* : vector |[dy dx]| of the cellspacing in (X,Y) direction (typically,%     |d=1|); default: |d=1|.%% *|norm|* : logical flag specifying if the weight matrix is to be normalized; %     default: |norm=false|.%   % *|inverse|* : logical flag setting if the inverse of the euclidean distance%     is to be computed or not; default: |inverse=false|, ie. the weights %     are given by the Euclidean distance.%%% Output% *|W|* : matrix with weights for every cell except center; weights are the %     (inverse of the) Euclidean distance to the center cell; center cell%     weight is 0.%%% Credit% <mailto:grazzja@lanl.gov J.Grazzini> (ISR-2/LANL)%%% See also% Related:% <DIRGAUSSKERNEL.html |DIRGAUSSKERNEL|>,% <GAUSSKERNEL.html |GAUSSKERNEL|>,% <HOURGLASSKERNEL.html |HOURGLASSKERNEL|>.% Called:% <matlab:web(whichpath('MESHGRID')) |MESHGRID|>.%% Function implementationfunction W = euclidkernel(ws, d, n, inv)%%% parsing parameterserror(nargchk(1, 4, nargin, 'struct'));% we allow for a variable number of entriesif nargin<4,  inv = false;    if nargin<3,  n = false;         if nargin<2,  d = 1;  end    endend%%% setting parametersif length(ws)<=2    if length(ws)==1, ws = [ws ws];  end    % if mod(ws(1),2)==0,  ws(1) = ws(1)+1;  end    % if mod(ws(2),2)==0,  ws(2) = ws(2)+1;  end    cx = ceil(ws(1)/2); cy = ceil(ws(2)/2);    elseif length(ws)==3    [cx cy] = ind2sub([ws(1) ws(2)], ws(3));    elseif length(ws)==4    cx = ws(3); cy = ws(4);   else     error('euclidkernel:inputerror',...        'input dimension vector ws must be of dimension >=2 and <=4');    endif cx>ws(1) || cy>ws(2)    warning('euclidkernel:inputwarning',...        'centroid outside kernel: its position may be different than what expected');endif length(d)==1    d = [d d];   elseif length(d)~=2    error('euclidkernel:inputerror',...        'input cellspacing vector must be of dimension <=2');end%%% create a meshgrid centered around the passed centroid[X,Y] = meshgrid(-cy+1:1:ws(2)-cy,-cx+1:1:ws(1)-cx);X = X * d(2);Y = Y * d(1);W = sqrt(X.^2 + Y.^2);%%% inverse the weightsif inv   W(cx,cy) = 1; %set center to 1 to avoid division by zero error   W = 1./W; % get inverse distance   W(cx,cy) = 0; %set center weight to zeroend%% % normalizeif n    s = sum(W(:));    if s~=0,   W = W ./ s;  endendend % end of euclidkernel##### SOURCE END #####--></body></html>