<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html>  <head>    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">    <!--This HTML was auto-generated from MATLAB code.To make changes, update the MATLAB code and republish this document.      -->    <title>FMMANISOPROPAGATION - Anisotropic propagation through Fast Marching      in 2D.</title>    <meta name="generator" content="MATLAB 7.14">    <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">    <meta name="DC.date" content="2012-05-31">    <meta name="DC.source" content="fmmanisopropagation.m">    <style type="text/css">html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}html { min-height:100%; margin-bottom:1px; }html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }html body td { vertical-align:top; text-align:left; }h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }a { color:#005fce; text-decoration:none; }a:hover { color:#005fce; text-decoration:underline; }a:visited { color:#004aa0; text-decoration:none; }p { padding:0px; margin:0px 0px 20px; }img { padding:0px; margin:0px 0px 20px; border:none; }p img, pre img, tt img, li img { margin-bottom:0px; } ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }ul li { padding:0px; margin:0px 0px 7px 0px; }ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }ul li ol li { list-style:decimal; }ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }ol li ol li { list-style-type:lower-alpha; }ol li ul { padding-top:7px; }ol li ul li { list-style:square; }.content { font-size:1.2em; line-height:140%; padding: 20px; }pre, tt, code { font-size:12px; }pre { margin:0px 0px 20px; }pre.error { color:red; }pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }span.keyword { color:#0000FF }span.comment { color:#228B22 }span.string { color:#A020F0 }span.untermstring { color:#B20000 }span.syscmd { color:#B28C00 }.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }.footer p { margin:0px; }  </style>  </head>  <body>    <div class="content">      <h1>FMMANISOPROPAGATION - Anisotropic propagation through Fast Marching in        2D.</h1>      <!--introduction--><!--/introduction-->      <h2>Contents</h2>      <div>        <ul>          <li><a href="#1">Description</a></li>          <li><a href="#2">Syntax</a></li>          <li><a href="#3">Inputs</a></li>          <li><a href="#4">Outputs</a></li>          <li><a href="#5">Remark</a></li>          <li><a href="#6">References</a></li>          <li><a href="#8">See also</a></li>          <li><a href="#9">Function implementation</a></li>        </ul>      </div>      <h2>Description<a name="1"></a></h2>      <p>Perform anisotropic Fast Marching following the approach developped in        [SKDCCRRA07,BPC08,PC09] and using the implementation of [GCM] as        suggested in [PLPWDFS06a,PLPWDFS06b].</p>      <h2>Syntax<a name="2"></a></h2>      <pre class="language-matlab">D = FMMANISOPROPAGATION(W, start_pts, L);[D, V] = FMMANISOPROPAGATION(W, start_pts, method, L, niter);</pre>      <h2>Inputs<a name="3"></a></h2>      <p><b><tt>W</tt></b> : cost function; it should be a <tt>(m,n,2)</tt>        (for 2D vector field) or a <tt>(m,n,2,2)</tt> (for tensor field) weight        matrix.</p>      <p><b><tt>start_pts</tt></b> : a <tt>(2,k)</tt> matrix where <tt>k</tt>        is the number of starting points.</p>      <p><b><tt>end_pts</tt></b> : a (2,l) matrix where <tt>l</tt> is the        number of ending points; the FMM propagation stops when these points are        reached.</p>      <p><b><tt>method</tt></b> : logical boolean used for selecting the method:        <tt>true</tt> for using <tt>FMMANISOPROPAGATION_MEX</tt> and <tt>false</tt>        for using <tt>FM2DANISO_MEX</tt>.</p>      <p><b><tt>L</tt></b> : optional constraint map used when <tt>method=true</tt>        to reduce the set of explored points, as only points with current        distance smaller than their values in <tt>L</tt> will be visited; set        entries to <tt>-Inf</tt> in <tt>L</tt> if you do not want points to be        visited by FMM; default: <tt>L=Inf</tt>, ie. all points are visited.</p>      <p><b><tt>niter</tt></b> : maximum number of iterations; default: <tt>niter=Inf</tt>.</p>      <h2>Outputs<a name="4"></a></h2>      <p><b><tt>D</tt></b> : a 2D array containing the value of the distance        function to seed.</p>      <p><b><tt>V</tt></b> : optional variable returned when method=true; index        of the closest point from the set of starting points (0 for points which        have not been reached); <tt>V</tt> provide a Voronoi decomposition of        the domain.</p>      <h2>Remark<a name="5"></a></h2>      <p>If the Voronoi diagram <tt>V</tt> is desired in output (see above),        the function <tt>FM2DANISO_MEX</tt> should be called, hence the option        method should be set to <tt>false</tt>.</p>      <h2>References<a name="6"></a></h2>      <p>[PLPWDFS06a] E. Prados, C. Lenglet, J. Pons, N. Wotawa, R. Deriche, O.        Faugeras, S. Soatto: "Control theory and fast marching methods for brain        connectivity mapping", INRIA Research Report 5845, 2006.</p>      <p>[PLPWDFS06b] E. Prados, C. Lenglet, J. Pons, N. Wotawa, R. Deriche, O.        Faugeras, S. Soatto: "Control theory and fast marching methods for brain        connectivity mapping", Proc. IEEE CVPR, pp. 1076?1083, 2006.</p>      <p>[SKDCCRRA07] M. Sermesant, E. Konukoglu, H. Delingette, Y. Coudiere, P.        Chinchapatnam, K. Rhode, R. Razavi and N. Ayache: "An anisotropic        multi-front fast marching method for real-time simulation of cardiac        electrophysiology, Proc. FIMH, LNCS 4466, pp. 160-169, 2007,</p>      <p>[BPC08] S. Bougleux, G. Peyre, and L. Cohen: "Anisotropic geodesics for        perceptual grouping and domain meshing", Proc. ECCV, vol. 2, pp.        129-142, 2008.</p>      <p>[PC09] G. Peyre, and L. Cohen: "Geodesic methods for shape and surface        processing", in "Advances in Computational Vision and Medical Image        Processing: Methods and Applications", vol. 13 of "Computational Methods        in Applied Sciences", pp. 29-56, Springer, 2009.</p>      <p>[PFMM] Peyre 's toolbox on FMM available at <a href="http://www.mathworks.com/matlabcentral/fileexchange/24531-accurate-fast-marching">https://www.ceremade.dauphine.fr/~peyre/matlab/fast-marching/content.html</a></p>      <p>[GCM] See GCM - Geodesic Connectivity Mapping source code available at        <a href="http://gcm.gforge.inria.fr/GCM-Publications.html">http://gcm.gforge.inria.fr/GCM-Publications.html</a></p>      <h2>See also<a name="8"></a></h2>      <p>Ressembles: <a href="fmm.html"><tt>FMM</tt></a>, <a href="fmm_base.html"><tt>FMM_BASE</tt></a>,        <a href="fmmisopropagation.html"><tt>FMMISOPROPAGATION</tt></a>, <a href="dijkstrapropagation.html"><tt>DIJKSTRAPROPAGATION</tt></a>,        <a href="potential2front.html"><tt>POTENTIAL2FRONT</tt></a>, <a href="im2front_base.html"><tt>IM2FRONT_BASE</tt></a>.        Requires: <a href="im2potential.html"><tt>IM2POTENTIAL</tt></a>,        FMMANISOPROPAGATION_MEX, FM2DANISO_MEX.</p>      <h2>Function implementation<a name="9"></a></h2>      <pre class="codeinput"><span class="keyword">function</span> [D, V] = fmmanisopropagation(W, start_pts, method, L, niter)</pre>      <pre class="codeinput"><span class="comment">% we allow variable number of inputs</span><span class="keyword">if</span> nargin &lt;=4,    niter = Inf;    <span class="keyword">if</span> nargin&lt;=3,      L = [];        <span class="keyword">if</span> nargin&lt;=2,  method = true;  <span class="keyword">end</span>    <span class="keyword">end</span><span class="keyword">end</span><span class="comment">% ensure this outside the function</span><span class="comment">% if size(start_pts,1)~=2</span><span class="comment">%     error('fmmanisopropagation:inputerror', ...</span><span class="comment">%     'seed points should be (2 x k) dimensional');</span><span class="comment">% end</span></pre>      <p>check/set the input tensor field used for anisotropic propagation via        FMM</p>      <pre class="codeinput">d = nb_dims(W);m = size(W,1);n = size(W,2);<span class="keyword">if</span> d==2 <span class="comment">% a scalar field has been passed: use isotropic FMM instead</span>    warning(<span class="string">'fmmanisopropagation:inputwarning'</span>, <spanclass="keyword">...</span>        <span class="string">'use isotropic FMM approach with scalar cost field'</span>);    <span class="comment">% W = gstfeature(W(:,:,1,1),W(:,:,2,2),W(:,:,1,2),'norm');</span>    <span class="comment">% TODO: rather call isotropic FMM with FMMISOPROPAGATION</span>    <span class="keyword">return</span>;<span class="keyword">elseif</span> d==3 <span class="comment">% a vector field has been passed</span>    V = cat(3, -W(:,:,2), W(:,:,1)); <span class="comment">% orthogonal vector</span>    W = gstdecomp(W, V, ones(m,n), ones(m,n) );<span class="keyword">elseif</span> d~=4 <span class="comment">% all other cases: hope not to reach this point</span>     error(<span class="string">'fmmanisopropagation:inputerror'</span>, <span class="keyword">...</span>        <span class="string">'input cost function should be a vector of a tensor field'</span>);<span class="keyword">end</span></pre>      <p>!!! The following code runs with square matrices (ie. <tt>size(w,1)==size(w,2)</tt>),        therefore we have to transform the input !!!</p>      <pre class="codeinput"><span class="keyword">if</span> m~=n    M = max([m n]);    W = padarray(W, [M-m M-n], 1, <span class="string">'post'</span>);<span class="keyword">else</span>    M = m;<span class="keyword">end</span>pad = 0;<span class="comment">% pad = 1;</span><span class="keyword">if</span> pad,  W = padarray(W,[pad pad], 1, <span class="string">'both'</span>);  <spanclass="keyword">end</span>                    <spanclass="comment">%#ok</span></pre>      <p>launch the mex files</p>      <pre class="codeinput"><span class="keyword">if</span> method &amp;&amp; exist(<spanclass="string">'fmmanisopropagation_mex'</span>,<spanclass="string">'file'</span>)    <span class="comment">% at that point, we should have d=4: W is a structure tensor field</span>    <span class="comment">% in order to use fmmanisopropagation_mex (see [GCM] source code), we</span>    <span class="comment">% need to inject the 2D space into a 3D space</span>    <span class="comment">% % practical issue: how to deal with null tensor</span>    <span class="comment">% [l1, l2, e1, e2] = gstdecomp(W);</span>    <span class="comment">% I = l1==0;</span>    <span class="comment">% l1(I) = 1e-9; % eps for C implementation</span>    <span class="comment">% % l2(I) = 0;</span>    <span class="comment">% % v = e1(:,:,1); v(I) = 1; e1(:,:,1) = v;</span>    <span class="comment">% % v = e1(:,:,2); v(I) = 0; e1(:,:,2) = v;</span>    <span class="comment">% % v = e2(:,:,1); v(I) = 0; e2(:,:,1) = v;</span>    <span class="comment">% % v = e2(:,:,2); v(I) = 1; e2(:,:,2) = v;</span>    <span class="comment">% W = gstdecomp(l1, l2, e1, e2);</span>    <span class="keyword">if</span> size(W,3)==2 &amp;&amp; size(W,4)==2        <span class="comment">% we transform the 2D vector field into a 3D field</span>        W1 = zeros(M+2*pad, M+2*pad, 3, 3);        W1(:,:,1:2,1:2) = W;        W1(:,:,3,3) = 1;        W = reshape(W1, [M+2*pad M+2*pad, 1 3 3]);        <span class="comment">% convert to correct size</span>        W = cat(4, W(:,:,:,1,1), W(:,:,:,1,2), W(:,:,:,1,3), <span class="keyword">...</span>            W(:,:,:,2,2), W(:,:,:,2,3), W(:,:,:,3,3) );    <span class="keyword">end</span>    <span class="comment">% padd to avoid boundary problem</span>    W = cat(1, W(1,:,:,:), W, W(end,:,:,:));    W = cat(2, W(:,1,:,:), W, W(:,end,:,:));    W = cat(3, W(:,:,1,:), W, W(:,:,end,:));    <span class="comment">% prepare the set of points</span>    start_pts(end+1,:) = 1; <span class="comment">% we represent the point in a 3D space</span>    <span class="comment">% launch the anisotropic FMM</span>    <span class="comment">%    start_pts = start_pts-1;</span>    <span class="keyword">if</span> isempty(L),  L = Inf(size(W,1), size(W,2), 3); <spanclass="comment">% ones</span>    <span class="keyword">end</span>    <span class="comment">%    if pad,  L = padarray(L, [pad pad], -Inf, 'both');  end</span>    alpha = 0; <span class="comment">% euclidean norm: see source code [GCM], functions</span>    <span class="comment">% AnisotropicTensorDistanceConfidence.h and AnisotropicTensorDistance.h</span>    [D, V] = fmmanisopropagation_mex(W, L, alpha, start_pts, niter);    <span class="comment">% remove boundary problems</span>    D = D(2:end-1, 2:end-1, 2);    <span class="keyword">if</span> sum(V(:))==0,  V = [];  <span class="comment">% no Voronoi output... problem here!!!</span>    <span class="keyword">else</span>              V = V(2:end-1, 2:end-1, 2);  <spanclass="keyword">end</span><span class="keyword">elseif</span> ~method &amp;&amp; exist(<span class="string">'fm2daniso_mex'</span>,<spanclass="string">'file'</span>)    step = [1; 1];    <span class="comment">% step = [1/size(W,1), 1/size(W,2)];</span>    [D, ~, ~, V] = fm2daniso_mex(step, W, start_pts);<span class="keyword">else</span> <span class="comment">% hope not to reach this point either</span>    error(<span class="string">'fmmanisopropagation:libraryerror'</span>,<span class="keyword">...</span>        <span class="string">'method fmmanisopropagation not available'</span>);<span class="keyword">end</span></pre>      <p>the final touch...</p>      <pre class="codeinput"><span class="keyword">if</span> pad  <span class="comment">% get rid of the boundary pad</span>    D = D(1+pad:end-pad, 1+pad:end-pad);                               <span class="comment">%#ok</span><span class="keyword">end</span><span class="keyword">if</span> m~=n  <span class="comment">% get rid of the dimension pad: finally reset to the correct size</span>    D = D(1:m,1:n);    <span class="keyword">if</span> ~isempty(V),  V = V(1:m,1:n);  <span class="keyword">end</span><span class="keyword">end</span><span class="comment">% reset to Matlab Inf values</span>D(D&gt;1e16) = Inf;</pre>      <pre class="codeinput"><span class="keyword">end</span> <span class="comment">% end of fmmanisopropagation</span></pre></div>    <!--##### SOURCE BEGIN #####%% FMMANISOPROPAGATION - Anisotropic propagation through Fast Marching in 2D.%%% Description% Perform anisotropic Fast Marching following the approach developped in% [SKDCCRRA07,BPC08,PC09] and using the implementation of [GCM] as suggested% in [PLPWDFS06a,PLPWDFS06b]. %%% Syntax%   D = FMMANISOPROPAGATION(W, start_pts, L);%   [D, V] = FMMANISOPROPAGATION(W, start_pts, method, L, niter);%%% Inputs% *|W|* : cost function; it should be a |(m,n,2)| (for 2D vector field) or%     a |(m,n,2,2)| (for tensor field) weight matrix.%% *|start_pts|* : a |(2,k)| matrix where |k| is the number of starting points.%% *|end_pts|* : a (2,l) matrix where |l| is the number of ending points; the%     FMM propagation stops when these points are reached.%% *|method|* : logical boolean used for selecting the method: |true| for using%     |FMMANISOPROPAGATION_MEX| and |false| for using |FM2DANISO_MEX|.%% *|L|* : optional constraint map used when |method=true| to reduce the set%     of explored points, as only points with current distance smaller than %     their values in |L| will be visited; set entries to |-Inf| in |L| if %     you do not want points to be visited by FMM; default: |L=Inf|, ie. all%     points are visited.%% *|niter|* : maximum number of iterations; default: |niter=Inf|.% %% Outputs% *|D|* : a 2D array containing the value of the distance function to seed.%% *|V|* : optional variable returned when method=true; index of the closest%     point from the set of starting points (0 for points which have not%     been reached); |V| provide a Voronoi decomposition of the domain. %%% Remark% If the Voronoi diagram |V| is desired in output (see above), the function% |FM2DANISO_MEX| should be called, hence the option method should be set to% |false|.%%% References% [PLPWDFS06a] E. Prados, C. Lenglet, J. Pons, N. Wotawa, R. Deriche, O.%       Faugeras, S. Soatto: "Control theory and fast marching methods for%       brain connectivity mapping", INRIA Research Report 5845, 2006.%% [PLPWDFS06b] E. Prados, C. Lenglet, J. Pons, N. Wotawa, R. Deriche, O.%       Faugeras, S. Soatto: "Control theory and fast marching methods for%       brain connectivity mapping", Proc. IEEE CVPR, pp. 1076?1083, 2006.%% [SKDCCRRA07]  M. Sermesant, E. Konukoglu, H. Delingette, Y. Coudiere,%       P. Chinchapatnam, K. Rhode, R. Razavi and N. Ayache: "An anisotropic%       multi-front fast marching method for real-time simulation of cardiac%       electrophysiology, Proc. FIMH, LNCS 4466, pp. 160-169, 2007,%% [BPC08]  S. Bougleux, G. Peyre, and L. Cohen: "Anisotropic geodesics for%       perceptual grouping and domain meshing", Proc. ECCV, vol. 2, pp.%       129-142, 2008.%% [PC09]  G. Peyre, and L. Cohen: "Geodesic methods for shape and surface%       processing", in "Advances in Computational Vision and Medical Image%       Processing: Methods and Applications", vol. 13 of "Computational %       Methods in Applied Sciences", pp. 29-56, Springer, 2009.%% [GCM]  See GCM - Geodesic Connectivity Mapping source code available at%                          http://gcm.gforge.inria.fr/GCM-Publications.html%  %% Credit% <mailto:grazzja@lanl.gov J.Grazzini> (ISR-2/LANL)%%% See also% Ressembles:% <fmm.html |FMM|>,% <fmm_base.html |FMM_BASE|>,% <fmmisopropagation.html |FMMISOPROPAGATION|>,% <dijkstrapropagation.html |DIJKSTRAPROPAGATION|>,% <potential2front.html |POTENTIAL2FRONT|>,% <im2front_base.html |IM2FRONT_BASE|>.% Requires: % <im2potential.html |IM2POTENTIAL|>,% FMMANISOPROPAGATION_MEX, % FM2DANISO_MEX. %% Function implementationfunction [D, V] = fmmanisopropagation(W, start_pts, method, L, niter)% we allow variable number of inputsif nargin <=4,    niter = Inf;    if nargin<=3,      L = [];        if nargin<=2,  method = true;  end    endend % ensure this outside the function% if size(start_pts,1)~=2%     error('fmmanisopropagation:inputerror', ...%     'seed points should be (2 x k) dimensional');% end%% % check/set the input tensor field used for anisotropic propagation via FMMd = nb_dims(W);m = size(W,1);n = size(W,2);if d==2 % a scalar field has been passed: use isotropic FMM instead    warning('fmmanisopropagation:inputwarning', ...        'use isotropic FMM approach with scalar cost field');    % W = gstfeature(W(:,:,1,1),W(:,:,2,2),W(:,:,1,2),'norm');    % TODO: rather call isotropic FMM with FMMISOPROPAGATION    return;    elseif d==3 % a vector field has been passed    V = cat(3, -W(:,:,2), W(:,:,1)); % orthogonal vector    W = gstdecomp(W, V, ones(m,n), ones(m,n) );    elseif d~=4 % all other cases: hope not to reach this point     error('fmmanisopropagation:inputerror', ...        'input cost function should be a vector of a tensor field');    end%%% !!! The following code runs with square matrices (ie. |size(w,1)==size(w,2)|),% therefore we have to transform the input !!!if m~=n    M = max([m n]);    W = padarray(W, [M-m M-n], 1, 'post'); else     M = m;endpad = 0;% pad = 1;if pad,  W = padarray(W,[pad pad], 1, 'both');  end                    %#ok%% % launch the mex filesif method && exist('fmmanisopropagation_mex','file')     % at that point, we should have d=4: W is a structure tensor field    % in order to use fmmanisopropagation_mex (see [GCM] source code), we    % need to inject the 2D space into a 3D space        % % practical issue: how to deal with null tensor    % [l1, l2, e1, e2] = gstdecomp(W);    % I = l1==0;    % l1(I) = 1e-9; % eps for C implementation    % % l2(I) = 0;    % % v = e1(:,:,1); v(I) = 1; e1(:,:,1) = v;    % % v = e1(:,:,2); v(I) = 0; e1(:,:,2) = v;    % % v = e2(:,:,1); v(I) = 0; e2(:,:,1) = v;    % % v = e2(:,:,2); v(I) = 1; e2(:,:,2) = v;    % W = gstdecomp(l1, l2, e1, e2);        if size(W,3)==2 && size(W,4)==2        % we transform the 2D vector field into a 3D field        W1 = zeros(M+2*pad, M+2*pad, 3, 3);        W1(:,:,1:2,1:2) = W;        W1(:,:,3,3) = 1;        W = reshape(W1, [M+2*pad M+2*pad, 1 3 3]);        % convert to correct size        W = cat(4, W(:,:,:,1,1), W(:,:,:,1,2), W(:,:,:,1,3), ...            W(:,:,:,2,2), W(:,:,:,2,3), W(:,:,:,3,3) );    end        % padd to avoid boundary problem    W = cat(1, W(1,:,:,:), W, W(end,:,:,:));    W = cat(2, W(:,1,:,:), W, W(:,end,:,:));    W = cat(3, W(:,:,1,:), W, W(:,:,end,:));        % prepare the set of points    start_pts(end+1,:) = 1; % we represent the point in a 3D space        % launch the anisotropic FMM        %    start_pts = start_pts-1;    if isempty(L),  L = Inf(size(W,1), size(W,2), 3); % ones    end    %    if pad,  L = padarray(L, [pad pad], -Inf, 'both');  end        alpha = 0; % euclidean norm: see source code [GCM], functions    % AnisotropicTensorDistanceConfidence.h and AnisotropicTensorDistance.h    [D, V] = fmmanisopropagation_mex(W, L, alpha, start_pts, niter);    % remove boundary problems    D = D(2:end-1, 2:end-1, 2);    if sum(V(:))==0,  V = [];  % no Voronoi output... problem here!!!    else              V = V(2:end-1, 2:end-1, 2);  end     elseif ~method && exist('fm2daniso_mex','file')    step = [1; 1];      % step = [1/size(W,1), 1/size(W,2)];    [D, ~, ~, V] = fm2daniso_mex(step, W, start_pts);    else % hope not to reach this point either    error('fmmanisopropagation:libraryerror',...        'method fmmanisopropagation not available');    end%% % the final touch...if pad  % get rid of the boundary pad    D = D(1+pad:end-pad, 1+pad:end-pad);                               %#okendif m~=n  % get rid of the dimension pad: finally reset to the correct size    D = D(1:m,1:n);    if ~isempty(V),  V = V(1:m,1:n);  endend% reset to Matlab Inf valuesD(D>1e16) = Inf;end % end of fmmanisopropagation##### SOURCE END #####--></body></html>