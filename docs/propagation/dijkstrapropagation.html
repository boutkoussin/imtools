<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html>  <head>    <meta content="text/html; charset=utf-8" http-equiv="content-type">    <!--This HTML was auto-generated from MATLAB code.To make changes, update the MATLAB code and republish this document.      -->    <title>DIJKSTRAPROPAGATION - C implementation of Dijsktra algorithm through      propagation.</title>    <meta name="generator" content="MATLAB 7.14">    <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">    <meta name="DC.date" content="2012-05-31">    <meta name="DC.source" content="dijkstrapropagation.m">    <style type="text/css">html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}html { min-height:100%; margin-bottom:1px; }html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }html body td { vertical-align:top; text-align:left; }h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }a { color:#005fce; text-decoration:none; }a:hover { color:#005fce; text-decoration:underline; }a:visited { color:#004aa0; text-decoration:none; }p { padding:0px; margin:0px 0px 20px; }img { padding:0px; margin:0px 0px 20px; border:none; }p img, pre img, tt img, li img { margin-bottom:0px; } ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }ul li { padding:0px; margin:0px 0px 7px 0px; }ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }ul li ol li { list-style:decimal; }ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }ol li ol li { list-style-type:lower-alpha; }ol li ul { padding-top:7px; }ol li ul li { list-style:square; }.content { font-size:1.2em; line-height:140%; padding: 20px; }pre, tt, code { font-size:12px; }pre { margin:0px 0px 20px; }pre.error { color:red; }pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }span.keyword { color:#0000FF }span.comment { color:#228B22 }span.string { color:#A020F0 }span.untermstring { color:#B20000 }span.syscmd { color:#B28C00 }.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }.footer p { margin:0px; }  </style>  </head>  <body>    <div class="content">      <h1>DIJKSTRAPROPAGATION - C implementation of Dijsktra algorithm through        propagation.</h1>      <!--introduction--><!--/introduction-->      <h2>Contents</h2>      <div>        <ul>          <li><a href="#1">Description</a></li>          <li><a href="#2">Syntax</a></li>          <li><a href="#3">Outputs</a></li>          <li><a href="#4">References</a></li>          <li><a href="#6">See also</a></li>          <li><a href="#7">Function implementation</a></li>          <li><a href="#8">Subfunctions</a></li>        </ul>      </div>      <h2>Description<a name="1"></a></h2>      <p>Shortest distance from multiple source points on graph.</p>      <h2>Syntax<a name="2"></a></h2>      <pre class="language-matlab">[D,P] = DIJKSTRAPROPAGATION(W, start_verts, end_verts, niter);</pre>      <h2>Outputs<a name="3"></a></h2>      <p><b><tt>D</tt></b> : the distance to the set of starting points. <b><tt>P</tt></b>        : shortest paths.</p>      <h2>References<a name="4"></a></h2>      <pre>http://www.comp.nus.edu.sg/~xujia/mirror/algorithm.myrice.com/resources/technical_artile/fibonacci_heap/fibonacci.htmand source code available at      http://web.mit.edu/cocosci/isomap/code/</pre>      <h2>See also<a name="6"></a></h2>      <p>Related: <a href="../graph/dijkstra.html"><tt>DIJKSTRA</tt></a>,        <a href="../graph/dijkstra_base.html"><tt>DIJKSTRA_BASE</tt></a>,        <a href="../graph/dijk.html"><tt>DIJK</tt></a>, <a href="../graph/dijkadvanced.html"><tt>DIJKADVANCED</tt></a>,        <a href="fmm.html"><tt>FMM</tt></a>. Called: DIJKSTRAPROPAGATION_MEX.</p>      <h2>Function implementation<a name="7"></a></h2>      <pre class="codeinput"><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> [D,P] = dijkstrapropagation(W, start_verts, end_verts, niter)n = size(W,1); <span class="comment">% n = length(W);  % number of points in the graph</span>m = length(start_verts);<span class="keyword">if</span> sum(start_verts&gt;n)&gt;0 || sum(end_verts&gt;n)&gt;0    error(<span class="string">'dijkstrapropagation:inputerror'</span>, <span class="keyword">...</span>        <span class="string">'out of bound start/end vertices.'</span>);<span class="keyword">end</span><span class="keyword">if</span> isequal(start_verts,end_verts)    <span class="comment">% compute the distance between each point on the graph: compute path</span>    <span class="comment">% from a set of points</span>    <span class="keyword">if</span> exist(<span class="string">'dijkstraset_mex'</span>,<spanclass="string">'file'</span>)        D = dijkstraset_mex(W, start_verts);        <span class="comment">% D(i,j) is the distance between start_verts(i) and start_verts(j)</span>        D(diag(true(m,1),0)) = 0; <span class="comment">% set the distance of a point to itself to 0</span>        <span class="keyword">if</span> nargout==2            <span class="comment">% extract the paths</span>            <span class="comment">% !!!may not be correct, use DIJK instead!!!</span>            P = cell(m,n);            <span class="keyword">for</span> i=1:m                p = extract_dijkstrapath(W, D(i,:), end_verts);                P(i,:) = p(:)';            <span class="keyword">end</span>        <span class="keyword">end</span>    <span class="keyword">else</span>  <span class="comment">% recursive call</span>        D = zeros(m,n);        P = cell(m,n);        <span class="keyword">for</span> i=1:m            [d, p] = dijkstrapropagation(W, start_verts(i), end_verts, Inf);            D(i,:) = d(:)';            P(i,:) = p(:)';        <span class="keyword">end</span>        <span class="comment">% symmetric-ize!</span>        <span class="keyword">if</span> m==n,    D = (D+D')/2; <span class="keyword">end</span>    <span class="keyword">end</span>    <span class="comment">% dist(i,j) is the distance between start_points(i) and</span>    <span class="comment">% start_points(j).</span><span class="keyword">else</span>    niter = min(niter, 1.2*n^2);    <span class="comment">% use fast C-coded version if possible</span>    <span class="keyword">if</span> exist(<span class="string">'dijkstrapropagation_mex'</span>,<spanclass="string">'file'</span>)        D = dijkstrapropagation_mex(W, start_verts-1, end_verts-1, niter);    <span class="keyword">else</span>        D = dijkstraslowpropagation(W, start_verts, end_verts, niter);    <span class="keyword">end</span>    <span class="comment">% replace C 'Inf' value (1e9) by Matlab Inf value</span>    D(D&gt;1e8 ) = Inf;    <span class="keyword">if</span> nargout==2        <span class="comment">% finally extract the paths</span>        P = extract_dijkstrapath(W, D, end_verts);    <span class="keyword">end</span>    D = D(end_verts)'; <span class="comment">% keep the distance to the ending points only</span><span class="keyword">end</span><span class="keyword">if</span> nargout==2,  P = P';  <span class="keyword">end</span><span class="comment">% P(D==Inf) = []; % the paths of the points which not reached set to empty</span><span class="keyword">end</span> <span class="comment">% end of dijkstrapropagation</span></pre>      <h2>Subfunctions<a name="8"></a></h2>      <p><tt>DIJKSTRASLOWPROPAGATION</tt> - Another Matlab implementation of        Dijkstra algorithm.</p>      <pre class="codeinput"><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> [D,S] = dijkstraslowpropagation(W, start_verts, end_verts, niter)<span class="comment">%   [D,S] = perform_dijkstra_propagation_slow(W,start_verts,end_verts,niter,H);</span>niter = min(niter, size(W,1));n = size(W,1);<span class="comment">% dynamic allocation to initialize the data</span>data.A = Inf(n,1);  data.A(start_verts) = 0;data.O = start_verts;data.C = [];data.F = zeros(n,1) - 1;data.P = zeros(n,1) - 1;  data.P(start_verts) = start_verts;data.S = zeros(n,1);  data.S(start_verts) = <span class="string">'O'</span>;data.W = W;<span class="comment">% convert from matrix adjacency representation to list adjacency.</span><span class="keyword">for</span> i=1:n    I = find(W(i,:)&gt;0 &amp;  W(i,:)~=Inf);    data.adj_list{i} = I;<span class="keyword">end</span><span class="comment">% 'data' is a structure containing all data for the dijkstra algorithm:</span><span class="comment">%   - 'data.A': action (distance to starting points)</span><span class="comment">%   - 'data.O', 'data.C': open and close list</span><span class="comment">%   - 'data.S': state, either 'O' or 'C'</span><span class="comment">%   - 'data.F', 'data.P': father and origin seed point</span><span class="comment">% performing Dijkstra algorithm</span>i = 0;<span class="keyword">while</span> i&lt;niter <span class="comment">% iteration</span>    i = i+1;    data = dijkstra_step(data);                                    <span class="comment">% return</span>    <span class="comment">% check if we have reach one of the end points</span>    <span class="keyword">for</span> j=end_verts        <span class="keyword">if</span> ~isempty(find(data.C==j,1,<span class="string">'first'</span>))            S = data.S;  D = data.A;            S(S==0) = 1;  S(S==<span class="string">'O'</span>) = 0;  S(S==<spanclass="string">'C'</span>) = -1;            <span class="keyword">return</span>;        <span class="keyword">end</span>    <span class="keyword">end</span><span class="keyword">end</span>S = data.S;  D = data.A;S(S==<span class="string">'O'</span>) = 0; S(S==0) = 1; S(S==<span class="string">'D'</span>) = -1;<span class="keyword">end</span></pre>      <p><tt>DIJKSTRA_STEP</tt> - Perform one step in the dijkstra algorithm in        function <tt>DIJKSTRASLOWPROPAGATION_BASE</tt>.</p>      <pre class="codeinput"><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> data1 = dijkstra_step(data)<span class="comment">%   [O1,C1] = dijkstra_step(O,C,W,adj_list);</span>A = data.A; <span class="comment">% action</span><span class="comment">% open and close lists</span>O = data.O;  C = data.C;<span class="comment">% state, either 'O' or 'C'</span>S = data.S;<span class="comment">% father and origin seed point</span>F = data.F; P = data.P;adj_list = data.adj_list;   <span class="comment">% adjacency list</span>W = data.W; <span class="comment">% weight matrix</span><span class="keyword">if</span> isempty(O)    data1 = data;    <span class="keyword">return</span>;<span class="keyword">end</span>[~,I] = min(A(O));x = O(I(1));   <span class="comment">% selected vertex</span><span class="comment">% pop from open and add to close</span>O = O( O~=x );C = [C,x];S(x) = <span class="string">'C'</span>; <span class="comment">% now its close</span><span class="comment">% its neighbor</span>nei = adj_list{x};<span class="keyword">for</span> i=nei    w = W(x,i);    A1 = A(x) + w;    <span class="comment">% new action from x</span>    <span class="keyword">switch</span> S(i)        <span class="keyword">case</span> <span class="string">'C'</span>            <span class="comment">% check if action has change. Should not happen for dijkstra</span>            <span class="keyword">if</span> A1&lt;A(i)                <span class="comment">% pop from Close and add to Open</span>                C = C( C~=i );                O = [O,i];                                             <span class="comment">%#ok</span>                S(i) = <span class="string">'O'</span>;                A(i) = A1;                F(i) = x;       <span class="comment">% new father in path</span>                P(i) = P(x);    <span class="comment">% new origin</span>            <span class="keyword">end</span>        <span class="keyword">case</span> <span class="string">'O'</span>            <span class="comment">% check if action has change.</span>            <span class="keyword">if</span> A1&lt;A(i)                A(i) = A1;                F(i) = x;   <span class="comment">% new father in path</span>                P(i) = P(x);    <span class="comment">% new origin</span>            <span class="keyword">end</span>        <span class="keyword">otherwise</span>            <span class="comment">%if A(i)~=Inf, warning('initialize Action to Inf'); end</span>            <span class="comment">% add to open</span>            O = [O,i];                                                 <span class="comment">%#ok</span>            S(i) = <span class="string">'O'</span>;            <span class="comment">% action must have change.</span>            A(i) = A1;            F(i) = x;   <span class="comment">% new father in path</span>            P(i) = P(x);    <span class="comment">% new origin</span>    <span class="keyword">end</span><span class="keyword">end</span>data1.A = A; data1.O = O;data1.C = C; data1.S = S;data1.P = P;data1.adj_list = adj_list;data1.W = W; data1.F = F;<span class="keyword">end</span></pre>      <p><tt>EXTRACT_DIJKSTRAPATH</tt> - Extract a shortest path from a discrete        graph.</p>      <pre class="codeinput"><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> path = extract_dijkstrapath(A, D, end_points)<span class="comment">%     path = dijkstrapath_base(A,D,end_points);</span>n = length(end_points);<span class="keyword">if</span> n&gt;1    path = cell(n,1);    <span class="keyword">for</span> i=1:n        path{i} = extract_dijkstrapath(A,D,end_points(i));    <span class="keyword">end</span>    <span class="keyword">return</span>;<span class="keyword">end</span><span class="keyword">if</span> D(end_points)==Inf    <span class="comment">% warning('extract_dijkstrapath:warning','end point was not reached');</span>    I = find(D~=Inf);    [~,j] = min(D(I));    end_points = I(j);<span class="keyword">end</span>path = end_points;   <span class="comment">% the path</span><span class="keyword">while</span> true    <span class="comment">% select neighbors</span>    N = find( A(path(end),:)&gt;0 );    <span class="keyword">if</span> isempty(N)        <span class="keyword">return</span>;    <span class="keyword">end</span>    <span class="comment">% find minium distance</span>    [d,I] = min( D(N) );    <span class="keyword">if</span> d&gt;=D(path(end))        <span class="comment">% we are on a minima, stop</span>        <span class="keyword">return</span>;    <span class="keyword">end</span>    path(end+1) = N(I);                                                <span class="comment">%#ok</span><span class="keyword">end</span><span class="keyword">end</span></pre></div>    <!--##### SOURCE BEGIN #####%% DIJKSTRAPROPAGATION - C implementation of Dijsktra algorithm through propagation.%%% Description% Shortest distance from multiple source points on graph.%%% Syntax%   [D,P] = DIJKSTRAPROPAGATION(W, start_verts, end_verts, niter);%%% Outputs% *|D|* : the distance to the set of starting points.% *|P|* : shortest paths.%%% References%  http://www.comp.nus.edu.sg/~xujia/mirror/algorithm.myrice.com/resources/technical_artile/fibonacci_heap/fibonacci.htm %  and source code available at      http://web.mit.edu/cocosci/isomap/code/%   %% Credit% <mailto:grazzja@lanl.gov J.Grazzini> (ISR-2/LANL)%%% See also% Related:% <../graph/dijkstra.html |DIJKSTRA|>, % <../graph/dijkstra_base.html |DIJKSTRA_BASE|>, % <../graph/dijk.html |DIJK|>, % <../graph/dijkadvanced.html |DIJKADVANCED|>, % <fmm.html |FMM|>.% Called: % DIJKSTRAPROPAGATION_MEX.%% Function implementation%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction [D,P] = dijkstrapropagation(W, start_verts, end_verts, niter)n = size(W,1); % n = length(W);  % number of points in the graphm = length(start_verts);if sum(start_verts>n)>0 || sum(end_verts>n)>0    error('dijkstrapropagation:inputerror', ...        'out of bound start/end vertices.');endif isequal(start_verts,end_verts)    % compute the distance between each point on the graph: compute path    % from a set of points        if exist('dijkstraset_mex','file')        D = dijkstraset_mex(W, start_verts);        % D(i,j) is the distance between start_verts(i) and start_verts(j)        D(diag(true(m,1),0)) = 0; % set the distance of a point to itself to 0                if nargout==2            % extract the paths            % !!!may not be correct, use DIJK instead!!!            P = cell(m,n);            for i=1:m                p = extract_dijkstrapath(W, D(i,:), end_verts);                P(i,:) = p(:)';            end            end            else  % recursive call        D = zeros(m,n);        P = cell(m,n);                for i=1:m            [d, p] = dijkstrapropagation(W, start_verts(i), end_verts, Inf);            D(i,:) = d(:)';            P(i,:) = p(:)';        end                % symmetric-ize!        if m==n,    D = (D+D')/2; end    end    % dist(i,j) is the distance between start_points(i) and    % start_points(j).    else    niter = min(niter, 1.2*n^2);    % use fast C-coded version if possible    if exist('dijkstrapropagation_mex','file')        D = dijkstrapropagation_mex(W, start_verts-1, end_verts-1, niter);            else        D = dijkstraslowpropagation(W, start_verts, end_verts, niter);    end        % replace C 'Inf' value (1e9) by Matlab Inf value    D(D>1e8 ) = Inf;        if nargout==2        % finally extract the paths        P = extract_dijkstrapath(W, D, end_verts);    end        D = D(end_verts)'; % keep the distance to the ending points onlyendif nargout==2,  P = P';  end% P(D==Inf) = []; % the paths of the points which not reached set to emptyend % end of dijkstrapropagation%% Subfunctions%%% |DIJKSTRASLOWPROPAGATION| - Another Matlab implementation of Dijkstra% algorithm.%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction [D,S] = dijkstraslowpropagation(W, start_verts, end_verts, niter)%   [D,S] = perform_dijkstra_propagation_slow(W,start_verts,end_verts,niter,H); niter = min(niter, size(W,1));n = size(W,1);% dynamic allocation to initialize the datadata.A = Inf(n,1);  data.A(start_verts) = 0;data.O = start_verts;data.C = [];data.F = zeros(n,1) - 1; data.P = zeros(n,1) - 1;  data.P(start_verts) = start_verts;data.S = zeros(n,1);  data.S(start_verts) = 'O';data.W = W;% convert from matrix adjacency representation to list adjacency. for i=1:n    I = find(W(i,:)>0 &  W(i,:)~=Inf);    data.adj_list{i} = I;end% 'data' is a structure containing all data for the dijkstra algorithm:%   - 'data.A': action (distance to starting points)%   - 'data.O', 'data.C': open and close list%   - 'data.S': state, either 'O' or 'C'%   - 'data.F', 'data.P': father and origin seed point% performing Dijkstra algorithmi = 0; while i<niter % iteration     i = i+1;    data = dijkstra_step(data);                                    % return    % check if we have reach one of the end points    for j=end_verts        if ~isempty(find(data.C==j,1,'first'))            S = data.S;  D = data.A;            S(S==0) = 1;  S(S=='O') = 0;  S(S=='C') = -1;            return;        end    endendS = data.S;  D = data.A;S(S=='O') = 0; S(S==0) = 1; S(S=='D') = -1;end%%% |DIJKSTRA_STEP| - Perform one step in the dijkstra algorithm in function% |DIJKSTRASLOWPROPAGATION_BASE|.%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction data1 = dijkstra_step(data)%   [O1,C1] = dijkstra_step(O,C,W,adj_list);A = data.A; % action % open and close listsO = data.O;  C = data.C;% state, either 'O' or 'C'S = data.S; % father and origin seed pointF = data.F; P = data.P;adj_list = data.adj_list;   % adjacency listW = data.W; % weight matrixif isempty(O)    data1 = data;    return;end[~,I] = min(A(O));x = O(I(1));   % selected vertex% pop from open and add to closeO = O( O~=x );C = [C,x];S(x) = 'C'; % now its close% its neighbornei = adj_list{x};for i=nei    w = W(x,i);    A1 = A(x) + w;    % new action from x    switch S(i)        case 'C'            % check if action has change. Should not happen for dijkstra            if A1<A(i)                % pop from Close and add to Open                  C = C( C~=i );                O = [O,i];                                             %#ok                S(i) = 'O';                A(i) = A1;                F(i) = x;       % new father in path                P(i) = P(x);    % new origin            end                    case 'O'            % check if action has change.            if A1<A(i)                A(i) = A1;                F(i) = x;   % new father in path                P(i) = P(x);    % new origin            end                    otherwise            %if A(i)~=Inf, warning('initialize Action to Inf'); end            % add to open            O = [O,i];                                                 %#ok            S(i) = 'O';            % action must have change.            A(i) = A1;            F(i) = x;   % new father in path            P(i) = P(x);    % new origin    endenddata1.A = A; data1.O = O;data1.C = C; data1.S = S;data1.P = P;data1.adj_list = adj_list;data1.W = W; data1.F = F;end%%% |EXTRACT_DIJKSTRAPATH| - Extract a shortest path from a discrete graph. %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction path = extract_dijkstrapath(A, D, end_points)%     path = dijkstrapath_base(A,D,end_points);n = length(end_points);if n>1    path = cell(n,1);    for i=1:n        path{i} = extract_dijkstrapath(A,D,end_points(i));    end    return;endif D(end_points)==Inf    % warning('extract_dijkstrapath:warning','end point was not reached');    I = find(D~=Inf);    [~,j] = min(D(I));    end_points = I(j);endpath = end_points;   % the pathwhile true    % select neighbors    N = find( A(path(end),:)>0 );    if isempty(N)        return;    end    % find minium distance    [d,I] = min( D(N) );    if d>=D(path(end))        % we are on a minima, stop        return;    end    path(end+1) = N(I);                                                %#okendend##### SOURCE END #####-->  </body></html>