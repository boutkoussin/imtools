<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html>  <head>    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">    <!--This HTML was auto-generated from MATLAB code.To make changes, update the MATLAB code and republish this document.      -->    <title>FMM - Launch the Fast Marching algorithm in 2D.</title>    <meta name="generator" content="MATLAB 7.14">    <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">    <meta name="DC.date" content="2012-05-31">    <meta name="DC.source" content="fmm.m">    <style type="text/css">html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}html { min-height:100%; margin-bottom:1px; }html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }html body td { vertical-align:top; text-align:left; }h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }a { color:#005fce; text-decoration:none; }a:hover { color:#005fce; text-decoration:underline; }a:visited { color:#004aa0; text-decoration:none; }p { padding:0px; margin:0px 0px 20px; }img { padding:0px; margin:0px 0px 20px; border:none; }p img, pre img, tt img, li img { margin-bottom:0px; } ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }ul li { padding:0px; margin:0px 0px 7px 0px; }ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }ul li ol li { list-style:decimal; }ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }ol li ol li { list-style-type:lower-alpha; }ol li ul { padding-top:7px; }ol li ul li { list-style:square; }.content { font-size:1.2em; line-height:140%; padding: 20px; }pre, tt, code { font-size:12px; }pre { margin:0px 0px 20px; }pre.error { color:red; }pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }span.keyword { color:#0000FF }span.comment { color:#228B22 }span.string { color:#A020F0 }span.untermstring { color:#B20000 }span.syscmd { color:#B28C00 }.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }.footer p { margin:0px; }  </style>  </head>  <body>    <div class="content">      <h1>FMM - Launch the Fast Marching algorithm in 2D.</h1>      <!--introduction--><!--/introduction-->      <h2>Contents</h2>      <div>        <ul>          <li><a href="#1">Syntax</a></li>          <li><a href="#2">Inputs</a></li>          <li><a href="#3">Property [propertyname propertyvalues]</a></li>          <li><a href="#4">Outputs</a></li>          <li><a href="#5">References</a></li>          <li><a href="#7">See also</a></li>          <li><a href="#8">Function implementation</a></li>        </ul>      </div>      <h2>Syntax<a name="1"></a></h2>      <pre>  D = FMM(W);  [D, P] = FMM(W, start_pts, end_pts, m_seed, m_path, ...                'Property', propertyvalue, ...);</pre>      <h2>Inputs<a name="2"></a></h2>      <p><b><tt>W</tt></b> : weight matrix defining the potential function for        FMM; it can be (see functions <tt>FMMISOPROPAGATION</tt> and <tt>FMMANISOPROPAGATION</tt>):</p>      <div>        <ul>          <li>a <tt>(m,n)</tt> matrix defining a scalar field for isotropic FMM            (the geodesics will follow regions where <tt>W</tt> is large),</li>          <li>a <tt>(n,m,2)</tt> matrix defining a vector field for anisotropic            FMM,</li>          <li>a <tt>(m,n,2,2)</tt> matrix defining a tensor field for            anisotropic <tt>FMM</tt>.</li>        </ul>      </div>      <p><b><tt>start_pts</tt></b> : <tt>(2,k)</tt> array, where <tt>k</tt> is        the number of starting points, ie. <tt>start_points(:,i)</tt> are the        coordinates of the <tt>i</tt>-th starting point.</p>      <p><b><tt>end_pts</tt></b> : optional ending points, of same size as <tt>start_points</tt>;        FMM will stop when these points are reached; default: <tt>end_pts = []</tt>.</p>      <p><b><tt>m_seed</tt></b> : string setting the function used when        propagating; it is either:</p>      <div>        <ul>          <li><tt>'sing'</tt> or <tt>'sing1'</tt> for calculating the distance            and the shortest paths from single sourced graph,</li>          <li><tt>'mult'</tt> for calculating shortest paths through propagation            from multiple sources: in that case, the ouputs <tt>D</tt> and <tt>P</tt>            (see below) are resp. the shortest distance and the shortest path            from any point in the list of points given by <tt>start_pts</tt>,</li>          <li>'allpairs' for calculating allpairs shortest paths in the graph            (it is in fact the same as <tt>'sing'</tt>, renamed for            convenience);</li>        </ul>      </div>      <p>default: <tt>m_seed = 'sing'</tt>.</p>      <p><b><tt>m_path</tt></b> : (optional) logical scalar or string defining        if geodesic paths are calculated, and, if so, which method is to be        used; it is either (see function <tt>FMMPATH</tt>):</p>      <div>        <ul>          <li><tt>'disc'</tt> or <tt>'cont'</tt> to use a pure discrete or            continuous gradient descent,</li>          <li><tt>'kroo'</tt> to use Kroon's <tt>SHORTESTPATH</tt> function            [MSFMM] based on Runge Kutta scheme;</li>        </ul>      </div>      <p>default: <tt>m_path=false</tt>, ie. no paths are calculated unless two        outputs are present, then <tt>m_path='kroo'</tt>; can be very slow.</p>      <h2>Property [propertyname propertyvalues]<a name="3"></a></h2>      <p><b><tt>'order'</tt></b> : scalar defining the method used to compute        Fast Marching; it is either (see function <tt>FMMISOPROPAGATION</tt>):</p>      <div>        <ul>          <li>0 for classical FMM [KS98] with the mex function <tt>FMMISOPROPAGATION_MEX</tt>            if it exists, or the Matlab function <tt>FMMSLOWPROPAGATION</tt>            otherwise,</li>          <li>1 or 2 for Multistencil FMM of order 1 or 2 resp. [HF07], using            the mex function <tt>MSFM2D</tt> implemented by Kroon [MSFMM].</li>        </ul>      </div>      <p><b><tt>'niter'</tt></b> : FMM stops when a given number of iterations        is reached; default: <tt>niter=Inf</tt>;</p>      <p><b><tt>'D0'</tt></b> : initial distance value for starting points;        default: <tt>D0=[]</tt>.</p>      <p><b><tt>'L'</tt></b> : constraint map used to reduce the set of explored        points; it is set to <tt>-Inf</tt> to avoid the exploration of some        points; default: <tt>L=[]</tt>.</p>      <h2>Outputs<a name="4"></a></h2>      <p><b><tt>D</tt></b> : distance function to the set of starting points.</p>      <p><b><tt>P</tt></b> : geodesic paths.</p>      <h2>References<a name="5"></a></h2>      <p>[OS88] S. Osher and J. Sethian: "Fronts propagating with curvature        speed: Algorithms based on Hamilton-Jacobi formulations", J.        Computational Physics, 79:12-49, 1988.</p>      <p>[KS98] R. Kimmel and J. Sethian: "Computing geodesic paths on        manifolds", Proc. National Academy of Sciences, 95(15):8431-8435, 1998.<br>      </p>      <p>[PFMM] Peyre 's toolbox on FMM available at <a href="http://www.mathworks.com/matlabcentral/fileexchange/24531-accurate-fast-marching">https://www.ceremade.dauphine.fr/~peyre/matlab/fast-marching/content.html</a></p>      <h2>See also<a name="7"></a></h2>      <p>Related: <a href="FMMISOPROPAGATION.html"><tt>FMMISOPROPAGATION</tt></a>,        <a href="FMMANISOPROPAGATION.html"><tt>FMMANISOPROPAGATION</tt></a>, <a          href="FMMPATH.html"><tt>FMMPATH</tt></a>.        <a href="../../graph/html/DIJKSTRA.html"><tt>DIJKSTRA</tt></a>. Called:        <a href="FMM_BASE.html"><tt>FMM_BASE</tt></a>,</p>      <h2>Function implementation<a name="8"></a></h2>      <pre class="codeinput"><span class="keyword">function</span> [D, P] = fmm(W, varargin)</pre>      <p>parsing and checking parameters</p>      <pre class="codeinput">error(nargchk(1, 32, nargin, <span class="string">'struct'</span>));error(nargoutchk(1, 1, nargout, <span class="string">'struct'</span>));<span class="comment">% mandatory parameter</span><span class="keyword">if</span> ~(isempty(W) || isnumeric(W))    error(<span class="string">'fmm:inputerror'</span>, <span class="string">'cost matrix required in input'</span>);<span class="keyword">end</span>p = createParser(<span class="string">'FMM'</span>);p.Required(<span class="string">'start_pts'</span>, @(x)isempty(x) || (isvector(x) &amp;&amp; all(x&gt;=1)));p.addOptional(<span class="string">'end_pts'</span>, [], @(x)isempty(x) || (isvector(x) &amp;&amp; all(x&gt;=1)));p.addOptional(<span class="string">'m_seed'</span>, <span class="string">'sing'</span>, @(x)ischar(x) &amp;&amp; <spanclass="keyword">...</span>    any(strcmpi(x,{<span class="string">'allpairs'</span>,<span class="string">'sing'</span>,<spanclass="string">'sing1'</span>,<spanclass="string">'mult'</span>})));p.addOptional(<span class="string">'m_path'</span>, false, @(x)islogical(x) || isempty(x) || <spanclass="keyword">...</span>    (ischar(x) &amp;&amp; any(strcmpi(x,{<span class="string">'kroon'</span>,<spanclass="string">'disc'</span>,<spanclass="string">'cont'</span>}))));<span class="comment">% additional optional parameters</span>p.addParamValue(<span class="string">'iter'</span>,Inf, @(x)isscalar(x) &amp; x&gt;0);p.addParamValue(<span class="string">'order'</span>, 0, @(x)isscalar(x) &amp;&amp; ismember(x,[0 1 2]));p.addParamValue(<span class="string">'L'</span>, [], @(x)isnumeric(x));p.addParamValue(<span class="string">'D0'</span>, [], @(x)isnumeric(x));<span class="comment">% parse and validate all input arguments</span>p.parse(varargin{:});p = getvarParser(p);</pre>      <p>checking settings</p>      <pre class="codeinput"><span class="keyword">if</span> isempty(p.m_path),  p.m_path = false;  <spanclass="keyword">end</span><span class="keyword">if</span> islogical(p.m_path) &amp;&amp; p.m_path    p.m_path = <span class="string">'kroon'</span>; <span class="comment">% set to default</span><span class="keyword">end</span><span class="keyword">if</span> size(p.start_pts,1)~=2,  p.start_pts = p.start_pts';  <spanclass="keyword">end</span><span class="keyword">if</span> size(p.end_pts,1)~=2,  p.end_pts = p.end_pts';  <spanclass="keyword">end</span><span class="keyword">if</span> size(p.start_pts,1)~=2 || size(p.end_pts,1)~=2    error(<span class="string">'fmm:inputerror'</span>, <span class="keyword">...</span>        <span class="string">'seed and end points should be (2 x k) dimensional'</span>);<span class="keyword">end</span><span class="keyword">if</span> nargout==2 &amp;&amp; islogical(p.m_path),  p.m_path = <spanclass="string">'kroo'</span>;  <spanclass="keyword">end</span></pre>      <p>main calculation</p>      <pre class="codeinput">[D, P] = fmm_base(W, p.m_seed, p.m_path, p.start_pts, p.end_pts, <spanclass="keyword">...</span>    p.order, p.L, p.iter);</pre>      <pre class="codeinput"><span class="keyword">end</span> <span class="comment">% end of fmm</span></pre></div>    <!--##### SOURCE BEGIN #####%% FMM - Launch the Fast Marching algorithm in 2D.%%% Syntax%    D = FMM(W);%    [D, P] = FMM(W, start_pts, end_pts, m_seed, m_path, ...%                  'Property', propertyvalue, ...);%%% Inputs% *|W|* : weight matrix defining the potential function for FMM; it can be %     (see functions |FMMISOPROPAGATION| and |FMMANISOPROPAGATION|): %% * a |(m,n)| matrix defining a scalar field for isotropic FMM (the%         geodesics will follow regions where |W| is large),% * a |(n,m,2)| matrix defining a vector field for anisotropic FMM,% * a |(m,n,2,2)| matrix defining a tensor field for anisotropic%         |FMM|.%% *|start_pts|* : |(2,k)| array, where |k| is the number of starting points,%     ie. |start_points(:,i)| are the coordinates of the |i|-th starting point.%% *|end_pts|* : optional ending points, of same size as |start_points|; FMM%     will stop when these points are reached; default: |end_pts = []|.%% *|m_seed|* : string setting the function used when propagating; it%     is either: %% * |'sing'| or |'sing1'| for calculating the distance and the shortest%         paths from single sourced graph,% * |'mult'| for calculating shortest paths through propagation from%         multiple sources: in that case, the ouputs |D| and |P| (see below)%         are resp. the shortest distance and the shortest path from any%         point in the list of points given by |start_pts|,% * 'allpairs' for calculating allpairs shortest paths in the graph%         (it is in fact the same as |'sing'|, renamed for convenience);%% default: |m_seed = 'sing'|. %% *|m_path|* : (optional) logical scalar or string defining if geodesic paths %     are calculated, and, if so, which method is to be used; it is either%     (see function |FMMPATH|):%% * |'disc'| or |'cont'| to use a pure discrete or continuous gradient%         descent, % * |'kroo'| to use Kroon's |SHORTESTPATH| function [MSFMM] based on Runge%         Kutta scheme;%% default: |m_path=false|, ie. no paths are calculated unless two outputs%     are present, then |m_path='kroo'|; can be very slow.%    %% Property [propertyname  propertyvalues]% *|'order'|* : scalar defining the method used to compute Fast Marching; it%     is either (see function |FMMISOPROPAGATION|):%% * 0 for classical FMM [KS98] with the mex function |FMMISOPROPAGATION_MEX| %        if it exists, or the Matlab function |FMMSLOWPROPAGATION| otherwise,% * 1 or 2 for Multistencil FMM of order 1 or 2 resp. [HF07], using%        the mex function |MSFM2D| implemented by Kroon [MSFMM].    %% *|'niter'|* : FMM stops when a given number of iterations is reached; %      default: |niter=Inf|; %% *|'D0'|* : initial distance value for starting points; default: |D0=[]|.%% *|'L'|* : constraint map used to reduce the set of explored points; it is%      set to |-Inf| to avoid the exploration of some points; default: |L=[]|.%%% Outputs% *|D|* : distance function to the set of starting points.%% *|P|* : geodesic paths.%%% References% [OS88]  S. Osher and J. Sethian: "Fronts propagating with curvature speed:%       Algorithms based on Hamilton-Jacobi formulations", J. Computational%       Physics, 79:12-49, 1988.%% [KS98]  R. Kimmel and J. Sethian: "Computing geodesic paths on manifolds",%       Proc. National Academy of Sciences, 95(15):8431-8435, 1998.%%% Credit% <mailto:grazzja@lanl.gov J.Grazzini> (ISR-2/LANL)%%% See also% Related:% <FMMISOPROPAGATION.html |FMMISOPROPAGATION|>,% <FMMANISOPROPAGATION.html |FMMANISOPROPAGATION|>,% <FMMPATH.html |FMMPATH|>.% <../../graph/html/DIJKSTRA.html |DIJKSTRA|>.% Called: % <FMM_BASE.html |FMM_BASE|>,%% Function implementationfunction [D, P] = fmm(W, varargin)%% % parsing and checking parameterserror(nargchk(1, 32, nargin, 'struct'));error(nargoutchk(1, 1, nargout, 'struct'));% mandatory parameterif ~(isempty(W) || isnumeric(W))    error('fmm:inputerror', 'cost matrix required in input'); endp = createParser('FMM');   p.Required('start_pts', @(x)isempty(x) || (isvector(x) && all(x>=1)));p.addOptional('end_pts', [], @(x)isempty(x) || (isvector(x) && all(x>=1)));p.addOptional('m_seed', 'sing', @(x)ischar(x) && ...    any(strcmpi(x,{'allpairs','sing','sing1','mult'})));p.addOptional('m_path', false, @(x)islogical(x) || isempty(x) || ...    (ischar(x) && any(strcmpi(x,{'kroon','disc','cont'}))));% additional optional parametersp.addParamValue('iter',Inf, @(x)isscalar(x) & x>0);p.addParamValue('order', 0, @(x)isscalar(x) && ismember(x,[0 1 2]));p.addParamValue('L', [], @(x)isnumeric(x));p.addParamValue('D0', [], @(x)isnumeric(x));% parse and validate all input argumentsp.parse(varargin{:});p = getvarParser(p);                                                            %% % checking settingsif isempty(p.m_path),  p.m_path = false;  endif islogical(p.m_path) && p.m_path    p.m_path = 'kroon'; % set to defaultendif size(p.start_pts,1)~=2,  p.start_pts = p.start_pts';  endif size(p.end_pts,1)~=2,  p.end_pts = p.end_pts';  endif size(p.start_pts,1)~=2 || size(p.end_pts,1)~=2    error('fmm:inputerror', ...        'seed and end points should be (2 x k) dimensional');endif nargout==2 && islogical(p.m_path),  p.m_path = 'kroo';  end%% % main calculation[D, P] = fmm_base(W, p.m_seed, p.m_path, p.start_pts, p.end_pts, ...    p.order, p.L, p.iter);    end % end of fmm##### SOURCE END #####-->  </body></html>