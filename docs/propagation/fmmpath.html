<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html>  <head>    <meta content="text/html; charset=utf-8" http-equiv="content-type">    <!--This HTML was auto-generated from MATLAB code.To make changes, update the MATLAB code and republish this document.      -->    <title>FMMPATH - Discrete geodesic paths.</title>    <meta name="generator" content="MATLAB 7.14">    <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">    <meta name="DC.date" content="2012-05-31">    <meta name="DC.source" content="fmmpath.m">    <style type="text/css">html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}html { min-height:100%; margin-bottom:1px; }html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }html body td { vertical-align:top; text-align:left; }h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }a { color:#005fce; text-decoration:none; }a:hover { color:#005fce; text-decoration:underline; }a:visited { color:#004aa0; text-decoration:none; }p { padding:0px; margin:0px 0px 20px; }img { padding:0px; margin:0px 0px 20px; border:none; }p img, pre img, tt img, li img { margin-bottom:0px; } ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }ul li { padding:0px; margin:0px 0px 7px 0px; }ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }ul li ol li { list-style:decimal; }ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }ol li ol li { list-style-type:lower-alpha; }ol li ul { padding-top:7px; }ol li ul li { list-style:square; }.content { font-size:1.2em; line-height:140%; padding: 20px; }pre, tt, code { font-size:12px; }pre { margin:0px 0px 20px; }pre.error { color:red; }pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }span.keyword { color:#0000FF }span.comment { color:#228B22 }span.string { color:#A020F0 }span.untermstring { color:#B20000 }span.syscmd { color:#B28C00 }.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }.footer p { margin:0px; }  </style>  </head>  <body>    <div class="content">      <h1>FMMPATH - Discrete geodesic paths.</h1>      <!--introduction--><!--/introduction-->      <h2>Contents</h2>      <div>        <ul>          <li><a href="#1">Description</a></li>          <li><a href="#2">Syntax</a></li>          <li><a href="#3">Inputs</a></li>          <li><a href="#4">Output</a></li>          <li><a href="#5">References</a></li>          <li><a href="#7">See also</a></li>          <li><a href="#8">Function implementation</a></li>          <li><a href="#9">Subfunctions</a></li>        </ul>      </div>      <h2>Description<a name="1"></a></h2>      <p>Extract a discrete geodesic path using gradient descent or Runge-Kutta        methods.</p>      <h2>Syntax<a name="2"></a></h2>      <pre>   path = FMMPATH(D, start_pts, end_pts, method);</pre>      <h2>Inputs<a name="3"></a></h2>      <p><b><tt>D</tt></b> : the distance map.</p>      <p><b><tt>start_pts</tt></b> : list of seed points; it should satisfy <tt>D(start_pts)=0</tt>.</p>      <p><b><tt>end_pts</tt></b> : list of ending points.</p>      <p><b><tt>m_path</tt></b> : string defining the method used for extracting        the shortest paths from the distance map; it is either:</p>      <div>        <ul>          <li><tt>'disc'</tt> or <tt>'cont'</tt> to use a pure discrete or            continuous gradient descent,</li>          <li><tt>'kroo'</tt> to use Kroon's SHORTESTPATH function [MSFMM] based            on Runge Kutta scheme.</li>        </ul>      </div>      <h2>Output<a name="4"></a></h2>      <p><b><tt>path</tt></b> : shortest path between start_pts and end_pts.</p>      <h2>References<a name="5"></a></h2>      <p>[PFMM] Peyre 's toolbox on FMM available at <a href="http://www.mathworks.com/matlabcentral/fileexchange/24531-accurate-fast-marching">https://www.ceremade.dauphine.fr/~peyre/matlab/fast-marching/content.html</a>      </p>      <p>[MSFMM] Kroon's toolbox on multistencil FMM available at <a href="http://www.mathworks.com/matlabcentral/fileexchange/24531-accurate-fast-marching">http://www.mathworks.com/matlabcentral/fileexchange/24531-accurate-fast-marching</a></p>      <h2>See also<a name="7"></a></h2>      <p>Related: <a href="fmm.html"><tt>FMM</tt></a>, <a href="fmm_base.html"><tt>FMM_BASE</tt></a>,        <a href="fmmisopropagation.html"><tt>FMMISOPROPAGATION</tt></a>, <a href="fmmanisopropagation.html"><tt>FMMANISOPROPAGATION</tt></a>,        Called: <a href="matlab:webpub%28whichpath%28%27SHORTESTPATH%27%29%29"><tt>SHORTESTPATH</tt></a>,        <a href="matlab:webpub%28whichpath%28%27GRADIENT%27%29%29"><tt>GRADIENT</tt></a>.</p>      <h2>Function implementation<a name="8"></a></h2>      <pre class="codeinput"><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> path = fmmpath(D, start_pts, end_pts, m_path)<span class="keyword">if</span> size(end_pts,1)&gt;3,  end_pts = end_pts';  <spanclass="keyword">end</span><span class="keyword">if</span> size(end_pts,1)~=2    error(<span class="string">'fmmpath:inputerror'</span>, <span class="string">'end_points should be of size 2xk'</span>);<span class="keyword">end</span><span class="keyword">if</span> size(end_pts,2)&gt;1    <span class="comment">% several geodesics</span>    path = cell(size(end_pts,2),1);    <span class="keyword">for</span> i=1:size(end_pts,2)        path{i} = fmmpath(D, start_pts, end_pts(:,i), m_path);    <span class="keyword">end</span>    <span class="keyword">return</span>;<span class="keyword">end</span><span class="keyword">if</span> strcmp(m_path, <span class="string">'disc'</span>) <spanclass="comment">% discrete gradient descent</span>    path = fmmdiscretepath(D,x);<span class="keyword">elseif</span> strcmp(m_path, <span class="string">'cont'</span>)    start_pts = [];    trim_path = 1;    path = extract_path(D, end_pts, start_pts, trim_path);    <span class="keyword">if</span> size(path,1)&gt;size(path,2)        path = path';    <span class="keyword">end</span><span class="keyword">elseif</span> strcmp(m_path, <span class="string">'kroon'</span>)    <span class="keyword">if</span> ~exist(<span class="string">'shortestpath'</span>,<spanclass="string">'file'</span>)        error(<span class="string">'fmmpath:methoderror'</span>, <span class="string">'load Kroon''s fast marching library'</span>);    <span class="keyword">end</span>    <span class="comment">% shortest path from start point to source point using Runge Kutta 4 in</span>    <span class="comment">% a 2D distance map</span>    path = shortestpath(D, start_pts, end_pts, 1);<span class="keyword">else</span>    error(<span class="string">'fmmpath:methoderror'</span>, [<span class="string">'unknown method '</span> met_path]);<span class="keyword">end</span><span class="keyword">end</span> <span class="comment">% end of fmmpath</span></pre>      <h2>Subfunctions<a name="9"></a></h2>      <p><tt>FMMDISCRETEPATH</tt> - Extract a discrete geodesic in 2D</p>      <pre class="codeinput"><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> path = fmmdiscretepath(D, x)<span class="comment">% Same as extract_path but less precise and more robust.</span>x = x(:);path = round(x(1:2));<span class="comment">% admissible moves</span>dx = [1 -1 0 0];dy = [0 0 1 -1];d = cat(1,dx,dy);vprev = D(x(1),x(2));s = size(D);<span class="keyword">while</span> true    x0 = path(:,end);    x = repmat(x0,1,size(d,2))+d;    I = x(1,:)&gt;0 &amp; x(2,:)&gt;0 &amp; x(1,:)&lt;=s(1) &amp; x(2,:)&lt;=s(2);    x = x(:,I);    I = x(1,:) + (x(2,:)-1)*s(1);    [v,J] = min(D(I));    x = x(:,J);    <span class="keyword">if</span> v&gt;vprev,   <span class="keyword">return</span>;   <spanclass="keyword">end</span>    vprev = v;    path(:,end+1) = x;                                                 <span class="comment">%#ok</span><span class="keyword">end</span><span class="keyword">end</span></pre>      <p><tt>EXTRACT_PATH</tt> - Extract the shortest path using a gradient        descent.</p>      <pre class="codeinput"><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> path = extract_path(A, end_points, start_points, trim_path)<span class="comment">% D is the distance function.</span><span class="comment">% end_point is ending point (should be integer).</span><span class="keyword">if</span> size(end_points,1)~=2    end_points = end_points';<span class="keyword">end</span><span class="comment">% stepsize = 0.1;  maxverts = 10000;</span><span class="comment">% gradient computation</span>I = A==Inf;J = A~=Inf;A1 = A;A1(I) = mmax(A(J));[gy,gx] = gradient(A1);grad = -vf_normalization(cat(3, gx,gy));<span class="comment">% path extraction</span>path = stream2(grad(:,:,2),grad(:,:,1),end_points(2,:),end_points(1,:));<span class="keyword">for</span> i=1:length(path)    path{i} = path{i}(:,2:-1:1);<span class="keyword">end</span><span class="keyword">if</span> length(path)==1,  path = path{1};   <span class="keyword">end</span><span class="keyword">if</span> isempty(start_points)    start_points = path(end,:);<span class="keyword">end</span>start_points = start_points(:);<span class="keyword">if</span> trim_path    <span class="comment">% removing too verbose points</span>    d = distance_to_points(path', start_points);    <span class="comment">% perform thresholding</span>    T = mmax(d)/300^2;    I = find(d&lt;T);    <span class="keyword">if</span> ~isempty(I)        path = path(1:I(1), :);        path = [path; start_points'];    <span class="keyword">else</span>        path = path';    <span class="keyword">end</span><span class="keyword">end</span><span class="comment">% complete with a discrete extraction (nasty hack)</span><span class="keyword">if</span> size(path, 2)~=2 &amp;&amp; size(path, 1)==2    path = path';<span class="keyword">end</span>path = [path; fmmdiscretepath(A, round(path(end,:)))'];<span class="keyword">end</span></pre>      <p><tt>DISTANCE_TO_POINTS</tt> - Compute euclidean distance to a set of        points.</p>      <pre class="codeinput"><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> D = distance_to_points(X,seeds)<span class="comment">% X is a [d,n] matrix, X(:,i) is the ith point living in R^d.</span><span class="comment">% seeds is a [d,k] matrix.</span><span class="comment">% D(i,j) = |X(:,j)-seeds(:,i)|^2.</span>nseeds = size(seeds,2);n = size(X,2);D = zeros(nbCluster,n);<span class="keyword">for</span> k=1:nseeds    <span class="comment">% distance to seed</span>    D(k,:) = sum( (X - repmat(seeds(:,k),1,n)).^2 );<span class="keyword">end</span><span class="keyword">end</span></pre>      <p><tt>VF_NORMALIZATION</tt> - Renormalize a vector field.</p>      <pre class="codeinput"><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> v = vf_normalization(v)a = nb_dims(v);d = sqrt( sum(v.^2,a) );d(d&lt;1e-6) = 1;v = v .* repmat( 1./d, [ones(a-1,1)' size(v,a)] );<span class="keyword">end</span></pre></div>    <!--##### SOURCE BEGIN #####%% FMMPATH - Discrete geodesic paths.%%% Description% Extract a discrete geodesic path using gradient descent or Runge-Kutta % methods.%%% Syntax%     path = FMMPATH(D, start_pts, end_pts, method);%%% Inputs% *|D|* : the distance map.%% *|start_pts|* : list of seed points; it should satisfy |D(start_pts)=0|.%% *|end_pts|* : list of ending points.%% *|m_path|* : string defining the method used for extracting the shortest paths%     from the distance map; it is either:%% * |'disc'| or |'cont'| to use a pure discrete or continuous gradient%         descent, % * |'kroo'| to use Kroon's SHORTESTPATH function [MSFMM] based on Runge%         Kutta scheme.%%% Output% *|path|* : shortest path between start_pts and end_pts.%%% Reference% [MSFMM]  Kroon's toolbox on multistencil FMM available at %       http://www.mathworks.com/matlabcentral/fileexchange/24531-accurate-fast-marching %%% Credit% <mailto:grazzja@lanl.gov J.Grazzini> (ISR-2/LANL)%%% See also% Related:% <fmm.html |FMM|>,% <fmm_base.html |FMM_BASE|>,% <fmmisopropagation.html |FMMISOPROPAGATION|>, % <fmmanisopropagation.html |FMMANISOPROPAGATION|>, % Called: % <matlab:webpub(whichpath('SHORTESTPATH')) |SHORTESTPATH|>,% <matlab:webpub(whichpath('GRADIENT')) |GRADIENT|>.%% Function implementation%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction path = fmmpath(D, start_pts, end_pts, m_path)if size(end_pts,1)>3,  end_pts = end_pts';  endif size(end_pts,1)~=2    error('fmmpath:inputerror', 'end_points should be of size 2xk');endif size(end_pts,2)>1    % several geodesics    path = cell(size(end_pts,2),1);    for i=1:size(end_pts,2)        path{i} = fmmpath(D, start_pts, end_pts(:,i), m_path);    end    return;endif strcmp(m_path, 'disc') % discrete gradient descent    path = fmmdiscretepath(D,x);    elseif strcmp(m_path, 'cont')        start_pts = [];    trim_path = 1;    path = extract_path(D, end_pts, start_pts, trim_path);    if size(path,1)>size(path,2)        path = path';    endelseif strcmp(m_path, 'kroon')     if ~exist('shortestpath','file')        error('fmmpath:methoderror', 'load Kroon''s fast marching library');    end    % shortest path from start point to source point using Runge Kutta 4 in    % a 2D distance map    path = shortestpath(D, start_pts, end_pts, 1);    else    error('fmmpath:methoderror', ['unknown method ' met_path]);    endend % end of fmmpath%% Subfunctions%%% |FMMDISCRETEPATH| - Extract a discrete geodesic in 2D %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction path = fmmdiscretepath(D, x)% Same as extract_path but less precise and more robust.x = x(:);path = round(x(1:2));% admissible movesdx = [1 -1 0 0];dy = [0 0 1 -1];d = cat(1,dx,dy);vprev = D(x(1),x(2));s = size(D);while true    x0 = path(:,end);    x = repmat(x0,1,size(d,2))+d;    I = x(1,:)>0 & x(2,:)>0 & x(1,:)<=s(1) & x(2,:)<=s(2);    x = x(:,I);    I = x(1,:) + (x(2,:)-1)*s(1);    [v,J] = min(D(I));    x = x(:,J);    if v>vprev,   return;   end    vprev = v;    path(:,end+1) = x;                                                 %#okendend%%% |EXTRACT_PATH| - Extract the shortest path using a gradient descent.%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction path = extract_path(A, end_points, start_points, trim_path)% D is the distance function.% end_point is ending point (should be integer). if size(end_points,1)~=2    end_points = end_points';end% stepsize = 0.1;  maxverts = 10000;% gradient computationI = A==Inf;J = A~=Inf;A1 = A; A1(I) = mmax(A(J));[gy,gx] = gradient(A1);grad = -vf_normalization(cat(3, gx,gy));% path extractionpath = stream2(grad(:,:,2),grad(:,:,1),end_points(2,:),end_points(1,:));for i=1:length(path)    path{i} = path{i}(:,2:-1:1);endif length(path)==1,  path = path{1};   endif isempty(start_points)    start_points = path(end,:);endstart_points = start_points(:);if trim_path    % removing too verbose points    d = distance_to_points(path', start_points);    % perform thresholding    T = mmax(d)/300^2;    I = find(d<T);    if ~isempty(I)        path = path(1:I(1), :);        path = [path; start_points'];    else        path = path';    endend% complete with a discrete extraction (nasty hack)if size(path, 2)~=2 && size(path, 1)==2    path = path';endpath = [path; fmmdiscretepath(A, round(path(end,:)))'];end%%% |DISTANCE_TO_POINTS| - Compute euclidean distance to a set of points.%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction D = distance_to_points(X,seeds)% X is a [d,n] matrix, X(:,i) is the ith point living in R^d.% seeds is a [d,k] matrix.% D(i,j) = |X(:,j)-seeds(:,i)|^2.nseeds = size(seeds,2);n = size(X,2);D = zeros(nbCluster,n);for k=1:nseeds    % distance to seed    D(k,:) = sum( (X - repmat(seeds(:,k),1,n)).^2 );endend%%% |VF_NORMALIZATION| - Renormalize a vector field.%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction v = vf_normalization(v)a = nb_dims(v);d = sqrt( sum(v.^2,a) );d(d<1e-6) = 1;v = v .* repmat( 1./d, [ones(a-1,1)' size(v,a)] );end##### SOURCE END #####-->  </body></html>