<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html>  <head>    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">    <!--This HTML was auto-generated from MATLAB code.To make changes, update the MATLAB code and republish this document.      -->    <title>fmmanisopropagation_base</title>    <meta name="generator" content="MATLAB 7.14">    <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">    <meta name="DC.date" content="2012-05-31">    <meta name="DC.source" content="fmmanisopropagation_base.m">    <style type="text/css">html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}html { min-height:100%; margin-bottom:1px; }html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }html body td { vertical-align:top; text-align:left; }h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }a { color:#005fce; text-decoration:none; }a:hover { color:#005fce; text-decoration:underline; }a:visited { color:#004aa0; text-decoration:none; }p { padding:0px; margin:0px 0px 20px; }img { padding:0px; margin:0px 0px 20px; border:none; }p img, pre img, tt img, li img { margin-bottom:0px; } ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }ul li { padding:0px; margin:0px 0px 7px 0px; }ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }ul li ol li { list-style:decimal; }ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }ol li ol li { list-style-type:lower-alpha; }ol li ul { padding-top:7px; }ol li ul li { list-style:square; }.content { font-size:1.2em; line-height:140%; padding: 20px; }pre, tt, code { font-size:12px; }pre { margin:0px 0px 20px; }pre.error { color:red; }pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }span.keyword { color:#0000FF }span.comment { color:#228B22 }span.string { color:#A020F0 }span.untermstring { color:#B20000 }span.syscmd { color:#B28C00 }.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }.footer p { margin:0px; }  </style>  </head>  <body>    <div class="content">      <h2>Contents</h2>      <div>        <ul>          <li><a href="#3">Check/set the input tensor field used for anisotropic              propagation via</a></li>          <li><a href="#4">Launch the mex files</a></li>          <li><a href="#5">The final touch...</a></li>        </ul>      </div>      <pre class="codeinput"><span class="keyword">function</span> [D, V] = fmmanisopropagation_base(W, start_pts, method, L, niter)</pre>      <pre class="codeinput"><span class="comment">% FMMANISOPROPAGATION_BASE - Perform anisotropic fast marching following the</span><span class="comment">% approach in [SKDCCRRA07,BPC08,PC09] and using [GCM] implementation of the</span><span class="comment">% papers [PLPWDFS06a,PLPWDFS06b].</span><span class="comment">%</span><span class="comment">%   D = FMMANISOPROPAGATION_BASE(W, start_pts, L);</span><span class="comment">%   [D, V] = FMMANISOPROPAGATION_BASE(W, start_pts, method, L, niter);</span><span class="comment">%</span><span class="comment">% Inputs:</span><span class="comment">%   W : cost function; it should be a (m x n x 2) (for 2D vector field) or</span><span class="comment">%     a (m x n x 2 x 2) (for tensor field) weight matrix.</span><span class="comment">%   start_pts : a (2 x k) matrix where k is the number of starting points.</span><span class="comment">%   end_pts : a (2 x l) matrix where l is the number of ending points; the</span><span class="comment">%     FMM propagation stops when these points are reached.</span><span class="comment">%   method : logical boolean used for selecting the method: true for using</span><span class="comment">%     FMMANISOPROPAGATION_MEX and false for using FM2DANISO_MEX.</span><span class="comment">%   L : optional constraint map used when method=true to reduce the set of</span><span class="comment">%     explored points, as only points with current distance smaller than</span><span class="comment">%     their values in L will be visited; set entries to -Inf in L if you do</span><span class="comment">%     not want points to be visited by FMM; default: L=Inf, ie. all points</span><span class="comment">%     are visited.</span><span class="comment">%   niter : maximum number of iterations; default: niter=Inf.</span><span class="comment">%</span><span class="comment">% Outputs:</span><span class="comment">%   D : a 2D array containing the value of the distance function to seed.</span><span class="comment">%   V : optional variable returned when method=true; index of the closest</span><span class="comment">%     point from the set of starting points (0 for points which have not</span><span class="comment">%     been reached); V provide a Voronoi decomposition of the domain.</span><span class="comment">%</span><span class="comment">% Remark:</span><span class="comment">%  if the Voronoi diagram V is desired in output (see above), the function</span><span class="comment">%  FM2DANISO_MEX should be called, hence the option method should be set to</span><span class="comment">%  false.</span><span class="comment">%</span><span class="comment">% References:</span><span class="comment">%   [PLPWDFS06a] E. Prados, C. Lenglet, J. Pons, N. Wotawa, R. Deriche, O.</span><span class="comment">%       Faugeras, S. Soatto: "Control theory and fast marching methods for</span><span class="comment">%       brain connectivity mapping", INRIA Research Report 5845, 2006.</span><span class="comment">%   [PLPWDFS06b] E. Prados, C. Lenglet, J. Pons, N. Wotawa, R. Deriche, O.</span><span class="comment">%       Faugeras, S. Soatto: "Control theory and fast marching methods for</span><span class="comment">%       brain connectivity mapping", Proc. IEEE CVPR, pp. 1076?1083, 2006.</span><span class="comment">%   [SKDCCRRA07]  M. Sermesant, E. Konukoglu, H. Delingette, Y. Coudiere,</span><span class="comment">%       P. Chinchapatnam, K. Rhode, R. Razavi and N. Ayache: "An anisotropic</span><span class="comment">%       multi-front fast marching method for real-time simulation of cardiac</span><span class="comment">%       electrophysiology, Proc. FIMH, LNCS 4466, pp. 160-169, 2007,</span><span class="comment">%   [BPC08]  S. Bougleux, G. Peyre, and L. Cohen: "Anisotropic geodesics for</span><span class="comment">%       perceptual grouping and domain meshing", Proc. ECCV, vol. 2, pp.</span><span class="comment">%       129-142, 2008.</span><span class="comment">%   [PC09]  G. Peyre, and L. Cohen: "Geodesic methods for shape and surface</span><span class="comment">%       processing", in "Advances in Computational Vision and Medical Image</span><span class="comment">%       Processing: Methods and Applications", vol. 13 of "Computational</span><span class="comment">%       Methods in Applied Sciences", pp. 29-56, Springer, 2009.</span><span class="comment">%   [GCM]  See GCM - Geodesic Connectivity Mapping source code available at</span><span class="comment">%                          http://gcm.gforge.inria.fr/GCM-Publications.html</span><span class="comment">%   [PFMM] Peyre 's toolbox on FMM available at</span><span class="comment">%       https://www.ceremade.dauphine.fr/~peyre/matlab/fast-marching/content.html</span><spanclass="comment"></span><span class="comment">%</span><span class="comment">% See also</span><span class="comment">% Related: FMM, FMM_BASE, FMMISOPROPAGATION_BASE, DIJKSTRAPROPAGATION_BASE,</span><span class="comment">%   IM2FRONT_BASE, POTENTIAL2FRONT_BASE --</span><span class="comment">% Called: FMMANISOPROPAGATION_MEX, FM2DANISO_MEX.</span><span class="comment">% we allow variable number of inputs</span><span class="keyword">if</span> nargin &lt;=4,    niter = Inf;    <span class="keyword">if</span> nargin&lt;=3,      L = [];        <span class="keyword">if</span> nargin&lt;=2,  method = true;  <span class="keyword">end</span>    <span class="keyword">end</span><span class="keyword">end</span><span class="comment">% ensure this outside the function</span><span class="comment">% if size(start_pts,1)~=2</span><span class="comment">%     error('fmmanisopropagation_base:inputerror', ...</span><span class="comment">%     'seed points should be (2 x k) dimensional');</span><span class="comment">% end</span></pre>      <h2>Check/set the input tensor field used for anisotropic propagation via<a          name="3"></a></h2>      <p>FMM</p>      <pre class="codeinput">d = nb_dims(W);m = size(W,1);n = size(W,2);<span class="keyword">if</span> d==2 <span class="comment">% a scalar field has been passed: use isotropic FMM instead</span>    warning(<span class="string">'fmmanisopropagation_base:inputwarning'</span>, <spanclass="keyword">...</span>        <span class="string">'use isotropic FMM approach with scalar cost field'</span>);    <span class="comment">% W = gstfeature(W(:,:,1,1),W(:,:,2,2),W(:,:,1,2),'norm');</span>    <span class="comment">% TODO: rather call isotropic FMM with FMMISOPROPAGATION_BASE</span>    <span class="keyword">return</span>;<span class="keyword">elseif</span> d==3 <span class="comment">% a vector field has been passed</span>    V = cat(3, -W(:,:,2), W(:,:,1)); <span class="comment">% orthogonal vector</span>    W = gstdecomp(W, V, ones(m,n), ones(m,n) );<span class="keyword">elseif</span> d~=4 <span class="comment">% all other cases: hope not to reach this point</span>     error(<span class="string">'fmmanisopropagation_base:inputerror'</span>, <spanclass="keyword">...</span>        <span class="string">'input cost function should be a vector of a tensor field'</span>);<span class="keyword">end</span><span class="comment">% !!! The following code runs with square matrices (ie. size(w,1)==size(w,2)),</span><span class="comment">% therefore we have to transform the input !!!</span><span class="keyword">if</span> m~=n    M = max([m n]);    W = padarray(W, [M-m M-n], 1, <span class="string">'post'</span>);<span class="keyword">else</span>    M = m;<span class="keyword">end</span>pad = 0;<span class="comment">% pad = 1;</span><span class="keyword">if</span> pad,  W = padarray(W,[pad pad], 1, <span class="string">'both'</span>);  <spanclass="keyword">end</span>                    <spanclass="comment">%#ok</span></pre>      <h2>Launch the mex files<a name="4"></a></h2>      <pre class="codeinput"><span class="keyword">if</span> method &amp;&amp; exist(<spanclass="string">'fmmanisopropagation_mex'</span>,<spanclass="string">'file'</span>)    <span class="comment">% at that point, we should have d=4: W is a structure tensor field</span>    <span class="comment">% in order to use fmmanisopropagation_mex (see [GCM] source code), we</span>    <span class="comment">% need to inject the 2D space into a 3D space</span>    <span class="comment">% % practical issue: how to deal with null tensor</span>    <span class="comment">% [l1, l2, e1, e2] = gstdecomp(W);</span>    <span class="comment">% I = l1==0;</span>    <span class="comment">% l1(I) = 1e-9; % eps for C implementation</span>    <span class="comment">% % l2(I) = 0;</span>    <span class="comment">% % v = e1(:,:,1); v(I) = 1; e1(:,:,1) = v;</span>    <span class="comment">% % v = e1(:,:,2); v(I) = 0; e1(:,:,2) = v;</span>    <span class="comment">% % v = e2(:,:,1); v(I) = 0; e2(:,:,1) = v;</span>    <span class="comment">% % v = e2(:,:,2); v(I) = 1; e2(:,:,2) = v;</span>    <span class="comment">% W = gstdecomp(l1, l2, e1, e2);</span>    <span class="keyword">if</span> size(W,3)==2 &amp;&amp; size(W,4)==2        <span class="comment">% we transform the 2D vector field into a 3D field</span>        W1 = zeros(M+2*pad, M+2*pad, 3, 3);        W1(:,:,1:2,1:2) = W;        W1(:,:,3,3) = 1;        W = reshape(W1, [M+2*pad M+2*pad, 1 3 3]);        <span class="comment">% convert to correct size</span>        W = cat(4, W(:,:,:,1,1), W(:,:,:,1,2), W(:,:,:,1,3), <span class="keyword">...</span>            W(:,:,:,2,2), W(:,:,:,2,3), W(:,:,:,3,3) );    <span class="keyword">end</span>    <span class="comment">% padd to avoid boundary problem</span>    W = cat(1, W(1,:,:,:), W, W(end,:,:,:));    W = cat(2, W(:,1,:,:), W, W(:,end,:,:));    W = cat(3, W(:,:,1,:), W, W(:,:,end,:));    <span class="comment">% prepare the set of points</span>    start_pts(end+1,:) = 1; <span class="comment">% we represent the point in a 3D space</span>    <span class="comment">% launch the anisotropic FMM</span>    <span class="comment">%    start_pts = start_pts-1;</span>    <span class="keyword">if</span> isempty(L),  L = Inf(size(W,1), size(W,2), 3); <spanclass="comment">% ones</span>    <span class="keyword">end</span>    <span class="comment">%    if pad,  L = padarray(L, [pad pad], -Inf, 'both');  end</span>    alpha = 0; <span class="comment">% euclidean norm: see source code [GCM], functions</span>    <span class="comment">% AnisotropicTensorDistanceConfidence.h and AnisotropicTensorDistance.h</span>    [D, V] = fmmanisopropagation_mex(W, L, alpha, start_pts, niter);    <span class="comment">% remove boundary problems</span>    D = D(2:end-1, 2:end-1, 2);    <span class="keyword">if</span> sum(V(:))==0,  V = [];  <span class="comment">% no Voronoi output... problem here!!!</span>    <span class="keyword">else</span>              V = V(2:end-1, 2:end-1, 2);  <spanclass="keyword">end</span><span class="keyword">elseif</span> ~method &amp;&amp; exist(<span class="string">'fm2daniso_mex'</span>,<spanclass="string">'file'</span>)    step = [1; 1];    <span class="comment">% step = [1/size(W,1), 1/size(W,2)];</span>    [D, dum1, dum2, V] = fm2daniso_mex(step, W, start_pts);<span class="keyword">else</span> <span class="comment">% hope not to reach this point either</span>    error(<span class="string">'fmmanisopropagation_base:libraryerror'</span>,<spanclass="keyword">...</span>        <span class="string">'method fmmanisopropagation_base not available'</span>);<span class="keyword">end</span></pre>      <h2>The final touch...<a name="5"></a></h2>      <pre class="codeinput"><span class="keyword">if</span> pad  <span class="comment">% get rid of the boundary pad</span>    D = D(1+pad:end-pad, 1+pad:end-pad);                               <span class="comment">%#ok</span><span class="keyword">end</span><span class="keyword">if</span> m~=n  <span class="comment">% get rid of the dimension pad: finally reset to the correct size</span>    D = D(1:m,1:n);    <span class="keyword">if</span> ~isempty(V),  V = V(1:m,1:n);  <span class="keyword">end</span><span class="keyword">end</span><span class="comment">% reset to Matlab Inf values</span>D(D&gt;1e16) = Inf;</pre>      <pre class="codeinput"><span class="keyword">end</span></pre>      <p class="footer"><br>        Published with MATLAB® 7.14</p>    </div>    <!--##### SOURCE BEGIN #####function [D, V] = fmmanisopropagation_base(W, start_pts, method, L, niter)% FMMANISOPROPAGATION_BASE - Perform anisotropic fast marching following the % approach in [SKDCCRRA07,BPC08,PC09] and using [GCM] implementation of the% papers [PLPWDFS06a,PLPWDFS06b].  %%   D = FMMANISOPROPAGATION_BASE(W, start_pts, L);%   [D, V] = FMMANISOPROPAGATION_BASE(W, start_pts, method, L, niter);%% Inputs:%   W : cost function; it should be a (m x n x 2) (for 2D vector field) or%     a (m x n x 2 x 2) (for tensor field) weight matrix.%   start_pts : a (2 x k) matrix where k is the number of starting points.%   end_pts : a (2 x l) matrix where l is the number of ending points; the%     FMM propagation stops when these points are reached.%   method : logical boolean used for selecting the method: true for using%     FMMANISOPROPAGATION_MEX and false for using FM2DANISO_MEX.%   L : optional constraint map used when method=true to reduce the set of%     explored points, as only points with current distance smaller than %     their values in L will be visited; set entries to -Inf in L if you do %     not want points to be visited by FMM; default: L=Inf, ie. all points %     are visited.%   niter : maximum number of iterations; default: niter=Inf.% % Outputs:%   D : a 2D array containing the value of the distance function to seed.%   V : optional variable returned when method=true; index of the closest%     point from the set of starting points (0 for points which have not%     been reached); V provide a Voronoi decomposition of the domain. %% Remark:%  if the Voronoi diagram V is desired in output (see above), the function%  FM2DANISO_MEX should be called, hence the option method should be set to%  false.%% References:%   [PLPWDFS06a] E. Prados, C. Lenglet, J. Pons, N. Wotawa, R. Deriche, O.%       Faugeras, S. Soatto: "Control theory and fast marching methods for%       brain connectivity mapping", INRIA Research Report 5845, 2006.%   [PLPWDFS06b] E. Prados, C. Lenglet, J. Pons, N. Wotawa, R. Deriche, O.%       Faugeras, S. Soatto: "Control theory and fast marching methods for%       brain connectivity mapping", Proc. IEEE CVPR, pp. 1076?1083, 2006.%   [SKDCCRRA07]  M. Sermesant, E. Konukoglu, H. Delingette, Y. Coudiere,%       P. Chinchapatnam, K. Rhode, R. Razavi and N. Ayache: "An anisotropic%       multi-front fast marching method for real-time simulation of cardiac%       electrophysiology, Proc. FIMH, LNCS 4466, pp. 160-169, 2007,%   [BPC08]  S. Bougleux, G. Peyre, and L. Cohen: "Anisotropic geodesics for%       perceptual grouping and domain meshing", Proc. ECCV, vol. 2, pp.%       129-142, 2008.%   [PC09]  G. Peyre, and L. Cohen: "Geodesic methods for shape and surface%       processing", in "Advances in Computational Vision and Medical Image%       Processing: Methods and Applications", vol. 13 of "Computational %       Methods in Applied Sciences", pp. 29-56, Springer, 2009.%   [GCM]  See GCM - Geodesic Connectivity Mapping source code available at%                          http://gcm.gforge.inria.fr/GCM-Publications.html%  % credit: J.Grazzini (ISR-2/LANL)%% See also % Related: FMM, FMM_BASE, FMMISOPROPAGATION_BASE, DIJKSTRAPROPAGATION_BASE,%   IM2FRONT_BASE, POTENTIAL2FRONT_BASE REPLACE_WITH_DASH_DASH% Called: FMMANISOPROPAGATION_MEX, FM2DANISO_MEX.% we allow variable number of inputsif nargin <=4,    niter = Inf;    if nargin<=3,      L = [];        if nargin<=2,  method = true;  end    endend % ensure this outside the function% if size(start_pts,1)~=2%     error('fmmanisopropagation_base:inputerror', ...%     'seed points should be (2 x k) dimensional');% end%% Check/set the input tensor field used for anisotropic propagation via% FMMd = nb_dims(W);m = size(W,1);n = size(W,2);if d==2 % a scalar field has been passed: use isotropic FMM instead    warning('fmmanisopropagation_base:inputwarning', ...        'use isotropic FMM approach with scalar cost field');    % W = gstfeature(W(:,:,1,1),W(:,:,2,2),W(:,:,1,2),'norm');    % TODO: rather call isotropic FMM with FMMISOPROPAGATION_BASE    return;    elseif d==3 % a vector field has been passed    V = cat(3, -W(:,:,2), W(:,:,1)); % orthogonal vector    W = gstdecomp(W, V, ones(m,n), ones(m,n) );    elseif d~=4 % all other cases: hope not to reach this point     error('fmmanisopropagation_base:inputerror', ...        'input cost function should be a vector of a tensor field');    end% !!! The following code runs with square matrices (ie. size(w,1)==size(w,2)),% therefore we have to transform the input !!!if m~=n    M = max([m n]);    W = padarray(W, [M-m M-n], 1, 'post'); else     M = m;endpad = 0;% pad = 1;if pad,  W = padarray(W,[pad pad], 1, 'both');  end                    %#ok%% Launch the mex filesif method && exist('fmmanisopropagation_mex','file')     % at that point, we should have d=4: W is a structure tensor field    % in order to use fmmanisopropagation_mex (see [GCM] source code), we    % need to inject the 2D space into a 3D space        % % practical issue: how to deal with null tensor    % [l1, l2, e1, e2] = gstdecomp(W);    % I = l1==0;    % l1(I) = 1e-9; % eps for C implementation    % % l2(I) = 0;    % % v = e1(:,:,1); v(I) = 1; e1(:,:,1) = v;    % % v = e1(:,:,2); v(I) = 0; e1(:,:,2) = v;    % % v = e2(:,:,1); v(I) = 0; e2(:,:,1) = v;    % % v = e2(:,:,2); v(I) = 1; e2(:,:,2) = v;    % W = gstdecomp(l1, l2, e1, e2);        if size(W,3)==2 && size(W,4)==2        % we transform the 2D vector field into a 3D field        W1 = zeros(M+2*pad, M+2*pad, 3, 3);        W1(:,:,1:2,1:2) = W;        W1(:,:,3,3) = 1;        W = reshape(W1, [M+2*pad M+2*pad, 1 3 3]);        % convert to correct size        W = cat(4, W(:,:,:,1,1), W(:,:,:,1,2), W(:,:,:,1,3), ...            W(:,:,:,2,2), W(:,:,:,2,3), W(:,:,:,3,3) );    end        % padd to avoid boundary problem    W = cat(1, W(1,:,:,:), W, W(end,:,:,:));    W = cat(2, W(:,1,:,:), W, W(:,end,:,:));    W = cat(3, W(:,:,1,:), W, W(:,:,end,:));        % prepare the set of points    start_pts(end+1,:) = 1; % we represent the point in a 3D space        % launch the anisotropic FMM        %    start_pts = start_pts-1;    if isempty(L),  L = Inf(size(W,1), size(W,2), 3); % ones    end    %    if pad,  L = padarray(L, [pad pad], -Inf, 'both');  end        alpha = 0; % euclidean norm: see source code [GCM], functions    % AnisotropicTensorDistanceConfidence.h and AnisotropicTensorDistance.h    [D, V] = fmmanisopropagation_mex(W, L, alpha, start_pts, niter);    % remove boundary problems    D = D(2:end-1, 2:end-1, 2);    if sum(V(:))==0,  V = [];  % no Voronoi output... problem here!!!    else              V = V(2:end-1, 2:end-1, 2);  end     elseif ~method && exist('fm2daniso_mex','file')    step = [1; 1];      % step = [1/size(W,1), 1/size(W,2)];    [D, dum1, dum2, V] = fm2daniso_mex(step, W, start_pts);    else % hope not to reach this point either    error('fmmanisopropagation_base:libraryerror',...        'method fmmanisopropagation_base not available');    end%% The final touch...if pad  % get rid of the boundary pad    D = D(1+pad:end-pad, 1+pad:end-pad);                               %#okendif m~=n  % get rid of the dimension pad: finally reset to the correct size    D = D(1:m,1:n);    if ~isempty(V),  V = V(1:m,1:n);  endend% reset to Matlab Inf valuesD(D>1e16) = Inf;end##### SOURCE END #####--></body></html>