<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html>  <head>    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">    <!--This HTML was auto-generated from MATLAB code.To make changes, update the MATLAB code and republish this document.      -->    <title>IM2POTENTIAL - Build a potential function from an image.</title>    <meta name="generator" content="MATLAB 7.14">    <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">    <meta name="DC.date" content="2012-11-23">    <meta name="DC.source" content="im2potential.m">    <style type="text/css">html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}html { min-height:100%; margin-bottom:1px; }html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }html body td { vertical-align:top; text-align:left; }h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }a { color:#005fce; text-decoration:none; }a:hover { color:#005fce; text-decoration:underline; }a:visited { color:#004aa0; text-decoration:none; }p { padding:0px; margin:0px 0px 20px; }img { padding:0px; margin:0px 0px 20px; border:none; }p img, pre img, tt img, li img { margin-bottom:0px; } ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }ul li { padding:0px; margin:0px 0px 7px 0px; }ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }ul li ol li { list-style:decimal; }ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }ol li ol li { list-style-type:lower-alpha; }ol li ul { padding-top:7px; }ol li ul li { list-style:square; }.content { font-size:1.2em; line-height:140%; padding: 20px; }pre, tt, code { font-size:12px; }pre { margin:0px 0px 20px; }pre.error { color:red; }pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }span.keyword { color:#0000FF }span.comment { color:#228B22 }span.string { color:#A020F0 }span.untermstring { color:#B20000 }span.syscmd { color:#B28C00 }.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }.footer p { margin:0px; }  </style>  </head>  <body>    <div class="content">      <h1>IM2POTENTIAL - Build a potential function from an image.</h1>      <!--introduction--><!--/introduction-->      <h2>Contents</h2>      <div>        <ul>          <li><a href="#1">Description</a></li>          <li><a href="#2">Syntax</a></li>          <li><a href="#3">Inputs</a></li>          <li><a href="#4">Outputs</a></li>          <li><a href="#5">References</a></li>          <li><a href="#8">See also</a></li>          <li><a href="#9">Function implementation</a></li>        </ul>      </div>      <h2>Description<a name="1"></a></h2>      <p>Given an input image, design a metric to be used as a potential (cost)        function in front propagation over its domain. Typically, we extract        norm and directional information from its derivatives to build the        metric. In particular, (iso- or anisotropic) metrics can be designed        from the gradient or the gradient structure tensor of the input image.</p>      <h2>Syntax<a name="2"></a></h2>      <pre class="language-matlab">P = IM2POTENTIAL(I, method);P = IM2POTENTIAL(I, method, a, rho, sigma, der, int, samp, eign);</pre>      <pre class="language-matlab">P = IM2POTENTIAL(I, <span class="string">'uni'</span>, a);P = IM2POTENTIAL(I, <span class="string">'pix'</span>/<span class="string">'pixinv'</span>, a);P = IM2POTENTIAL(I, <span class="string">'grd*'</span>/<span class="string">'iso'</span>, a, sigma);</pre>      <pre class="language-matlab">P = IM2POTENTIAL(I, <span class="string">'gst*'</span>/<spanclass="string">'iso'</span>/<spanclass="string">'ani'</span>, a, rho, sigma, der, int, samp, eign);P = IM2POTENTIAL(I, <span class="string">'gst*'</span>/<span class="string">'iso'</span>/<spanclass="string">'ani'</span>, a, rho, sigma, der, int, samp, N);P = IM2POTENTIAL(T, <span class="string">'gst*'</span>/<span class="string">'iso'</span>/<spanclass="string">'ani'</span>, a, eign);P = IM2POTENTIAL(T, <span class="string">'gst*'</span>/<span class="string">'iso'</span>/<spanclass="string">'ani'</span>, a, N);</pre>      <h2>Inputs<a name="3"></a></h2>      <p><b><tt>I</tt></b> : input image of size <tt>(X,Y,C)</tt>, possibly        multichannel when <tt>C&gt;1</tt>.</p>      <p><b><tt>T</tt></b> : input tensor matrix, typically the gradient        structure tensor (GST); this avoids redoing calculations inside the        function.</p>      <p><b><tt>method</tt></b> : string defining the method used for computing        the potential (and the metric) derived from the image; it is either        based on the image itself by setting it to:</p>      <div>        <ul>          <li><tt>'pix'</tt>, then the potential is scalar and equal everywhere            to the image (note that the higher the value at a pixel, the higher            its potential, the faster the propagation through it),</li>          <li><tt>'pixinv'</tt>, then the potential is scalar and equal to the            inverse of the image (inversely: the higher the value at a pixel,            the lower its potential, the slower the propagation through it),</li>        </ul>      </div>      <p>or based on the gradient of the image, by setting it to:</p>      <div>        <ul>          <li><tt>'grd'</tt>, then the potential is vectorial equal to the image            gradient,</li>          <li><tt>'grdorth'</tt> or <tt>'ani'</tt>, then the potential is            vectorial equal to the orthogonal vector to the gradient vector,</li>          <li><tt>'grdn'</tt> (or <tt>'isoinv'</tt>), then the potential is            scalar and equal to the gradient norm,</li>          <li><tt>'grdninv'</tt> (or <tt>'iso'</tt>), then the potential is            scalar and equal to the inverse of the gradient norm;</li>        </ul>      </div>      <p>whenever the image is a scalar (graylevel) image; when the image is        multispectral (<tt>C&gt;1</tt>), the GST is used to derive the potential        function, which will depend on the chosen method [GSD10]:</p>      <div>        <ul>          <li><tt>'iso'</tt> (or <tt>'gstninv'</tt>) for a scalar potential set            to the inverse of the GST norm,</li>          <li><tt>'gst'</tt> for a tensorial potential set to the GST itself            (same eigen- decomposition),</li>          <li><tt>'gstorth'</tt> for a tensorial potential set to the orthogonal            tensor to the GST (same eigenvalues, orthogonal eigenvectors),</li>          <li><tt>'ani'</tt> for a tensorial tensor set to the orthogonal of the            GST and scaled by <tt>N</tt> (scaled eigenvalues, orthogonal            eigenvector),</li>          <li><tt>'gstcoh'</tt> for a tensorial tensor set to the orthogonal of            the GST and scaled by the coherence (see <tt>GSTFEATURE</tt>),</li>          <li><tt>'gstiso'</tt> for a unitary tensorial potential set to the            normalized GST (same eigenvectors, normalized eigenvalues),</li>        </ul>      </div>      <p>where <tt>N</tt> is a scaling function passed externally or estimated        as the GST norm (see below).</p>      <p><b><tt>a</tt></b> : exponent used for amplyfying the strenght of the        cost function (cases <tt>'pix'</tt>, <tt>'pixinv'</tt>, <tt>'grdn'</tt>,        <tt>'iso'</tt>) or the strenght of the scaling function (cases <tt>'gstninv'</tt>,        <tt>'gstnorm'</tt>); default: <tt>a=1</tt>.</p>      <p><b><tt>rho</tt></b> : integration scale for computing the GST; default:        <tt>rho=1</tt>.</p>      <p><b><tt>sigma</tt></b> : differentiation scale for estimating the        directional derivatives; default: <tt>sigma=1</tt>.</p>      <p><b><tt>der</tt></b> : string defining the method of        pre-smoothing/differentiation used for estimating the directional        derivatives of the input image; it is one among (see <tt>GRDSMOOTH</tt>):        <tt>'matlab'</tt>, <tt>'vista'</tt>, <tt>'fast'</tt>, <tt>'conv'</tt>,        <tt>'fleck'</tt>, <tt>'tap5'</tt>, <tt>'tap7'</tt>, <tt>'sob'</tt>, <tt>'opt'</tt>        or <tt>'ana'</tt>; default: <tt>der='fast'</tt>.</p>      <p><b><tt>int</tt></b> : string defining the method used for the        post-smoothing of the GST; it is either (see <tt>GRD2GST</tt>): <tt>'matlab'</tt>,        <tt>'conv'</tt> or <tt>'fast'</tt> for isotropic Gaussian smoothing, or        <tt>'ani'</tt> for anisotropic Gaussian (using hourglass shaped Gaussian        kernels) along the edges; this latter better captures edges anisotropy;        default: <tt>int='fast'</tt>.</p>      <p><b><tt>samp</tt></b> : scalar used as a sampling rate for the gradient        when estimating the GST; default: <tt>samp=1</tt>.</p>      <p><b><tt>eign</tt></b> : in the case the tensor norm estimated from the        eigenvalues (l1 and l2, with l1&gt;l2) is to be estimated , the string        eign defines the method used for its approximation; it is either (see <tt>GSTFEATURE</tt>):        <tt>'l1'</tt> (or <tt>'zen'</tt>), <tt>'abs'</tt>, <tt>'sum'</tt> (or        <tt>'sap'</tt>), <tt>'dif'</tt> (or <tt>'koe'</tt>) or <tt>'ndi'</tt>;        default: <tt>eign='l1'</tt>.</p>      <p><b><tt>N</tt></b> : additional scaling (or pilot) function; it is a        matrix of size <tt>(X,Y)</tt> used to scalenormalize the eigenvalues of        the GST when the potential is derived from it; it counter-balances the        influence of the eigenvalues in the potential definition; typically, it        is set to the input image, or the gradient norm; default <tt>N = []</tt>,        and the gradient norm is estimated and used as the scale function.</p>      <h2>Outputs<a name="4"></a></h2>      <p><b><tt>P</tt></b> : potential function derived from the image (see also        function <tt>POTENTIAL2FRONT</tt>); it can be:</p>      <div>        <ul>          <li>a vector of size <tt>(n,m,2)</tt> representing a vector field            used to define an anisotropic metric when the image is scalar</li>          <li>a matrix of size <tt>(n,m)</tt> representing a scalar potential            field; it will be used for defining an isotropic metric,</li>          <li>a tensor matrix of size <tt>(n,m)</tt> representing a tensor            field when the image is multispectral, and used for defining an            anisotropic Riemannian metric.</li>        </ul>      </div>      <h2>References<a name="5"></a></h2>      <p>[PC09] G. Peyre, and L. Cohen: "Geodesic methods for shape and surface        processing", in "Advances in Computational Vision and Medical Image        Processing: Methods and Applications", vol. 13 of "Computational Methods        in Applied Sciences", pp. 29-56, Springer, 2009.</p>      <p>[GSD10] J. Grazzini, P. Soille and S. Dillard: "Multichannel image        regularisation using anisotropic geodesic filtering", Proc. ICPR, pp.        2664-2667, 2010.</p>      <h2>See also<a name="8"></a></h2>      <p>Related: <a href="im2front.html"><tt>IM2FRONT</tt></a>, <a href="potential2front.html"><tt>POTENTIAL2FRONT</tt></a>,        <a href="fmmanisopropagation.html"><tt>FMMANISOPROPAGATION</tt></a>, <a          href="fmmisopropagation.html"><tt>FMMISOPROPAGATION</tt></a>,        <a href="fmm_base.html"><tt>FMM_BASE</tt></a>. Called: <a href="../derive/grdsmooth_base.html"><tt>GRDSMOOTH_BASE</tt></a>,        <a href="../derive/gstsmooth_base.html"><tt>GSTSMOOTH_BASE</tt></a>,        <a href="../derive/gstfeature_base.html"><tt>GSTFEATURE_BASE</tt></a>,        <a href="../derive/gstdecomp.html"><tt>GSTDECOMP</tt></a>.</p>      <h2>Function implementation<a name="9"></a></h2>      <pre class="codeinput"><span class="keyword">function</span> [P, N, T] = <spanclass="keyword">...</span>    im2potential(I, method, a, rho, sigma, der, int, samp, eign)</pre>      <p>Note for debugger/coder: not all the cases below are listed in the        cases mentioned to the user</p>      <p>check/set parameters</p>      <pre class="codeinput">error(nargchk(2, 9, nargin, <span class="string">'struct'</span>));error(nargoutchk(1, 3, nargout, <span class="string">'struct'</span>));<span class="comment">% we accept a variable number of inputs</span><span class="keyword">if</span> nargin&lt;9,     eign = <span class="string">'l1'</span>;    <span class="keyword">if</span> nargin&lt;8,     samp = 1;        <span class="keyword">if</span> nargin&lt;7,     int = <span class="string">'fast'</span>;            <span class="keyword">if</span> nargin&lt;6,     der = <span class="string">'fast'</span>;                <span class="keyword">if</span> nargin&lt;5,     sigma = 1;                    <span class="keyword">if</span> nargin&lt;4,     rho = 1;                        <span class="keyword">if</span> nargin&lt;3,     a = [1 2];  <spanclass="keyword">end</span>                    <span class="keyword">end</span>                <span class="keyword">end</span>            <span class="keyword">end</span>        <span class="keyword">end</span>    <span class="keyword">end</span><span class="keyword">end</span><span class="comment">% still, in the rest of the code we take into account the number of</span><span class="comment">% variables that have been entered!</span><span class="keyword">if</span> length(a)==1,  a = [a a];<span class="comment">% elseif length(a)==2 &amp;&amp;  a(1)&gt;a(2)</span><span class="comment">%     a = [a a(1)];</span><span class="comment">%     a(1) = []; % invert the order</span><span class="keyword">end</span>d = nb_dims(I);C = size(I,3);cons = 1;  <span class="comment">% cons = eps;</span><span class="comment">% dummy settings in some cases</span><span class="keyword">if</span> nargout&gt;=2,  N = [];    <span class="keyword">if</span> nargout==3,  T = [];  <span class="keyword">end</span><span class="keyword">end</span></pre>      <p>define the potential function</p>      <pre class="codeinput"><span class="keyword">if</span> nargin&lt;=3 &amp;&amp; strcmpi(method,<spanclass="string">'uni'</span>)  <spanclass="comment">% uniform isotropic potential</span>    <span class="comment">% no information regarding the image is used here</span>    <span class="comment">% compute the normalized unitary tensor: equivalent to Euclidean</span>    <span class="comment">% isotropic unitary eigenvector.</span>    P = a(1) * ones(size(I)); <span class="comment">% Euclidean when a(1) = 1</span>    <span class="comment">% note: this is equivalent to building a tensor metric with the following</span>    <span class="comment">% eigendecomposition:</span>    <span class="comment">% l1 = ones(size(l1)); l2 = ones(size(l2));</span>    <span class="comment">% e1(:,:,1) = 0; e1(:,:,2) = 1; e2 = cat(3, -e1(:,:,2), e1(:,:,1));</span><span class="keyword">elseif</span> C==1 &amp;&amp; any(strcmpi(method,{<span class="string">'pix'</span>,<spanclass="string">'pixinv'</span>}))    <span class="keyword">switch</span> method        <span class="keyword">case</span> <span class="string">'pix'</span> <spanclass="comment">% pixel based value potential</span>            <span class="comment">% the highest the greylevel, the lowest the potential</span>            P = (eps + I).^a(1);        <span class="keyword">case</span> <span class="string">'pixinv'</span>  <spanclass="comment">% pixel based value potential</span>            <span class="comment">% the lowest the greylevel, the highest the potential</span>            P = 1 ./ (cons + I).^a(1);    <span class="keyword">end</span><span class="keyword">elseif</span> C==1 &amp;&amp; any(strcmpi(method(1:3),{<spanclass="string">'grd'</span>,<spanclass="string">'iso'</span>}))    <span class="keyword">if</span> nargin&lt;=3 &amp;&amp; any(strcmpi(method,{<spanclass="string">'grdninv'</span>,<spanclass="string">'iso'</span>,<spanclass="string">'grdn'</span>}))        N = I;    <span class="keyword">else</span> <span class="comment">% note that we use rho here!</span>        [gx, gy, N] = grdsmooth_base(I, rho, <span class="string">'fast'</span>, [], <spanclass="string">'ij'</span>);    <span class="keyword">end</span>    <span class="keyword">switch</span>  method        <span class="keyword">case</span> <span class="string">'grd'</span>            <span class="comment">% vector field</span>            P(:,:,1) = gx;  P(:,:,2) = gy;        <span class="keyword">case</span> {<span class="string">'grdorth'</span>,<spanclass="string">'ani'</span>}            <span class="comment">% orthogonal vector field</span>            P(:,:,1) = gy;  P(:,:,2) = gx;        <span class="keyword">case</span> {<span class="string">'grdn'</span>,<spanclass="string">'isoinv'</span>} <spanclass="comment">% gradient attracting potential</span>            P = (eps + N).^a(1);        <span class="keyword">case</span> {<span class="string">'grdninv'</span>,<spanclass="string">'iso'</span>} <spanclass="comment">% gradient avoiding potential</span>            <span class="comment">% the propagation will be isotropic and based on a scalar field</span>            <span class="comment">% defined as the inverse of the gradient norm (the higher the</span>            <span class="comment">% gradient N, the lower P, the slower the front will propagate)</span>            P = 1 ./ (cons + N).^a(1);    <span class="keyword">end</span>    <span class="comment">% note that calling im2potential(X,'pixinv',a) or</span>    <span class="comment">% im2potential(X,'grdninv',a) is equivalent, but calling</span>    <span class="comment">% im2potential(X,'grdninv',a, rho) is not.</span>    <span class="comment">% similarly, it is equiavelent to call im2potential(X,'pix',a)</span>    <span class="comment">% or im2potential(X,'grdn',a), but not the call to</span>    <span class="comment">% im2potential(X,'grdn',a,rho)</span><span class="keyword">elseif</span> any(strcmpi(method(1:3),{<span class="string">'gst'</span>,<spanclass="string">'iso'</span>,<spanclass="string">'ani'</span>})) <spanclass="comment">% the input can be any dimension</span>    <span class="comment">% compute the structure tensor</span>    <span class="keyword">if</span> d&lt;4        P = gstsmooth_base(I, rho, sigma, der, int, samp, <span class="keyword">...</span>            [], false, false, 8, .4); <span class="comment">% default choices</span>        <span class="keyword">if</span> nargout==3,  T = P;  <span class="keyword">end</span>  <spanclass="comment">% may be useful later in some code...</span>    <span class="keyword">elseif</span> nargin&lt;=4 &amp;&amp; d==4  <span class="comment">% we suppose we passed the already estimated tensor</span>        P = I;        <span class="comment">% trick to pass only 4 parameters when the first one is a tensor</span>        <span class="comment">% and only the norm needs to be computed (because then variables</span>        <span class="comment">% rho, sigma, der, int, samp are not needed) by  passing eign in rho</span>        <span class="comment">% or the norm itself in rho</span>        <span class="keyword">if</span> ischar(rho) || (~isscalar(rho) &amp;&amp; isequal(size(rho),size(I(:,:,1,1))))            eign = rho;        <span class="keyword">end</span>    <span class="keyword">end</span>    <span class="keyword">if</span> ischar(eign)        <span class="comment">% compute the norm of the structure tensor</span>        N = gstfeature_base(P(:,:,1,1), P(:,:,2,2), P(:,:,1,2), <span class="keyword">...</span>            <span class="string">'norm'</span>, eign, [], []);        <span class="comment">% N a can also be used for tensor normalization</span>        <span class="comment">% N = rescale(N,0,1); % N = rescale(N,0,1-eps);</span>    <span class="keyword">elseif</span> isequal(size(eign),size(I(:,:,1,1))) <spanclass="comment">% whatever I may be (tensor</span>        <span class="comment">% or image), we assume we passed a pilot image in the variable eign</span>        N = eign;    <span class="keyword">end</span>    <span class="keyword">if</span> any(strcmpi(method,{<span class="string">'iso'</span>,<spanclass="string">'gstninv'</span>,<spanclass="string">'gstn'</span>}))        <span class="keyword">switch</span> method            <span class="keyword">case</span> {<span class="string">'iso'</span>,<spanclass="string">'gstninv'</span>}                <span class="comment">% we return the inverse of the tensor norm for isotropic</span>                <span class="comment">% propagation: the higher the gradient norm value of a pixel,</span>                <span class="comment">% the lower its potential, the slower the propagation through</span>                <span class="comment">% it</span>                P = 1 ./ (cons + N).^a(1);            <span class="keyword">case</span> <span class="string">'gstn'</span>                P = (eps + N).^a(1);        <span class="keyword">end</span>        <span class="keyword">return</span>;    <span class="keyword">end</span>    <span class="comment">% eigendecomposition of the structure tensor</span>    [l1, l2, e1, e2] = gstdecomp(P);    <span class="comment">% % normalize wrt l1's extrema</span>    <span class="comment">% m = min(l2(:));   mm = max(l2(:));</span>    <span class="comment">% l1 = (l1 - m) / (mm - m);</span>    <span class="comment">% l2 = (l2 - m) / (mm - m);</span>    <span class="keyword">switch</span>  method        <span class="comment">% case 'gstninv'</span>        <span class="comment">%     % tensorial unitary (eigenvectors) and scaled by N</span>        <span class="comment">%     l1 = 1 ./ (cons + N).^a(1);</span>        <span class="comment">%     l2 = eps;</span>        <span class="comment">%     %e1(:,:,1) = 0; e1(:,:,2) = 1;</span>        <span class="comment">%     e2 = cat(3, -e1(:,:,2), e1(:,:,1));</span>        <span class="comment">% % note that in the case the image is scalar (graylevel, C=1)</span>        <span class="comment">% % and N is computed using GSTFEATURE, the results obtained</span>        <span class="comment">% % with methods 'gdrninv' and 'gstninv' are equivalent</span>        <span class="keyword">case</span> <span class="string">'gst'</span>            <span class="comment">% do nothing: we will use the GST itself as the tensor metric</span>        <span class="keyword">case</span> <span class="string">'gstorth'</span>            <span class="comment">% define the tensor orhogonal to the GST</span>            tmp = e1;            e1 = e2;            e2 = tmp;        <span class="keyword">case</span> <span class="string">'ani'</span>            <span class="comment">% the propagation is anisotropic and based on the normalized</span>            <span class="comment">% gradient structure tensor</span>            l1 = l1 ./ (cons + N).^a(1);            l2 = 1 ./ (cons + N).^a(2);        <span class="keyword">case</span> <span class="string">'gstn1'</span>            l1 = l1 ./ (cons + N).^a(1);            l2 = l2 ./ (cons + N).^a(2);            <span class="comment">% 'ani' and 'gstn1' perform better</span>        <span class="keyword">case</span> <span class="string">'gstn2'</span> <spanclass="comment">% this is exactly Eqs.(3) and (4) of [GSD10]</span>            l1 = 1 ./ (cons + N).^a(1);            l2 = 1 ./ (cons + N).^a(2);        <span class="keyword">case</span> <span class="string">'gstn3'</span>            tmp = l1;            l1 = l2 ./ (cons + N).^a(1);            l2 = tmp ./ (cons + N).^a(2);        <span class="keyword">case</span> <span class="string">'gstcoh'</span>            l1 = (l1 + l2) ./ (l1 - l2 + eps);            l2 = 1;        <span class="keyword">case</span> <span class="string">'gstiso'</span>            <span class="comment">% conserve the GST direction only, set eigenvalues to 1</span>            l1 = ones(size(l1));            l2 = ones(size(l2));    <span class="keyword">end</span>    <span class="comment">% recompose the structure tensor with modified eigenvalues and/or</span>    <span class="comment">% eigenvectors</span>    P = gstdecomp(l1, l2, e1, e2);  <span class="comment">% new tensor metric</span><span class="keyword">else</span>    error(<span class="string">'im2potential:methoderror'</span>, <span class="keyword">...</span>        [<span class="string">'unknown method '</span> method <span class="string">' or incompatible combination of input parameters'</span>])<span class="keyword">end</span></pre>      <pre class="codeinput"><span class="keyword">end</span> <span class="comment">% end of im2potential</span></pre></div>    <!--##### SOURCE BEGIN #####%% IM2POTENTIAL - Build a potential function from an image.%%% Description% Given an input image, design a metric to be used as a potential (cost)% function in front propagation over its domain. Typically, we extract norm % and directional information from its derivatives to build the metric. In% particular, (iso- or anisotropic) metrics can be designed from the gradient% or the gradient structure tensor of the input image.%%% Syntax%   P = IM2POTENTIAL(I, method);%   P = IM2POTENTIAL(I, method, a, rho, sigma, der, int, samp, eign);% %   P = IM2POTENTIAL(I, 'uni', a);%   P = IM2POTENTIAL(I, 'pix'/'pixinv', a);%   P = IM2POTENTIAL(I, 'grd*'/'iso', a, sigma);%%   P = IM2POTENTIAL(I, 'gst*'/'iso'/'ani', a, rho, sigma, der, int, samp, eign);%   P = IM2POTENTIAL(I, 'gst*'/'iso'/'ani', a, rho, sigma, der, int, samp, N);%   P = IM2POTENTIAL(T, 'gst*'/'iso'/'ani', a, eign);%   P = IM2POTENTIAL(T, 'gst*'/'iso'/'ani', a, N);   % %% Inputs% *|I|* : input image of size |(X,Y,C)|, possibly multichannel when |C>1|.%% *|T|* : input tensor matrix, typically the gradient structure tensor (GST);%     this avoids redoing calculations inside the function.%% *|method|* : string defining the method used for computing the potential%     (and the metric) derived from the image; it is either based on the image%     itself by setting it to:%% * |'pix'|, then the potential is scalar and equal everywhere to the image%          (note that the higher the value at a pixel, the higher its%          potential, the faster the propagation through it),% * |'pixinv'|, then the potential is scalar and equal to the inverse of the %          image (inversely: the higher the value at a pixel, the lower its%          potential, the slower the propagation through it),%% or based on the gradient of the image, by setting it to:%% * |'grd'|, then the potential is vectorial equal to the image gradient,% * |'grdorth'| or |'ani'|, then the potential is vectorial equal to the%          orthogonal vector to the gradient vector,% * |'grdn'| (or |'isoinv'|), then the potential is scalar and equal to the%          gradient norm,% * |'grdninv'| (or |'iso'|), then the potential is scalar and equal to the%          inverse of the gradient norm;%% whenever the image is a scalar (graylevel) image; when the image is%     multispectral (|C>1|), the GST is used to derive the potential function,%     which will depend on the chosen method [GSD10]:%% * |'iso'| (or |'gstninv'|) for a scalar potential set to the inverse of the%          GST norm,% * |'gst'| for a tensorial potential set to the GST itself (same eigen-%          decomposition),% * |'gstorth'| for a tensorial potential set to the orthogonal tensor to the%          GST (same eigenvalues, orthogonal eigenvectors),% * |'ani'| for a tensorial tensor set to the orthogonal of the GST and%          scaled by |N| (scaled eigenvalues, orthogonal eigenvector),% * |'gstcoh'| for a tensorial tensor set to the orthogonal of the GST and%          scaled by the coherence (see |GSTFEATURE|),% * |'gstiso'| for a unitary tensorial potential set to the normalized GST%          (same eigenvectors, normalized eigenvalues),%% where |N| is a scaling function passed externally or estimated as the GST%     norm (see below).%% *|a|* : exponent used for amplyfying the strenght of the cost function%     (cases |'pix'|, |'pixinv'|, |'grdn'|, |'iso'|) or the strenght of the%     scaling function (cases |'gstninv'|, |'gstnorm'|); default: |a=1|.%% *|rho|* : integration scale for computing the GST; default: |rho=1|.%% *|sigma|* : differentiation scale for estimating the directional derivatives;%     default: |sigma=1|.%% *|der|* : string defining the method of pre-smoothing/differentiation used%     for estimating the directional derivatives of the input image; it is %     one among (see |GRDSMOOTH|): |'matlab'|, |'vista'|, |'fast'|, |'conv'|,%     |'fleck'|, |'tap5'|, |'tap7'|, |'sob'|, |'opt'| or |'ana'|; default: %     |der='fast'|.%% *|int|* : string defining the method used for the post-smoothing of the GST;%     it is either (see |GRD2GST|): |'matlab'|, |'conv'| or |'fast'| for%     isotropic Gaussian smoothing, or |'ani'| for anisotropic Gaussian (using%     hourglass shaped Gaussian kernels) along the edges; this latter better%     captures edges anisotropy; default: |int='fast'|.%% *|samp|* : scalar used as a sampling rate for the gradient when estimating%     the GST; default: |samp=1|.%% *|eign|* : in the case the tensor norm estimated from the eigenvalues (l1%     and l2, with l1>l2) is to be estimated , the string eign defines the%     method used for its approximation; it is either (see |GSTFEATURE|): %     |'l1'| (or |'zen'|), |'abs'|, |'sum'| (or |'sap'|), |'dif'| (or |'koe'|)%     or |'ndi'|; default: |eign='l1'|. %% *|N|* : additional scaling (or pilot) function; it is a matrix of size |(X,Y)|%     used to scalenormalize the eigenvalues of the GST when the potential is%     derived from it; it counter-balances the influence of the eigenvalues%     in the potential definition; typically, it is set to the input image,%     or the gradient norm; default |N = []|, and the gradient norm is%     estimated and used as the scale function.% %% Outputs% *|P|* : potential function derived from the image (see also function %     |POTENTIAL2FRONT|); it can be:%% * a vector of size |(n,m,2)| representing a vector field used to define an%          anisotropic metric when the image is scalar% * a matrix of size |(n,m)| representing a scalar potential field; it will%          be used for defining an isotropic metric,% * a tensor matrix of size |(n,m)| representing a tensor field when the%          image is multispectral, and used for defining an anisotropic%          Riemannian metric.%%% References% [PC09]  G. Peyre, and L. Cohen: "Geodesic methods for shape and surface%      processing", in "Advances in Computational Vision and Medical Image%      Processing: Methods and Applications", vol. 13 of "Computational %      Methods in Applied Sciences", pp. 29-56, Springer, 2009.%% [GSD10]  J. Grazzini, P. Soille and S. Dillard: "Multichannel image %      regularisation using anisotropic geodesic filtering", Proc. ICPR,%      pp. 2664-2667, 2010.%%% TODO% Implement the loop for local window analysis inside the mex for efficiency!%  %% Credit% <mailto:grazzja@lanl.gov J.Grazzini> (ISR-2/LANL)%%% See also% Related:% <im2front.html |IM2FRONT|>, % <potential2front.html |POTENTIAL2FRONT|>,% <fmmanisopropagation.html |FMMANISOPROPAGATION|>,% <fmmisopropagation.html |FMMISOPROPAGATION|>,% <fmm_base.html |FMM_BASE|>.% Called: % <../derive/grdsmooth_base.html |GRDSMOOTH_BASE|>, % <../derive/gstsmooth_base.html |GSTSMOOTH_BASE|>, % <../derive/gstfeature_base.html |GSTFEATURE_BASE|>, % <../derive/gstdecomp.html |GSTDECOMP|>. %% Function implementationfunction [P, N, T] = ...    im2potential(I, method, a, rho, sigma, der, int, samp, eign)%%% Note for debugger/coder: not all the cases below are listed in the cases % mentioned to the user%%% check/set parameterserror(nargchk(2, 9, nargin, 'struct'));error(nargoutchk(1, 3, nargout, 'struct'));% we accept a variable number of inputsif nargin<9,     eign = 'l1';    if nargin<8,     samp = 1;        if nargin<7,     int = 'fast';            if nargin<6,     der = 'fast';                if nargin<5,     sigma = 1;                    if nargin<4,     rho = 1;                        if nargin<3,     a = [1 2];  end                    end                end            end        end    endend% still, in the rest of the code we take into account the number of% variables that have been entered!if length(a)==1,  a = [a a];% elseif length(a)==2 &&  a(1)>a(2)%     a = [a a(1)];%     a(1) = []; % invert the orderendd = nb_dims(I);C = size(I,3);cons = 1;  % cons = eps;% dummy settings in some casesif nargout>=2,  N = [];    if nargout==3,  T = [];  endend%% % define the potential functionif nargin<=3 && strcmpi(method,'uni')  % uniform isotropic potential    % no information regarding the image is used here    % compute the normalized unitary tensor: equivalent to Euclidean    % isotropic unitary eigenvector.    P = a(1) * ones(size(I)); % Euclidean when a(1) = 1    % note: this is equivalent to building a tensor metric with the following    % eigendecomposition:    % l1 = ones(size(l1)); l2 = ones(size(l2));    % e1(:,:,1) = 0; e1(:,:,2) = 1; e2 = cat(3, -e1(:,:,2), e1(:,:,1));elseif C==1 && any(strcmpi(method,{'pix','pixinv'}))     switch method                    case 'pix' % pixel based value potential            % the highest the greylevel, the lowest the potential            P = (eps + I).^a(1);                    case 'pixinv'  % pixel based value potential            % the lowest the greylevel, the highest the potential            P = 1 ./ (cons + I).^a(1);    end    elseif C==1 && any(strcmpi(method(1:3),{'grd','iso'}))       if nargin<=3 && any(strcmpi(method,{'grdninv','iso','grdn'}))        N = I;    else % note that we use rho here!        [gx, gy, N] = grdsmooth_base(I, rho, 'fast', [], 'ij');     end         switch  method                case 'grd'            % vector field            P(:,:,1) = gx;  P(:,:,2) = gy;        case {'grdorth','ani'}            % orthogonal vector field            P(:,:,1) = gy;  P(:,:,2) = gx;        case {'grdn','isoinv'} % gradient attracting potential            P = (eps + N).^a(1);        case {'grdninv','iso'} % gradient avoiding potential            % the propagation will be isotropic and based on a scalar field            % defined as the inverse of the gradient norm (the higher the            % gradient N, the lower P, the slower the front will propagate)            P = 1 ./ (cons + N).^a(1);                end        % note that calling im2potential(X,'pixinv',a) or      % im2potential(X,'grdninv',a) is equivalent, but calling    % im2potential(X,'grdninv',a, rho) is not.    % similarly, it is equiavelent to call im2potential(X,'pix',a)    % or im2potential(X,'grdn',a), but not the call to    % im2potential(X,'grdn',a,rho)     elseif any(strcmpi(method(1:3),{'gst','iso','ani'})) % the input can be any dimension    % compute the structure tensor    if d<4        P = gstsmooth_base(I, rho, sigma, der, int, samp, ...            [], false, false, 8, .4); % default choices        if nargout==3,  T = P;  end  % may be useful later in some code...            elseif nargin<=4 && d==4  % we suppose we passed the already estimated tensor        P = I;        % trick to pass only 4 parameters when the first one is a tensor        % and only the norm needs to be computed (because then variables        % rho, sigma, der, int, samp are not needed) by  passing eign in rho        % or the norm itself in rho        if ischar(rho) || (~isscalar(rho) && isequal(size(rho),size(I(:,:,1,1))))            eign = rho;        end    end        if ischar(eign)        % compute the norm of the structure tensor        N = gstfeature_base(P(:,:,1,1), P(:,:,2,2), P(:,:,1,2), ...            'norm', eign, [], []);        % N a can also be used for tensor normalization        % N = rescale(N,0,1); % N = rescale(N,0,1-eps);            elseif isequal(size(eign),size(I(:,:,1,1))) % whatever I may be (tensor        % or image), we assume we passed a pilot image in the variable eign        N = eign;    end        if any(strcmpi(method,{'iso','gstninv','gstn'}))        switch method            case {'iso','gstninv'}                % we return the inverse of the tensor norm for isotropic                % propagation: the higher the gradient norm value of a pixel,                % the lower its potential, the slower the propagation through                % it                P = 1 ./ (cons + N).^a(1);                            case 'gstn'                P = (eps + N).^a(1);        end                return;    end        % eigendecomposition of the structure tensor    [l1, l2, e1, e2] = gstdecomp(P);        % % normalize wrt l1's extrema     % m = min(l2(:));   mm = max(l2(:));    % l1 = (l1 - m) / (mm - m);    % l2 = (l2 - m) / (mm - m);     switch  method                % case 'gstninv'        %     % tensorial unitary (eigenvectors) and scaled by N        %     l1 = 1 ./ (cons + N).^a(1);        %     l2 = eps;        %     %e1(:,:,1) = 0; e1(:,:,2) = 1;        %     e2 = cat(3, -e1(:,:,2), e1(:,:,1));        % % note that in the case the image is scalar (graylevel, C=1)        % % and N is computed using GSTFEATURE, the results obtained        % % with methods 'gdrninv' and 'gstninv' are equivalent                case 'gst'            % do nothing: we will use the GST itself as the tensor metric                    case 'gstorth'            % define the tensor orhogonal to the GST            tmp = e1;            e1 = e2;            e2 = tmp;                    case 'ani'            % the propagation is anisotropic and based on the normalized            % gradient structure tensor            l1 = l1 ./ (cons + N).^a(1);            l2 = 1 ./ (cons + N).^a(2);         case 'gstn1'            l1 = l1 ./ (cons + N).^a(1);            l2 = l2 ./ (cons + N).^a(2);                        % 'ani' and 'gstn1' perform better                    case 'gstn2' % this is exactly Eqs.(3) and (4) of [GSD10]            l1 = 1 ./ (cons + N).^a(1);            l2 = 1 ./ (cons + N).^a(2);                     case 'gstn3'            tmp = l1;            l1 = l2 ./ (cons + N).^a(1);            l2 = tmp ./ (cons + N).^a(2);                    case 'gstcoh'            l1 = (l1 + l2) ./ (l1 - l2 + eps);            l2 = 1;                                case 'gstiso'            % conserve the GST direction only, set eigenvalues to 1            l1 = ones(size(l1));            l2 = ones(size(l2));                end    % recompose the structure tensor with modified eigenvalues and/or    % eigenvectors    P = gstdecomp(l1, l2, e1, e2);  % new tensor metric    else    error('im2potential:methoderror', ...        ['unknown method ' method ' or incompatible combination of input parameters'])endend % end of im2potential##### SOURCE END #####-->  </body></html>