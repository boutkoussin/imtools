<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html>  <head>    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">    <!--This HTML was auto-generated from MATLAB code.To make changes, update the MATLAB code and republish this document.      -->    <title>IM2FRONT - Potential-based front propagation over an image.</title>    <meta name="generator" content="MATLAB 7.14">    <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">    <meta name="DC.date" content="2012-11-23">    <meta name="DC.source" content="im2front.m">    <style type="text/css">html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}html { min-height:100%; margin-bottom:1px; }html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }html body td { vertical-align:top; text-align:left; }h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }a { color:#005fce; text-decoration:none; }a:hover { color:#005fce; text-decoration:underline; }a:visited { color:#004aa0; text-decoration:none; }p { padding:0px; margin:0px 0px 20px; }img { padding:0px; margin:0px 0px 20px; border:none; }p img, pre img, tt img, li img { margin-bottom:0px; } ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }ul li { padding:0px; margin:0px 0px 7px 0px; }ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }ul li ol li { list-style:decimal; }ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }ol li ol li { list-style-type:lower-alpha; }ol li ul { padding-top:7px; }ol li ul li { list-style:square; }.content { font-size:1.2em; line-height:140%; padding: 20px; }pre, tt, code { font-size:12px; }pre { margin:0px 0px 20px; }pre.error { color:red; }pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }span.keyword { color:#0000FF }span.comment { color:#228B22 }span.string { color:#A020F0 }span.untermstring { color:#B20000 }span.syscmd { color:#B28C00 }.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }.footer p { margin:0px; }  </style>  </head>  <body>    <div class="content">      <h1>IM2FRONT - Potential-based front propagation over an image.</h1>      <!--introduction--><!--/introduction-->      <h2>Contents</h2>      <div>        <ul>          <li><a href="#1">Description</a></li>          <li><a href="#2">Syntax</a></li>          <li><a href="#3">Inputs</a></li>          <li><a href="#4">Property [propertyname propertyvalues]</a></li>          <li><a href="#5">Outputs</a></li>          <li><a href="#7">See also</a></li>          <li><a href="#8">Function implementation</a></li>        </ul>      </div>      <h2>Description<a name="1"></a></h2>      <p>Perform a (multiple) front propagation from a set of seed points using        a metric derived from the input image over its domain.</p>      <h2>Syntax<a name="2"></a></h2>      <pre class="language-matlab">D = IM2FRONT(I, start_pts);D = IM2FRONT(I, start_pts, method);[D, Q] = IM2FRONT(I, start_pts, method, <span class="string">'Property'</span>, propertyvalue, <spanclass="keyword">...</span><spanclass="comment">);</span></pre>      <h2>Inputs<a name="3"></a></h2>      <p><b><tt>I</tt></b> : input image of size <tt>(X,Y,C)</tt>, possibly        multichannel with <tt>C&gt;1</tt>.</p>      <p><b><tt>start_pts</tt></b> : array of size <tt>(2,k)</tt>, where <tt>k</tt>        is the number of starting points, ie. <tt>start_pts(:,i)</tt> are the        coordinates of the <tt>i</tt>-th starting point.</p>      <p><b><tt>method</tt></b> : any string accepted by <tt>IM2POTENTIAL</tt>,        representing the method used to derive the potential function from the        input image; it can be: <tt>'uni'</tt>, <tt>'iso'</tt>, <tt>'isotropic'</tt>,        <tt>'ani'</tt>, <tt>'anisotropic'</tt>, <tt>'pix'</tt>, <tt>'pixinv'</tt>,        <tt>'grd'</tt>, <tt>'grdorth'</tt>, <tt>'grdn'</tt>, <tt>'grdninv'</tt>,        <tt>'gst'</tt>, <tt>'gstnorm'</tt>, <tt>'gstcoh'</tt>, <tt>'gstiso'</tt>;        see <tt>IM2POTENTIAL</tt> for further description.</p>      <h2>Property [propertyname propertyvalues]<a name="4"></a></h2>      <p><b><tt>'alpha'</tt></b> : (optional) exponent factor used for        amplyfying/moderating the strenght of the cost function.</p>      <p><b><tt>'rho'</tt></b> : (optional) integration scale for spatial        averaging, used for the estimation of the GST when required (see        function <tt>GSTSMOOTH</tt>); default: <tt>rho=3</tt>.</p>      <p><b><tt>'sig'</tt></b> : differentiation scale used for the estimation        of the 1st order image derivatives when required (see functions <tt>GRDSMOOTH</tt>        and <tt>GSTSMOOTH</tt>); default: <tt>sig=1</tt>.</p>      <p><b><tt>'der'</tt></b> : string defining the method of        pre-smoothing/differentiation used for estimating the directional        derivatives of the input image; it is either (see <tt>GRDSMOOTH</tt>):        <tt>'matlab'</tt>, <tt>'vista'</tt>, <tt>'fast'</tt>, <tt>'conv'</tt>,        <tt>'fleck'</tt>, <tt>'tap5'</tt>, <tt>'tap7'</tt>, <tt>'sob'</tt>, <tt>'opt'</tt>        or <tt>'ana'</tt>; default: <tt>der='fast'</tt>.</p>      <p><b><tt>'int'</tt></b> : string defining the method used for the        post-smoothing of the GST; it is either (see <tt>GRD2GST</tt>): <tt>'matlab'</tt>,        <tt>'conv'</tt>, <tt>'fast'</tt> or <tt>'ani'</tt>; default: <tt>int='fast'</tt>.</p>      <p><b><tt>'samp'</tt></b> : sampling factor used for GST estimation when        required (see <tt>GRD2GST</tt>); default: <tt>samp=1</tt>.</p>      <p><b><tt>'eign'</tt></b> : optional string defining the method used to        combine multichannel in GST norm estimation when required; it is either        (see <tt>GSTFEATURE</tt>): <tt>'abs'</tt>, <tt>'l1'</tt> (or <tt>'zen'</tt>),        <tt>'sum'</tt> (or <tt>'sap'</tt>), <tt>'dif'</tt> (or <tt>'koe'</tt>)        or <tt>'ndi'; default: |eign='l1'</tt>.</p>      <h2>Outputs<a name="5"></a></h2>      <p><b><tt>D</tt></b> : distance map representing the propagated front from        <tt>start_pts</tt> using a metric derived from the image.</p>      <h2>See also<a name="7"></a></h2>      <p>Related: <a href="fmm_base.html"><tt>FMM_BASE</tt></a>, <a href="im2potential.html"><tt>IM2POTENTIAL</tt></a>,        <a href="potential2front.html"><tt>POTENTIAL2FRONT</tt></a>, <a href="../derive/gstsmooth_base.html"><tt>GSTSMOOTH_BASE</tt></a>,        Called: <a href="im2front_base.html"><tt>IM2FRONT_BASE</tt></a>.</p>      <h2>Function implementation<a name="8"></a></h2>      <pre class="codeinput"><span class="keyword">function</span> [D, Q] = im2front(I, start_pts, varargin)</pre>      <p>parsing and checking parameters</p>      <pre class="codeinput">error(nargchk(1, 16, nargin, <span class="string">'struct'</span>));error(nargoutchk(1, 4, nargout, <span class="string">'struct'</span>));<span class="keyword">if</span> ~isnumeric(I) <span class="comment">% mandatory parameter</span>    error(<span class="string">'im2front:inputerror'</span>,<span class="string">'a matrix is required in input'</span>);<span class="keyword">end</span>p = createParser(<span class="string">'IM2FRONT'</span>);   <span class="comment">% create an instance of the inputParser class.</span><span class="comment">% optional parameters</span>p.addOptional(<span class="string">'method'</span>, <span class="string">'gstnorm'</span>, @(x)ischar(x) &amp;&amp; <spanclass="keyword">...</span>    any(strcmpi(x,{<span class="string">'iso'</span>,<span class="string">'isotropic'</span>,<spanclass="string">'ani'</span>,<spanclass="string">'anisotropic'</span>, <spanclass="string">'isoinv'</span>,<spanclass="keyword">...</span>    <span class="string">'uni'</span>,<span class="string">'pix'</span>,<span class="string">'pixinv'</span>,<spanclass="string">'grd'</span>,<spanclass="string">'grdorth'</span>,<spanclass="string">'grdn'</span>,<spanclass="string">'grdninv'</span>,<spanclass="string">'gstninv'</span>, <spanclass="keyword">...</span>    <span class="string">'gst'</span>,<span class="string">'gstnorm'</span>,<spanclass="string">'gstnorm1'</span>,<spanclass="string">'gstnorm2'</span>,<spanclass="string">'gstnorm3'</span>,<spanclass="string">'gstcoh'</span>,<spanclass="string">'gstiso'</span>})));<span class="comment">% additional optional parameters</span>p.addParamValue(<span class="string">'alpha'</span>, [1 2], @(x)isscalar(x) || (isvector(x) &amp;&amp; length(x)==2));p.addParamValue(<span class="string">'rho'</span>, 3, @(x)isscalar(x) &amp;&amp; isfloat(x) &amp;&amp; x&gt;=0);p.addParamValue(<span class="string">'sig'</span>, 1, @(x)isscalar(x) &amp;&amp; isfloat(x) &amp;&amp; x&gt;=0);p.addParamValue(<span class="string">'der'</span>, <span class="string">'fast'</span>, @(x)islogical(x) || (ischar(x) &amp;&amp; <spanclass="keyword">...</span>    any(strcmpi(x,{<span class="string">'matlab'</span>,<span class="string">'vista'</span>,<spanclass="string">'fast'</span>,<spanclass="string">'conv'</span>,<spanclass="string">'fleck'</span>, <spanclass="keyword">...</span>    <span class="string">'tap5'</span>,<span class="string">'tap7'</span>,<spanclass="string">'sob'</span>,<spanclass="string">'opt'</span>,<spanclass="string">'ana'</span>}))));p.addParamValue(<span class="string">'int'</span>, <span class="string">'fast'</span>, @(x)islogical(x) || (ischar(x) &amp;&amp; <spanclass="keyword">...</span>    any(strcmpi(x,{<span class="string">'matlab'</span>,<span class="string">'conv'</span>,<spanclass="string">'fast'</span>,<spanclass="string">'ani'</span>}))));p.addParamValue(<span class="string">'samp'</span>, 1, @(x)isscalar(x) &amp;&amp; round(x)==x &amp;&amp; x&gt;=1 &amp;&amp; x&lt;=5);p.addParamValue(<span class="string">'eign'</span>,<span class="string">'l1'</span>,@(x)ischar(x) &amp;&amp; <spanclass="keyword">...</span>    any(strcmpi(x,{<span class="string">'abs'</span>,<span class="string">'zen'</span>,<spanclass="string">'l1'</span>,<spanclass="string">'sap'</span>,<spanclass="string">'sum'</span>,<spanclass="string">'ndi'</span>,<spanclass="string">'dif'</span>,<spanclass="string">'koe'</span>})));<span class="comment">% parse and validate all input arguments</span>p.parse(varargin{:});p = getvarParser(p);</pre>      <p>checking/setting variables</p>      <pre class="codeinput"><span class="keyword">if</span> strcmpi(p.method,<spanclass="string">'anisotropic'</span>),    p.method = <spanclass="string">'ani'</span>;<span class="keyword">elseif</span> strcmpi(p.method,<span class="string">'isotropic'</span>),  p.method = <spanclass="string">'iso'</span>;<span class="keyword">end</span></pre>      <p>main computation</p>      <pre class="codeinput">[D, Q] = im2front_base(I, start_pts, p.method, <spanclass="keyword">...</span>    p.alpha, p.rho, p.sig, p.der, p.int, p.samp, p.eign );</pre>      <p>display</p>      <pre class="codeinput"><span class="keyword">if</span> p.disp    figure;    <span class="keyword">if</span> isempty(ver(<span class="string">'images'</span>))        subplot(1,3,1), imagesc(rescale(I));        subplot(1,3,2), imagesc(Q), colormap <span class="string">jet</span>;    <span class="keyword">else</span>        M = (imdilate(Q,ones(3,3))-Q==0);        subplot(1,3,2), imagesc(label2rgb(Q.*M)), axis <span class="string">image</span> <spanclass="string">off</span>;        M = cat(3,M,M,M);        subplot(1,3,1), imagesc(rescale(I.*M)+(1-M)), axis <span class="string">image</span> <spanclass="string">off</span>;    <span class="keyword">end</span>    subplot(1,3,3), imagesc(rescale(D)), colormap <span class="string">gray</span>, axis <spanclass="string">image</span> <spanclass="string">off</span>;    hold <span class="string">on</span>, plot(start_pts(1,:),start_pts(2,:),<spanclass="string">'*r'</span>), hold <spanclass="string">off</span>    suptitle(<span class="string">'front propagation'</span>);<span class="keyword">end</span></pre>      <pre class="codeinput"><span class="keyword">end</span> <span class="comment">% end of im2front</span></pre></div>    <!--##### SOURCE BEGIN #####%% IM2FRONT - Potential-based front propagation over an image.%%% Description% Perform a (multiple) front propagation from a set of seed points using a% metric derived from the input image over its domain.%%% Syntax%   D = IM2FRONT(I, start_pts);%   D = IM2FRONT(I, start_pts, method);%   [D, Q] = IM2FRONT(I, start_pts, method, 'Property', propertyvalue, ...);%%% Inputs% *|I|* : input image of size |(X,Y,C)|, possibly multichannel with |C>1|.%% *|start_pts|* : array of size |(2,k)|, where |k| is the number of starting%     points, ie. |start_pts(:,i)| are the coordinates of the |i|-th starting%     point.%% *|method|* : any string accepted by |IM2POTENTIAL|, representing the%     method used to derive the potential function from the input image;%     it can be: |'uni'|, |'iso'|, |'isotropic'|, |'ani'|, |'anisotropic'|,%     |'pix'|, |'pixinv'|, |'grd'|, |'grdorth'|, |'grdn'|, |'grdninv'|,%     |'gst'|, |'gstnorm'|, |'gstcoh'|, |'gstiso'|; see |IM2POTENTIAL| for %     further description.%%% Property [propertyname  propertyvalues]% *|'alpha'|* : (optional) exponent factor used for amplyfying/moderating the%     strenght of the cost function.%% *|'rho'|* : (optional) integration scale for spatial averaging, used for %     the estimation of the GST when required (see function |GSTSMOOTH|); %     default: |rho=3|.%% *|'sig'|* : differentiation scale used for the estimation of the 1st order%     image derivatives when required (see functions |GRDSMOOTH| and %     |GSTSMOOTH|); default: |sig=1|.%% *|'der'|* : string defining the method of pre-smoothing/differentiation used%     for estimating the directional derivatives of the input image; it is %     either (see |GRDSMOOTH|): |'matlab'|, |'vista'|, |'fast'|, |'conv'|, %     |'fleck'|, |'tap5'|, |'tap7'|, |'sob'|, |'opt'| or |'ana'|; default:%    |der='fast'|.%% *|'int'|* : string defining the method used for the post-smoothing of the GST;%     it is either (see |GRD2GST|): |'matlab'|, |'conv'|, |'fast'| or |'ani'|; %     default: |int='fast'|.%% *|'samp'|* : sampling factor used for GST estimation when required (see %     |GRD2GST|); default: |samp=1|.%% *|'eign'|* : optional string defining the method used to combine multichannel%     in GST norm estimation when required; it is either (see |GSTFEATURE|):  %     |'abs'|, |'l1'| (or |'zen'|), |'sum'| (or |'sap'|), |'dif'| (or |'koe'|)%     or |'ndi'; default: |eign='l1'|. %%% Outputs% *|D|* : distance map representing the propagated front from |start_pts| using %     a metric derived from the image.%  %% Credit% <mailto:grazzja@lanl.gov J.Grazzini> (ISR-2/LANL)%%% See also% Related:% <fmm_base.html |FMM_BASE|>,% <im2potential.html |IM2POTENTIAL|>,% <potential2front.html |POTENTIAL2FRONT|>,% <../derive/gstsmooth_base.html |GSTSMOOTH_BASE|>, % Called: % <im2front_base.html |IM2FRONT_BASE|>. %% Function implementationfunction [D, Q] = im2front(I, start_pts, varargin)%%% parsing and checking parameterserror(nargchk(1, 16, nargin, 'struct'));error(nargoutchk(1, 4, nargout, 'struct'));if ~isnumeric(I) % mandatory parameter    error('im2front:inputerror','a matrix is required in input'); endp = createParser('IM2FRONT');   % create an instance of the inputParser class.% optional parametersp.addOptional('method', 'gstnorm', @(x)ischar(x) && ...    any(strcmpi(x,{'iso','isotropic','ani','anisotropic', 'isoinv',...    'uni','pix','pixinv','grd','grdorth','grdn','grdninv','gstninv', ...    'gst','gstnorm','gstnorm1','gstnorm2','gstnorm3','gstcoh','gstiso'})));% additional optional parametersp.addParamValue('alpha', [1 2], @(x)isscalar(x) || (isvector(x) && length(x)==2));p.addParamValue('rho', 3, @(x)isscalar(x) && isfloat(x) && x>=0);p.addParamValue('sig', 1, @(x)isscalar(x) && isfloat(x) && x>=0);p.addParamValue('der', 'fast', @(x)islogical(x) || (ischar(x) && ...    any(strcmpi(x,{'matlab','vista','fast','conv','fleck', ...    'tap5','tap7','sob','opt','ana'}))));p.addParamValue('int', 'fast', @(x)islogical(x) || (ischar(x) && ...    any(strcmpi(x,{'matlab','conv','fast','ani'}))));p.addParamValue('samp', 1, @(x)isscalar(x) && round(x)==x && x>=1 && x<=5);p.addParamValue('eign','l1',@(x)ischar(x) && ...    any(strcmpi(x,{'abs','zen','l1','sap','sum','ndi','dif','koe'})));% parse and validate all input argumentsp.parse(varargin{:}); p = getvarParser(p);                                                            %%% checking/setting variablesif strcmpi(p.method,'anisotropic'),    p.method = 'ani';elseif strcmpi(p.method,'isotropic'),  p.method = 'iso';end%% % main computation[D, Q] = im2front_base(I, start_pts, p.method, ...    p.alpha, p.rho, p.sig, p.der, p.int, p.samp, p.eign );%%% displayif p.disp    figure;    if isempty(ver('images'))        subplot(1,3,1), imagesc(rescale(I));        subplot(1,3,2), imagesc(Q), colormap jet;    else        M = (imdilate(Q,ones(3,3))-Q==0);        subplot(1,3,2), imagesc(label2rgb(Q.*M)), axis image off;        M = cat(3,M,M,M);        subplot(1,3,1), imagesc(rescale(I.*M)+(1-M)), axis image off;    end    subplot(1,3,3), imagesc(rescale(D)), colormap gray, axis image off;    hold on, plot(start_pts(1,:),start_pts(2,:),'*r'), hold off    suptitle('front propagation');endend % end of im2front##### SOURCE END #####-->  </body></html>