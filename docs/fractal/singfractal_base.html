<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html>  <head>    <meta content="text/html; charset=utf-8" http-equiv="content-type">    <!--This HTML was auto-generated from MATLAB code.To make changes, update the MATLAB code and republish this document.      -->    <title>singfractal_base</title>    <meta name="generator" content="MATLAB 7.14">    <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">    <meta name="DC.date" content="2012-11-14">    <meta name="DC.source" content="singfractal_base.m">    <style type="text/css">html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}html { min-height:100%; margin-bottom:1px; }html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }html body td { vertical-align:top; text-align:left; }h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }a { color:#005fce; text-decoration:none; }a:hover { color:#005fce; text-decoration:underline; }a:visited { color:#004aa0; text-decoration:none; }p { padding:0px; margin:0px 0px 20px; }img { padding:0px; margin:0px 0px 20px; border:none; }p img, pre img, tt img, li img { margin-bottom:0px; } ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }ul li { padding:0px; margin:0px 0px 7px 0px; }ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }ul li ol li { list-style:decimal; }ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }ol li ol li { list-style-type:lower-alpha; }ol li ul { padding-top:7px; }ol li ul li { list-style:square; }.content { font-size:1.2em; line-height:140%; padding: 20px; }pre, tt, code { font-size:12px; }pre { margin:0px 0px 20px; }pre.error { color:red; }pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }span.keyword { color:#0000FF }span.comment { color:#228B22 }span.string { color:#A020F0 }span.untermstring { color:#B20000 }span.syscmd { color:#B28C00 }.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }.footer p { margin:0px; }  </style>  </head>  <body>    <div class="content">      <pre class="codeinput"><span class="keyword">function</span> [S, R, Histoh, H, H_r, DH, ErrDh, edges] = <spanclass="keyword">...</span>    singfractal_base(MS, scale, sc0, hmin, hmax, hstep, trans)<span class="comment">% SINGFRACTAL_BASE - Compute the multifractal singularity exponents and the</span><span class="comment">% multifractal spectrum.</span><span class="comment">%</span><span class="comment">%       [S, R, Histoh, H, H_r, DH, ErrDh, edges] = ...</span><span class="comment">%           SINGFRACTAL_BASE(MS, scale, sc0, hmin, hmax, hstep, trans)</span><span class="comment">%</span><span class="comment">% See also</span><span class="comment">% Ressembles: FRACTALWAVE_BASE, SINGFRACTALRECONS_BASE, FRACTALMORPH_BASE.</span>error(nargchk(3, 7, nargin, <span class="string">'struct'</span>));error(nargoutchk(1, 8, nargout, <span class="string">'struct'</span>));<span class="comment">% we allow a variable number of inputs with this function</span><span class="keyword">if</span> nargin&lt;7,  trans = false;    <span class="keyword">if</span> nargin&lt;6,  hstep = 100;        <span class="keyword">if</span> nargin&lt;5,  hmax = 2;            <span class="keyword">if</span> nargin&lt;4,  hmin  = -1;  <span class="keyword">end</span>        <span class="keyword">end</span>    <span class="keyword">end</span><span class="keyword">end</span>[S,R] = calculate_multifractal(MS, scale, sc0);[Histoh, H, edges] = singularity_histogram(S, hmin, hmax, hstep, sc0, trans);[H_r, DH, ErrDh] = spectrum_histogram(H, Histoh, sc0);<span class="keyword">end</span><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> [S,R] = calculate_multifractal(Tpsi_r, rho, sc0)funreg = @(x)log(x);n_x = size(Tpsi_r,2);<span class="comment">% compute the average</span>Tpsi_mean = mean(Tpsi_r);                                              <span class="comment">%#ok</span><span class="comment">% scale variable considered for the regression: log(r)</span>rr =  1 ./ funreg(rho*sc0); <span class="comment">% xx[ip] = 1 / log(sc*output.sc0);</span><span class="comment">% rr is transformed for estimating the log of the wavelet transform divided</span><span class="comment">% by the log of the scale</span>rr = repmat(rr,[1 n_x]); <span class="comment">% the entry rr is repeated over the columns</span><span class="comment">% compute the transform log(|T_psi|)</span>Tpsi_r = funreg(abs(Tpsi_r));   <span class="comment">% yy[ip] = log(fabs(wave[ip]));</span><span class="comment">% compute the transform log(|T_psi|)/log(r): yy[ip] *= xx[ip];</span>Tpsi_r = Tpsi_r .* rr;<span class="comment">% compute the regression coefficients=singularity exponents for each pixel</span>[a, S, R] = linearfit(rr, Tpsi_r);<span class="comment">% returns, for each pixel, the singularity exponent in the intercept b of</span><span class="comment">% the log-log linear regression</span><span class="keyword">end</span><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> [a, b, R, E] = linearfit(xx, yy)<span class="comment">% linear regression - fast vectorized implementation</span>sumx = mean(xx);sumy = mean(yy);sx = mean(xx.^2);sxy = mean(xx.*yy);sy = mean(yy.^2);sxy = sxy - sumx.*sumy;sx = sqrt(abs(sx - sumx.*sumx));sy = sqrt(abs(sy - sumy.*sumy));I=sx&gt;eps;a(I) = sxy(I) ./ (sx(I).*sx(I));b(I) = sumy(I) - a(I) .* sumx(I);J=sy&gt;eps;R(I&amp;J) = sxy(I&amp;J) ./ (sx(I&amp;J) .*sy(I&amp;J));R(I&amp;~J) = 1;a(~I) = 0;b(~I) = sumy(~I);R(~I) = 1;E = sy .* sy - a .* sx .*sx;<span class="comment">% non vectorized matlab implementation using regress, polyfit or \</span><span class="comment">% n_x = size(yy,2);</span><span class="comment">% for x=1:n_x</span><span class="comment">%     % \ : Backslash or left matrix divide.</span><span class="comment">%     % A\B is the matrix division of A into B. If A is an N-by-N matrix and</span><span class="comment">%     % B is a matrix with several such columns, then X = A\B is the solution</span><span class="comment">%     % to the equation A*X = B.</span><span class="comment">%     xx = xx(:,1); % xx is 'back'-transformed for using the operator \</span><span class="comment">%     %XX = [ones(length(xx),1), xx];</span><span class="comment">%     rr = xx \ yy(:,x);</span><span class="comment">%     a(x) = rr(2);  b(x) = rr(1);</span><span class="comment">%     % p = polyfit(xx,yy(:,x),1);</span><span class="comment">%     % a(x) = p(1); b(x) = p(2);</span><span class="comment">%     % p1 = regress(yy,xx);</span><span class="comment">%     % a(x) = p1(2); b(x) = p1(1);</span><span class="comment">%     [rr,P] = corrcoef([xx yy(:,x)]);</span><span class="comment">%     R(x) = rr(1,2);</span><span class="comment">% end</span><span class="keyword">end</span><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> [histoh, h, edges] = <span class="keyword">...</span>    singularity_histogram(S, hmin, hmax, hstep, sc0, trans)S = S(:);<span class="comment">%h0 = min(S);    h1 = max(S);</span><span class="comment">%delta_h = (h1 - h0) / hstep;</span><span class="keyword">if</span> hstep&gt;0 &amp;&amp; hstep&lt;1    delta_h = hstep;<span class="keyword">elseif</span> hstep&gt;1    delta_h = (hmax - hmin) / hstep;<span class="keyword">end</span>S(S&gt;hmax | isnan(S)) = hmax+0.1; <span class="comment">% S(S&gt;hmax) = [];</span>S(S&lt;hmin) = hmin-0.1;<span class="comment">% histoh = hist(S(:),range_h);</span><span class="comment">% [histoh,bin] = histc(S(:),h0:delta_h:h1);</span>edges = [hmin-0.1 hmin:delta_h:hmax hmax+0.1];[histoh,bins] = histc(S, edges);<span class="comment">% note: with the previous transformation of S, there should not be 'out of</span><span class="comment">% range' values (ie. null values in bins) anymore</span>h = accumarray(bins, S, [length(histoh) 1]);<span class="comment">% get rid of those pixels outside the bounds [hmin,hmax]</span>histoh = histoh(2:end-1);h = h(2:end-1);<span class="comment">% closing for the max: count/store the values for which S=hmax with the bin</span><span class="comment">% hmax-delta_h&lt;=S&lt;hmax</span>histoh(end-1) = histoh(end-1) + histoh(end); histoh(end) = [];h(end-1) = h(end-1) + h(end); h(end) = [];<span class="comment">% +outliers</span><span class="comment">% also modify edges accordingly</span>edges = edges(2:end-2);<span class="keyword">if</span> trans    [hmode, ihmode] = max(histoh);    I = histoh(1:ihmode)&gt;0;    auxdist = h(I) ./ histoh(I) + log(histoh(I)/hmode) / log(sc0);    hshift = min(auxdist);    h = h - hshift * histoh;<span class="keyword">end</span><span class="keyword">end</span><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> [h_r, Dh, errDh] = spectrum_histogram(h, histoh, sc0)min_ev = 100;cump = cumsum(histoh);<span class="comment">%I = floor(cump/min_ev);</span><span class="comment">%[dum,ir0] = unique(I,'first');</span><span class="comment">%[dum,ir1] = unique(I,'last');</span><span class="comment">% I = [0; diff(floor(cump/min_ev))]</span><span class="comment">% ir0 = find(I);</span><span class="comment">% ir1 = find(~I);</span><span class="comment">% if length(ir1)&lt;length(ir0),  ir1 = [ir1; ir0(end)];  end</span>Nh = length(histoh);histo_r = zeros(Nh,1);h_r = zeros(Nh,1);i = 1; ir0 = 1;ir1 = find(cump&gt;=min_ev,1,<span class="string">'first'</span>);<span class="keyword">while</span> ir0&lt;=length(histoh) &amp;&amp; ~isempty(ir1)    histo_r(i) = sum(histoh(ir0:ir1).^2) / cump(ir1); <span class="comment">% sum(histoh(ir0:ir1));</span>    h_r(i) = sum(h(ir0:ir1)) / cump(ir1);    cump = cump - cump(ir1); cump(1:ir1) = 0;    ir0 = ir1 + 1;    ir1 = find(cump&gt;=min_ev,1,<span class="string">'first'</span>);    i = i+1;<span class="keyword">end</span><span class="keyword">if</span> ~all(cump==0)    histo_r(i) = sum(histoh(ir0:end).^2) / cump(end); <span class="comment">% sum(histoh(ir0:ir1));</span>    h_r(i) = sum(h(ir0:end)) / cump(end);<span class="keyword">end</span>histo_r(i+1:end) = [];h_r(i+1:end) = [];<span class="comment">% the confidence range is taken as +-Ks sigmas in the distribution of</span><span class="comment">% probability boxes, which is renormalized binomial. we directly propagate</span><span class="comment">% the confidence range to the D(h) calculation</span>Ks = 3;prob = Ks * sqrt((1-histo_r/sum(histo_r)) ./ histo_r);prob(prob&lt;eps) = 0;prob(prob&gt;=1) = 1;<span class="comment">% the error bar is constructed by propagation: as the propagated interval</span><span class="comment">% is symmetric, we take the bar as the maximum of the two distances to the</span><span class="comment">% central value. this is given by the lower bound in the logarithm</span>errDh = log(1-prob) / log(sc0);errDh(isinf(errDh)) = 1; <span class="comment">% cases where prob==1</span><span class="comment">% finding and normalizing by the mode</span>maxprob = max(histo_r);<span class="keyword">if</span> maxprob&gt;eps,  histo_r = histo_r / maxprob;  <spanclass="keyword">end</span>;<span class="comment">% evaluating experimental reduced D(h): D_reduced(h) = D(h) - D_space</span>histo_r(histo_r==0) = eps;Dh = - log(histo_r) / log(sc0);<span class="keyword">end</span></pre></div>    <!--##### SOURCE BEGIN #####function [S, R, Histoh, H, H_r, DH, ErrDh, edges] = ...    singfractal_base(MS, scale, sc0, hmin, hmax, hstep, trans)% SINGFRACTAL_BASE - Compute the multifractal singularity exponents and the% multifractal spectrum.%%       [S, R, Histoh, H, H_r, DH, ErrDh, edges] = ...%           SINGFRACTAL_BASE(MS, scale, sc0, hmin, hmax, hstep, trans)%% credit: J.Grazzini (ISR-2/LANL)%% See also % Ressembles: FRACTALWAVE_BASE, SINGFRACTALRECONS_BASE, FRACTALMORPH_BASE.error(nargchk(3, 7, nargin, 'struct'));error(nargoutchk(1, 8, nargout, 'struct'));% we allow a variable number of inputs with this functionif nargin<7,  trans = false;    if nargin<6,  hstep = 100;        if nargin<5,  hmax = 2;            if nargin<4,  hmin  = -1;  end        end    endend[S,R] = calculate_multifractal(MS, scale, sc0);[Histoh, H, edges] = singularity_histogram(S, hmin, hmax, hstep, sc0, trans);[H_r, DH, ErrDh] = spectrum_histogram(H, Histoh, sc0);end%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction [S,R] = calculate_multifractal(Tpsi_r, rho, sc0)funreg = @(x)log(x); n_x = size(Tpsi_r,2);% compute the averageTpsi_mean = mean(Tpsi_r);                                              %#ok% scale variable considered for the regression: log(r)rr =  1 ./ funreg(rho*sc0); % xx[ip] = 1 / log(sc*output.sc0);% rr is transformed for estimating the log of the wavelet transform divided% by the log of the scalerr = repmat(rr,[1 n_x]); % the entry rr is repeated over the columns% compute the transform log(|T_psi|)Tpsi_r = funreg(abs(Tpsi_r));   % yy[ip] = log(fabs(wave[ip]));% compute the transform log(|T_psi|)/log(r): yy[ip] *= xx[ip];Tpsi_r = Tpsi_r .* rr;% compute the regression coefficients=singularity exponents for each pixel[a, S, R] = linearfit(rr, Tpsi_r);% returns, for each pixel, the singularity exponent in the intercept b of% the log-log linear regressionend%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction [a, b, R, E] = linearfit(xx, yy)% linear regression - fast vectorized implementationsumx = mean(xx);sumy = mean(yy);sx = mean(xx.^2);sxy = mean(xx.*yy);sy = mean(yy.^2);sxy = sxy - sumx.*sumy;sx = sqrt(abs(sx - sumx.*sumx));sy = sqrt(abs(sy - sumy.*sumy));I=sx>eps;a(I) = sxy(I) ./ (sx(I).*sx(I));b(I) = sumy(I) - a(I) .* sumx(I);J=sy>eps;R(I&J) = sxy(I&J) ./ (sx(I&J) .*sy(I&J));R(I&~J) = 1;a(~I) = 0;b(~I) = sumy(~I);R(~I) = 1;E = sy .* sy - a .* sx .*sx;% non vectorized matlab implementation using regress, polyfit or \% n_x = size(yy,2);% for x=1:n_x%     % \ : Backslash or left matrix divide.%     % A\B is the matrix division of A into B. If A is an N-by-N matrix and%     % B is a matrix with several such columns, then X = A\B is the solution%     % to the equation A*X = B.%     xx = xx(:,1); % xx is 'back'-transformed for using the operator \%     %XX = [ones(length(xx),1), xx];%     rr = xx \ yy(:,x);%     a(x) = rr(2);  b(x) = rr(1);                                 %     % p = polyfit(xx,yy(:,x),1);%     % a(x) = p(1); b(x) = p(2);   %     % p1 = regress(yy,xx);%     % a(x) = p1(2); b(x) = p1(1);  %     [rr,P] = corrcoef([xx yy(:,x)]);%     R(x) = rr(1,2);% endend%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction [histoh, h, edges] = ...    singularity_histogram(S, hmin, hmax, hstep, sc0, trans)S = S(:);%h0 = min(S);    h1 = max(S);                                           %delta_h = (h1 - h0) / hstep;if hstep>0 && hstep<1    delta_h = hstep;elseif hstep>1    delta_h = (hmax - hmin) / hstep;                                   end    S(S>hmax | isnan(S)) = hmax+0.1; % S(S>hmax) = [];S(S<hmin) = hmin-0.1;% histoh = hist(S(:),range_h);% [histoh,bin] = histc(S(:),h0:delta_h:h1);edges = [hmin-0.1 hmin:delta_h:hmax hmax+0.1];[histoh,bins] = histc(S, edges);% note: with the previous transformation of S, there should not be 'out of% range' values (ie. null values in bins) anymoreh = accumarray(bins, S, [length(histoh) 1]);% get rid of those pixels outside the bounds [hmin,hmax]histoh = histoh(2:end-1);h = h(2:end-1);% closing for the max: count/store the values for which S=hmax with the bin% hmax-delta_h<=S<hmaxhistoh(end-1) = histoh(end-1) + histoh(end); histoh(end) = [];h(end-1) = h(end-1) + h(end); h(end) = [];% +outliers% also modify edges accordinglyedges = edges(2:end-2);if trans    [hmode, ihmode] = max(histoh);        I = histoh(1:ihmode)>0;    auxdist = h(I) ./ histoh(I) + log(histoh(I)/hmode) / log(sc0);    hshift = min(auxdist);        h = h - hshift * histoh;endend%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction [h_r, Dh, errDh] = spectrum_histogram(h, histoh, sc0)min_ev = 100;cump = cumsum(histoh);%I = floor(cump/min_ev);%[dum,ir0] = unique(I,'first');%[dum,ir1] = unique(I,'last');% I = [0; diff(floor(cump/min_ev))]% ir0 = find(I);% ir1 = find(~I);% if length(ir1)<length(ir0),  ir1 = [ir1; ir0(end)];  endNh = length(histoh);histo_r = zeros(Nh,1);h_r = zeros(Nh,1);i = 1; ir0 = 1;ir1 = find(cump>=min_ev,1,'first');while ir0<=length(histoh) && ~isempty(ir1)    histo_r(i) = sum(histoh(ir0:ir1).^2) / cump(ir1); % sum(histoh(ir0:ir1));    h_r(i) = sum(h(ir0:ir1)) / cump(ir1);    cump = cump - cump(ir1); cump(1:ir1) = 0;    ir0 = ir1 + 1;    ir1 = find(cump>=min_ev,1,'first');    i = i+1;endif ~all(cump==0)    histo_r(i) = sum(histoh(ir0:end).^2) / cump(end); % sum(histoh(ir0:ir1));    h_r(i) = sum(h(ir0:end)) / cump(end);endhisto_r(i+1:end) = []; h_r(i+1:end) = [];% the confidence range is taken as +-Ks sigmas in the distribution of% probability boxes, which is renormalized binomial. we directly propagate% the confidence range to the D(h) calculationKs = 3;prob = Ks * sqrt((1-histo_r/sum(histo_r)) ./ histo_r);prob(prob<eps) = 0;prob(prob>=1) = 1;% the error bar is constructed by propagation: as the propagated interval% is symmetric, we take the bar as the maximum of the two distances to the% central value. this is given by the lower bound in the logarithmerrDh = log(1-prob) / log(sc0);errDh(isinf(errDh)) = 1; % cases where prob==1% finding and normalizing by the modemaxprob = max(histo_r);if maxprob>eps,  histo_r = histo_r / maxprob;  end;% evaluating experimental reduced D(h): D_reduced(h) = D(h) - D_spacehisto_r(histo_r==0) = eps;Dh = - log(histo_r) / log(sc0);end##### SOURCE END #####-->  </body></html>