<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html>  <head>    <meta content="text/html; charset=utf-8" http-equiv="content-type">    <!--This HTML was auto-generated from MATLAB code.To make changes, update the MATLAB code and republish this document.      -->    <title>BRESENHAMLINE_BASE - Base function for BRESENHAMLINE.</title>    <meta name="generator" content="MATLAB 7.14">    <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">    <meta name="DC.date" content="2012-05-31">    <meta name="DC.source" content="bresenhamline_base.m">    <style type="text/css">html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}html { min-height:100%; margin-bottom:1px; }html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }html body td { vertical-align:top; text-align:left; }h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }a { color:#005fce; text-decoration:none; }a:hover { color:#005fce; text-decoration:underline; }a:visited { color:#004aa0; text-decoration:none; }p { padding:0px; margin:0px 0px 20px; }img { padding:0px; margin:0px 0px 20px; border:none; }p img, pre img, tt img, li img { margin-bottom:0px; } ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }ul li { padding:0px; margin:0px 0px 7px 0px; }ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }ul li ol li { list-style:decimal; }ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }ol li ol li { list-style-type:lower-alpha; }ol li ul { padding-top:7px; }ol li ul li { list-style:square; }.content { font-size:1.2em; line-height:140%; padding: 20px; }pre, tt, code { font-size:12px; }pre { margin:0px 0px 20px; }pre.error { color:red; }pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }span.keyword { color:#0000FF }span.comment { color:#228B22 }span.string { color:#A020F0 }span.untermstring { color:#B20000 }span.syscmd { color:#B28C00 }.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }.footer p { margin:0px; }  </style>  </head>  <body>    <div class="content">      <h1>BRESENHAMLINE_BASE - Base function for BRESENHAMLINE.</h1>      <!--introduction--><!--/introduction-->      <h2>Contents</h2>      <div>        <ul>          <li><a href="#1">Syntax</a></li>          <li><a href="#2">Acknowledgment</a></li>          <li><a href="#4">See also</a></li>          <li><a href="#5">Function implementation</a></li>          <li><a href="#13">Original</a></li>        </ul>      </div>      <h2>Syntax<a name="1"></a></h2>      <pre>   [x y pts] = BRESENHAMLINE_BASE(x1, y1, x2, y2);</pre>      <h2>Acknowledgment<a name="2"></a></h2>      <p>Entirely derived from the implementation of A.Wetzler; see original        source code <tt>BRESENHAM</tt> included in this file, otherwise        available at: <a href="http://www.mathworks.com/matlabcentral/fileexchange/28190">http://www.mathworks.com/matlabcentral/fileexchange/28190</a>.        Still, this original code did not support vectors of coordinates in        input, contrary to the implementation <tt>BRESENHAMLINE_BASE</tt>        proposed herein. See other implementations and source codes: <a href="http://www.mathworks.com/matlabcentral/fileexchange/12939">http://www.mathworks.com/matlabcentral/fileexchange/12939</a>,        <a href="http://www.mathworks.com/matlabcentral/fileexchange/13221">http://www.mathworks.com/matlabcentral/fileexchange/13221</a>.</p>      <h2>See also<a name="4"></a></h2>      <p>Ressembles: <a href="bresenhamline.html"><tt>BRESENHAMLINE</tt></a>, <a          href="sampledisk_base.html"><tt>SAMPLEDISK_BASE</tt></a>,        <a href="sampletriangle_base.html"><tt>SAMPLETRIANGLE_BASE</tt></a>, <a          href="drawleakcircle_base.html"><tt>DRAWLEAKCIRCLE_BASE</tt></a>.        Requires: <a href="matlab:webpub%28whichpath%28%27DIFF%27%29%29"><tt>DIFF</tt></a>,        <a href="matlab:webpub%28whichpath%28%27SUM%27%29%29"><tt>SUM</tt></a>,        <a href="matlab:webpub%28whichpath%28%27CUMSUM%27%29%29"><tt>CUMSUM</tt></a>,        <a href="matlab:webpub%28whichpath%28%27MESHGRID%27%29%29"><tt>MESHGRID</tt></a>.</p>      <h2>Function implementation<a name="5"></a></h2>      <pre class="codeinput"><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> [x, y, pts] = bresenhamline_base(x1, y1, x2, y2)</pre>      <p>transform the inputs in column vector and round the coordinates</p>      <pre class="codeinput">x1 = round(x1(:)); x2 = round(x2(:));y1 = round(y1(:)); y2 = round(y2(:));</pre>      <p>main computation starts here</p>      <pre class="codeinput">s = size(x1(:),1);dx = abs(x2-x1);dy = abs(y2-y1);steep = dy&gt;dx; <span class="comment">% vector column</span><span class="comment">% invert positions</span>t = dx(steep); dx(steep) = dy(steep); dy(steep) = t;<span class="comment">% length of the longest line</span>mdx = max(dx)+1;odx = ones(1,mdx);</pre>      <p>transform steep</p>      <pre class="codeinput">steep = steep(:, odx);   <span class="comment">% repmat(steep, [1 mdx]);</span>I = dy==0;DX = dx(:, odx);   <span class="comment">% repmat(dx, [1 mdx]);</span>DY = dy(:, odx);   <span class="comment">% repmat(dy, [1 mdx]);</span>A = floor(DX/2);B = DX .* DY;Z = cumsum(DY,2) - DY;Z = -Z;Q = A+Z;Q(Q &lt; A-B) = 0;Q = [zeros(s,1) diff(mod(Q,DX),1,2)&gt;=0];Q = cumsum(Q,2);Q(I,:) = 0;Z = meshgrid(0:mdx-1,1:s); <span class="comment">% cumsum(ones(s, mdx),2)-1</span>Y1 = y1(:, odx);   <span class="comment">% repmat(y1, [1 mdx]);</span>X1 = x1(:, odx);   <span class="comment">% repmat(x1, [1 mdx]);</span>Y2 = y2(:, odx);   <span class="comment">% repmat(y2, [1 mdx]);</span>X2 = x2(:, odx);   <span class="comment">% repmat(x2, [1 mdx]);</span></pre>      <p>vectorized version of Bresnham algorith (see A.Wetzler's code)</p>      <pre class="codeinput">A = X1&lt;=X2;  pts = ~A;x  = X1  + Z;x(pts) = x(pts) - 2*Z(pts);x(steep &amp; A) = X1(steep &amp; A) + Q(steep &amp; A);x(steep &amp; pts) = X1(steep &amp; pts) - Q(steep &amp; pts);B = (A &amp; x&gt;X2) | (pts &amp; x&lt;X2);A = Y1&lt;=Y2;  pts = ~A;y = Y1  + Z;y(pts) = y(pts) - 2*Z(pts);steep = ~steep;y(steep &amp; A) = Y1(steep &amp; A) + Q(steep &amp; A);y(steep &amp; pts) = Y1(steep &amp; pts) - Q(steep &amp; pts);A = (A &amp; y&gt;Y2) | (pts &amp; y&lt;Y2);</pre>      <p>trim</p>      <pre class="codeinput">A = A | B;<span class="comment">% additional output: but can be easily handled also without (using isnan)</span>pts = ~A; <span class="comment">% pts = ~isnan(x);</span>x(A) = NaN;y(A) = NaN;</pre>      <pre class="codeinput"><span class="keyword">end</span> <span class="comment">% end of bresenhamline_base</span></pre>      <h2>Original<a name="13"></a></h2>      <p><tt>BRESENHAM</tt> - Original implementation by A.Wetzler: single        entries only (coordinates of two vertices to be linked by a line).</p>      <pre class="codeinput"><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> [x y] = bresenham(x1,y1,x2,y2)                                <spanclass="comment">%#ok</span><span class="comment">%Matlab optmized version of Bresenham line algorithm. No loops.</span><span class="comment">%Format:</span><span class="comment">%               [x y]=bresenham(x1,y1,x2,y2)</span><span class="comment">%</span><span class="comment">%Input:</span><span class="comment">%               (x1,y1): Start position</span><span class="comment">%               (x2,y2): End position</span><span class="comment">%</span><span class="comment">%Output:</span><span class="comment">%               x y: the line coordinates from (x1,y1) to (x2,y2)</span><span class="comment">%</span><span class="comment">%Usage example:</span><span class="comment">%               [x y]=bresenham(1,1, 10,-5);</span><span class="comment">%               plot(x,y,'or');</span>x1=round(x1); x2=round(x2);y1=round(y1); y2=round(y2);dx = abs(x2-x1);dy = abs(y2-y1);steep = dy&gt;dx;   <span class="comment">% steep=abs(dy)&gt;abs(dx)</span><span class="keyword">if</span> steep, t=dx; dx=dy; dy=t;  <span class="keyword">end</span><span class="comment">% the main algorithm goes here.</span><span class="keyword">if</span> dy==0    q=zeros(dx+1,1);<span class="keyword">else</span>    q=[0;diff(mod((floor(dx/2):-dy:-dy*dx+floor(dx/2))',dx))&gt;=0];<span class="keyword">end</span><span class="comment">% and ends here.</span><span class="keyword">if</span> steep    <span class="keyword">if</span> y1&lt;=y2,  y = (y1:y2)';    <span class="keyword">else</span>        y = (y1:-1:y2)';   <span class="keyword">end</span>    <span class="keyword">if</span> x1&lt;=x2,  x = x1+cumsum(q);    <span class="keyword">else</span>        x = x1-cumsum(q);  <span class="keyword">end</span><span class="keyword">else</span>    <span class="keyword">if</span> x1&lt;=x2,  x = (x1:x2)';    <span class="keyword">else</span>        x = (x1:-1:x2)';   <span class="keyword">end</span>    <span class="keyword">if</span> y1&lt;=y2,  y = y1+cumsum(q);    <span class="keyword">else</span>        y = y1-cumsum(q);  <span class="keyword">end</span><span class="keyword">end</span><span class="keyword">end</span></pre></div>    <!--##### SOURCE BEGIN #####%% BRESENHAMLINE_BASE - Base function for BRESENHAMLINE. %%% Syntax%     [x y pts] = BRESENHAMLINE_BASE(x1, y1, x2, y2);%%% Acknowledgment% Entirely derived from the implementation of A.Wetzler; see original source  % code |BRESENHAM| included in this file, otherwise available at:%   <http://www.mathworks.com/matlabcentral/fileexchange/28190>.% Still, this original code did not support vectors of coordinates in input,% contrary to the implementation |BRESENHAMLINE_BASE| proposed herein.% See other implementations and source codes:%   <http://www.mathworks.com/matlabcentral/fileexchange/12939>,%   <http://www.mathworks.com/matlabcentral/fileexchange/13221>.%%% Credit% <mailto:grazzja@lanl.gov J.Grazzini> (ISR-2/LANL)%%% See also % Ressembles: % <bresenhamline.html |BRESENHAMLINE|>, % <sampledisk_base.html |SAMPLEDISK_BASE|>, % <sampletriangle_base.html |SAMPLETRIANGLE_BASE|>, % <drawleakcircle_base.html |DRAWLEAKCIRCLE_BASE|>.% Requires:% <matlab:webpub(whichpath('DIFF')) |DIFF|>,% <matlab:webpub(whichpath('SUM')) |SUM|>,% <matlab:webpub(whichpath('CUMSUM')) |CUMSUM|>,% <matlab:webpub(whichpath('MESHGRID')) |MESHGRID|>.%% Function implementation%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction [x, y, pts] = bresenhamline_base(x1, y1, x2, y2)%%% transform the inputs in column vector and round the coordinatesx1 = round(x1(:)); x2 = round(x2(:));y1 = round(y1(:)); y2 = round(y2(:));%%% main computation starts heres = size(x1(:),1);dx = abs(x2-x1);dy = abs(y2-y1);steep = dy>dx; % vector column% invert positionst = dx(steep); dx(steep) = dy(steep); dy(steep) = t;  % length of the longest linemdx = max(dx)+1;odx = ones(1,mdx);%%% transform steepsteep = steep(:, odx);   % repmat(steep, [1 mdx]);I = dy==0;DX = dx(:, odx);   % repmat(dx, [1 mdx]);DY = dy(:, odx);   % repmat(dy, [1 mdx]);A = floor(DX/2);B = DX .* DY;Z = cumsum(DY,2) - DY; Z = -Z;Q = A+Z;Q(Q < A-B) = 0;Q = [zeros(s,1) diff(mod(Q,DX),1,2)>=0];Q = cumsum(Q,2);Q(I,:) = 0;Z = meshgrid(0:mdx-1,1:s); % cumsum(ones(s, mdx),2)-1 Y1 = y1(:, odx);   % repmat(y1, [1 mdx]);X1 = x1(:, odx);   % repmat(x1, [1 mdx]);Y2 = y2(:, odx);   % repmat(y2, [1 mdx]);X2 = x2(:, odx);   % repmat(x2, [1 mdx]);%%% vectorized version of Bresnham algorith (see A.Wetzler's code)A = X1<=X2;  pts = ~A;x  = X1  + Z;x(pts) = x(pts) - 2*Z(pts);x(steep & A) = X1(steep & A) + Q(steep & A);x(steep & pts) = X1(steep & pts) - Q(steep & pts); B = (A & x>X2) | (pts & x<X2);A = Y1<=Y2;  pts = ~A;y = Y1  + Z;y(pts) = y(pts) - 2*Z(pts);steep = ~steep;y(steep & A) = Y1(steep & A) + Q(steep & A);y(steep & pts) = Y1(steep & pts) - Q(steep & pts);A = (A & y>Y2) | (pts & y<Y2);%%% trimA = A | B;  % additional output: but can be easily handled also without (using isnan)pts = ~A; % pts = ~isnan(x);x(A) = NaN;y(A) = NaN;end % end of bresenhamline_base%% Original%%% |BRESENHAM| - Original implementation by A.Wetzler: single entries only% (coordinates of two vertices to be linked by a line).%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction [x y] = bresenham(x1,y1,x2,y2)                                %#ok%Matlab optmized version of Bresenham line algorithm. No loops.%Format:%               [x y]=bresenham(x1,y1,x2,y2)%%Input:%               (x1,y1): Start position%               (x2,y2): End position%%Output:%               x y: the line coordinates from (x1,y1) to (x2,y2)%%Usage example:%               [x y]=bresenham(1,1, 10,-5);%               plot(x,y,'or');x1=round(x1); x2=round(x2);y1=round(y1); y2=round(y2);dx = abs(x2-x1);dy = abs(y2-y1);steep = dy>dx;   % steep=abs(dy)>abs(dx)if steep, t=dx; dx=dy; dy=t;  end% the main algorithm goes here.if dy==0     q=zeros(dx+1,1);else    q=[0;diff(mod((floor(dx/2):-dy:-dy*dx+floor(dx/2))',dx))>=0];end% and ends here.if steep    if y1<=y2,  y = (y1:y2)';     else        y = (y1:-1:y2)';   end    if x1<=x2,  x = x1+cumsum(q);     else        x = x1-cumsum(q);  endelse    if x1<=x2,  x = (x1:x2)';      else        x = (x1:-1:x2)';   end    if y1<=y2,  y = y1+cumsum(q);    else        y = y1-cumsum(q);  endendend##### SOURCE END #####--></body></html>