<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html>  <head>    <meta content="text/html; charset=utf-8" http-equiv="content-type">    <!--This HTML was auto-generated from MATLAB code.To make changes, update the MATLAB code and republish this document.      -->    <title>SAMPLEDISK_BASE - Base function for SAMPLEDISK.</title>    <meta name="generator" content="MATLAB 7.14">    <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">    <meta name="DC.date" content="2012-05-31">    <meta name="DC.source" content="sampledisk_base.m">    <style type="text/css">html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}html { min-height:100%; margin-bottom:1px; }html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }html body td { vertical-align:top; text-align:left; }h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }a { color:#005fce; text-decoration:none; }a:hover { color:#005fce; text-decoration:underline; }a:visited { color:#004aa0; text-decoration:none; }p { padding:0px; margin:0px 0px 20px; }img { padding:0px; margin:0px 0px 20px; border:none; }p img, pre img, tt img, li img { margin-bottom:0px; } ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }ul li { padding:0px; margin:0px 0px 7px 0px; }ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }ul li ol li { list-style:decimal; }ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }ol li ol li { list-style-type:lower-alpha; }ol li ul { padding-top:7px; }ol li ul li { list-style:square; }.content { font-size:1.2em; line-height:140%; padding: 20px; }pre, tt, code { font-size:12px; }pre { margin:0px 0px 20px; }pre.error { color:red; }pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }span.keyword { color:#0000FF }span.comment { color:#228B22 }span.string { color:#A020F0 }span.untermstring { color:#B20000 }span.syscmd { color:#B28C00 }.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }.footer p { margin:0px; }  </style>  </head>  <body>    <div class="content">      <h1>SAMPLEDISK_BASE - Base function for SAMPLEDISK.</h1>      <!--introduction--><!--/introduction-->      <h2>Contents</h2>      <div>        <ul>          <li><a href="#1">Syntax</a></li>          <li><a href="#2">Reference</a></li>          <li><a href="#4">See also</a></li>          <li><a href="#5">Function implementation</a></li>          <li><a href="#6">Subfunctions</a></li>        </ul>      </div>      <h2>Syntax<a name="1"></a></h2>      <pre>  [x, y, w] = SAMPLEDISK_BASE(center, radius, method, samp);</pre>      <h2>Reference<a name="2"></a></h2>      <p>See discussions at <a href="http://mathworld.wolfram.com/DiskPointPicking.html">http://mathworld.wolfram.com/DiskPointPicking.html</a>        <a href="http://mathworld.wolfram.com/GausssCircleProblem.html">http://mathworld.wolfram.com/GausssCircleProblem.html</a></p>      <h2>See also<a name="4"></a></h2>      <p>Ressembles: <a href="sampledisk.html"><tt>SAMPLEDISK</tt></a>, <a href="sampletriangle_base.html"><tt>SAMPLETRIANGLE_BASE</tt></a>,        <a href="bresenhamline_base.html"><tt>BRESENHAMLINE_BASE</tt></a>.        Requires: <a href="matlab:webpub%28whichpath%28%27POL2CART%27%29%29"><tt>POL2CART</tt></a>,        <a href="matlab:webpub%28whichpath%28%27CUMSUM%27%29%29"><tt>CUMSUM</tt></a>,        <a href="matlab:webpub%28whichpath%28%27STREL%27%29%29"><tt>STREL</tt></a>,        <a href="matlab:webpub%28whichpath%28%27MESHGRID%27%29%29"><tt>MESHGRID</tt></a>.</p>      <h2>Function implementation<a name="5"></a></h2>      <pre class="codeinput"><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> [x, y, w] = sampledisk_base(center, radius, method, samp)<span class="comment">%error(nargchk(4, 5, nargin, 'struct'));</span><span class="comment">%error(nargoutchk(2, 3, nargout, 'struct'));</span><span class="comment">% set default</span><span class="keyword">if</span> nargout&lt;=3,  w = [];  <span class="keyword">end</span><span class="keyword">if</span> any(strcmpi(method,{<span class="string">'full'</span>,<spanclass="string">'grid'</span>,<spanclass="string">'scale'</span>}))    radius = round(radius);<span class="keyword">end</span><span class="comment">% % avoid duplicate entries calculations</span><span class="comment">% [radius, dum, J] = unique(radius);</span><span class="comment">% the sampling also depends on the variable samp, so unvalid approach</span><span class="keyword">switch</span> method    <span class="keyword">case</span> <span class="string">'full'</span> <span class="comment">% sampling of all discrete points inside the circle</span>        [x, y, nsamp] = fullsampledisk(radius);    <span class="keyword">case</span> <span class="string">'scale'</span> <spanclass="comment">% sampling of all discrete points inside the circle with</span>        <span class="comment">% multiscale weight assignation</span>        [x, y, nsamp, w] = radisampledisk(radius);    <span class="keyword">case</span> <span class="string">'grid'</span> <span class="comment">% regular grid sampling</span>        <span class="keyword">if</span> samp&gt;=0 &amp;&amp; samp&lt;1,            n = floor(samp .* gausscircle(radius));            samp = floor(4*radius/sqrt(n)); <span class="comment">% our approximation</span>        <span class="keyword">end</span>        [x,y,nsamp] = gridsampledisk(radius, abs(samp));    <span class="keyword">case</span> <span class="string">'radi'</span> <span class="comment">% radial sampling</span>        [x,y,nsamp] = radisampledisk1(radius, samp);    <span class="keyword">case</span> <span class="string">'rand'</span> <span class="comment">% random sampling</span>        <span class="keyword">if</span> all(samp(:)&gt;=0) &amp;&amp; all(samp(:)&lt;1),            samp = floor(samp .* gausscircle(radius));        <span class="keyword">end</span>        [x,y,nsamp] = randsampledisk(radius, abs(samp));    <span class="keyword">otherwise</span>        error(<span class="string">'sampledisk_base:methoderror'</span>,[<span class="string">'unknown method '</span> method]);<span class="keyword">end</span><span class="comment">% % reset original ordering and set possible duplicate entries</span><span class="comment">% x = x(J,:);</span><span class="comment">% y = y(J,:);</span><span class="comment">% for i=1:length(x)</span><span class="comment">% x{i} = round(x{i} + repmat(center(i,1),[length(x{i}) 1]));</span><span class="comment">% y{i} = round(y{i} + repmat(center(i,2),[length(y{i}) 1]));</span><span class="comment">% end</span>x = round(x + repmat(center(:,1),[1 nsamp])); <span class="comment">% rounds toward 0</span>y = round(y + repmat(center(:,2),[1 nsamp]));<span class="comment">% note that NaN number will still be NaN number after this operation.</span><span class="keyword">if</span> isempty(w),  w = ones(size(x));  <span class="keyword">end</span><span class="keyword">end</span> <span class="comment">% end of sampledisk_base</span></pre>      <h2>Subfunctions<a name="6"></a></h2>      <p><tt>RADISAMPLEDISK</tt> - Sample on radial circles inside the disk</p>      <pre class="codeinput"><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> [x, y, nsamp, w] = radisampledisk(radius)ndisks = length(radius);<span class="comment">% note: technique suggested in [DPG10]</span><span class="comment">% generate an adaptive grid around each center pixel so that samples are</span><span class="comment">% selected with increasing sparsity as the distance to the center (within</span><span class="comment">% the limit given by the radius) increases.</span><span class="comment">% reduce the grid resolution by two and compute on the coarser grid; repeat</span><span class="comment">% this process and continuously coarsen the grid; values from the fine grid</span><span class="comment">% are reused for the coarser grid so that there is no computational overhead.</span><span class="comment">% sampling rule</span><span class="comment">% the rate of sampling is fixed to 1/2 over all radial circles except for</span><span class="comment">% the first two circles with radius 1 and 2samp = repmat(0.5,[ndisks,1]);</span><span class="comment">%         irad:       1       2       3      4     5     6</span><span class="comment">%       radius:       1       2       4      8     16    32</span><span class="comment">%                  2^(i-1)    ...</span><span class="comment">%      no. pts:       4       8       8      16    32    64</span><span class="comment">%                  2^(i+1)  2^(i+1)  2^i    ...</span><span class="comment">% tot. no. pts:       5       13      21     37    69    133</span><span class="comment">%      (csamp)</span>rad = floor(log2(radius))+1;rad(isinf(rad)) = 0;R = max(radius);Rad = floor(log2(R));<span class="comment">% list of considered radii</span>rsamp = 2.^(0:Rad);<span class="comment">% number of sample for each radius</span>nrsamp = 2*rsamp;<span class="keyword">if</span> Rad&gt;=1,  nrsamp(1) = 4;    <span class="keyword">if</span> Rad&gt;=2, nrsamp(2) = 8;  <span class="keyword">end</span><span class="keyword">end</span><span class="comment">% cumulated number of samples</span>ncsamp = [0 cumsum(nrsamp,2)]+1;<span class="comment">% maximal number of samples</span>nsamp = ncsamp(end); <span class="comment">% 1 stand for the added center of the circle</span>x = NaN(ndisks,nsamp);y = NaN(ndisks,nsamp);<span class="keyword">if</span> nargout==4,    w = zeros(ndisks,nsamp);<span class="keyword">else</span>    w = [];<span class="keyword">end</span><span class="keyword">for</span> i=1:Rad+1 <span class="comment">% Rad+1 is length(rsamp)</span>    s = rand() * pi; <span class="comment">% random pixel chosen chosen as the first sampling point</span>    theta = linspace(s,2*pi+s,nrsamp(i));    rho = rsamp(i) * ones(1,nrsamp(i));    [a,b] = pol2cart(theta, rho);    I = rad&gt;=i+1;    nI = sum(I);    x(I,ncsamp(i)+1:ncsamp(i+1)) = repmat(a,[nI,1]);    y(I,ncsamp(i)+1:ncsamp(i+1)) = repmat(b,[nI,1]);    <span class="keyword">if</span> ~isempty(w) <span class="comment">% multiscale weight factor</span>        w(I,ncsamp(i)+1:ncsamp(i+1)) = repmat(1/rsamp(i), [nI, nrsamp(i)]);    <span class="keyword">end</span><span class="keyword">end</span><span class="comment">% replace the first entry by the offset of the central point</span>x(:,1) = 0;y(:,1) = 0;<span class="keyword">if</span> ~isempty(w),  w(:,1) = 1;  <span class="keyword">end</span><span class="keyword">end</span></pre>      <p><tt>FULLSAMPLEDISK</tt> - Sample all lattice points inside a disk.</p>      <pre class="codeinput"><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> [x, y, nsamp, w] = fullsampledisk(radius)<span class="comment">% initialize</span>ndisks = length(radius);R = max(radius);nsamp = sum(sum(getnhood(strel(<span class="string">'disk'</span>,R,0))));<span class="keyword">if</span> R&gt;30    warning(<span class="string">'sampledisk:warningdata'</span>, <span class="keyword">...</span>        [<span class="string">'large circles (max detected R='</span> num2str(R) <spanclass="string">') imply too many '</span> <spanclass="keyword">...</span>        <span class="string">'samples with method ''full'' and risk ''Out of Memory'' usage'</span>]);<span class="keyword">end</span>x = NaN(nsamp,ndisks);y = NaN(nsamp,ndisks);<span class="comment">% x = cell(ndisks,1);</span><span class="comment">% y = cell(ndisks,1);</span><span class="keyword">if</span> nargout==4,    w = zeros(nsamp,ndisks);    <span class="comment">% r = cell(ndisks,1);</span><span class="keyword">else</span>    w = [];<span class="keyword">end</span><span class="keyword">for</span> i=1:ndisks    offsets = getneighbors(strel(<span class="string">'disk'</span>,radius(i),0));    <span class="comment">% when N equals 0, no approximation is used, and the structuring element</span>    <span class="comment">% members consist of all pixels whose centers are no greater than R away</span>    <span class="comment">% from the origin.</span>    k = size(offsets,1);    x(1:k,i) = offsets(:,1);    y(1:k,i) = offsets(:,2);    <span class="comment">% x{i} = offsets(:,1);</span>    <span class="comment">% y{i} = offsets(:,2);</span>    <span class="keyword">if</span> ~isempty(w) <span class="comment">% multiscale weight factor</span>        <span class="comment">% w(1:k,i) = 1 ./ floor(sqrt(offsets(:,1).^2 + offsets(:,2).^2));</span>        w(1:k,i) = 1 ./ sqrt(offsets(:,1).^2 + offsets(:,2).^2);        <span class="comment">% w{i} = 1 ./ sqrt(offsets(:,1).^2 + offsets(:,2).^2);</span>        <span class="comment">% w{i}(isinf(r{i})) = 1;</span>    <span class="keyword">end</span><span class="keyword">end</span>x = x';y = y';<span class="keyword">if</span> ~isempty(w),  w(isinf(w)) = 1; w = w';   <span class="keyword">end</span><span class="keyword">end</span></pre>      <p><tt>RANDSAMPLEDISK</tt> - Randomly sample inside a disk.</p>      <p>See <a href="http://mathworld.wolfram.com/DiskPointPicking.html">http://mathworld.wolfram.com/DiskPointPicking.html</a></p>      <pre class="codeinput"><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> [x, y, nsamp] = randsampledisk(radius, samp)ndisks = length(radius);nsamp = max(samp);<span class="keyword">if</span> numel(samp)==1    <span class="comment">% probability density function (PDF) pdf_r(r)=(2/R^2) * r;</span>    <span class="comment">% and cumulative PDF is F_r = (2/R^2)* (r^2)/2</span>    <span class="comment">% inverse cumulative PDF is r = R*sqrt(F_r)</span>    <span class="comment">% so we generate the correct r as</span>    rho = repmat(radius, [1 nsamp]) .* sqrt(rand(ndisks,nsamp));    theta = 2 * pi * rand(ndisks,nsamp);    <span class="comment">% convert to cartesian</span>    [x,y] = pol2cart(theta, rho);<span class="keyword">else</span>   <span class="comment">%if all(0&lt;=samp &amp;&amp; samp&lt;1)</span>    x = NaN(ndisks,nsamp);    y = NaN(ndisks,nsamp);    <span class="keyword">for</span> i=1:ndisks        rho = repmat(radius(i), [1 samp(i)]) .* sqrt(rand(1,samp(i)));        theta = 2 * pi * rand(1,samp(i));        [x(i,1:samp(i)), y(i,1:samp(i))] = pol2cart(theta, rho);    <span class="keyword">end</span><span class="keyword">end</span><span class="comment">% at that point, samples are not unique</span><span class="keyword">end</span></pre>      <p><tt>GRIDSAMPLEDISK</tt> - Sample inside the disk on a regular lattice        grid.</p>      <pre class="codeinput"><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> [x, y, nsamp] = gridsampledisk(radius, samp)<span class="comment">% initialize</span>ndisks = length(radius);<span class="keyword">if</span> numel(samp)==1   <span class="comment">% samp may be a scalar or a vector</span>    samp = repmat(samp,[ndisks,1]);<span class="keyword">end</span>[~,i] = max(radius./ samp);se = getnhood(strel(<span class="string">'disk'</span>,radius(i),0));<span class="comment">% we look at the worse case</span>nsamp = sum(sum(se(1:samp(i):end,1:samp(i):end)))+1;<span class="comment">% note that we add 1 for the case the center of the circle (which is</span><span class="comment">% automatically added to sampling grid) is not already included in the</span><span class="comment">% grid</span>x = NaN(nsamp,ndisks);y = NaN(nsamp,ndisks);<span class="keyword">for</span> i=1:ndisks    se = getnhood(strel(<span class="string">'disk'</span>,radius(i),0));    grid = false(size(se));    grid(1:samp(i):end,1:samp(i):end) = true;    grid = grid &amp; se;    grid(radius(i)+1,radius(i)+1) = true;    [m,n] = find(grid);    k = size(m,1);    x(1:k,i) = m - (radius(i)+1);    y(1:k,i) = n - (radius(i)+1);<span class="keyword">end</span>x = x';y = y';<span class="keyword">end</span></pre>      <p><tt>RADISAMPLEDISK1</tt> - Sample on a single circle (at a distance        radius from the disk's center)</p>      <pre class="codeinput"><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> [x, y, nsamp] = radisampledisk1(radius, samp)ndisks = length(radius);<span class="keyword">if</span> numel(samp)==1   <span class="comment">% samp may be a scalar or a vector</span>    samp = repmat(samp,[ndisks,1]);<span class="keyword">end</span>r = radius;I = samp&gt;=1;r(I) = min(radius(I), ceil(samp(I)/8));I = samp&lt;-1;r(I) = ceil(radius(I)/2);samp(I) = abs(samp(I));I = samp&gt;0 &amp; samp&lt;=1;r(I) = ceil(samp(I) .* radius(I));samp(I) = 8 * r(I);samp((I) &amp; radius==1) = 4;nsamp = max(samp);theta = NaN(ndisks,nsamp);<span class="keyword">for</span> i=1:ndisks    theta(i,1:samp(i)) = linspace(0,2*pi,samp(i));<span class="keyword">end</span>rho = r(:) * ones(1,nsamp);[x,y] = pol2cart(theta, rho);<span class="comment">% replace the last (repeated) entry by the offset of the central point</span>x(:,end) = 0;y(:,end) = 0;<span class="keyword">end</span></pre>      <p><tt>GAUSSCIRCLE</tt> - Count the number of lattice points <tt>N</tt>        inside the boundaries of a circle with radius <tt>r</tt></p>      <p><img src="sampledisk_base_eq93409.png" alt="$$ N(r) = 1 + 4 \lfloor r \rfloor +          4 \sum_{i=1}^{\lfloor r\rfloor}  \lfloor \sqrt{r^2 - i^2} \rfloor  $$"></p>      <p>From <a href="http://mathworld.wolfram.com/GausssCircleProblem.html">http://mathworld.wolfram.com/GausssCircleProblem.html</a></p>      <p>See also <a href="http://mathworld.wolfram.com/CircleLatticePoints.html">http://mathworld.wolfram.com/CircleLatticePoints.html</a></p>      <pre class="codeinput"><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> N = gausscircle(r)nr = size(r,1);fr = floor(r);frmax = max(fr);R = repmat(r,[1 frmax]);FR = meshgrid(1:frmax,1:nr);FR = cumsum(floor(sqrt(R.^2 - FR.^2)),2);N = 1 + 4*fr + 4*FR((fr-1)*nr+(1:nr)');<span class="keyword">end</span></pre></div>    <!--##### SOURCE BEGIN #####%% SAMPLEDISK_BASE - Base function for SAMPLEDISK.%%% Syntax%    [x, y, w] = SAMPLEDISK_BASE(center, radius, method, samp);%%% Reference% See discussions at     http://mathworld.wolfram.com/DiskPointPicking.html%                     http://mathworld.wolfram.com/GausssCircleProblem.html   %%% Credit% <mailto:grazzja@lanl.gov J.Grazzini> (ISR-2/LANL)%%%% See also % Ressembles: % <sampledisk.html |SAMPLEDISK|>, % <sampletriangle_base.html |SAMPLETRIANGLE_BASE|>, % <bresenhamline_base.html |BRESENHAMLINE_BASE|>.% Requires:% <matlab:webpub(whichpath('POL2CART')) |POL2CART|>,% <matlab:webpub(whichpath('CUMSUM')) |CUMSUM|>,% <matlab:webpub(whichpath('STREL')) |STREL|>,% <matlab:webpub(whichpath('MESHGRID')) |MESHGRID|>.%% Function implementation%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction [x, y, w] = sampledisk_base(center, radius, method, samp)%error(nargchk(4, 5, nargin, 'struct'));%error(nargoutchk(2, 3, nargout, 'struct'));% set defaultif nargout<=3,  w = [];  endif any(strcmpi(method,{'full','grid','scale'}))    radius = round(radius);end% % avoid duplicate entries calculations% [radius, dum, J] = unique(radius);% the sampling also depends on the variable samp, so unvalid approachswitch method    case 'full' % sampling of all discrete points inside the circle        [x, y, nsamp] = fullsampledisk(radius);    case 'scale' % sampling of all discrete points inside the circle with        % multiscale weight assignation        [x, y, nsamp, w] = radisampledisk(radius);            case 'grid' % regular grid sampling        if samp>=0 && samp<1,            n = floor(samp .* gausscircle(radius));            samp = floor(4*radius/sqrt(n)); % our approximation        end        [x,y,nsamp] = gridsampledisk(radius, abs(samp));            case 'radi' % radial sampling        [x,y,nsamp] = radisampledisk1(radius, samp);            case 'rand' % random sampling        if all(samp(:)>=0) && all(samp(:)<1),            samp = floor(samp .* gausscircle(radius));        end        [x,y,nsamp] = randsampledisk(radius, abs(samp));            otherwise        error('sampledisk_base:methoderror',['unknown method ' method]);        end% % reset original ordering and set possible duplicate entries% x = x(J,:);% y = y(J,:);% for i=1:length(x)% x{i} = round(x{i} + repmat(center(i,1),[length(x{i}) 1]));% y{i} = round(y{i} + repmat(center(i,2),[length(y{i}) 1]));% endx = round(x + repmat(center(:,1),[1 nsamp])); % rounds toward 0y = round(y + repmat(center(:,2),[1 nsamp]));% note that NaN number will still be NaN number after this operation.if isempty(w),  w = ones(size(x));  endend % end of sampledisk_base%% Subfunctions%%% |RADISAMPLEDISK| - Sample on radial circles inside the disk%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction [x, y, nsamp, w] = radisampledisk(radius)ndisks = length(radius);% note: technique suggested in [DPG10]% generate an adaptive grid around each center pixel so that samples are  % selected with increasing sparsity as the distance to the center (within% the limit given by the radius) increases.% reduce the grid resolution by two and compute on the coarser grid; repeat% this process and continuously coarsen the grid; values from the fine grid% are reused for the coarser grid so that there is no computational overhead.% sampling rule% the rate of sampling is fixed to 1/2 over all radial circles except for% the first two circles with radius 1 and 2samp = repmat(0.5,[ndisks,1]);%         irad:       1       2       3      4     5     6%       radius:       1       2       4      8     16    32   %                  2^(i-1)    ...         %      no. pts:       4       8       8      16    32    64%                  2^(i+1)  2^(i+1)  2^i    ...% tot. no. pts:       5       13      21     37    69    133%      (csamp)rad = floor(log2(radius))+1;rad(isinf(rad)) = 0;R = max(radius);Rad = floor(log2(R));% list of considered radiirsamp = 2.^(0:Rad);% number of sample for each radiusnrsamp = 2*rsamp;if Rad>=1,  nrsamp(1) = 4;    if Rad>=2, nrsamp(2) = 8;  endend% cumulated number of samplesncsamp = [0 cumsum(nrsamp,2)]+1;% maximal number of samplesnsamp = ncsamp(end); % 1 stand for the added center of the circlex = NaN(ndisks,nsamp);y = NaN(ndisks,nsamp);if nargout==4,    w = zeros(ndisks,nsamp);else    w = [];endfor i=1:Rad+1 % Rad+1 is length(rsamp)    s = rand() * pi; % random pixel chosen chosen as the first sampling point    theta = linspace(s,2*pi+s,nrsamp(i));    rho = rsamp(i) * ones(1,nrsamp(i));    [a,b] = pol2cart(theta, rho);    I = rad>=i+1;    nI = sum(I);    x(I,ncsamp(i)+1:ncsamp(i+1)) = repmat(a,[nI,1]);    y(I,ncsamp(i)+1:ncsamp(i+1)) = repmat(b,[nI,1]);    if ~isempty(w) % multiscale weight factor        w(I,ncsamp(i)+1:ncsamp(i+1)) = repmat(1/rsamp(i), [nI, nrsamp(i)]);    endend% replace the first entry by the offset of the central pointx(:,1) = 0;y(:,1) = 0;if ~isempty(w),  w(:,1) = 1;  endend%%% |FULLSAMPLEDISK| - Sample all lattice points inside a disk.%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction [x, y, nsamp, w] = fullsampledisk(radius)% initializendisks = length(radius);R = max(radius);nsamp = sum(sum(getnhood(strel('disk',R,0))));if R>30    warning('sampledisk:warningdata', ...        ['large circles (max detected R=' num2str(R) ') imply too many ' ...        'samples with method ''full'' and risk ''Out of Memory'' usage']);endx = NaN(nsamp,ndisks);y = NaN(nsamp,ndisks);% x = cell(ndisks,1);% y = cell(ndisks,1);if nargout==4,    w = zeros(nsamp,ndisks);    % r = cell(ndisks,1);else    w = [];endfor i=1:ndisks    offsets = getneighbors(strel('disk',radius(i),0));    % when N equals 0, no approximation is used, and the structuring element    % members consist of all pixels whose centers are no greater than R away    % from the origin.    k = size(offsets,1);    x(1:k,i) = offsets(:,1);    y(1:k,i) = offsets(:,2);    % x{i} = offsets(:,1);    % y{i} = offsets(:,2);    if ~isempty(w) % multiscale weight factor        % w(1:k,i) = 1 ./ floor(sqrt(offsets(:,1).^2 + offsets(:,2).^2));        w(1:k,i) = 1 ./ sqrt(offsets(:,1).^2 + offsets(:,2).^2);        % w{i} = 1 ./ sqrt(offsets(:,1).^2 + offsets(:,2).^2);        % w{i}(isinf(r{i})) = 1;    endendx = x';y = y';if ~isempty(w),  w(isinf(w)) = 1; w = w';   endend%%% |RANDSAMPLEDISK| - Randomly sample inside a disk.%% See http://mathworld.wolfram.com/DiskPointPicking.html%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction [x, y, nsamp] = randsampledisk(radius, samp)ndisks = length(radius);nsamp = max(samp);if numel(samp)==1    % probability density function (PDF) pdf_r(r)=(2/R^2) * r;    % and cumulative PDF is F_r = (2/R^2)* (r^2)/2    % inverse cumulative PDF is r = R*sqrt(F_r)    % so we generate the correct r as    rho = repmat(radius, [1 nsamp]) .* sqrt(rand(ndisks,nsamp));    theta = 2 * pi * rand(ndisks,nsamp);        % convert to cartesian    [x,y] = pol2cart(theta, rho);    else   %if all(0<=samp && samp<1)    x = NaN(ndisks,nsamp);    y = NaN(ndisks,nsamp);    for i=1:ndisks         rho = repmat(radius(i), [1 samp(i)]) .* sqrt(rand(1,samp(i)));        theta = 2 * pi * rand(1,samp(i));        [x(i,1:samp(i)), y(i,1:samp(i))] = pol2cart(theta, rho);    endend% at that point, samples are not uniqueend%%% |GRIDSAMPLEDISK| - Sample inside the disk on a regular lattice grid.%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction [x, y, nsamp] = gridsampledisk(radius, samp)% initializendisks = length(radius);if numel(samp)==1   % samp may be a scalar or a vector    samp = repmat(samp,[ndisks,1]);end[~,i] = max(radius./ samp); se = getnhood(strel('disk',radius(i),0));% we look at the worse casensamp = sum(sum(se(1:samp(i):end,1:samp(i):end)))+1;% note that we add 1 for the case the center of the circle (which is% automatically added to sampling grid) is not already included in the% gridx = NaN(nsamp,ndisks);y = NaN(nsamp,ndisks);for i=1:ndisks    se = getnhood(strel('disk',radius(i),0));    grid = false(size(se));    grid(1:samp(i):end,1:samp(i):end) = true;    grid = grid & se;    grid(radius(i)+1,radius(i)+1) = true;    [m,n] = find(grid);    k = size(m,1);    x(1:k,i) = m - (radius(i)+1);    y(1:k,i) = n - (radius(i)+1);endx = x';y = y';end%%% |RADISAMPLEDISK1| - Sample on a single circle (at a distance radius from the% disk's center)%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction [x, y, nsamp] = radisampledisk1(radius, samp)                 ndisks = length(radius);if numel(samp)==1   % samp may be a scalar or a vector    samp = repmat(samp,[ndisks,1]);endr = radius;I = samp>=1;r(I) = min(radius(I), ceil(samp(I)/8));I = samp<-1;r(I) = ceil(radius(I)/2);samp(I) = abs(samp(I));I = samp>0 & samp<=1;r(I) = ceil(samp(I) .* radius(I));samp(I) = 8 * r(I);samp((I) & radius==1) = 4;nsamp = max(samp);theta = NaN(ndisks,nsamp);for i=1:ndisks    theta(i,1:samp(i)) = linspace(0,2*pi,samp(i));endrho = r(:) * ones(1,nsamp);[x,y] = pol2cart(theta, rho);% replace the last (repeated) entry by the offset of the central pointx(:,end) = 0;y(:,end) = 0;end%%% |GAUSSCIRCLE| - Count the number of lattice points |N| inside the boundaries% of a circle with radius |r| %% $$ N(r) = 1 + 4 \lfloor r \rfloor + %           4 \sum_{i=1}^{\lfloor r\rfloor}  \lfloor \sqrt{r^2 - i^2} \rfloor  $$%% From http://mathworld.wolfram.com/GausssCircleProblem.html%% See also http://mathworld.wolfram.com/CircleLatticePoints.html%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction N = gausscircle(r)nr = size(r,1);fr = floor(r);frmax = max(fr);R = repmat(r,[1 frmax]);FR = meshgrid(1:frmax,1:nr);FR = cumsum(floor(sqrt(R.^2 - FR.^2)),2);N = 1 + 4*fr + 4*FR((fr-1)*nr+(1:nr)');end##### SOURCE END #####--></body></html>