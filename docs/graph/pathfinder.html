<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html>  <head>    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">    <!--This HTML was auto-generated from MATLAB code.To make changes, update the MATLAB code and republish this document.      -->    <title>PATHFINDER - Find paths in a graph.</title>    <meta name="generator" content="MATLAB 7.14">    <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">    <meta name="DC.date" content="2012-05-31">    <meta name="DC.source" content="pathfinder.m">    <style type="text/css">html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}html { min-height:100%; margin-bottom:1px; }html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }html body td { vertical-align:top; text-align:left; }h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }a { color:#005fce; text-decoration:none; }a:hover { color:#005fce; text-decoration:underline; }a:visited { color:#004aa0; text-decoration:none; }p { padding:0px; margin:0px 0px 20px; }img { padding:0px; margin:0px 0px 20px; border:none; }p img, pre img, tt img, li img { margin-bottom:0px; } ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }ul li { padding:0px; margin:0px 0px 7px 0px; }ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }ul li ol li { list-style:decimal; }ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }ol li ol li { list-style-type:lower-alpha; }ol li ul { padding-top:7px; }ol li ul li { list-style:square; }.content { font-size:1.2em; line-height:140%; padding: 20px; }pre, tt, code { font-size:12px; }pre { margin:0px 0px 20px; }pre.error { color:red; }pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }span.keyword { color:#0000FF }span.comment { color:#228B22 }span.string { color:#A020F0 }span.untermstring { color:#B20000 }span.syscmd { color:#B28C00 }.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }.footer p { margin:0px; }  </style>  </head>  <body>    <div class="content">      <h1>PATHFINDER - Find paths in a graph.</h1>      <!--introduction--><!--/introduction-->      <h2>Contents</h2>      <div>        <ul>          <li><a href="#1">Description</a></li>          <li><a href="#2">Syntax</a></li>          <li><a href="#3">Inputs</a></li>          <li><a href="#4">Output</a></li>          <li><a href="#5">Acknowledgment</a></li>          <li><a href="#6">Remark</a></li>          <li><a href="#8">See also</a></li>          <li><a href="#9">Function implementation</a></li>          <li><a href="#10">Original</a></li>        </ul>      </div>      <h2>Description<a name="1"></a></h2>      <p>Find all possible (Hamiltonian) paths from a source node (vertex) to        sink node.</p>      <h2>Syntax<a name="2"></a></h2>      <pre>    path = PATHFINDER(G, start_pts, end_pts);</pre>      <h2>Inputs<a name="3"></a></h2>      <p><b><tt>G</tt></b> : matrix of size <tt>(m,m)</tt> representing the        adjacency matrix of a graph (undirected unweighted), where <tt>m</tt>        is the order (number of the nodes) of the graph, or matrix of size <tt>(n,2)</tt>        representing the <tt>n</tt> edges between pairs of nodes.</p>      <p><b><tt>start_pts, end_pts</tt></b> : source and sink nodes resp.,        referring to the indices of those nodes in the graph.</p>      <h2>Output<a name="4"></a></h2>      <p><b><tt>path</tt></b> : matrix of size <tt>(N,m)</tt>, where <tt>N</tt>        is the total number of found paths and <tt>m</tt> is the order of the        graph representing all possible (Hamiltonian, ie. passing once and once        only through every node) paths from the source node to the sink node;        paths which are not going through all nodes (ie. shorter than <tt>m</tt>)        are completed with 0.</p>      <h2>Acknowledgment<a name="5"></a></h2>      <p>Entirely derived from the implementation of A.Chakraborty; see original        source code <tt>PATHFINDER</tt> included in this file, otherwise        available at:</p>      <pre class="language-matlab">http://www.mathworks.com/matlabcentral/fileexchange/27438</pre>      <p>This version is optimized for Matlab through vector manipulation        (reduced number of loops).</p>      <h2>Remark<a name="6"></a></h2>      <p><b>!!! This program cannot handle graphs with more than <tt>m=25</tt>          nodes!!!</b></p>      <h2>See also<a name="8"></a></h2>      <p>Ressembles: <a href="scomponents.html"><tt>SCOMPONENTS</tt></a>, <a href="dfs.html"><tt>DFS</tt></a>,        <a href="matlab:webpub%28whichpath%28%27GAIMC/SCOMPONENTS%27%29%29"><tt>GAIMC/SCOMPONENTS</tt></a>,        <a href="matlab:webpub%28whichpath%28%27GAIMC/DFS%27%29%29"><tt>GAIMC/DFS</tt></a>.        Requires: <a href="matlab:webpub%28whichpath%28%27FF2N%27%29%29"><tt>FF2N</tt></a>,        <a href="matlab:webpub%28whichpath%28%27PERMS%27%29%29"><tt>PERMS</tt></a>.</p>      <h2>Function implementation<a name="9"></a></h2>      <pre class="codeinput"><span class="keyword">function</span> path = pathfinder(G, start_pts, end_pts)error(nargchk(1, 3, nargin, <span class="string">'struct'</span>));error(nargoutchk(0, 1, nargout, <span class="string">'struct'</span>));<span class="keyword">if</span> islogical(G) || issparse(G)    <span class="comment">% if ~islogical(G),  G = logical(G);   end</span>    u = size(G,1); <span class="comment">% number of nodes</span><span class="keyword">elseif</span> size(G,2)==2    <span class="comment">% in the case where a list of edges was passed instead of the graph itself</span>    u = max(G(:));    <span class="comment">% formation of the Adjacency Matrix</span>    G = sparse(G(:,1), G(:,2), ones(size(G,1),1), u, u);    G = G | G';<span class="keyword">else</span>    error(<span class="string">'pathfinder:inputerror'</span>,<span class="keyword">...</span>        <span class="string">'input parameter must be adjacency matrix or edges list'</span>)<span class="keyword">end</span>NodeVector = 1:u; <span class="comment">% vector containing all the nodes serially</span><span class="comment">% rearrangement</span>NodeArray = [start_pts, <span class="keyword">...</span>    NodeVector(~ismember(NodeVector,[start_pts,end_pts])), <span class="keyword">...</span>    end_pts];TTRaw = ff2n(u);<span class="comment">% reminder: FF2N is the two-level full-factorial design; X = FF2N(N) creates</span><span class="comment">% a two-level full-factorial design X, where N is the number of columns of X</span><span class="comment">% and 2^N is the number of rows.</span><span class="comment">% FF2N can not handle N&gt;25</span>T = TTRaw(~(TTRaw(:,1) | TTRaw(:,u)),:);v=length(T(:,1));Paths = repmat(NodeArray,[length(T(:,1)) 1]) .* (~T);path = zeros(1,u);<span class="keyword">for</span> i=1:v    Temp = Paths(i,2:end-1);    Temp = Temp(logical(Temp));    <span class="comment">%      if ~isempty(Temp)</span>    <span class="comment">% Permutation = perms(Temp(2:end-1));</span>    <span class="comment">% Prow = size(Permutation,1);</span>    Prow = factorial(length(Temp));    <span class="comment">% note: in the case Temp is empty, Prow=1 and the calculation below are</span>    <span class="comment">% still valid</span>    Permutation = [repmat(start_pts,[Prow 1]), <span class="keyword">...</span>        perms(Temp), <span class="keyword">...</span>        repmat(end_pts,[Prow 1])];    <span class="comment">% reminder: PERMS creates all possible permutations; PERMS(1:N) or PERMS(V)</span>    <span class="comment">% where V is a vector of length N, creates a matrix with N! rows and N</span>    <span class="comment">% columns containing all possible permutations of the N elements.</span>    Pcol = size(Permutation,2);    <span class="comment">% PathTemp = zeros(Prow,u);</span>    b = Permutation(:,2:end);    a = sum(G(Permutation(:,1:end-1)+(b-1)*u),2)==Pcol-1;    <span class="comment">% note: here it is important that the graph is unweighted, ie. only 1</span>    <span class="comment">% or 0 are possible edge weights (edge exists or not).</span>    l = sum(a);    <span class="comment">% PathTemp(a,1:Pcol) = [repmat(start_pts,[l 1]) b(a,:)];</span>    path(end+1:end+l,1:Pcol) = [repmat(start_pts,[l 1]) b(a,:)];    <span class="comment">%             path = [path;pathTemp];</span>    <span class="comment">%     else</span>    <span class="comment">%         if (A(start_pts,end_pts)==1)</span>    <span class="comment">%             path(end+1,1:2) = [start_pts end_pts];</span>    <span class="comment">%         end</span>    <span class="comment">%     end</span><span class="keyword">end</span>path(~any(path,2),:) = [];<span class="keyword">end</span> <span class="comment">% end of pathfinder</span></pre>      <h2>Original<a name="10"></a></h2>      <p><tt>PATHFINDER</tt> - Original path finder function to find all the        possible paths from a source node to sink node by A.Chakraborty.</p>      <pre class="codeinput"><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> PathFinal = PathFinder(B,StartNode,EndNode)                     <spanclass="comment">%#ok</span><span class="comment">% PathFinder(B,StartNode,EndNode)</span><span class="comment">% B is an Nx2 matrix, where N is the number of Edges in the Graph. The data</span><span class="comment">% is in the form of 'From Node' to 'To Node'.</span><span class="comment">% StartNode is the source node, and EndNode is the Sink Node.</span><span class="comment">% Limitation: Works good till N=20. Also as N increses, execution time also</span><span class="comment">% increases.</span><span class="comment">% By- Abhishek Chakraborty</span><span class="comment">% Dt: 01-May-2010</span><span class="comment">% For suggestions and queries, please contact the author at:</span><span class="comment">% abhishek.piku@gmail.com</span>fb=B(:,1);tb=B(:,2);u=max(max(fb),max(tb)); <span class="comment">% 'u' contains the number of nodes in the graph</span><span class="comment">% Formation of Adjacency Matrix</span>A=zeros(u,u); <span class="comment">% Initialization of Adjacency Matrix</span>n=length(fb); <span class="comment">%'n' is the number of edges</span><span class="keyword">for</span> i=1:nx=fb(i,1);y=tb(i,1);A(x,y)=A(x,y)+1;A(y,x)=A(y,x)+1;<span class="keyword">end</span><span class="comment">% Final Adjacency Matrix</span>NodeVector=1:u; <span class="comment">% 'NodeVector' is a vector containing all the nodes serially</span>SourceSinkVector=[StartNode,EndNode]                                   <span class="comment">%#ok</span><span class="comment">% Rearrangement</span>NodeArray=NodeVector;NodeArray(StartNode)=0;NodeArray(EndNode)=0;NodeVector=find(NodeArray);NodeArray=NodeArray(NodeVector);                                       <span class="comment">%#ok</span>NodeArray=[StartNode,NodeArray,EndNode];T=[];TTRaw=ff2n(u);x=2^u;<span class="keyword">for</span> i=1:x<span class="keyword">if</span> (TTRaw(i,1)==0 &amp;&amp; TTRaw(i,u)==0)T=[T;TTRaw(i,:)];                                                      <span class="comment">%#ok</span><span class="keyword">end</span><span class="keyword">end</span>v=length(T(:,1));Paths=[];<span class="keyword">for</span> i=1:vNodes=[];<span class="keyword">for</span> j=1:u<span class="keyword">if</span> (T(i,j)==0)Nodes=[Nodes,NodeArray(j)];                                            <span class="comment">%#ok</span><span class="keyword">else</span>Nodes=[Nodes,0];                                                       <span class="comment">%#ok</span><span class="keyword">end</span><span class="keyword">end</span>Paths=[Paths;Nodes];                                                   <span class="comment">%#ok</span><span class="keyword">end</span><span class="comment">%Paths;</span><span class="comment">%n=length(Paths(:,1));</span>PathFinalTemp=[];<span class="keyword">for</span> i=1:vTemp=Paths(i,:);NodeArray=find(Temp); <span class="comment">%eliminating zeros</span>Temp=Temp(NodeArray);                                                  <span class="comment">%#ok</span>Temp(1)=[]; <span class="comment">%eliminating start node</span>Temp(end)=[]; <span class="comment">%eliminating end node</span>Permutation=perms(Temp);<span class="keyword">if</span>(isempty(Permutation)==0)Prow=length(Permutation(:,1));SN=[];EN=[];<span class="keyword">for</span> c=1:ProwSN=[SN;StartNode];                                                     <span class="comment">%#ok</span>EN=[EN;EndNode];                                                       <span class="comment">%#ok</span><span class="keyword">end</span>Permutation=[SN,Permutation,EN];                                       <span class="comment">%#ok</span>Pcol=length(Permutation(1,:));<span class="keyword">for</span> k=1:ProwPathTemp=zeros(1,u);PathTemp(1)=StartNode;<span class="keyword">for</span> l=1:Pcol-1a=Permutation(k,l);b=Permutation(k,(l+1));<span class="keyword">if</span> (A(a,b)==1)PathTemp(l+1)=PathTemp(l+1)+b;<span class="keyword">else</span>PathTemp=zeros(1,u);<span class="keyword">break</span><span class="keyword">end</span><span class="keyword">end</span>PathFinalTemp=[PathFinalTemp;PathTemp];                                <span class="comment">%#ok</span><span class="keyword">end</span><span class="keyword">elseif</span> (isempty(Permutation)==1)PathTemp=zeros(1,u);<span class="keyword">if</span> (A(StartNode,EndNode)==1)PathTemp(1)=StartNode;PathTemp(2)=EndNode;<span class="keyword">else</span>PathTemp=zeros(1,u);                                                   <span class="comment">%#ok</span><span class="keyword">break</span><span class="keyword">end</span>PathFinalTemp=[PathFinalTemp;PathTemp];                                <span class="comment">%#ok</span><span class="keyword">end</span><span class="keyword">end</span>PathFinal=PathFinalTemp;PathFinal(~any(PathFinalTemp,2),:)=[];<span class="keyword">end</span></pre></div>    <!--##### SOURCE BEGIN #####%% PATHFINDER - Find paths in a graph.%%% Description% Find all possible (Hamiltonian) paths from a source node (vertex) to sink% node.%%% Syntax%      path = PATHFINDER(G, start_pts, end_pts);%%% Inputs% *|G|* : matrix of size |(m,m)| representing the  adjacency matrix of a graph %     (undirected unweighted), where |m| is the order (number of the nodes) of %     the graph, or matrix of size |(n,2)| representing the |n| edges between%     pairs of nodes.%% *|start_pts, end_pts|* : source and sink nodes resp., referring to the indices%     of those nodes in the graph.%%% Output% *|path|* : matrix of size |(N,m)|, where |N| is the total number of found%     paths and |m| is the order of the graph representing all possible %     (Hamiltonian, ie. passing once and once only through every node) paths%     from the source node to the sink node; paths which are not going through%     all nodes (ie. shorter than |m|) are completed with 0.%%% Acknowledgment% Entirely derived from the implementation of A.Chakraborty; see original% source code |PATHFINDER| included in this file, otherwise available at:%%   http://www.mathworks.com/matlabcentral/fileexchange/27438%% This version is optimized for Matlab through vector manipulation (reduced% number of loops).%%% Remark% *!!! This program cannot handle graphs with more than |m=25| nodes!!!*%%% Credit% <mailto:grazzja@lanl.gov J.Grazzini> (ISR-2/LANL)%%% See also% Ressembles:% <scomponents.html |SCOMPONENTS|>,% <dfs.html |DFS|>,% <matlab:webpub(whichpath('GAIMC/SCOMPONENTS')) |GAIMC/SCOMPONENTS|>,% <matlab:webpub(whichpath('GAIMC/DFS')) |GAIMC/DFS|>.% Requires:% <matlab:webpub(whichpath('FF2N')) |FF2N|>,% <matlab:webpub(whichpath('PERMS')) |PERMS|>.%% Function implementationfunction path = pathfinder(G, start_pts, end_pts)error(nargchk(1, 3, nargin, 'struct'));error(nargoutchk(0, 1, nargout, 'struct'));if islogical(G) || issparse(G)    % if ~islogical(G),  G = logical(G);   end    u = size(G,1); % number of nodes    elseif size(G,2)==2    % in the case where a list of edges was passed instead of the graph itself    u = max(G(:));    % formation of the Adjacency Matrix    G = sparse(G(:,1), G(:,2), ones(size(G,1),1), u, u);    G = G | G';else    error('pathfinder:inputerror',...        'input parameter must be adjacency matrix or edges list')endNodeVector = 1:u; % vector containing all the nodes serially% rearrangementNodeArray = [start_pts, ...    NodeVector(~ismember(NodeVector,[start_pts,end_pts])), ...    end_pts];TTRaw = ff2n(u);% reminder: FF2N is the two-level full-factorial design; X = FF2N(N) creates% a two-level full-factorial design X, where N is the number of columns of X % and 2^N is the number of rows.% FF2N can not handle N>25T = TTRaw(~(TTRaw(:,1) | TTRaw(:,u)),:);v=length(T(:,1));Paths = repmat(NodeArray,[length(T(:,1)) 1]) .* (~T);path = zeros(1,u);for i=1:v    Temp = Paths(i,2:end-1);    Temp = Temp(logical(Temp));    %      if ~isempty(Temp)    % Permutation = perms(Temp(2:end-1));    % Prow = size(Permutation,1);    Prow = factorial(length(Temp));    % note: in the case Temp is empty, Prow=1 and the calculation below are    % still valid    Permutation = [repmat(start_pts,[Prow 1]), ...        perms(Temp), ...        repmat(end_pts,[Prow 1])];    % reminder: PERMS creates all possible permutations; PERMS(1:N) or PERMS(V)    % where V is a vector of length N, creates a matrix with N! rows and N    % columns containing all possible permutations of the N elements.    Pcol = size(Permutation,2);    % PathTemp = zeros(Prow,u);    b = Permutation(:,2:end);    a = sum(G(Permutation(:,1:end-1)+(b-1)*u),2)==Pcol-1;    % note: here it is important that the graph is unweighted, ie. only 1    % or 0 are possible edge weights (edge exists or not).    l = sum(a);    % PathTemp(a,1:Pcol) = [repmat(start_pts,[l 1]) b(a,:)];    path(end+1:end+l,1:Pcol) = [repmat(start_pts,[l 1]) b(a,:)];    %             path = [path;pathTemp];    %     else    %         if (A(start_pts,end_pts)==1)    %             path(end+1,1:2) = [start_pts end_pts];    %         end    %     endendpath(~any(path,2),:) = [];end % end of pathfinder%% Original%%% |PATHFINDER| - Original path finder function to find all the possible paths% from a source node to sink node by A.Chakraborty.%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction PathFinal = PathFinder(B,StartNode,EndNode)                     %#ok% PathFinder(B,StartNode,EndNode)% B is an Nx2 matrix, where N is the number of Edges in the Graph. The data% is in the form of 'From Node' to 'To Node'.% StartNode is the source node, and EndNode is the Sink Node.% Limitation: Works good till N=20. Also as N increses, execution time also % increases.% By- Abhishek Chakraborty% Dt: 01-May-2010% For suggestions and queries, please contact the author at:% abhishek.piku@gmail.comfb=B(:,1);tb=B(:,2);u=max(max(fb),max(tb)); % 'u' contains the number of nodes in the graph% Formation of Adjacency MatrixA=zeros(u,u); % Initialization of Adjacency Matrixn=length(fb); %'n' is the number of edgesfor i=1:nx=fb(i,1);y=tb(i,1);A(x,y)=A(x,y)+1;A(y,x)=A(y,x)+1;end% Final Adjacency MatrixNodeVector=1:u; % 'NodeVector' is a vector containing all the nodes seriallySourceSinkVector=[StartNode,EndNode]                                   %#ok% RearrangementNodeArray=NodeVector;NodeArray(StartNode)=0;NodeArray(EndNode)=0;NodeVector=find(NodeArray);NodeArray=NodeArray(NodeVector);                                       %#okNodeArray=[StartNode,NodeArray,EndNode];T=[];TTRaw=ff2n(u);x=2^u;for i=1:xif (TTRaw(i,1)==0 && TTRaw(i,u)==0)T=[T;TTRaw(i,:)];                                                      %#ok endendv=length(T(:,1));Paths=[];for i=1:vNodes=[];for j=1:uif (T(i,j)==0)Nodes=[Nodes,NodeArray(j)];                                            %#ok elseNodes=[Nodes,0];                                                       %#okendendPaths=[Paths;Nodes];                                                   %#okend%Paths;%n=length(Paths(:,1));PathFinalTemp=[];for i=1:vTemp=Paths(i,:);NodeArray=find(Temp); %eliminating zerosTemp=Temp(NodeArray);                                                  %#okTemp(1)=[]; %eliminating start nodeTemp(end)=[]; %eliminating end nodePermutation=perms(Temp);if(isempty(Permutation)==0)Prow=length(Permutation(:,1));SN=[];EN=[];for c=1:ProwSN=[SN;StartNode];                                                     %#okEN=[EN;EndNode];                                                       %#okendPermutation=[SN,Permutation,EN];                                       %#okPcol=length(Permutation(1,:));for k=1:ProwPathTemp=zeros(1,u);PathTemp(1)=StartNode;for l=1:Pcol-1a=Permutation(k,l);b=Permutation(k,(l+1));if (A(a,b)==1)PathTemp(l+1)=PathTemp(l+1)+b;elsePathTemp=zeros(1,u);breakendendPathFinalTemp=[PathFinalTemp;PathTemp];                                %#okendelseif (isempty(Permutation)==1)PathTemp=zeros(1,u);if (A(StartNode,EndNode)==1)PathTemp(1)=StartNode;PathTemp(2)=EndNode;elsePathTemp=zeros(1,u);                                                   %#okbreakendPathFinalTemp=[PathFinalTemp;PathTemp];                                %#okendendPathFinal=PathFinalTemp;PathFinal(~any(PathFinalTemp,2),:)=[];end##### SOURCE END #####--></body></html>