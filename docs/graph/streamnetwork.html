<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html>  <head>    <meta content="text/html; charset=utf-8" http-equiv="content-type">    <!--This HTML was auto-generated from MATLAB code.To make changes, update the MATLAB code and republish this document.      -->    <title>STREAMNETWORK</title>    <meta name="generator" content="MATLAB 7.14">    <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">    <meta name="DC.date" content="2012-05-31">    <meta name="DC.source" content="streamnetwork.m">    <style type="text/css">html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}html { min-height:100%; margin-bottom:1px; }html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }html body td { vertical-align:top; text-align:left; }h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }a { color:#005fce; text-decoration:none; }a:hover { color:#005fce; text-decoration:underline; }a:visited { color:#004aa0; text-decoration:none; }p { padding:0px; margin:0px 0px 20px; }img { padding:0px; margin:0px 0px 20px; border:none; }p img, pre img, tt img, li img { margin-bottom:0px; } ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }ul li { padding:0px; margin:0px 0px 7px 0px; }ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }ul li ol li { list-style:decimal; }ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }ol li ol li { list-style-type:lower-alpha; }ol li ul { padding-top:7px; }ol li ul li { list-style:square; }.content { font-size:1.2em; line-height:140%; padding: 20px; }pre, tt, code { font-size:12px; }pre { margin:0px 0px 20px; }pre.error { color:red; }pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }span.keyword { color:#0000FF }span.comment { color:#228B22 }span.string { color:#A020F0 }span.untermstring { color:#B20000 }span.syscmd { color:#B28C00 }.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }.footer p { margin:0px; }  </style>  </head>  <body>    <div class="content">      <h1>STREAMNETWORK</h1>      <!--introduction--><!--/introduction-->      <h2>Contents</h2>      <div>        <ul>          <li><a href="#1">Algorithm:</a></li>          <li><a href="#2">Syntax</a></li>          <li><a href="#3">Inputs</a></li>          <li><a href="#4">Outputs</a></li>          <li><a href="#5">References</a></li>          <li><a href="#7">See also</a></li>          <li><a href="#8">Function implementation</a></li>          <li><a href="#16">Subfunctions</a></li>        </ul>      </div>      <h2>Algorithm:<a name="1"></a></h2>      <div>        <ol>          <li>extract the list of endpoints (leaves) of the existing network            (seen as a graph).</li>          <li>calculate the all-pair distances Dmap between endpoints over the            cost map (ie. through paths defined everywhere else on the grid)</li>          <li>calculate the all-pair distances Dnet between endpoints over the            network (ie only over paths defined inside the network)</li>          <li><tt>WHILE</tt> a new path (not already part of the network) is            added <tt>DO</tt></li>        </ol>      </div>      <div>        <ul>          <li>create a path linking the two closest disconnected endpoints            (through the network), ie. the couple of endpoints verifying: <img              src="streamnetwork_eq96407.png"              alt="$$          (x,y) = \min_{x,y} \{ D_{\mbox{map}}(x,y) \,\mid\, D_{\mbox{net}}(x,y)=\infty \}          $$"></li>          <li>for each endpoint x, create a path linking it to all other            connected endpoints y (through the network) that are closer in the            map than in the network, ie.: <img src="streamnetwork_eq00592.png"              alt="$$          (x,y) = \{D_{\mbox{map}}(x,y)&lt;D_{\mbox{net}}(x,y) \,\&amp;\, D_{\mbox{net}}(x,y)&lt;\infty \}          $$"></li>          <li>recompute the all-pair distances Dnet between endpoints over the            network like in step 3</li>        </ul>      </div>      <h2>Syntax<a name="2"></a></h2>      <pre>    fnet = STREAMNETWORK(net, cost, vertex, iscontinuous);</pre>      <h2>Inputs<a name="3"></a></h2>      <p><b><tt>net</tt></b> : already connected network; it can be either:</p>      <div>        <ul>          <li>a sparse (adjacency) matrix representing the connection between            the vertices of the network inside the image domain; in that case,            an additional variable providing with the coordinates of the            vertices inside the image domain should be passed (see variable            vertex below); if so, net should also be symmetric.</li>          <li>a logical matrix (binary mask, eg. a skeleton) providing the            different points of the network inside the image domain.</li>        </ul>      </div>      <p><b><tt>cost</tt></b> : matrix defining a dense cost function over the        image domain.</p>      <p><b><tt>vertex</tt></b> : in the case the network is passed as a sparse        matrix, vertex provides with the coordinates of the vertices inside the        image domain.</p>      <h2>Outputs<a name="4"></a></h2>      <p><b><tt>mapnet</tt></b> : a map of the completed network.</p>      <p><b><tt>net, vertex</tt></b> : the completed network described by its        vertices and edges.</p>      <h2>References<a name="5"></a></h2>      <p>[SG07] P. Soille and J. Grazzini: "Extraction of river networks from        satellite images by combining morphology and hydrology", Proc. CAIP,        LNCS, vol. 4673, pp. 636-644, 2007.</p>      <p>[GDS10] J. Grazzini, S. Dillard and P. Soille: "A new generic method        for semi-automatic extraction of rivers and road networks in low- and        mid- resolution satellite images", SPIE Remote Sensing, vol. 7830, 2010.</p>      <h2>See also<a name="7"></a></h2>      <p>Called: <a href="map2graph_base.html"><tt>MAP2GRAPH_BASE</tt></a>, <a          href="bresenhamline.html"><tt>BRESENHAMLINE</tt></a>,        <a href="dijkadvanced.html"><tt>DIJKADVANCED</tt></a>, <a href="DIJSKTRA_BASE.html"><tt>DIJSKTRA_BASE</tt></a>.</p>      <h2>Function implementation<a name="8"></a></h2>      <pre class="codeinput"><span class="keyword">function</span> [mapnet, net, vertex] = streamnetwork(net, cost, vertex)</pre>      <p>checking the parameters</p>      <pre class="codeinput"><span class="keyword">if</span> ~(isparse(net) || islogical(net))    error(<span class="string">'streamnetwork:inputerror'</span>, <span class="keyword">...</span>        <span class="string">'sparse or logical matrix required to represent the network'</span>);<span class="keyword">elseif</span> ~isnumeric(cost)    error(<span class="string">'streamnetwork:inputerror'</span>, <span class="keyword">...</span>        <span class="string">'numeric matrix required to represent the cost function'</span>);<span class="keyword">elseif</span> islogical(net) &amp;&amp; ~isequal(size(net),size(cost))    error(<span class="string">'streamnetwork:inputerror'</span>, <span class="keyword">...</span>        <span class="string">'incompatible sizes for the input matrices'</span>);<span class="keyword">end</span><span class="keyword">if</span> issparse(net)    <span class="keyword">if</span> size(net,1)~=size(net,2)        error(<span class="string">'streamnetwork:inputerror'</span>, <span class="keyword">...</span>            <span class="string">'symmetric square sparse matrix required'</span>);    <span class="keyword">elseif</span> ~isnumeric(vertex) || size(vertex,2)~=2        error(<span class="string">'streamnetwork:inputerror'</span>, <span class="keyword">...</span>            <span class="string">'incompatible input graph and vertex matrices'</span>);    <span class="keyword">elseif</span> max(vertex,1)&gt;size(cost,1) || max(vertex,2)&gt;size(cost,2)        error(<span class="string">'streamnetwork:inputerror'</span>, <span class="keyword">...</span>            <span class="string">'incompatible vertex coordinates and image domain'</span>);    <span class="keyword">else</span>        [i,j] = find(net,1,<span class="string">'last'</span>);        <span class="keyword">if</span> i&gt;size(vertex,1) || j&gt;size(vertex,1)            error(<span class="string">'streamnetwork:inputerror'</span>, <spanclass="string">'incompatible vertices indices'</span>);        <span class="keyword">end</span>    <span class="keyword">end</span><span class="keyword">end</span></pre>      <p>setting parameters</p>      <pre class="codeinput"><span class="keyword">if</span> issparse(net) &amp;&amp;  ~isequal(net,net')    <span class="comment">% symmetric-ize</span>    net = net | net';<span class="keyword">end</span>nvert = size(vertex,1);<span class="comment">% from now on, we will work with a graph only... however the output is a map</span><span class="keyword">if</span> islogical(net) <span class="comment">% we have a map here</span>    mapnet = net;    <span class="comment">% in the case the input network is given as a (logical) map, we convert</span>    <span class="comment">% it into a weighted graph linking the branchpoints and endpoints of</span>    <span class="comment">% the network (recude=true)</span>    [net,vertex] = map2graph_base(net, cost, 8, true);<span class="keyword">elseif</span> issparse(net)    <span class="comment">% in the case the input network is already a graph, we need to define</span>    <span class="comment">% the weights of the different edges of the graph</span>    [mapnet, edges, wedges] = graph2map_base(net, vertex, cost);    <span class="comment">% net is now a weighted graph; vertex unchanged</span>    <span class="comment">% rebuild the graph</span>    net = sparse(edges(:,1), edges(:,2), wedges, nvert, nvert);    net = net | net';<span class="keyword">end</span></pre>      <p>extract the endpoints (leaves) of the network : step (i)</p>      <pre class="codeinput">endPts = netleave(net,vertex);<span class="comment">% note: we could have called this function earlier, prior to the previous</span><span class="comment">% conversions, and, for instance, use morphological tools (when available)</span><span class="comment">% for extracting the leaves of the network when given as a map (see function</span><span class="comment">% NETLEAVE below)</span>nend = size(endPts,1);</pre>      <p>compute once for all the all-pair distances Dmap between endpoints over        the cost map (ie. through paths defined everywhere on the grid): step        (ii)</p>      <pre class="codeinput">W = cost;<span class="comment">% W = 1 / cost; % geodesics will follow regions where W is large</span>order =0; <span class="comment">% use order 0 approach</span>m_seed = <span class="string">'allpairs'</span>;m_path = true; <span class="comment">% compute the paths</span>[Dmap, Pmap] = fmm_base(W, m_seed, m_path, endPts, endPts, order);<span class="comment">% keep only the elements above the main diagonal of Dmap (on the diagonal</span><span class="comment">% is the distance between a point and itself)</span>Dmap = triu(Dmap,+1);<span class="comment">% we reduce the complexity as Dmap is symmetric</span>anychange = true;</pre>      <p>DO WHILE a new path (not already part of the network) is added</p>      <pre class="codeinput"><span class="keyword">while</span> anychange    anychange = false;    <span class="comment">% (re)calculate the all-pair distances Dnet between endpoints over the</span>    <span class="comment">% network (ie only over paths defined inside the network): step (iii)</span>    <span class="comment">% and (vi)</span>    Dnet = graphdistance(net, cost, vertex, endPts);    <span class="comment">% keep only the elements above the main diagonal of Dnet</span>    Dnet = triu(Dnet,+1);    <span class="comment">% create a path linking the two closest disconnected endpoints (through</span>    <span class="comment">% the network), ie. the couple of endpoints verifying: step (iv)</span>    <span class="comment">%          (x,y) = argmin_{x,y} {Dmap(x,y) | Dnet(x,y)=Inf}</span>    [dum, x] = min(Dmap(Dnet == Inf));    <span class="keyword">if</span> ~isempty(dum)        [x,y] = ind2sub(x,nend);        <span class="comment">% update the graph</span>        net(x,y) = Dmap(x,y);        net(y,x) = net(x,y); <span class="comment">% symmetric-ize</span>        <span class="comment">% update the map</span>        mapnet(Pmap(x,y)) = true;        anychange = true;    <span class="keyword">end</span>    <span class="comment">% for each endpoint x, create a path linking it to all other connected</span>    <span class="comment">% endpoints y (through the network) that are closer in the map than in</span>    <span class="comment">% the network: step (v)</span>    <span class="comment">%          (x,y) = {Dmap(x,y)&lt;Dnet(x,y) &amp; Dnet(x,y)&lt;Inf}</span>    [x,y] = find(Dmap&lt;Dnet);    <span class="keyword">if</span> ~isempty(dum)        net(x,y) = Dmap(x,y);   net(y,x) = net(x,y);        mapnet(Pmap(x,y)) = true;        anychange = true;    <span class="keyword">end</span><span class="keyword">end</span> <span class="comment">% end of streamnetwork</span></pre>      <pre class="codeinput"><span class="keyword">end</span></pre>      <h2>Subfunctions<a name="16"></a></h2>      <pre class="codeinput"><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> endPts = netleave(net, vertex)<span class="keyword">if</span> islogical(net) &amp;&amp; ~isempty(ver(<span class="string">'images'</span>))    <span class="comment">% endPts are found as the endpoints of the (supposedly thinned) network</span>    <span class="comment">% mask</span>    endPts = bwmorph(net,<span class="string">'endpoints'</span>);    <span class="comment">% branchPts = bwmorph(net,'branchpoints');</span>    [i,j] = find(endPts);    endPts = [i,j];  <span class="comment">% x-y coordinate of the endpoint vertices</span><span class="keyword">else</span>    <span class="comment">% endPts are those points connected to only one another vertex in the</span>    <span class="comment">% graph</span>    isEndPts = sum(net,2)==1; <span class="comment">% indices of the endpoint vertices</span>    endPts = vertex(isEndPts,:);<span class="keyword">end</span><span class="keyword">end</span><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> dist = graphdistance(graph, vertex, endPts)<span class="comment">% find all the vertices of the graph</span>[i,j] = find(graph);edges = unique(sort([i,j],2),<span class="string">'rows'</span>);startvert = vertex(edges(:,1),:);endvert = vertex(edges(:,2),:);V = [startvert; endvert]; <span class="comment">% dummy variable</span>E3 = [ivert wedge];dist = dijkadvanced(V, E3, endPts, endPts);<span class="comment">% [dists,paths] = dijkstra_base(cost, startvert, endvert, 'sing1' );</span><span class="keyword">end</span><span class="comment">% %--------------------------------------------------------------------------</span><span class="comment">% function [Z1,Z2] = closestzone(D, Q)</span><span class="comment">%</span><span class="comment">% sadd = saddlefront_base(D, Q);</span><span class="comment">%</span><span class="comment">% map = false(size(D));</span><span class="comment">% map(sadd(1,:)+size(D,2)*(sadd(2,:)-1)) = true;</span><span class="comment">%</span><span class="comment">% [ic,icd] = ixneighbours(true(size(D)), map, 8);</span><span class="comment">% % get rid of those neighbours which are not set to true in the map (ie,</span><span class="comment">% % they don't belong to the set of saddle points)</span><span class="comment">% ic(~map(icd)) = [];</span><span class="comment">% icd(~map(icd)) = [];</span><span class="comment">%</span><span class="comment">% V = [Q(ic) Q(icd) D(ic)+D(icd)];</span><span class="comment">% V(V(:,1) == V(:,2),:) = [];</span><span class="comment">% V = sortrows(V,3);</span><span class="comment">%</span><span class="comment">% dmin = min(V(:,3));</span><span class="comment">% imin = V(:,3)==dmin;</span><span class="comment">%</span><span class="comment">% Z1 = V(imin,1); Z2 = V(imin,2);</span><span class="comment">%</span><span class="comment">% end</span></pre></div>    <!--##### SOURCE BEGIN #####%% STREAMNETWORK% %% Algorithm:% # extract the list of endpoints (leaves) of the existing network (seen%     as a graph).% # calculate the all-pair distances Dmap between endpoints over the cost%     map (ie. through paths defined everywhere else on the grid)% # calculate the all-pair distances Dnet between endpoints over the%     network (ie only over paths defined inside the network)% # |WHILE| a new path (not already part of the network) is added |DO|%% * create a path linking the two closest disconnected endpoints (through%     the network), ie. the couple of endpoints verifying:%          $$%          (x,y) = \min_{x,y} \{ D_{\mbox{map}}(x,y) \,\mid\, D_{\mbox{net}}(x,y)=\infty \}%          $$% * for each endpoint x, create a path linking it to all other connected%     endpoints y (through the network) that are closer in the map than in%     the network, ie.:%          $$%          (x,y) = \{D_{\mbox{map}}(x,y)<D_{\mbox{net}}(x,y) \,\&\, D_{\mbox{net}}(x,y)<\infty \}%          $$% * recompute the all-pair distances Dnet between endpoints over the%     network like in step 3%%% Syntax%      fnet = STREAMNETWORK(net, cost, vertex, iscontinuous);%  %% Inputs% *|net|* : already connected network; it can be either:%% * a sparse (adjacency) matrix representing the connection between the%         vertices of the network inside the image domain; in that case,%         an additional variable providing with the coordinates of the%         vertices inside the image domain should be passed (see variable%         vertex below); if so, net should also be symmetric.% * a logical matrix (binary mask, eg. a skeleton) providing the different%         points of the network inside the image domain.%% *|cost|* : matrix defining a dense cost function over the image domain.%% *|vertex|* : in the case the network is passed as a sparse matrix, vertex%       provides with the coordinates of the vertices inside the image%       domain.%%% Outputs% *|mapnet|* : a map of the completed network.%% *|net, vertex|* : the completed network described by its vertices and edges.%   %% References% [SG07]  P. Soille and J. Grazzini: "Extraction of river networks from %      satellite images by combining morphology and hydrology", Proc. CAIP,%      LNCS, vol. 4673, pp. 636-644, 2007.%% [GDS10]  J. Grazzini, S. Dillard and P. Soille: "A new generic method for%      semi-automatic extraction of rivers and road networks in low- and mid-%      resolution satellite images", SPIE Remote Sensing, vol. 7830, 2010. %%% Credit% <mailto:grazzja@lanl.gov J.Grazzini> (ISR-2/LANL)%%% See also% Called:% <map2graph_base.html |MAP2GRAPH_BASE|>,% <bresenhamline.html |BRESENHAMLINE|>,% <dijkadvanced.html |DIJKADVANCED|>,% <DIJSKTRA_BASE.html |DIJSKTRA_BASE|>.%% Function implementationfunction [mapnet, net, vertex] = streamnetwork(net, cost, vertex)%% % checking the parametersif ~(isparse(net) || islogical(net))    error('streamnetwork:inputerror', ...        'sparse or logical matrix required to represent the network');elseif ~isnumeric(cost)    error('streamnetwork:inputerror', ...        'numeric matrix required to represent the cost function');elseif islogical(net) && ~isequal(size(net),size(cost))    error('streamnetwork:inputerror', ...        'incompatible sizes for the input matrices');endif issparse(net)    if size(net,1)~=size(net,2)        error('streamnetwork:inputerror', ...            'symmetric square sparse matrix required');    elseif ~isnumeric(vertex) || size(vertex,2)~=2        error('streamnetwork:inputerror', ...            'incompatible input graph and vertex matrices');    elseif max(vertex,1)>size(cost,1) || max(vertex,2)>size(cost,2)        error('streamnetwork:inputerror', ...            'incompatible vertex coordinates and image domain');    else        [i,j] = find(net,1,'last');        if i>size(vertex,1) || j>size(vertex,1)            error('streamnetwork:inputerror', 'incompatible vertices indices');        end    endend%% % setting parametersif issparse(net) &&  ~isequal(net,net')    % symmetric-ize    net = net | net';endnvert = size(vertex,1);% from now on, we will work with a graph only... however the output is a mapif islogical(net) % we have a map here    mapnet = net;    % in the case the input network is given as a (logical) map, we convert    % it into a weighted graph linking the branchpoints and endpoints of    % the network (recude=true)    [net,vertex] = map2graph_base(net, cost, 8, true);    elseif issparse(net)    % in the case the input network is already a graph, we need to define    % the weights of the different edges of the graph    [mapnet, edges, wedges] = graph2map_base(net, vertex, cost);    % net is now a weighted graph; vertex unchanged    % rebuild the graph    net = sparse(edges(:,1), edges(:,2), wedges, nvert, nvert);    net = net | net';end%% % extract the endpoints (leaves) of the network : step (i)endPts = netleave(net,vertex);% note: we could have called this function earlier, prior to the previous% conversions, and, for instance, use morphological tools (when available)% for extracting the leaves of the network when given as a map (see function% NETLEAVE below)nend = size(endPts,1);%% % compute once for all the all-pair distances Dmap between endpoints over % the cost map (ie. through paths defined everywhere on the grid): step (ii)W = cost;% W = 1 / cost; % geodesics will follow regions where W is largeorder =0; % use order 0 approachm_seed = 'allpairs';m_path = true; % compute the paths  [Dmap, Pmap] = fmm_base(W, m_seed, m_path, endPts, endPts, order);% keep only the elements above the main diagonal of Dmap (on the diagonal% is the distance between a point and itself)Dmap = triu(Dmap,+1);  % we reduce the complexity as Dmap is symmetricanychange = true;%% % DO WHILE a new path (not already part of the network) is addedwhile anychange        anychange = false;        % (re)calculate the all-pair distances Dnet between endpoints over the    % network (ie only over paths defined inside the network): step (iii)    % and (vi)    Dnet = graphdistance(net, cost, vertex, endPts);    % keep only the elements above the main diagonal of Dnet    Dnet = triu(Dnet,+1);        % create a path linking the two closest disconnected endpoints (through    % the network), ie. the couple of endpoints verifying: step (iv)    %          (x,y) = argmin_{x,y} {Dmap(x,y) | Dnet(x,y)=Inf}    [dum, x] = min(Dmap(Dnet == Inf));    if ~isempty(dum)        [x,y] = ind2sub(x,nend);        % update the graph        net(x,y) = Dmap(x,y);        net(y,x) = net(x,y); % symmetric-ize        % update the map        mapnet(Pmap(x,y)) = true;        anychange = true;    end        % for each endpoint x, create a path linking it to all other connected    % endpoints y (through the network) that are closer in the map than in    % the network: step (v)    %          (x,y) = {Dmap(x,y)<Dnet(x,y) & Dnet(x,y)<Inf}            [x,y] = find(Dmap<Dnet);    if ~isempty(dum)        net(x,y) = Dmap(x,y);   net(y,x) = net(x,y);         mapnet(Pmap(x,y)) = true;        anychange = true;    end    end % end of streamnetworkend%% Subfunctions%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction endPts = netleave(net, vertex)if islogical(net) && ~isempty(ver('images'))    % endPts are found as the endpoints of the (supposedly thinned) network    % mask    endPts = bwmorph(net,'endpoints');    % branchPts = bwmorph(net,'branchpoints');    [i,j] = find(endPts);     endPts = [i,j];  % x-y coordinate of the endpoint verticeselse    % endPts are those points connected to only one another vertex in the    % graph    isEndPts = sum(net,2)==1; % indices of the endpoint vertices    endPts = vertex(isEndPts,:);endend%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction dist = graphdistance(graph, vertex, endPts)% find all the vertices of the graph [i,j] = find(graph);edges = unique(sort([i,j],2),'rows');startvert = vertex(edges(:,1),:);endvert = vertex(edges(:,2),:);V = [startvert; endvert]; % dummy variableE3 = [ivert wedge];dist = dijkadvanced(V, E3, endPts, endPts);% [dists,paths] = dijkstra_base(cost, startvert, endvert, 'sing1' );end% %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH% function [Z1,Z2] = closestzone(D, Q)% % sadd = saddlefront_base(D, Q);% % map = false(size(D));% map(sadd(1,:)+size(D,2)*(sadd(2,:)-1)) = true;% % [ic,icd] = ixneighbours(true(size(D)), map, 8);% % get rid of those neighbours which are not set to true in the map (ie,% % they don't belong to the set of saddle points)% ic(~map(icd)) = [];% icd(~map(icd)) = [];% % V = [Q(ic) Q(icd) D(ic)+D(icd)];% V(V(:,1) == V(:,2),:) = [];% V = sortrows(V,3);% % dmin = min(V(:,3));% imin = V(:,3)==dmin;% % Z1 = V(imin,1); Z2 = V(imin,2);% % end##### SOURCE END #####--></body></html>