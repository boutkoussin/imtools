<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html>  <head>    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">    <!--This HTML was auto-generated from MATLAB code.To make changes, update the MATLAB code and republish this document.      -->    <title>MAP2GRAPH_BASE - From a map to a weighted graph.</title>    <meta name="generator" content="MATLAB 7.14">    <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">    <meta name="DC.date" content="2012-05-31">    <meta name="DC.source" content="map2graph_base.m">    <style type="text/css">html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}html { min-height:100%; margin-bottom:1px; }html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }html body td { vertical-align:top; text-align:left; }h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }a { color:#005fce; text-decoration:none; }a:hover { color:#005fce; text-decoration:underline; }a:visited { color:#004aa0; text-decoration:none; }p { padding:0px; margin:0px 0px 20px; }img { padding:0px; margin:0px 0px 20px; border:none; }p img, pre img, tt img, li img { margin-bottom:0px; } ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }ul li { padding:0px; margin:0px 0px 7px 0px; }ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }ul li ol li { list-style:decimal; }ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }ol li ol li { list-style-type:lower-alpha; }ol li ul { padding-top:7px; }ol li ul li { list-style:square; }.content { font-size:1.2em; line-height:140%; padding: 20px; }pre, tt, code { font-size:12px; }pre { margin:0px 0px 20px; }pre.error { color:red; }pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }span.keyword { color:#0000FF }span.comment { color:#228B22 }span.string { color:#A020F0 }span.untermstring { color:#B20000 }span.syscmd { color:#B28C00 }.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }.footer p { margin:0px; }  </style>  </head>  <body>    <div class="content">      <h1>MAP2GRAPH_BASE - From a map to a weighted graph.</h1>      <!--introduction--><!--/introduction-->      <h2>Contents</h2>      <div>        <ul>          <li><a href="#1">Description</a></li>          <li><a href="#2">Syntax</a></li>          <li><a href="#3">Inputs, outputs</a></li>          <li><a href="#4">Remark</a></li>          <li><a href="#6">See also</a></li>          <li><a href="#7">Function implementation</a></li>        </ul>      </div>      <h2>Description<a name="1"></a></h2>      <p>Convert a 2D logical map with pixels belonging to a (connected or not)        graph set to true into an (undirected) weighted graph (parameterized by        its adjacency matrix and the coordinates of the set of pixels belonging        to it), where the weight is given by an additional cost map.</p>      <h2>Syntax<a name="2"></a></h2>      <pre>     [graph, vertex] = MAP2GRAPH_BASE(map, weight, conn, reduce);</pre>      <h2>Inputs, outputs<a name="3"></a></h2>      <p>Depending on the boolean variable <tt>reduce</tt>, the output graph        describes the edges between neighbouring pixels belonging to the network        (<tt>vertex</tt> is then the list of all true pixels present in the        map): <tt>reduce=false</tt>, or the edges between the branching and        leave pixels extracted from the network (<tt>vertex</tt> is then the        list of such pixels): <tt>reduce=true</tt> (default).</p>      <h2>Remark<a name="4"></a></h2>      <p>In the case <tt>reduce=false</tt>, the map reconstruction with <tt>GRAPH2MAP_BASE</tt>        from the graph output of <tt>MAP2GRAPH_BASE</tt> is exactly the        original map.</p>      <h2>See also<a name="6"></a></h2>      <p>Ressembles: <a href="graphmap.html"><tt>GRAPHMAP</tt></a>, <a href="graph2map_base.html"><tt>GRAPH2MAP_BASE</tt></a>,        <a href="matlab:webpub%28whichpath%28%27GPLOT%27%29%29"><tt>GPLOT</tt></a>.        Requires: <a href="ixneighbours.html"><tt>IXNEIGHBOURS</tt></a>, <a href="dijkadvanced.html"><tt>DIJKADVANCED</tt></a>,        <a href="matlab:webpub%28whichpath%28%27BWMORPH%27%29%29"><tt>BWMORPH</tt></a>,        <a href="matlab:webpub%28whichpath%28%27SPARSE%27%29%29"><tt>SPARSE</tt></a>.</p>      <h2>Function implementation<a name="7"></a></h2>      <pre class="codeinput"><span class="keyword">function</span> [graph, vertex] = map2graph_base(map, weight, conn, reduce)</pre>      <p>check/set variables</p>      <pre class="codeinput"><span class="keyword">if</span> nargin&lt;4    <span class="keyword">if</span> isempty(ver(<span class="string">'images'</span>)),  reduce = false;    <span class="keyword">else</span>                        reduce = true;  <spanclass="keyword">end</span><span class="keyword">elseif</span> reduce &amp;&amp; isempty(ver(<span class="string">'images'</span>))    warning(<span class="string">'map2graph_base:inputwarning'</span>, <span class="keyword">...</span>        [<span class="string">'toolbox Image Processing required for reduced output - '</span><spanclass="keyword">...</span>        <span class="string">'reduce variale reset to false'</span>]);    reduce = false;<span class="keyword">end</span><span class="comment">% map should be a logical matrix</span>[X,Y] = size(map);</pre>      <p>first search for the connection pixel to pixel</p>      <pre class="codeinput">[ic,icd] = ixneighbours(true(X,Y), map, conn);<span class="comment">% true(X,Y): dummy variable used by IXNEIGHBOURS as map is logical</span></pre>      <p>get rid of those neighbours which are not set to true in the map (ie,        they don't belong to the graph/network)</p>      <pre class="codeinput">ic(~map(icd)) = [];icd(~map(icd)) = [];</pre>      <p>find the edges between neighbour pixels</p>      <pre class="codeinput">edges = unique(sort([ic icd],2),<span class="string">'rows'</span>);</pre>      <p>the weight we assign to an edge between two neighbour pixels is the        mean of the cost function evaluated on these two pixels</p>      <pre class="codeinput">wedges = mean(weight(edges),2);wedges(wedges==0) = NaN;  <span class="comment">% set null weight to NaN values</span></pre>      <p>define the list of points connected by an edge in the map</p>      <pre class="codeinput">[ind, ~, j] = unique(edges);</pre>      <p>change the edges FROM connection between pixels given by their indices        in the map TO connection between pixels given by their indices in the        vertex vector</p>      <pre class="codeinput">edges = reshape(j,size(edges));</pre>      <p>define the vertex vector of coordinates of the vertices in the map</p>      <pre class="codeinput">j = unique(j);nvert = j(end);[i,j] = ind2sub([X, Y], ind(j));vertex = [i,j];</pre>      <p>complete with possibly missed isolated pixels</p>      <pre class="codeinput">iso = bwisolated(map);[isoi, isoj] = find(iso);niso = length(isoi);<span class="keyword">if</span> niso&gt;0    vertex = [vertex; isoi isoj];    wedges = [wedges; zeros(niso,1)];    edges = [edges; repmat((nvert+1:nvert+niso)', [1 2])];    nvert = nvert + niso;<span class="keyword">end</span></pre>      <p>we now have a simpler representation based on vertex indices</p>      <pre class="codeinput">graph = sparse(edges(:,1), edges(:,2), wedges, nvert, nvert);<span class="comment">% note: otherwise we could have written at an earlier stage the</span><span class="comment">% representation as:</span><span class="comment">%    graph = sparse(edges(:,1), edges(:,2), wedges, X*Y, X*Y);</span><span class="comment">% but this is a (X*Y)x(X*Y) sparse matrix as all pixels are represented in</span><span class="comment">% the sparse matrix. Using vertex reduces the size of the full matrix.</span></pre>      <p>now symetric-ize!</p>      <pre class="codeinput">graph = graph | graph';<span class="comment">% note: we could also compute earlier:</span><span class="comment">%    edges = [edges; fliplr(edges)];</span><span class="comment">%    wedges = [wedges; wedges];</span><span class="comment">% to ensure that the resulting graph is symmetric</span></pre>      <p>reduce</p>      <pre class="codeinput"><span class="keyword">if</span> reduce    <span class="comment">% leave points</span>    endPts = bwmorph(map,<span class="string">'endpoints'</span>) &amp; map;    [i,j] = find(endPts);    rvertex = [i, j];    <span class="comment">% branching points</span>    branchPts = bwmorph(map,<span class="string">'branchpoints'</span>) &amp; map;    <span class="comment">% note: in some cases, BWMORPH(.,'BRANCHPOINTS') returns points that do</span>    <span class="comment">% not belong to the network; we avoid this by constraining the set of</span>    <span class="comment">% branching points to a subset of the network (&amp; map)</span>    [i,j] = find(branchPts);    rvertex = [rvertex; i, j];    <span class="comment">% display</span>    <span class="comment">% t = zeros(X,Y);</span>    <span class="comment">% t(sub2ind([X, Y],rvertex(:,1),rvertex(:,2))) = 1;</span>    <span class="comment">% figure, imagesc(t), colormap gray</span>    <span class="comment">% find the indices of the branch- and endpoints in the list of vertices</span>    [~,irvertex] = ismember(rvertex,vertex,<span class="string">'rows'</span>);    <span class="comment">% ISMEMBER returns 1 where the rows of vertex are also in rvertex</span>    nvert = length(irvertex);    <span class="comment">% we call DIJKADVANCED_BASE (faster, handles null weights)</span>    A = graph&gt;0 | isnan(graph);  <span class="comment">% adjacency matrix</span>    graph(isnan(graph)) = 0;     <span class="comment">% null weights are reset to 0</span>    d = dijkadvanced(A, graph, irvertex, irvertex);    <span class="comment">% equivalent to:</span>    <span class="comment">%    d = dijkstra_base(graph,irvertex,irvertex,'sing1');</span>    <span class="comment">% or:</span>    <span class="comment">%    d = [];</span>    <span class="comment">%    for i=1:nvert, d = [d;dijkstra_base(graph,irvertex(i),[],'sing1')];</span>    <span class="comment">%    end</span>    <span class="comment">% see also:</span>    <span class="comment">%    d = dijk(graph,irvertex,irvertex);</span>    [i,j] = find(d&lt;Inf);    graph = sparse(i, j, d(sub2ind([nvert nvert],i,j)), nvert, nvert);    graph = graph | graph';    vertex = rvertex;<span class="keyword">end</span><span class="comment">% display</span><span class="comment">% t = graph2map_base(graph, vertex, [X Y 1 1 1 1]);</span><span class="comment">% figure, imagesc(t), colormap gray</span></pre>      <pre class="codeinput"><span class="keyword">end</span> <span class="comment">% end of map2graph_base</span></pre></div>    <!--##### SOURCE BEGIN #####%% MAP2GRAPH_BASE - From a map to a weighted graph.%%% Description% Convert a 2D logical map with pixels belonging to a (connected or not) graph % set to true into an (undirected) weighted graph (parameterized by its % adjacency matrix and the coordinates of the set of pixels belonging to it), % where the weight is given by an additional cost map. % %% Syntax%       [graph, vertex] = MAP2GRAPH_BASE(map, weight, conn, reduce);%%% Inputs, outputs% Depending on the boolean variable |reduce|, the output graph describes the % edges between neighbouring pixels belonging to the network (|vertex| is then% the list of all true pixels present in the map): |reduce=false|, or the% edges between the branching and leave pixels extracted from the network % (|vertex| is then the list of such pixels): |reduce=true| (default).%%% Remark% In the case |reduce=false|, the map reconstruction with |GRAPH2MAP_BASE| from% the graph output of |MAP2GRAPH_BASE| is exactly the original map.% %% Credit% <mailto:grazzja@lanl.gov J.Grazzini> (ISR-2/LANL)%%% See also% Ressembles:% <graphmap.html |GRAPHMAP|>,% <graph2map_base.html |GRAPH2MAP_BASE|>,% <matlab:webpub(whichpath('GPLOT')) |GPLOT|>.% Requires:% <ixneighbours.html |IXNEIGHBOURS|>,% <dijkadvanced.html |DIJKADVANCED|>,% <matlab:webpub(whichpath('BWMORPH')) |BWMORPH|>,% <matlab:webpub(whichpath('SPARSE')) |SPARSE|>.%% Function implementationfunction [graph, vertex] = map2graph_base(map, weight, conn, reduce)%%% check/set variablesif nargin<4     if isempty(ver('images')),  reduce = false;     else                        reduce = true;  endelseif reduce && isempty(ver('images'))    warning('map2graph_base:inputwarning', ...        ['toolbox Image Processing required for reduced output - '...        'reduce variale reset to false']);    reduce = false;end% map should be a logical matrix[X,Y] = size(map);%%% first search for the connection pixel to pixel[ic,icd] = ixneighbours(true(X,Y), map, conn);% true(X,Y): dummy variable used by IXNEIGHBOURS as map is logical%%% get rid of those neighbours which are not set to true in the map (ie,% they don't belong to the graph/network)ic(~map(icd)) = [];icd(~map(icd)) = [];%%% find the edges between neighbour pixelsedges = unique(sort([ic icd],2),'rows');%%% the weight we assign to an edge between two neighbour pixels is the mean% of the cost function evaluated on these two pixelswedges = mean(weight(edges),2);wedges(wedges==0) = NaN;  % set null weight to NaN values%%% define the list of points connected by an edge in the map [ind, ~, j] = unique(edges);%%% change the edges FROM connection between pixels given by their indices in % the map TO connection between pixels given by their indices in the vertex% vectoredges = reshape(j,size(edges));%%% define the vertex vector of coordinates of the vertices in the mapj = unique(j);nvert = j(end);[i,j] = ind2sub([X, Y], ind(j));vertex = [i,j];%%% complete with possibly missed isolated pixelsiso = bwisolated(map);[isoi, isoj] = find(iso);niso = length(isoi);if niso>0    vertex = [vertex; isoi isoj];    wedges = [wedges; zeros(niso,1)];    edges = [edges; repmat((nvert+1:nvert+niso)', [1 2])];    nvert = nvert + niso;end%%% we now have a simpler representation based on vertex indicesgraph = sparse(edges(:,1), edges(:,2), wedges, nvert, nvert);% note: otherwise we could have written at an earlier stage the% representation as:%    graph = sparse(edges(:,1), edges(:,2), wedges, X*Y, X*Y);% but this is a (X*Y)x(X*Y) sparse matrix as all pixels are represented in% the sparse matrix. Using vertex reduces the size of the full matrix.%%% now symetric-ize!graph = graph | graph';% note: we could also compute earlier:%    edges = [edges; fliplr(edges)];%    wedges = [wedges; wedges];% to ensure that the resulting graph is symmetric%%% reduceif reduce    % leave points    endPts = bwmorph(map,'endpoints') & map;    [i,j] = find(endPts);    rvertex = [i, j];    % branching points    branchPts = bwmorph(map,'branchpoints') & map;    % note: in some cases, BWMORPH(.,'BRANCHPOINTS') returns points that do    % not belong to the network; we avoid this by constraining the set of    % branching points to a subset of the network (& map)    [i,j] = find(branchPts);    rvertex = [rvertex; i, j];        % display    % t = zeros(X,Y);    % t(sub2ind([X, Y],rvertex(:,1),rvertex(:,2))) = 1;    % figure, imagesc(t), colormap gray        % find the indices of the branch- and endpoints in the list of vertices    [~,irvertex] = ismember(rvertex,vertex,'rows');    % ISMEMBER returns 1 where the rows of vertex are also in rvertex    nvert = length(irvertex);        % we call DIJKADVANCED_BASE (faster, handles null weights)    A = graph>0 | isnan(graph);  % adjacency matrix    graph(isnan(graph)) = 0;     % null weights are reset to 0    d = dijkadvanced(A, graph, irvertex, irvertex);    % equivalent to:    %    d = dijkstra_base(graph,irvertex,irvertex,'sing1');    % or:    %    d = [];    %    for i=1:nvert, d = [d;dijkstra_base(graph,irvertex(i),[],'sing1')];    %    end    % see also:    %    d = dijk(graph,irvertex,irvertex);    [i,j] = find(d<Inf);    graph = sparse(i, j, d(sub2ind([nvert nvert],i,j)), nvert, nvert);    graph = graph | graph';        vertex = rvertex;end% display% t = graph2map_base(graph, vertex, [X Y 1 1 1 1]);% figure, imagesc(t), colormap grayend % end of map2graph_base##### SOURCE END #####--></body></html>