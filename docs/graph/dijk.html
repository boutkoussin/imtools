<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html>  <head>    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">    <!--This HTML was auto-generated from MATLAB code.To make changes, update the MATLAB code and republish this document.      -->    <title>DIJK - Matlab implementation of Dijkstra algorithm.</title>    <meta name="generator" content="MATLAB 7.14">    <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">    <meta name="DC.date" content="2012-05-31">    <meta name="DC.source" content="dijk.m">    <style type="text/css">html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}html { min-height:100%; margin-bottom:1px; }html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }html body td { vertical-align:top; text-align:left; }h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }a { color:#005fce; text-decoration:none; }a:hover { color:#005fce; text-decoration:underline; }a:visited { color:#004aa0; text-decoration:none; }p { padding:0px; margin:0px 0px 20px; }img { padding:0px; margin:0px 0px 20px; border:none; }p img, pre img, tt img, li img { margin-bottom:0px; } ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }ul li { padding:0px; margin:0px 0px 7px 0px; }ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }ul li ol li { list-style:decimal; }ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }ol li ol li { list-style-type:lower-alpha; }ol li ul { padding-top:7px; }ol li ul li { list-style:square; }.content { font-size:1.2em; line-height:140%; padding: 20px; }pre, tt, code { font-size:12px; }pre { margin:0px 0px 20px; }pre.error { color:red; }pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }span.keyword { color:#0000FF }span.comment { color:#228B22 }span.string { color:#A020F0 }span.untermstring { color:#B20000 }span.syscmd { color:#B28C00 }.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }.footer p { margin:0px; }  </style>  </head>  <body>    <div class="content">      <h1>DIJK - Matlab implementation of Dijkstra algorithm.</h1>      <!--introduction--><!--/introduction-->      <h2>Contents</h2>      <div>        <ul>          <li><a href="#1">Description</a></li>          <li><a href="#2">Syntax</a></li>          <li><a href="#3">Inputs</a></li>          <li><a href="#4">Outputs</a></li>          <li><a href="#5">Remarks</a></li>          <li><a href="#6">References</a></li>          <li><a href="#7">Acknowledgment</a></li>          <li><a href="#9">See also</a></li>          <li><a href="#10">Function implementation</a></li>          <li><a href="#11">Subfunctions</a></li>        </ul>      </div>      <h2>Description<a name="1"></a></h2>      <p>Shortest paths between nodes using Dijkstra algorithm. Based on Fig.        4.6, p.109 of [AMO93].</p>      <h2>Syntax<a name="2"></a></h2>      <pre>     [dist, paths] = DIJK(A, start_verts, end_verts);</pre>      <h2>Inputs<a name="3"></a></h2>      <p><b><tt>A</tt></b> : <tt>(n,n)</tt> node-node weighted adjacency matrix        of arc lengths.</p>      <p><tt>A(i,j) = 0 =&gt; Arc (i,j)</tt> does not exist;</p>      <p><tt>A(i,j) = NaN =&gt; Arc (i,j)</tt> exists with null weight.</p>      <p><b><tt>start_verts</tt></b> : FROM node indices; default: <tt>s=[]</tt>,        ie. paths from all nodes.</p>      <p><b><tt>end_verts</tt></b> : TO node indices; default: <tt>s=[]</tt>,        ie. paths to all nodes.</p>      <h2>Outputs<a name="4"></a></h2>      <p><b><tt>D</tt></b> : matrix of size <tt>(length(s),length(t))</tt>        storing the shortest path distances from <tt>s</tt> to <tt>t</tt>: <tt>D(i,j)</tt>        is the distance from node <tt>i</tt> to node <tt>j</tt>.</p>      <p><b><tt>P</tt></b> : shortest paths.</p>      <h2>Remarks<a name="5"></a></h2>      <div>        <ul>          <li>If <tt>A</tt> is a triangular matrix, then computationally            intensive node selection step not needed since graph is acyclic            (triangularity is a sufficient, but not a necessary, condition for a            graph to be acyclic) and <tt>A</tt> can have non-negative elements.</li>        </ul>      </div>      <div>        <ul>          <li>If <tt>length(s)&gt;&gt;length(t)</tt>, then <tt>DIJK</tt> is            faster if <tt>DIJK(A',t,s)</tt> used, where <tt>D</tt> is now            transposed and <tt>P</tt> represents successor indices.</li>        </ul>      </div>      <h2>References<a name="6"></a></h2>      <p>[AMO93] R. Ahuja, T. Magnanti and J. Orlin: "Network Flows: Theory,        Algorithms, and Applications", Prentice-Hall, 1993.</p>      <p>[DIJK] Source code made available by Michael G. Kay (see copyright) at        <a href="http://web.mit.edu/cocosci/isomap/code/dijk.m">http://web.mit.edu/cocosci/isomap/code/dijk.m</a>        <a href="http://cbi.nyu.edu/svn/mrTools/trunk/mrLoadRet/ROI/pred2path.m">http://cbi.nyu.edu/svn/mrTools/trunk/mrLoadRet/ROI/pred2path.m</a></p>      <h2>Acknowledgment<a name="7"></a></h2>      <p>Copyright (c) 1994-2006 by Michael G. Kay Matlog Version 9 13-Jan-2006        (<a href="http://www.ie.ncsu.edu/kay/matlog">http://www.ie.ncsu.edu/kay/matlog</a>)</p>      <h2>See also<a name="9"></a></h2>      <p>Ressembles: <a href="dijkstra.html"><tt>DIJKSTRA</tt></a>, <a href="dijkstra_base.html"><tt>DIJKSTRA_BASE</tt></a>,        <a href="dijkadvanced.html"><tt>DIJKADVANCED</tt></a>, <a href="../propagation/dijkstrapropagation.html"><tt>DIJKSTRAPROPAGATION</tt></a>.</p>      <h2>Function implementation<a name="10"></a></h2>      <pre class="codeinput"><span class="keyword">function</span> [dist, varargout] = dijk(W, start_verts, end_verts)[dist, P] = dijk_(W, start_verts, end_verts);<span class="keyword">if</span> nargout==2    varargout{1} = pred2path_(P, start_verts, end_verts);<span class="keyword">end</span><span class="keyword">end</span> <span class="comment">% end of dijk</span></pre>      <h2>Subfunctions<a name="11"></a></h2>      <p><tt>DIJK_</tt> - Matlab implementation of Dijkstra algorithm. Shortest        paths from nodes s to nodes t using Dijkstra algorithm. Based on Fig.        4.6, p.109 of [AMO93].</p>      <pre>       D = DIJK_(A,s,t)</pre>      <p>Inputs: see <tt>DIJK</tt> above.</p>      <p>Outputs:</p>      <p><tt>D</tt> : see <tt>DIJK</tt>.</p>      <p><tt>P</tt> : matrix of predecessor indices; it contains the node        indices of the node along the shortest path before the destination is        reached; these indices are useful to construct the shortest path with        the function <tt>PRED2PATH</tt> (by Michael G. Kay).</p>      <pre class="codeinput"><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> [D, P] = dijk_(A,s,t)<span class="comment">% Copyright (c) 1994-2003 by Michael G. Kay</span><span class="comment">% Matlog Version 7 02-Sep-2003</span>[n,cA] = size(A);<span class="keyword">if</span> nargin &lt; 2 || isempty(s), s = (1:n)'; <span class="keyword">else</span> s = s(:); <spanclass="keyword">end</span><span class="keyword">if</span> nargin &lt; 3 || isempty(t), t = (1:n)'; <span class="keyword">else</span> t = t(:); <spanclass="keyword">end</span><span class="keyword">if</span> ~any(any(tril(A) ~= 0))			<span class="comment">% A is upper triangular</span>   isAcyclic = 1;<span class="keyword">elseif</span> ~any(any(triu(A) ~= 0))	<span class="comment">% A is lower triangular</span>   isAcyclic = 2;<span class="keyword">else</span>										<span class="comment">% Graph may not be acyclic</span>   isAcyclic = 0;<span class="keyword">end</span><span class="keyword">if</span> n ~= cA   error(<span class="string">'A must be a square matrix'</span>);<span class="keyword">elseif</span> ~isAcyclic &amp;&amp; any(any(A &lt; 0))   error(<span class="string">'A must be non-negative'</span>);<span class="keyword">elseif</span> any(s &lt; 1 | s &gt; n)   error([<span class="string">'''s'' must be an integer between 1 and '</span>,num2str(n)]);<span class="keyword">elseif</span> any(t &lt; 1 | t &gt; n)   error([<span class="string">'''t'' must be an integer between 1 and '</span>,num2str(n)]);<span class="keyword">end</span>A = A';		<span class="comment">% Use transpose to speed-up FIND for sparse A</span>D = zeros(length(s),length(t));P = zeros(length(s),n);<span class="keyword">for</span> i = 1:length(s)   j = s(i);   Di = Inf*ones(n,1); Di(j) = 0;   isLab = false(length(t),1);   <span class="keyword">if</span> isAcyclic ==  1      nLab = j - 1;   <span class="keyword">elseif</span> isAcyclic == 2      nLab = n - j;   <span class="keyword">else</span>      nLab = 0;      UnLab = 1:n;      isUnLab = true(n,1);   <span class="keyword">end</span>   <span class="keyword">while</span> nLab &lt; n &amp;&amp; ~all(isLab)      <span class="keyword">if</span> isAcyclic         Dj = Di(j);      <span class="keyword">else</span>	<span class="comment">% Node selection</span>         [Dj,jj] = min(Di(isUnLab));         j = UnLab(jj);         UnLab(jj) = [];         isUnLab(j) = 0;      <span class="keyword">end</span>      nLab = nLab + 1;      <span class="keyword">if</span> length(t) &lt; n, isLab = isLab | (j == t); <spanclass="keyword">end</span>      [jA,~,Aj] = find(A(:,j));      Aj(isnan(Aj)) = 0;      <span class="keyword">if</span> isempty(Aj), Dk = Inf; <span class="keyword">else</span> Dk = Dj + Aj; <spanclass="keyword">end</span>      P(i,jA(Dk &lt; Di(jA))) = j;      Di(jA) = min(Di(jA),Dk);      <span class="keyword">if</span> isAcyclic == 1			<span class="comment">% Increment node index for upper triangular A</span>         j = j + 1;      <span class="keyword">elseif</span> isAcyclic == 2	<span class="comment">% Decrement node index for lower triangular A</span>         j = j - 1;      <span class="keyword">end</span>      <span class="comment">%disp( num2str( nLab ));</span>   <span class="keyword">end</span>   D(i,:) = Di(t)';<span class="keyword">end</span><span class="keyword">end</span></pre>      <p><tt>PRED2PATH_</tt> - Convert predecessor indices to shortest paths        from 's' to 't'. Used with the output of <tt>DIJK_</tt>.</p>      <pre class="language-matlab">rte = PRED2PATH_(P,s,t)</pre>      <p>Inputs:</p>      <p><tt>P</tt> = <tt>(s,n)</tt> matrix of predecessor indices (from <tt>DIJK_</tt>).</p>      <p><tt>s</tt> = FROM node indices; = <tt>[]</tt> (default), paths from        all nodes.</p>      <p><tt>t</tt> = TO node indices; = <tt>[]</tt> (default), paths to all        nodes.</p>      <p><tt>rte</tt> = <tt>s</tt> x <tt>t</tt> cell array of paths (or        routes) from <tt>s</tt> to <tt>t</tt>, where <tt>rte{i,j} = path</tt>        from <tt>s(i)</tt> to <tt>t(j)</tt>; = <tt>[]</tt>, if no path exists        from <tt>s(i)</tt> to <tt>t(j)</tt>.</p>      <pre class="codeinput"><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> rte = pred2path_(P,s,t)<span class="comment">% Copyright (c) 1994-2006 by Michael G. Kay</span><span class="comment">% Matlog Version 9 13-Jan-2006 (http://www.ie.ncsu.edu/kay/matlog)</span>[~,n] = size(P);<span class="keyword">if</span> nargin &lt; 2 || isempty(s), s = (1:n)'; <span class="keyword">else</span> s = s(:); <spanclass="keyword">end</span><span class="keyword">if</span> nargin &lt; 3 || isempty(t), t = (1:n)'; <span class="keyword">else</span> t = t(:); <spanclass="keyword">end</span><span class="keyword">if</span> any(P &lt; 0 | P &gt; n)   error([<span class="string">'Elements of P must be integers between 1 and '</span>,num2str(n)]);<span class="keyword">elseif</span> any(s &lt; 1 | s &gt; n)   error([<span class="string">'"s" must be an integer between 1 and '</span>,num2str(n)]);<span class="keyword">elseif</span> any(t &lt; 1 | t &gt; n)   error([<span class="string">'"t" must be an integer between 1 and '</span>,num2str(n)]);<span class="keyword">end</span>rte = cell(length(s),length(t));[~,idxs] = find(P==0);<span class="keyword">for</span> i = 1:length(s)<span class="comment">%    if rP == 1</span><span class="comment">%       si = 1;</span><span class="comment">%    else</span><span class="comment">%       si = s(i);</span><span class="comment">%       if si &lt; 1 | si &gt; rP</span><span class="comment">%          error('Invalid P matrix.')</span><span class="comment">%       end</span><span class="comment">%    end</span>   si = find(idxs == s(i));   <span class="keyword">for</span> j = 1:length(t)      tj = t(j);      <span class="keyword">if</span> tj == s(i)         r = tj;      <span class="keyword">elseif</span> P(si,tj) == 0         r = [];      <span class="keyword">else</span>         r = tj;         <span class="keyword">while</span> tj ~= 0            <span class="keyword">if</span> tj &lt; 1 || tj &gt; n               error(<span class="string">'Invalid element of P matrix found.'</span>)            <span class="keyword">end</span>            r = [P(si,tj); r];                                          <span class="comment">%#ok</span>            tj = P(si,tj);         <span class="keyword">end</span>         r(1) = [];      <span class="keyword">end</span>      rte{i,j} = r;   <span class="keyword">end</span><span class="keyword">end</span><span class="keyword">if</span> length(s) == 1 &amp;&amp; length(t) == 1   rte = rte{:};<span class="keyword">end</span><span class="comment">%rte = t;</span><span class="keyword">while</span> 0<span class="comment">%t ~= s</span>   <span class="keyword">if</span> t &lt; 1 || t &gt; n || round(t) ~= t      error(<span class="string">'Invalid "pred" element found prior to reaching "s"'</span>);   <span class="keyword">end</span>   rte = [P(t) rte];                                                   <span class="comment">%#ok</span>   t = P(t);<span class="keyword">end</span><span class="keyword">end</span></pre></div>    <!--##### SOURCE BEGIN #####%% DIJK - Matlab implementation of Dijkstra algorithm.%%% Description% Shortest paths between nodes using Dijkstra algorithm.% Based on Fig. 4.6, p.109 of [AMO93].%%% Syntax%       [dist, paths] = DIJK(A, start_verts, end_verts);%%% Inputs% *|A|* : |(n,n)| node-node weighted adjacency matrix of arc lengths.%% |A(i,j) = 0   => Arc (i,j)| does not exist;%% |A(i,j) = NaN => Arc (i,j)| exists with null weight.%% *|start_verts|* : FROM node indices; default: |s=[]|, ie. paths from all nodes.%% *|end_verts|* : TO node indices; default: |s=[]|, ie. paths to all nodes.%%% Outputs% *|D|* : matrix of size |(length(s),length(t))| storing the shortest path%     distances from |s| to |t|: |D(i,j)| is the distance from node |i| to %     node |j|.%% *|P|* : shortest paths.%%% Remarks% * If |A| is a triangular matrix, then computationally intensive node selection% step not needed since graph is acyclic (triangularity is a sufficient, but % not a necessary, condition for a graph to be acyclic) and |A| can have% non-negative elements.%% * If |length(s)>>length(t)|, then |DIJK| is faster if |DIJK(A',t,s)| used,% where |D| is now transposed and |P| represents successor indices.%%% References% [AMO93]  R. Ahuja, T. Magnanti and J. Orlin: "Network Flows: Theory,%     Algorithms, and Applications", Prentice-Hall, 1993.%% [DIJK]  Source code made available by Michael G. Kay (see copyright) at %     http://web.mit.edu/cocosci/isomap/code/dijk.m%     http://cbi.nyu.edu/svn/mrTools/trunk/mrLoadRet/ROI/pred2path.m%%% Acknowledgment% Copyright (c) 1994-2006 by Michael G. Kay% Matlog Version 9 13-Jan-2006 (http://www.ie.ncsu.edu/kay/matlog)%%% Contact% <mailto:grazzja@lanl.gov J.Grazzini> (ISR-2/LANL)%%% See also% Ressembles:% <dijkstra.html |DIJKSTRA|>,% <dijkstra_base.html |DIJKSTRA_BASE|>,% <dijkadvanced.html |DIJKADVANCED|>,% <../propagation/dijkstrapropagation.html |DIJKSTRAPROPAGATION|>.%% Function implementationfunction [dist, varargout] = dijk(W, start_verts, end_verts)[dist, P] = dijk_(W, start_verts, end_verts);if nargout==2    varargout{1} = pred2path_(P, start_verts, end_verts);endend % end of dijk%% Subfunctions%%% |DIJK_| - Matlab implementation of Dijkstra algorithm. Shortest paths from% nodes s to nodes t using Dijkstra algorithm.% Based on Fig. 4.6, p.109 of [AMO93].%%         D = DIJK_(A,s,t)%% Inputs: see |DIJK| above.%% Outputs:%% |D| : see |DIJK|. %% |P| : matrix of predecessor indices; it contains the node indices of the %     node along the shortest path before the destination is reached; these%     indices are useful to construct the shortest path with the function %     |PRED2PATH| (by Michael G. Kay).%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction [D, P] = dijk_(A,s,t)                                              % Copyright (c) 1994-2003 by Michael G. Kay% Matlog Version 7 02-Sep-2003[n,cA] = size(A);if nargin < 2 || isempty(s), s = (1:n)'; else s = s(:); endif nargin < 3 || isempty(t), t = (1:n)'; else t = t(:); endif ~any(any(tril(A) ~= 0))			% A is upper triangular   isAcyclic = 1;elseif ~any(any(triu(A) ~= 0))	% A is lower triangular   isAcyclic = 2;else										% Graph may not be acyclic   isAcyclic = 0;endif n ~= cA   error('A must be a square matrix');elseif ~isAcyclic && any(any(A < 0))   error('A must be non-negative');elseif any(s < 1 | s > n)   error(['''s'' must be an integer between 1 and ',num2str(n)]);elseif any(t < 1 | t > n)   error(['''t'' must be an integer between 1 and ',num2str(n)]);endA = A';		% Use transpose to speed-up FIND for sparse AD = zeros(length(s),length(t));P = zeros(length(s),n);for i = 1:length(s)   j = s(i);      Di = Inf*ones(n,1); Di(j) = 0;      isLab = false(length(t),1);   if isAcyclic ==  1      nLab = j - 1;   elseif isAcyclic == 2      nLab = n - j;   else      nLab = 0;      UnLab = 1:n;      isUnLab = true(n,1);   end      while nLab < n && ~all(isLab)      if isAcyclic         Dj = Di(j);      else	% Node selection         [Dj,jj] = min(Di(isUnLab));         j = UnLab(jj);         UnLab(jj) = [];         isUnLab(j) = 0;      end            nLab = nLab + 1;      if length(t) < n, isLab = isLab | (j == t); end            [jA,~,Aj] = find(A(:,j));      Aj(isnan(Aj)) = 0;                  if isempty(Aj), Dk = Inf; else Dk = Dj + Aj; end            P(i,jA(Dk < Di(jA))) = j;      Di(jA) = min(Di(jA),Dk);            if isAcyclic == 1			% Increment node index for upper triangular A         j = j + 1;      elseif isAcyclic == 2	% Decrement node index for lower triangular A         j = j - 1;      end            %disp( num2str( nLab ));   end   D(i,:) = Di(t)';endend%%% |PRED2PATH_| - Convert predecessor indices to shortest paths from 's' to % 't'. Used with the output of |DIJK_|.%%   rte = PRED2PATH_(P,s,t)%% Inputs:%% |P| = |(s,n)| matrix of predecessor indices (from |DIJK_|).%% |s| = FROM node indices;%     = |[]| (default), paths from all nodes.%% |t| = TO node indices;%     = |[]| (default), paths to all nodes.%% |rte| = |s| x |t| cell array of paths (or routes) from |s| to |t|, where%      |rte{i,j} = path| from |s(i)| to |t(j)|;%                  = |[]|, if no path exists from |s(i)| to |t(j)|.%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction rte = pred2path_(P,s,t)% Copyright (c) 1994-2006 by Michael G. Kay% Matlog Version 9 13-Jan-2006 (http://www.ie.ncsu.edu/kay/matlog)[~,n] = size(P);if nargin < 2 || isempty(s), s = (1:n)'; else s = s(:); endif nargin < 3 || isempty(t), t = (1:n)'; else t = t(:); endif any(P < 0 | P > n)   error(['Elements of P must be integers between 1 and ',num2str(n)]);elseif any(s < 1 | s > n)   error(['"s" must be an integer between 1 and ',num2str(n)]);elseif any(t < 1 | t > n)   error(['"t" must be an integer between 1 and ',num2str(n)]);endrte = cell(length(s),length(t));[~,idxs] = find(P==0);for i = 1:length(s)%    if rP == 1%       si = 1;%    else%       si = s(i);%       if si < 1 | si > rP%          error('Invalid P matrix.')%       end%    end   si = find(idxs == s(i));   for j = 1:length(t)      tj = t(j);      if tj == s(i)         r = tj;      elseif P(si,tj) == 0         r = [];      else         r = tj;         while tj ~= 0            if tj < 1 || tj > n               error('Invalid element of P matrix found.')            end            r = [P(si,tj); r];                                          %#ok            tj = P(si,tj);         end         r(1) = [];      end      rte{i,j} = r;   endendif length(s) == 1 && length(t) == 1   rte = rte{:};end%rte = t;while 0%t ~= s   if t < 1 || t > n || round(t) ~= t      error('Invalid "pred" element found prior to reaching "s"');   end   rte = [P(t) rte];                                                   %#ok   t = P(t);endend##### SOURCE END #####-->  </body></html>