<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html>  <head>    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">    <!--This HTML was auto-generated from MATLAB code.To make changes, update the MATLAB code and republish this document.      -->    <title>DFS - Matlab implementation of Depth first search algorithm.</title>    <meta name="generator" content="MATLAB 7.14">    <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">    <meta name="DC.date" content="2012-05-31">    <meta name="DC.source" content="dfs.m">    <style type="text/css">html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}html { min-height:100%; margin-bottom:1px; }html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }html body td { vertical-align:top; text-align:left; }h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }a { color:#005fce; text-decoration:none; }a:hover { color:#005fce; text-decoration:underline; }a:visited { color:#004aa0; text-decoration:none; }p { padding:0px; margin:0px 0px 20px; }img { padding:0px; margin:0px 0px 20px; border:none; }p img, pre img, tt img, li img { margin-bottom:0px; } ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }ul li { padding:0px; margin:0px 0px 7px 0px; }ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }ul li ol li { list-style:decimal; }ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }ol li ol li { list-style-type:lower-alpha; }ol li ul { padding-top:7px; }ol li ul li { list-style:square; }.content { font-size:1.2em; line-height:140%; padding: 20px; }pre, tt, code { font-size:12px; }pre { margin:0px 0px 20px; }pre.error { color:red; }pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }span.keyword { color:#0000FF }span.comment { color:#228B22 }span.string { color:#A020F0 }span.untermstring { color:#B20000 }span.syscmd { color:#B28C00 }.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }.footer p { margin:0px; }  </style>  </head>  <body>    <div class="content">      <h1>DFS - Matlab implementation of Depth first search algorithm.</h1>      <!--introduction--><!--/introduction-->      <h2>Contents</h2>      <div>        <ul>          <li><a href="#1">Description</a></li>          <li><a href="#2">Syntax</a></li>          <li><a href="#3">Inputs</a></li>          <li><a href="#4">Outputs</a></li>          <li><a href="#5">References</a></li>          <li><a href="#7">See also</a></li>          <li><a href="#8">Function implementation</a></li>          <li><a href="#9">Subfunctions</a></li>        </ul>      </div>      <h2>Description<a name="1"></a></h2>      <p>Perform a depth-first search (DFS) of an input graph.</p>      <h2>Syntax<a name="2"></a></h2>      <pre>   [d, pre, post, cycle, f, pred] = DFS(adj_mat, start, directed);</pre>      <h2>Inputs<a name="3"></a></h2>      <p><b><tt>adj_mat</tt></b> : adjacency matrix where <tt>adj_mat(i,j)=1</tt>        iff <tt>i</tt> is connected to <tt>j</tt>.</p>      <p><b><tt>start</tt></b> : root vertex of the dfs tree, from where the        search starts; if <tt>start=[]</tt>, all nodes are searched.</p>      <p><b><tt>directed</tt></b> : logical flag stating if the graph is        directed (<tt>true</tt>).</p>      <h2>Outputs<a name="4"></a></h2>      <p><b><tt>d</tt></b> : distance/time map where <tt>d(i)</tt> is the time        at which node <tt>i</tt> is first discovered.</p>      <p><b><tt>pre</tt></b> : list of the nodes in the order in which they are        first encountered (opened).</p>      <p><b><tt>post</tt></b> : list of the nodes in the order in which they are        last encountered (closed).</p>      <p><b><tt>cycle</tt></b> : logical flag set to true iff a (directed) cycle        is found.</p>      <p><b><tt>f</tt></b> : distance/time map where <tt>f(i)</tt> is the time        at which node <tt>i</tt> is finished.</p>      <p><b><tt>pred</tt></b> : list of predecessors where <tt>pred(i)</tt> is        the predecessor of <tt>i</tt> in the DFS tree.</p>      <h2>References<a name="5"></a></h2>      <p>[ZK00] R. Tarjan: "Depth-first search and linear graph algorithms",        SIAM's Journal of Computing, 1:146-160, 1972.</p>      <p>[CLRS01] T. Cormen, C. Leiserson, R. Rivest, C. Stein: "Introduction to        Algorithms, 2nd edition, MIT Press, 2001.</p>      <h2>See also<a name="7"></a></h2>      <p>Related: <a href="matlab:webpub%28whichpath%28%27BFS%27%29%29"><tt>BFS</tt></a>,        <a href="matlab:webpub%28whichpath%28%27GAIMC/SCOMPONENTS%27%29%29"><tt>GAIMC/SCOMPONENTS</tt></a>,        <a href="matlab:webpub%28whichpath%28%27GAIMC/DFS%27%29%29"><tt>GAIMC/DFS</tt></a>.</p>      <h2>Function implementation<a name="8"></a></h2>      <pre class="codeinput"><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> [d, pre, post, cycle, f, pred] = dfs(adj_mat, start, directed)n = length(adj_mat);<span class="keyword">global</span> white gray black color time_stamp d f pred cycle pre post       <spanclass="comment">%#ok</span>white = 0; gray = 1; black = 2;color = white*ones(1,n);time_stamp = 0;d = zeros(1,n);f = zeros(1,n);pred = zeros(1,n);cycle = 0;pre = [];post = [];<span class="keyword">if</span> ~isempty(start)  dfs_visit(start, adj_mat, directed);<span class="keyword">end</span><span class="keyword">for</span> u=1:n  <span class="keyword">if</span> color(u)==white    dfs_visit(u, adj_mat, directed);  <span class="keyword">end</span><span class="keyword">end</span><span class="keyword">end</span> <span class="comment">% end of dfs</span></pre>      <h2>Subfunctions<a name="9"></a></h2>      <pre class="codeinput"><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> dfs_visit(u, adj_mat, directed)<span class="keyword">global</span> white gray black color time_stamp d f pred cycle pre postpre = [pre u];color(u) = gray;time_stamp = time_stamp + 1;d(u) = time_stamp;<span class="keyword">if</span> directed  ns = children(adj_mat, u);<span class="keyword">else</span>  ns = neighbors(adj_mat, u);  ns = setdiff(ns, pred(u)); <span class="comment">% don't go back to visit the guy who called you!</span><span class="keyword">end</span><span class="keyword">for</span> v=ns(:)'  <span class="comment">%fprintf('u=%d, v=%d, color(v)=%d\n', u, v, color(v))</span>  <span class="keyword">switch</span> color(v)    <span class="keyword">case</span> white, <span class="comment">% not visited v before (tree edge)</span>     pred(v)=u;     dfs_visit(v, adj_mat, directed);   <span class="keyword">case</span> gray, <span class="comment">% back edge - v has been visited, but is still open</span>    cycle = 1;    <span class="comment">%fprintf('cycle: back edge from v=%d to u=%d\n', v, u);</span>   <span class="keyword">case</span> black, <span class="comment">% v has been visited, but is closed</span>    <span class="comment">% no-op</span>  <span class="keyword">end</span><span class="keyword">end</span>color(u) = black;post = [post u];time_stamp = time_stamp + 1;f(u) = time_stamp;<span class="keyword">end</span></pre></div>    <!--##### SOURCE BEGIN #####%% DFS - Matlab implementation of Depth first search algorithm.%%% Description% Perform a depth-first search (DFS) of an input graph.%%% Syntax%     [d, pre, post, cycle, f, pred] = DFS(adj_mat, start, directed);%%% Inputs% *|adj_mat|* : adjacency matrix where |adj_mat(i,j)=1| iff |i| is connected%     to |j|.%% *|start|* : root vertex of the dfs tree, from where the search starts; if %     |start=[]|, all nodes are searched.%% *|directed|* : logical flag stating if the graph is directed (|true|).%%% Outputs% *|d|* : distance/time map where |d(i)| is the time at which node |i| is first%     discovered.%% *|pre|* : list of the nodes in the order in which they are first encountered%     (opened).%% *|post|* : list of the nodes in the order in which they are last encountered%     (closed).%% *|cycle|* : logical flag set to true iff a (directed) cycle is found.%% *|f|* : distance/time map where |f(i)| is the time at which node |i| is finished.%% *|pred|* : list of predecessors where |pred(i)| is the predecessor of |i| in the%     DFS tree.%%% References% [ZK00] R. Tarjan: "Depth-first search and linear graph algorithms",%       SIAM's Journal of Computing, 1:146-160, 1972.%% [CLRS01]  T. Cormen, C. Leiserson, R. Rivest, C. Stein: "Introduction%       to Algorithms, 2nd edition, MIT Press, 2001.%%% Contact% <mailto:grazzja@lanl.gov J.Grazzini> (ISR-2/LANL)%%% See also% Related:% <matlab:webpub(whichpath('BFS')) |BFS|>,% <matlab:webpub(whichpath('GAIMC/SCOMPONENTS')) |GAIMC/SCOMPONENTS|>,% <matlab:webpub(whichpath('GAIMC/DFS')) |GAIMC/DFS|>.%% Function implementation%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction [d, pre, post, cycle, f, pred] = dfs(adj_mat, start, directed)n = length(adj_mat);global white gray black color time_stamp d f pred cycle pre post       %#okwhite = 0; gray = 1; black = 2;color = white*ones(1,n);time_stamp = 0;d = zeros(1,n);f = zeros(1,n);pred = zeros(1,n);cycle = 0;pre = [];post = [];if ~isempty(start)  dfs_visit(start, adj_mat, directed);endfor u=1:n  if color(u)==white    dfs_visit(u, adj_mat, directed);  endendend % end of dfs%% Subfunctions%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction dfs_visit(u, adj_mat, directed)global white gray black color time_stamp d f pred cycle pre postpre = [pre u];color(u) = gray;time_stamp = time_stamp + 1;d(u) = time_stamp;if directed  ns = children(adj_mat, u);else  ns = neighbors(adj_mat, u);  ns = setdiff(ns, pred(u)); % don't go back to visit the guy who called you!endfor v=ns(:)'  %fprintf('u=%d, v=%d, color(v)=%d\n', u, v, color(v))  switch color(v)    case white, % not visited v before (tree edge)     pred(v)=u;     dfs_visit(v, adj_mat, directed);   case gray, % back edge - v has been visited, but is still open    cycle = 1;    %fprintf('cycle: back edge from v=%d to u=%d\n', v, u);   case black, % v has been visited, but is closed    % no-op  endendcolor(u) = black;post = [post u];time_stamp = time_stamp + 1;f(u) = time_stamp;end##### SOURCE END #####--></body></html>