<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html>  <head>    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">    <!--This HTML was auto-generated from MATLAB code.To make changes, update the MATLAB code and republish this document.      -->    <title>DIJKADVANCED - Matlab implementation of Dijkstra algorithm.</title>    <meta name="generator" content="MATLAB 7.14">    <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">    <meta name="DC.date" content="2012-05-31">    <meta name="DC.source" content="dijkadvanced.m">    <style type="text/css">html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}html { min-height:100%; margin-bottom:1px; }html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }html body td { vertical-align:top; text-align:left; }h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }a { color:#005fce; text-decoration:none; }a:hover { color:#005fce; text-decoration:underline; }a:visited { color:#004aa0; text-decoration:none; }p { padding:0px; margin:0px 0px 20px; }img { padding:0px; margin:0px 0px 20px; border:none; }p img, pre img, tt img, li img { margin-bottom:0px; } ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }ul li { padding:0px; margin:0px 0px 7px 0px; }ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }ul li ol li { list-style:decimal; }ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }ol li ol li { list-style-type:lower-alpha; }ol li ul { padding-top:7px; }ol li ul li { list-style:square; }.content { font-size:1.2em; line-height:140%; padding: 20px; }pre, tt, code { font-size:12px; }pre { margin:0px 0px 20px; }pre.error { color:red; }pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }span.keyword { color:#0000FF }span.comment { color:#228B22 }span.string { color:#A020F0 }span.untermstring { color:#B20000 }span.syscmd { color:#B28C00 }.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }.footer p { margin:0px; }  </style>  </head>  <body>    <div class="content">      <h1>DIJKADVANCED - Matlab implementation of Dijkstra algorithm.</h1>      <!--introduction--><!--/introduction-->      <h2>Contents</h2>      <div>        <ul>          <li><a href="#1">Description</a></li>          <li><a href="#2">Syntax</a></li>          <li><a href="#3">Inputs</a></li>          <li><a href="#4">Outputs</a></li>          <li><a href="#5">Revision Notes</a></li>          <li><a href="#6">Remark</a></li>          <li><a href="#7">Example 1: all-pairs shortest distances and paths              using [A,xy] inputs</a></li>          <li><a href="#8">Example 2: all-pairs shortest distances and paths              using [A,C] inputs</a></li>          <li><a href="#9">Example 3: all-pairs shortest distances and paths              using [V,E] inputs</a></li>          <li><a href="#10">Example 4: all-pairs shortest distances and paths              using [V,E3] inputs</a></li>          <li><a href="#11">Example 5: shortest distances and paths from the 3rd              point to all the rest</a></li>          <li><a href="#12">Example 6: shortest distances and paths from all              points to the 2nd</a></li>          <li><a href="#13">Example 7: shortest distance and path from points [1              3 4] to</a></li>          <li><a href="#14">Example 8: shortest distance and path between two              points</a></li>          <li><a href="#15">Acknowledgment</a></li>          <li><a href="#17">See also</a></li>          <li><a href="#18">Function implementation</a></li>          <li><a href="#23">Subfunctions</a></li>        </ul>      </div>      <h2>Description<a name="1"></a></h2>      <p>Calculate minimum costs and paths using Dijkstra's algorithm.</p>      <h2>Syntax<a name="2"></a></h2>      <pre>       [costs,paths] = DIJKADVANCED(AorV, xyCorE);       [costs,paths] = DIJKADVANCED(AorV, xyCorE, SID, FID);</pre>      <h2>Inputs<a name="3"></a></h2>      <p><b><tt>AorV</tt></b> : either A or V where:</p>      <div>        <ul>          <li><tt>A</tt> is a <tt>(N,N)</tt> adjacency matrix, where <tt>A(I,J)</tt>            is nonzero (=1) if and only if an edge connects point <tt>I</tt> to            point <tt>J</tt>; note: works for both symmetric and asymmetric <tt>A</tt>,</li>          <li><tt>V</tt> is a <tt>(N,2)</tt> (or <tt>(N,3)</tt>) matrix of            x,y,(z) coordinates.</li>        </ul>      </div>      <p><b><tt>xyCorE</tt></b> : either <tt>xy</tt> (or <tt>C</tt>) or <tt>E</tt>        (or <tt>E3</tt>) where:</p>      <div>        <ul>          <li><tt>xy</tt> is a <tt>(N,2)</tt> (or <tt>(N,3)</tt>) matrix of            x,y,(z) coordinates (equivalent to <tt>V</tt>); note: only valid            with <tt>A</tt> as the first input,</li>          <li><tt>C</tt> is a <tt>(N,N)</tt> cost (perhaps distance) matrix,            where <tt>C(I,J)</tt> contains the value of the cost to move from            point <tt>I</tt> to point <tt>J</tt>; note: only valid with <tt>A</tt>            as the first input,</li>          <li><tt>E</tt> is a <tt>(P,2)</tt> matrix containing a list of edge            connections; note: only valid with <tt>V</tt> as the first input,</li>          <li><tt>E3</tt> is a <tt>(P,3)</tt> matrix containing a list of edge            connections in the first two columns and edge weights in the third            column; note: only valid with <tt>V</tt> as the first input.</li>        </ul>      </div>      <p><b><tt>SID</tt></b> : (optional) <tt>(1,L)</tt> vector of starting        points; if unspecified, the algorithm will calculate the minimal path        from all <tt>N</tt> points to the finish point(s) (automatically sets <tt>SID=1:N</tt>).</p>      <p><b><tt>FID</tt></b> : (optional) <tt>(1,M)</tt> vector of finish        points; if unspecified, the algorithm will calculate the minimal path        from the starting point(s) to all <tt>N</tt> points (automatically sets        <tt>FID=1:N</tt>).</p>      <h2>Outputs<a name="4"></a></h2>      <p><b><tt>costs</tt></b> : a <tt>(L,M)</tt> matrix of minimum cost values        for the minimal paths.</p>      <p><b><tt>paths</tt></b> : a <tt>(L,M)</tt> cell array containing the        shortest path arrays.</p>      <h2>Revision Notes<a name="5"></a></h2>      <p>Previously, this code ignored edges that have a cost of zero,        potentially producing an incorrect result when such a condition exists.        This issue has been solved by using <tt>NaN</tt> in the table rather        than a sparse matrix of zeros. However, storing all of the <tt>NaN</tt>        requires more memory than a sparse matrix. This may be an issue for        massive data sets, but only if there are one or more 0-cost edges,        because a sparse matrix is still used if all of the costs are positive.</p>      <h2>Remark<a name="6"></a></h2>      <div>        <ul>          <li>If the inputs are <tt>[A,xy]</tt> or <tt>[V,E]</tt>, the cost is            assumed to be (and is calculated as) the point-to-point Euclidean            distance</li>        </ul>      </div>      <div>        <ul>          <li>If the inputs are <tt>[A,C]</tt> or <tt>[V,E3]</tt>, the cost is            obtained from either the C matrix or from the edge weights in the            3rd column of <tt>E3</tt>.</li>        </ul>      </div>      <h2>Example 1: all-pairs shortest distances and paths using [A,xy] inputs<a          name="7"></a></h2>      <pre class="language-matlab">n = 7; A = zeros(n); xy = 10*rand(n,2);tri = delaunay(xy(:,1),xy(:,2));I = tri(:); J = tri(:,[2 3 1]); J = J(:);IJ = I + n*(J-1); A(IJ) = 1;[costs,paths] = dijkadvanced(A,xy);</pre>      <h2>Example 2: all-pairs shortest distances and paths using [A,C] inputs<a          name="8"></a></h2>      <pre class="language-matlab">n = 7; A = zeros(n); xy = 10*rand(n,2)tri = delaunay(xy(:,1),xy(:,2));I = tri(:); J = tri(:,[2 3 1]); J = J(:);IJ = I + n*(J-1); A(IJ) = 1a = (1:n); b = a(ones(n,1),:);C = round(reshape(sqrt(sum((xy(b,:) - xy(b',:)).^2,2)),n,n))[costs,paths] = dijkadvanced(A,C)</pre>      <h2>Example 3: all-pairs shortest distances and paths using [V,E] inputs<a          name="9"></a></h2>      <pre class="language-matlab">n = 7; V = 10*rand(n,2)I = delaunay(V(:,1),V(:,2));J = I(:,[2 3 1]); E = [I(:) J(:)][costs,paths] = dijkadvanced(V,E)</pre>      <h2>Example 4: all-pairs shortest distances and paths using [V,E3] inputs<a          name="10"></a></h2>      <pre class="language-matlab">n = 7; V = 10*rand(n,2)I = delaunay(V(:,1),V(:,2));J = I(:,[2 3 1]);D = sqrt(sum((V(I(:),:) - V(J(:),:)).^2,2));E3 = [I(:) J(:) D][costs,paths] = dijkadvanced(V,E3)</pre>      <h2>Example 5: shortest distances and paths from the 3rd point to all the        rest<a name="11"></a></h2>      <pre class="language-matlab">n = 7; V = 10*rand(n,2)I = delaunay(V(:,1),V(:,2));J = I(:,[2 3 1]); E = [I(:) J(:)][costs,paths] = dijkadvanced(V,E,3)</pre>      <h2>Example 6: shortest distances and paths from all points to the 2nd<a name="12"></a></h2>      <pre class="language-matlab">n = 7; A = zeros(n); xy = 10*rand(n,2)tri = delaunay(xy(:,1),xy(:,2));I = tri(:); J = tri(:,[2 3 1]); J = J(:);IJ = I + n*(J-1); A(IJ) = 1[costs,paths] = dijkadvanced(A,xy,1:n,2)</pre>      <h2>Example 7: shortest distance and path from points [1 3 4] to<a name="13"></a></h2>      <pre class="language-matlab"><span class="comment">% [2 3 5 7]</span>n = 7; V = 10*rand(n,2)I = delaunay(V(:,1),V(:,2));J = I(:,[2 3 1]); E = [I(:) J(:)][costs,paths] = dijkadvanced(V,E,[1 3 4],[2 3 5 7])</pre>      <h2>Example 8: shortest distance and path between two points<a name="14"></a></h2>      <pre class="language-matlab">n = 1000; A = zeros(n); xy = 10*rand(n,2);tri = delaunay(xy(:,1),xy(:,2));I = tri(:); J = tri(:,[2 3 1]); J = J(:);D = sqrt(sum((xy(I,:)-xy(J,:)).^2,2));I(D &gt; 0.75,:) = []; J(D &gt; 0.75,:) = [];IJ = I + n*(J-1); A(IJ) = 1;[cost,path] = dijkadvanced(A,xy,1,n);gplot(A,xy,<span class="string">'k.:'</span>); hold <span class="string">on</span>;plot(xy(path,1),xy(path,2),<span class="string">'ro-'</span>,<span class="string">'LineWidth'</span>,2); hold <spanclass="string">off</span>title(sprintf(<span class="string">'Distance from 1 to 1000 = %1.3f'</span>,cost))</pre>      <h2>Acknowledgment<a name="15"></a></h2>      <p>author: Joseph Kirk - email: <a href="mailto:jdkirk630@gmail.com">jdkirk630@gmail.com</a>        - source: <a href="http://www.mathworks.com/matlabcentral/fileexchange/20025">http://www.mathworks.com/matlabcentral/fileexchange/20025</a>        release: 1.1</p>      <h2>See also<a name="17"></a></h2>      <p>Related: <a href="DIJKSTRA.html"><tt>DIJKSTRA</tt></a>, <a href="DIJK_BASE.html"><tt>DIJK_BASE</tt></a>,        <a href="../../propagation/html/FMM_BASE.html"><tt>FMM_BASE</tt></a>, <a          href="../../propagation/html/DIJKSTRAPROPAGATION_BASE.html"><tt>DIJKSTRAPROPAGATION_BASE</tt></a>,        <a href="matlab:webpub%28whichpath%28%27GPLOT%27%29%29"><tt>GPLOT</tt></a>,        <a href="matlab:webpub%28whichpath%28%27DISTMAT%27%29%29"><tt>DISTMAT</tt></a>.</p>      <h2>Function implementation<a name="18"></a></h2>      <pre class="codeinput"><span class="keyword">function</span> [costs,paths] = dijkadvanced(AorV, xyCorE, SID, FID)</pre>      <p>checking variables</p>      <pre class="codeinput">error(nargoutchk(1, 2, nargout, <span class="string">'struct'</span>));error(nargchk(1, 4, nargin, <span class="string">'struct'</span>));<span class="comment">% we allow variable nargin for this function</span><span class="keyword">if</span> nargin&lt;4,  FID = [];    <span class="keyword">if</span> nargin&lt;3,  SID = [];  <span class="keyword">end</span><span class="keyword">end</span>n = size(AorV,1);<span class="keyword">if</span> isempty(FID),  FID = (1:n);        <span class="keyword">end</span><span class="keyword">if</span> isempty(SID),  SID = (1:n);        <span class="keyword">end</span><span class="keyword">if</span> max(SID) &gt; n || min(SID) &lt; 1    error(<span class="string">'dijkadvanced:inputerror'</span>, <span class="string">'invalid [SID] input'</span>);<span class="keyword">elseif</span> max(FID) &gt; n || min(FID) &lt; 1    error(<span class="string">'dijkadvanced:inputerror'</span>, <span class="string">'invalid [FID] input'</span>);<span class="keyword">end</span></pre>      <p>main calculation</p>      <pre class="codeinput"><span class="comment">% process Inputs</span>[n,nc] = size(AorV);                                                   <span class="comment">%#ok</span>[E, cost, all_positive] = processInputs(AorV,xyCorE);<span class="comment">% all_positive = true;</span>isreversed = 0;<span class="keyword">if</span> length(FID) &lt; length(SID)    E = E(:,[2 1]);    cost = cost';    tmp = SID;    SID = FID;    FID = tmp;    isreversed = 1;<span class="keyword">end</span>L = length(SID);M = length(FID);costs = zeros(L,M);paths = num2cell(nan(L,M));<span class="comment">% find the Minimum Costs and Paths using Dijkstra's Algorithm</span><span class="keyword">for</span> k = 1:L    <span class="comment">% Initializations</span>    <span class="keyword">if</span> all_positive,  TBL = sparse(1,n);    <span class="keyword">else</span>              TBL = NaN(1,n);    <span class="keyword">end</span>    min_cost = Inf(1,n);    settled = zeros(1,n);    path = num2cell(nan(1,n));    I = SID(k);    min_cost(I) = 0;    TBL(I) = 0;    settled(I) = 1;    path(I) = {I};    <span class="keyword">while</span> any(~settled(FID))        <span class="comment">% Update the Table</span>        TAB = TBL;        <span class="keyword">if</span> all_positive,  TBL(I) = 0;        <span class="keyword">else</span>              TBL(I) = NaN;  <span class="keyword">end</span>        nids = find(E(:,1) == I);        <span class="comment">% Calculate the Costs to the Neighbor Points and Record Paths</span>        <span class="keyword">for</span> kk = 1:length(nids)            J = E(nids(kk),2);            <span class="keyword">if</span> ~settled(J)                c = cost(I,J);                <span class="keyword">if</span> all_positive,  empty = ~TAB(J);                <span class="keyword">else</span>              empty = isnan(TAB(J));  <spanclass="keyword">end</span>                <span class="keyword">if</span> empty || (TAB(J) &gt; (TAB(I) + c))                    TBL(J) = TAB(I) + c;                    <span class="keyword">if</span> isreversed                        path{J} = [J path{I}];                    <span class="keyword">else</span>                        path{J} = [path{I} J];                    <span class="keyword">end</span>                <span class="keyword">else</span>                    TBL(J) = TAB(J);                <span class="keyword">end</span>            <span class="keyword">end</span>        <span class="keyword">end</span>        <span class="keyword">if</span> all_positive,  K = find(TBL);        <span class="keyword">else</span>              K = find(~isnan(TBL));  <spanclass="keyword">end</span>        <span class="comment">% Find the Minimum Value in the Table</span>        N = find(TBL(K) == min(TBL(K)));        <span class="keyword">if</span> isempty(N)            <span class="keyword">break</span>        <span class="keyword">else</span>            <span class="comment">% Settle the Minimum Value</span>            I = K(N(1));            min_cost(I) = TBL(I);            settled(I) = 1;        <span class="keyword">end</span>    <span class="keyword">end</span>    <span class="comment">% Store Costs and Paths</span>    costs(k,:) = min_cost(FID);    paths(k,:) = path(FID);<span class="keyword">end</span><span class="keyword">if</span> isreversed    costs = costs';    paths = paths';<span class="keyword">end</span><span class="keyword">if</span> L == 1 &amp;&amp; M == 1    paths = paths{1};<span class="keyword">end</span></pre>      <pre class="codeinput"><span class="keyword">end</span> <span class="comment">% end of dijkadvanced</span></pre>      <h2>Subfunctions<a name="23"></a></h2>      <pre class="codeinput"><span class="comment">%-------------------------------------------------------------------</span><span class="keyword">function</span> [E, C, all_positive] = processInputs(AorV,xyCorE)[n,nc] = size(AorV);[m,mc] = size(xyCorE);C = sparse(n,n);<span class="keyword">if</span> n == nc    <span class="keyword">if</span> m == n        <span class="keyword">if</span> m == mc <span class="comment">% Inputs: A,cost</span>            A = AorV;            A = A - diag(diag(A));            C = xyCorE;            all_positive = all(C(logical(A)) &gt; 0);            E = a2e(A);        <span class="keyword">else</span> <span class="comment">% Inputs: A,xy</span>            A = AorV;            A = A - diag(diag(A));            xy = xyCorE;            E = a2e(A);            D = ve2d(xy,E);            all_positive = all(D &gt; 0);            <span class="keyword">for</span> row = 1:length(D)                C(E(row,1),E(row,2)) = D(row);            <span class="keyword">end</span>        <span class="keyword">end</span>    <span class="keyword">else</span>        error(<span class="string">'dijkadvanced:errorinput'</span>, <span class="keyword">...</span>            <span class="string">'invalid [A,xy] or [A,cost] inputs'</span>);    <span class="keyword">end</span><span class="keyword">else</span>    <span class="keyword">if</span> mc == 2 <span class="comment">% Inputs: V,E</span>        V = AorV;        E = xyCorE;        D = ve2d(V,E);        all_positive = all(D &gt; 0);        <span class="keyword">for</span> row = 1:m            C(E(row,1),E(row,2)) = D(row);        <span class="keyword">end</span>    <span class="keyword">elseif</span> mc == 3 <span class="comment">% Inputs: V,E3</span>        E3 = xyCorE;        all_positive = all(E3 &gt; 0);        E = E3(:,1:2);        <span class="keyword">for</span> row = 1:m            C(E3(row,1),E3(row,2)) = E3(row,3);        <span class="keyword">end</span>    <span class="keyword">else</span>        error(<span class="string">'dijkadvanced:errorinput'</span>, <span class="keyword">...</span>            <span class="string">'invalid [V,E] inputs'</span>);    <span class="keyword">end</span><span class="keyword">end</span><span class="keyword">end</span><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> E = a2e(A)<span class="comment">% Convert Adjacency Matrix to Edge List</span>[I,J] = find(A);E = [I J];<span class="keyword">end</span><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> D = ve2d(V,E)<span class="comment">% Compute Euclidean Distance for Edges</span>VI = V(E(:,1),:);VJ = V(E(:,2),:);D = sqrt(sum((VI - VJ).^2,2));<span class="keyword">end</span></pre></div>    <!--##### SOURCE BEGIN #####%% DIJKADVANCED - Matlab implementation of Dijkstra algorithm.%%% Description% Calculate minimum costs and paths using Dijkstra's algorithm.%%% Syntax%         [costs,paths] = DIJKADVANCED(AorV, xyCorE);%         [costs,paths] = DIJKADVANCED(AorV, xyCorE, SID, FID); %%% Inputs% *|AorV|* : either A or V where:%% * |A| is a |(N,N)| adjacency matrix, where |A(I,J)| is nonzero (=1) if%          and only if an edge connects point |I| to point |J|; note: works%          for both symmetric and asymmetric |A|,% * |V| is a |(N,2)| (or |(N,3)|) matrix of x,y,(z) coordinates.%% *|xyCorE|* : either |xy| (or |C|) or |E| (or |E3|) where:%% * |xy| is a |(N,2)| (or |(N,3)|) matrix of x,y,(z) coordinates (equivalent%          to |V|); note: only valid with |A| as the first input,% * |C| is a |(N,N)| cost (perhaps distance) matrix, where |C(I,J)| contains%          the value of the cost to move from point |I| to point |J|; note:%          only valid with |A| as the first input,% * |E| is a |(P,2)| matrix containing a list of edge connections; note:%          only valid with |V| as the first input,% * |E3| is a |(P,3)| matrix containing a list of edge connections in the%          first two columns and edge weights in the third column; note:%          only valid with |V| as the first input.%% *|SID|* : (optional) |(1,L)| vector of starting points; if unspecified, the%       algorithm will calculate the minimal path from all |N| points to the %       finish point(s) (automatically sets |SID=1:N|).%% *|FID|* : (optional) |(1,M)| vector of finish points; if unspecified, the %       algorithm will calculate the minimal path from the starting point(s) %       to all |N| points (automatically sets |FID=1:N|).%%% Outputs% *|costs|* : a |(L,M)| matrix of minimum cost values for the minimal paths.%% *|paths|* : a |(L,M)| cell array containing the shortest path arrays.%%% Revision Notes% Previously, this code ignored edges that have a cost of zero, potentially%   producing an incorrect result when such a condition exists.%   This issue has been solved by using |NaN| in the table rather than a sparse%   matrix of zeros. However, storing all of the |NaN| requires more memory%   than a sparse matrix. This may be an issue for massive data sets, but%   only if there are one or more 0-cost edges, because a sparse matrix is%   still used if all of the costs are positive.%%% Remark% * If the inputs are |[A,xy]| or |[V,E]|, the cost is assumed to be (and is%  calculated as) the point-to-point Euclidean distance%% * If the inputs are |[A,C]| or |[V,E3]|, the cost is obtained from either%  the C matrix or from the edge weights in the 3rd column of |E3|.%%% Example 1: all-pairs shortest distances and paths using [A,xy] inputs%   n = 7; A = zeros(n); xy = 10*rand(n,2);%   tri = delaunay(xy(:,1),xy(:,2));%   I = tri(:); J = tri(:,[2 3 1]); J = J(:);%   IJ = I + n*(J-1); A(IJ) = 1;%   [costs,paths] = dijkadvanced(A,xy);%%% Example 2: all-pairs shortest distances and paths using [A,C] inputs%   n = 7; A = zeros(n); xy = 10*rand(n,2)%   tri = delaunay(xy(:,1),xy(:,2));%   I = tri(:); J = tri(:,[2 3 1]); J = J(:);%   IJ = I + n*(J-1); A(IJ) = 1%   a = (1:n); b = a(ones(n,1),:);%   C = round(reshape(sqrt(sum((xy(b,:) - xy(b',:)).^2,2)),n,n))%   [costs,paths] = dijkadvanced(A,C)%%% Example 3: all-pairs shortest distances and paths using [V,E] inputs%   n = 7; V = 10*rand(n,2)%   I = delaunay(V(:,1),V(:,2));%   J = I(:,[2 3 1]); E = [I(:) J(:)]%   [costs,paths] = dijkadvanced(V,E)%%% Example 4: all-pairs shortest distances and paths using [V,E3] inputs%   n = 7; V = 10*rand(n,2)%   I = delaunay(V(:,1),V(:,2));%   J = I(:,[2 3 1]);%   D = sqrt(sum((V(I(:),:) - V(J(:),:)).^2,2));%   E3 = [I(:) J(:) D]%   [costs,paths] = dijkadvanced(V,E3)%%% Example 5: shortest distances and paths from the 3rd point to all the rest%   n = 7; V = 10*rand(n,2)%   I = delaunay(V(:,1),V(:,2));%   J = I(:,[2 3 1]); E = [I(:) J(:)]%   [costs,paths] = dijkadvanced(V,E,3)%%% Example 6: shortest distances and paths from all points to the 2nd%   n = 7; A = zeros(n); xy = 10*rand(n,2)%   tri = delaunay(xy(:,1),xy(:,2));%   I = tri(:); J = tri(:,[2 3 1]); J = J(:);%   IJ = I + n*(J-1); A(IJ) = 1%   [costs,paths] = dijkadvanced(A,xy,1:n,2)%%% Example 7: shortest distance and path from points [1 3 4] to%   % [2 3 5 7]%   n = 7; V = 10*rand(n,2)%   I = delaunay(V(:,1),V(:,2));%   J = I(:,[2 3 1]); E = [I(:) J(:)]%   [costs,paths] = dijkadvanced(V,E,[1 3 4],[2 3 5 7])%%% Example 8: shortest distance and path between two points%   n = 1000; A = zeros(n); xy = 10*rand(n,2);%   tri = delaunay(xy(:,1),xy(:,2));%   I = tri(:); J = tri(:,[2 3 1]); J = J(:);%   D = sqrt(sum((xy(I,:)-xy(J,:)).^2,2));%   I(D > 0.75,:) = []; J(D > 0.75,:) = [];%   IJ = I + n*(J-1); A(IJ) = 1;%   [cost,path] = dijkadvanced(A,xy,1,n);%   gplot(A,xy,'k.:'); hold on;%   plot(xy(path,1),xy(path,2),'ro-','LineWidth',2); hold off%   title(sprintf('Distance from 1 to 1000 = %1.3f',cost))%%% Acknowledgment% author: Joseph Kirk  - email: jdkirk630@gmail.com - % source:     http://www.mathworks.com/matlabcentral/fileexchange/20025% release: 1.1%%% Contact% <mailto:grazzja@lanl.gov J.Grazzini> (ISR-2/LANL)%%% See also% Related:% <DIJKSTRA.html |DIJKSTRA|>,% <DIJK_BASE.html |DIJK_BASE|>,% <../../propagation/html/FMM_BASE.html |FMM_BASE|>,% <../../propagation/html/DIJKSTRAPROPAGATION_BASE.html |DIJKSTRAPROPAGATION_BASE|>,% <matlab:webpub(whichpath('GPLOT')) |GPLOT|>,% <matlab:webpub(whichpath('DISTMAT')) |DISTMAT|>.%% Function implementationfunction [costs,paths] = dijkadvanced(AorV, xyCorE, SID, FID)%% % checking variableserror(nargoutchk(1, 2, nargout, 'struct'));error(nargchk(1, 4, nargin, 'struct'));% we allow variable nargin for this functionif nargin<4,  FID = [];    if nargin<3,  SID = [];  endendn = size(AorV,1);                                                  if isempty(FID),  FID = (1:n);        endif isempty(SID),  SID = (1:n);        endif max(SID) > n || min(SID) < 1    error('dijkadvanced:inputerror', 'invalid [SID] input');elseif max(FID) > n || min(FID) < 1    error('dijkadvanced:inputerror', 'invalid [FID] input');end%%% main calculation% process Inputs[n,nc] = size(AorV);                                                   %#ok[E, cost, all_positive] = processInputs(AorV,xyCorE);                               % all_positive = true;isreversed = 0;if length(FID) < length(SID)    E = E(:,[2 1]);    cost = cost';    tmp = SID;    SID = FID;    FID = tmp;    isreversed = 1;endL = length(SID);M = length(FID);costs = zeros(L,M);paths = num2cell(nan(L,M));% find the Minimum Costs and Paths using Dijkstra's Algorithmfor k = 1:L    % Initializations    if all_positive,  TBL = sparse(1,n);     else              TBL = NaN(1,n);    end                              min_cost = Inf(1,n);    settled = zeros(1,n);    path = num2cell(nan(1,n));    I = SID(k);    min_cost(I) = 0;    TBL(I) = 0;    settled(I) = 1;    path(I) = {I};        while any(~settled(FID))        % Update the Table        TAB = TBL;        if all_positive,  TBL(I) = 0;         else              TBL(I) = NaN;  end                                  nids = find(E(:,1) == I);        % Calculate the Costs to the Neighbor Points and Record Paths        for kk = 1:length(nids)            J = E(nids(kk),2);            if ~settled(J)                c = cost(I,J);                if all_positive,  empty = ~TAB(J);                 else              empty = isnan(TAB(J));  end                       if empty || (TAB(J) > (TAB(I) + c))                    TBL(J) = TAB(I) + c;                    if isreversed                        path{J} = [J path{I}];                    else                        path{J} = [path{I} J];                    end                else                    TBL(J) = TAB(J);                end            end        end                if all_positive,  K = find(TBL);         else              K = find(~isnan(TBL));  end                        % Find the Minimum Value in the Table        N = find(TBL(K) == min(TBL(K)));        if isempty(N)            break        else            % Settle the Minimum Value            I = K(N(1));            min_cost(I) = TBL(I);            settled(I) = 1;        end    end    % Store Costs and Paths    costs(k,:) = min_cost(FID);    paths(k,:) = path(FID);    endif isreversed    costs = costs';    paths = paths';endif L == 1 && M == 1    paths = paths{1};endend % end of dijkadvanced%% Subfunctions%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-function [E, C, all_positive] = processInputs(AorV,xyCorE)[n,nc] = size(AorV);                                                   [m,mc] = size(xyCorE);                                                C = sparse(n,n);if n == nc    if m == n        if m == mc % Inputs: A,cost            A = AorV;            A = A - diag(diag(A));            C = xyCorE;            all_positive = all(C(logical(A)) > 0);                                 E = a2e(A);        else % Inputs: A,xy            A = AorV;            A = A - diag(diag(A));            xy = xyCorE;            E = a2e(A);            D = ve2d(xy,E);            all_positive = all(D > 0);                                            for row = 1:length(D)                C(E(row,1),E(row,2)) = D(row);            end        end    else        error('dijkadvanced:errorinput', ...            'invalid [A,xy] or [A,cost] inputs');    endelse    if mc == 2 % Inputs: V,E        V = AorV;        E = xyCorE;        D = ve2d(V,E);        all_positive = all(D > 0);                                            for row = 1:m            C(E(row,1),E(row,2)) = D(row);        end    elseif mc == 3 % Inputs: V,E3        E3 = xyCorE;        all_positive = all(E3 > 0);                                           E = E3(:,1:2);        for row = 1:m            C(E3(row,1),E3(row,2)) = E3(row,3);        end    else        error('dijkadvanced:errorinput', ...            'invalid [V,E] inputs');    endendend%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction E = a2e(A)% Convert Adjacency Matrix to Edge List[I,J] = find(A);E = [I J];end%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction D = ve2d(V,E)% Compute Euclidean Distance for EdgesVI = V(E(:,1),:);VJ = V(E(:,2),:);D = sqrt(sum((VI - VJ).^2,2));end##### SOURCE END #####-->  </body></html>