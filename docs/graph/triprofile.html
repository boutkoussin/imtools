<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html>  <head>    <meta content="text/html; charset=utf-8" http-equiv="content-type">    <!--This HTML was auto-generated from MATLAB code.To make changes, update the MATLAB code and republish this document.      -->    <title>TRIPROFILE -</title>    <meta name="generator" content="MATLAB 7.14">    <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">    <meta name="DC.date" content="2012-05-31">    <meta name="DC.source" content="triprofile.m">    <style type="text/css">html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}html { min-height:100%; margin-bottom:1px; }html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }html body td { vertical-align:top; text-align:left; }h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }a { color:#005fce; text-decoration:none; }a:hover { color:#005fce; text-decoration:underline; }a:visited { color:#004aa0; text-decoration:none; }p { padding:0px; margin:0px 0px 20px; }img { padding:0px; margin:0px 0px 20px; border:none; }p img, pre img, tt img, li img { margin-bottom:0px; } ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }ul li { padding:0px; margin:0px 0px 7px 0px; }ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }ul li ol li { list-style:decimal; }ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }ol li ol li { list-style-type:lower-alpha; }ol li ul { padding-top:7px; }ol li ul li { list-style:square; }.content { font-size:1.2em; line-height:140%; padding: 20px; }pre, tt, code { font-size:12px; }pre { margin:0px 0px 20px; }pre.error { color:red; }pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }span.keyword { color:#0000FF }span.comment { color:#228B22 }span.string { color:#A020F0 }span.untermstring { color:#B20000 }span.syscmd { color:#B28C00 }.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }.footer p { margin:0px; }  </style>  </head>  <body>    <div class="content">      <h1>TRIPROFILE -</h1>      <!--introduction--><!--/introduction-->      <h2>Contents</h2>      <div>        <ul>          <li><a href="#1">Description</a></li>          <li><a href="#2">Algorithm</a></li>          <li><a href="#3">Syntax</a></li>          <li><a href="#4">Inputs</a></li>          <li><a href="#5">Outputs</a></li>          <li><a href="#6">Remarks</a></li>          <li><a href="#8">See also</a></li>          <li><a href="#9">Function implementation</a></li>          <li><a href="#33">Subfunctions</a></li>        </ul>      </div>      <h2>Description<a name="1"></a></h2>      <p>Given the set of vertex connected components and the indices of the so        called junction vertices in an order-3 graph, find all possible vertex        profiles by reconnecting pairs of components in the graph that share a        junction.</p>      <h2>Algorithm<a name="2"></a></h2>      <p>#</p>      <h2>Syntax<a name="3"></a></h2>      <pre>     P = triprofile(P, junction, neighbors);</pre>      <h2>Inputs<a name="4"></a></h2>      <p><b><tt>P</tt></b> :</p>      <p><b><tt>junction</tt></b> :</p>      <p><b><tt>neighbors</tt></b> :</p>      <h2>Outputs<a name="5"></a></h2>      <p><b><tt>P</tt></b> :</p>      <h2>Remarks<a name="6"></a></h2>      <p>we distinguish three types of vertices (see also <tt>TRICOMPONENTS</tt>):</p>      <div>        <ul>          <li>junction vertices of order 3 exactly (index given by <tt>find(sum(G,2)==3)</tt>            when considering the adjacency graph)</li>          <li>sleeve vertices of order 2 exactly ( <tt>find(sum(G,2)==2)</tt>),</li>          <li>terminal vertices of order 1 (<tt>find(sum(G,2)==1)</tt>).</li>        </ul>      </div>      <h2>See also<a name="8"></a></h2>      <p>Ressembles: <a href="triadjacency.html"><tt>TRIADJACENCY</tt></a>, <a href="tricomponents.html"><tt>TRICOMPONENTS</tt></a>.        Requires: <a href="../graph/dijkadvanced.html"><tt>DIJKADVANCED</tt></a>,        <a href="../algebra/accumarrayset.html"><tt>ACCUMARRAYSET</tt></a>,        <a href="../algebra/allcombs.html"><tt>ALLCOMBS</tt></a>. <a href="../algebra/cellnumsubtrim.html"><tt>CELLNUMSUBTRIM</tt></a>,        <a href="matlab:webpub%28whichpath%28%27SPARSE%27%29%29"><tt>SPARSE</tt></a>,        <a href="matlab:webpub%28whichpath%28%27ISMEMBER%27%29%29"><tt>ISMEMBER</tt></a>,        <a href="matlab:webpub%28whichpath%28%27SETDIFF%27%29%29"><tt>SETDIFF</tt></a>,        <a href="matlab:webpub%28whichpath%28%27UNIQUE%27%29%29"><tt>UNIQUE</tt></a>,        <a href="matlab:webpub%28whichpath%28%27TRIU%27%29%29"><tt>TRIU</tt></a>,        <a href="matlab:webpub%28whichpath%28%27CELLFUN%27%29%29"><tt>CELLFUN</tt></a>.</p>      <h2>Function implementation<a name="9"></a></h2>      <pre class="codeinput"><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> P = triprofile(P, junction, neighbors, rec)</pre>      <pre class="codeinput"><span class="keyword">if</span> nargin&lt;4 || isempty(rec),  rec=false;  <spanclass="keyword">end</span></pre>      <p>easy case: no junction, a single connected component</p>      <pre class="codeinput"><span class="keyword">if</span> isempty(junction),  <spanclass="keyword">return</span>;  <spanclass="keyword">end</span></pre>      <div>        <ul>          <li>first, consider all the paths and concatenate them (in head and/or            tail position(s)) with the junction vertex(s) they are connected            with</li>        </ul>      </div>      <p>we define a utility function for extracting head and tail vertices</p>      <pre class="codeinput">headortail = @(P,d) cellfun(@(p) p(1+d*(length(p)-1)), P, <spanclass="string">'Uniform'</span>, false);headtail = @(P)  cellfun(@(x,y) [x y], headortail(P,0), headortail(P,1), <span class="keyword">...</span>    <span class="string">'Uniform'</span>, false);<span class="comment">% note: the use of 'end' instead of length(p) is prohibited...</span></pre>      <p>first prolong the heads and the tails of all other profiles (those        identified with length&gt;1) with the junction vertex they are connected        to, if any; note that the head (ibid, the tail) of a vertex profile is        connected to at most one junction vertex... otherwise it would have        itself been identified as a junction vertex!</p>      <pre class="codeinput">I = cellfun(@(p) length(p)&gt;1, P);<span class="keyword">if</span> any(I)</pre>      <p>connect the junction vertices to the heads and/or tails of the profiles</p>      <pre class="codeinput">    <span class="comment">% retrieve the first vertex of each path</span>    ht = headortail(P(I),0);    <span class="comment">% find the (unique) junction vertex connected to the head of the profiles</span>    <span class="comment">% (NaN when it does not exist)</span>    T = junctionleave(ht, neighbors, junction);    <span class="comment">% prolong the head of the profiles (when possible, nothing otherwise)</span>    P(I) = cellfun(@(p,t) [t(~isnan(t)); p], P(I), T, <span class="string">'Uniform'</span>, false);</pre>      <p>ibid, prolong the tails of the profile with its connected junction        vertices when possible</p>      <pre class="codeinput">    ht = headortail(P(I),1);    T = junctionleave(ht, neighbors, junction);    P(I) = cellfun(@(p,t) [p; t(~isnan(t))], P(I), T, <span class="string">'Uniform'</span>, false);</pre>      <pre class="codeinput"><span class="keyword">else</span> <span class="comment">% we are done...</span>    <span class="keyword">return</span>;<span class="keyword">end</span></pre>      <p>some vertices may be left 'alone': typically isolated vertices not        discarded because they do link to an endpoint; this should happen only        if we have not discarded isolated vertex component made of 1 vertex (see        also function <tt>TRIPATH</tt>); ie. if we use the command</p>      <pre>  P(cellfun(@(p) length(p)&lt;1,P)) = [];</pre>      <p>in the line code prior to the last one, instead of:</p>      <pre>  |P(cellfun(@(p) length(p)&lt;=1,P)) = [];|</pre>      <pre class="codeinput">I = cellfun(@(p) length(p)==1, P);<span class="keyword">if</span> ~isempty(I)    I = find(I);    <span class="comment">% retrieve the 1st vertex of the profiles: this is the only vertex in</span>    <span class="comment">% the case of profiles in I</span>    ht = headortail(P(I),0);    <span class="comment">% compute, when they exist, the connected junction vertex</span>    T = junctionleave(ht, neighbors, junction);    <span class="comment">% update the profiles by concatenating the isolated vertices with their</span>    <span class="comment">% connected vertices</span>    T = cellfun(@(t) t(~isnan(t)), T, <span class="string">'Uniform'</span>, false);    <span class="comment">% note that some vertices may be connected to two junction vertices: thus</span>    <span class="comment">% they will have two neighbour vertices and they should be connected in</span>    <span class="comment">% between those two neighbours</span>    K = cellfun(@isempty,T);  I(K) = [];  T(K) = [];    P(I) = cellfun(@(p,t) [t(1); p], P(I), T, <span class="string">'Uniform'</span>, false);    K = cellfun(@(t)length(t)~=2,T);  I(K) = [];  T(K) = [];    <span class="keyword">if</span> any(I),        P(I) = cellfun(@(p,t) [p; t(2)], P(I), T, <span class="string">'Uniform'</span>, false);    <span class="keyword">end</span>    <span class="comment">% the others: unchanged</span><span class="keyword">end</span></pre>      <div>        <ul>          <li>then, we focus on multiple junctions: junction vertex neighbour of            other junction vertices</li>        </ul>      </div>      <p>identify the junction vertices that are also connected to (an)other        junction vertice(s)</p>      <pre class="codeinput">I = sum(ismember(neighbors(junction,:),junction),2);</pre>      <p>consider the situation where multiple junction vertices are connected        to each other; we build optimal profiles of junction vertices from        'leave' junction vertices (connected to only one other junction vertex)        to similar leave junction vertices, and going through junction vertices        flanking more than one other junction vertex ...uff!</p>      <pre class="codeinput"><span class="keyword">if</span> any(I)    <span class="comment">% we define the 'leaves' of the set of junction vertices: they are those</span>    <span class="comment">% junction vertices that connect to another non junction vertex at least:</span>    <span class="comment">% those 'leaves' will help up reconnect with the set of vertices profiles</span>    leave = find(I==1);    <span class="comment">% we apply Dijkstra's algorithm to build (shortest) path of junction</span>    <span class="comment">% vertices joining the leaves between them</span>    Pj = junctionprofile(neighbors(junction,:), junction, leave);<span class="keyword">else</span>    Pj = [];<span class="comment">% else do nothing</span><span class="keyword">end</span></pre>      <div>        <ul>          <li>before going further, retrieve the set of 'independent' paths, ie.            those that are not completed, and therefore, that are left unchanged</li>        </ul>      </div>      <p>retrieve the head and the tail of the profiles as before (but they may        have been naturally updated in the previous steps)</p>      <pre class="codeinput">ht = cell2mat(headtail(P));</pre>      <p>we find those profiles that are not 'matched' with any other profile:        none of their head and tail vertices are shared by another profile;</p>      <pre class="codeinput">I = junction_no_connection(ht);</pre>      <p>they should be kept as they are in the output profile list</p>      <pre class="codeinput"><span class="keyword">if</span> ~isempty(I)    <span class="comment">% we initialize the output with those profiles</span>    PP = P(I);    <span class="comment">% we discard those profiles from P: no more computation with them</span>    P(I) = [];<span class="keyword">else</span>    PP = [];<span class="keyword">end</span></pre>      <div>        <ul>          <li>proceed now with the merging of the profiles through the            identification and matching of the junction vertices they connect to</li>        </ul>      </div>      <p>create a utility handle function for merging: it returns <tt>profile(end:-1:1)</tt>        when <tt>dir==-1</tt> (flipped) and <tt>profile(1:1:end)</tt> when <tt>dir==1</tt>        (unchanged)</p>      <pre class="codeinput">flipp = @(p, dir) <span class="keyword">...</span><spanclass="comment">  % flip a profile depending on dir</span>    p(((1-length(p))*dir+length(p)+1)/2 : <span class="keyword">...</span>    dir : <span class="keyword">...</span>    ((length(p)-1)*dir+length(p)+1)/2);</pre>      <p>we go back to consider the multiple junction profiles to ensure that        they can be connected to other profiles when possible</p>      <pre class="codeinput"><span class="keyword">if</span> ~isempty(P) &amp;&amp; ~isempty(Pj)    nP = numel(P);    <span class="comment">% first merge both profiles lists</span>    P(end+1:end+numel(Pj)) = Pj(:);    <span class="comment">% note: ? why does P = {P(:) Pj(:)} not work?!!!</span>    <span class="comment">% find which profiles connect to each other</span>    ht = cell2mat(headtail(P));    I = junctionconnection(ht);    <span class="comment">% however, we are interested only on those connections involving at</span>    <span class="comment">% least one multiple junctions profile</span>    I = I(any(abs(I)&gt;nP,2),:);    <span class="comment">% then we do merge for those connections only</span>    <span class="keyword">if</span> ~isempty(I),        ni = size(I,1); <span class="comment">% number of completions</span>        <span class="comment">% sort the index so that the lower indices are always on the left:</span>        <span class="comment">% multiple junction indices are on the right</span>        [~,i] = sort(abs(I),2);  i = ni*(i-1)+ndgrid(1:ni,1:2);  I = I(i);        <span class="comment">% identify which multiple junctions are reconnected</span>        i = sign(I);  nm = unique(abs(I(I.*i&gt;nP)));  i = i(:,1);        <span class="comment">% two passes: first complete the head, then the tail (so that we do</span>        <span class="comment">% not duplicate the entries)</span>        P(end+1:end+ni) = <span class="keyword">...</span>            cellfun(@(p1,s1,p2,s2) [flipp(p1,-s1); flipp(p2,s2)], <span class="keyword">...</span>            P(abs(I(:,1))), num2cell(i), <span class="keyword">...</span>            P(abs(I(:,2))), num2cell(sign(I(:,2))), <span class="keyword">...</span>            <span class="string">'Uniform'</span>, false);        <span class="comment">% discard the multiple junctions that have been reconnected at</span>        <span class="comment">% least once</span>        P(nm) = [];        <span class="comment">% discard the reconnected profiles</span>        P(abs(I(:,1))) = [];        <span class="comment">% just to be sure... not really necessary</span>         P = cellnumsubtrim(P, 0);    <span class="keyword">end</span><span class="keyword">end</span><span class="keyword">if</span> rec    <span class="comment">% finally, we can connect all profiles to each other</span>    <span class="keyword">if</span> ~isempty(P)        <span class="comment">% we shall update again the head/tail matrix</span>        ht = cell2mat(headtail(P));        I = junctionconnection(ht);        <span class="keyword">if</span> ~isempty(I)            <span class="comment">% finally merge together by concatenation the profiles whose head of</span>            <span class="comment">% tails match together</span>            P = cellfun(@(p1,s1,p2,s2) [flipp(p1,-s1); flipp(p2,s2)], <span class="keyword">...</span>                P(abs(I(:,1))), num2cell(sign(I(:,1))), <span class="keyword">...</span>                P(abs(I(:,2))), num2cell(sign(I(:,2))), <span class="keyword">...</span>                <span class="string">'Uniform'</span>, false);            <span class="comment">% trim to avoid redundant profiles</span>            P = cellnumsubtrim(P, 0);        <span class="keyword">end</span>    <span class="keyword">end</span><span class="keyword">end</span></pre>      <p>final merge</p>      <pre class="codeinput">P(end+1:end+numel(PP)) = PP(:);</pre>      <p>final clean up: get rid of the junction vertices left alone in 1-length        paths (they have been merged to other paths anyway)</p>      <pre class="codeinput">P(cellfun(@(p) length(p)==1, P)) = [];</pre>      <p>get rid of those inserted junction that appear in both profiles        connected through when concatenating</p>      <pre class="codeinput">P = cellfun(@(p) p([diff(p)~=0; true]), P, <span class="string">'Uniform'</span>, false);</pre>      <pre class="codeinput"><span class="keyword">end</span> <span class="comment">% end of triprofile</span></pre>      <h2>Subfunctions<a name="33"></a></h2>      <p><tt>JUNCTIONLEAVE</tt></p>      <pre class="codeinput"><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> T = junctionleave(ht, neighbors, junction)<span class="comment">% retrieve the neighbors of the leave vertices</span>T = cellfun(@(ht) neighbors(ht(1),:), ht, <span class="string">'Uniform'</span>, false);<span class="comment">% check which one is a junction vertex: there should at most 1 (0 in some</span><span class="comment">% cases)</span>J = cellfun(@(t) ismember(t,junction), T, <span class="string">'Uniform'</span>, false);T = cellfun(@(t,j) t(j), T, J, <span class="string">'Uniform'</span>, false);T(cellfun(@isempty,T)) = {NaN};<span class="comment">% other solution, using isJunction and edges=Tri.edges</span><span class="comment">% T = cell(size(ht,1),1);</span><span class="comment">% % retrieve the neighbors of the leave vertices</span><span class="comment">% TT = cellfun(@(ht) neighbors(ht(1),:), ht, 'Uniform', false);</span><span class="comment">% % check for NaN's</span><span class="comment">% TT = cellfun(@(t) t(~isnan(t)), TT, 'Uniform', false);</span><span class="comment">% J = cellfun(@isempty,TT);</span><span class="comment">% % those with</span><span class="comment">% T(J) = {NaN};  TT(J) = [];  ht(J) = [];</span><span class="comment">% % find the edge that is a junction edge (not more than one for</span><span class="comment">% % those vertices), discard those vertices that are not flanking any</span><span class="comment">% % junction edge</span><span class="comment">% E = cellfun(@(T,ht) ...</span><span class="comment">%     cell2mat(arrayfun(@(t) ...</span><span class="comment">%     intersect(edges(t,:),edges(ht(1),:)), T, 'Uniform', false)), ...</span><span class="comment">%     TT, ht, 'Uniform', false);</span><span class="comment">% E = cellfun(@(e) isJunction(e), E, 'Uniform', false);</span><span class="comment">% % retrieve the corresponding vertices</span><span class="comment">% T(~J) = cellfun(@(t,e) t(e), TT, E, 'Uniform', false);</span><span class="comment">% T(cellfun(@isempty,T)) = {NaN};</span><span class="keyword">end</span></pre>      <p><tt>JUNCTIONPROFILE</tt></p>      <pre class="codeinput"><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> Pj = junctionprofile(neighbors, junction, leave)<span class="comment">% count</span>nJunction = numel(junction);<span class="comment">% rearrange the neightbors and junction in order to have a (1 &lt;-&gt; 1)</span><span class="comment">% correspondance matrix between junction vertices and their neighbours</span>TT = [repmat((1:nJunction)',[3 1]) neighbors(:)];[~,TT(:,2)] = ismember(TT(:,2),junction);TT = TT(TT(:,2)~=0,:);<span class="comment">% remark: no need to duplicate T as the entries are already present</span><span class="comment">% twice considering we deal with 'doubled' junctions</span>G  = sparse(TT(:,1), TT(:,2), ones(size(TT(:,1))), nJunction, nJunction);<span class="comment">% we use Dijkstra here to extract paths going through junction vertices</span><span class="comment">% only</span>[~,Pj] = dijkadvanced(G, G, leave, leave);nPj = size(Pj,1); <span class="comment">% length(leave)</span><span class="comment">% transform the output paths to keep the non redundant ones</span>Pj = Pj(logical(triu(ones(nPj,nPj),1)));<span class="comment">% get rid of the NaN paths: set of junction vertices not connected together</span>Pj(cellfun(@(p) isnan(p(1)), Pj)) = [];<span class="comment">% retrieve the ID of the junction vertex along the paths</span>Pj = cellfun(@(p) junction(p), Pj, <span class="string">'Uniform'</span>, false);<span class="keyword">end</span></pre>      <p><tt>JUNCTION_NO_CONNECTION</tt></p>      <pre class="codeinput"><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> J = junction_no_connection(ht)np = numel(ht) / 2;[m, ~] = accumarrayset(ht(:), [(1:np) (1:np)], true);<span class="comment">% note that closed shapes may induce closed vertices profiles (cycles) where</span><span class="comment">% the head and the tail coincide</span>m = cellfun(@unique, m, <span class="string">'Uniform'</span>, false);J = cellfun(@(m) length(m) == 1,  m);J = setdiff(cell2mat(m(J)), cell2mat(m(~J)));<span class="keyword">end</span></pre>      <p><tt>JUNCTIONCONNECTION</tt></p>      <pre class="codeinput"><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> J = junctionconnection(ht)np = numel(ht) / 2; <span class="comment">% in fact, the number of profiles</span><span class="comment">% !careful not to write nP: the scope of the function interferes</span><span class="comment">% with the outside nP, which we do not want</span><span class="comment">% group together the profiles' indices (positive for head, negative for tail)</span><span class="comment">% corresponding to an identical junction profile</span>J = accumarrayset(ht(:), ([1:np -1:-1:-np]'),true);<span class="comment">% find all possible combinations for a same junction vertex ID</span>J = cellfun(@(x) allcombs(x,x), J, <span class="string">'Uniform'</span>, false);<span class="comment">% get rid of double entries in the matrix</span>J = cellfun(@(x) unique(sort(x,2),<span class="string">'rows'</span>), J, <spanclass="string">'Uniform'</span>, false);<span class="comment">% get rid of row doublons (same absolute value, head and tail</span><span class="comment">% together): a profile would be connected to itself otherwise</span>J = cellfun(@(x) x(abs(x(:,1))~=abs(x(:,2)),:), J, <span class="string">'Uniform'</span>, false);<span class="comment">% transform it into a (n,2) matrix</span>J = cell2mat(J); <span class="comment">%  nonzeros(cell2mat(J));</span><span class="keyword">end</span></pre></div>    <!--##### SOURCE BEGIN #####%% TRIPROFILE - %%% Description% Given the set of vertex connected components and the indices of the so % called junction vertices in an order-3 graph, find all possible vertex% profiles by reconnecting pairs of components in the graph that share a% junction.%%% Algorithm% #%%% Syntax%       P = triprofile(P, junction, neighbors);%%% Inputs% *|P|* : %     %% *|junction|* : %     %% *|neighbors|* : %     %%% Outputs% *|P|* : %     %%% Remarks% we distinguish three types of vertices (see also |TRICOMPONENTS|):%% * junction vertices of order 3 exactly (index given by |find(sum(G,2)==3)|% when considering the adjacency graph)% * sleeve vertices of order 2 exactly ( |find(sum(G,2)==2)|),% * terminal vertices of order 1 (|find(sum(G,2)==1)|). %%% Credit% <mailto:grazzja@lanl.gov J.Grazzini> (ISR-2/LANL)%%% See also% Ressembles:% <triadjacency.html |TRIADJACENCY|>,% <tricomponents.html |TRICOMPONENTS|>.% Requires:% <../graph/dijkadvanced.html |DIJKADVANCED|>,% <../algebra/accumarrayset.html |ACCUMARRAYSET|>,% <../algebra/allcombs.html |ALLCOMBS|>.% <../algebra/cellnumsubtrim.html |CELLNUMSUBTRIM|>,% <matlab:webpub(whichpath('SPARSE')) |SPARSE|>,% <matlab:webpub(whichpath('ISMEMBER')) |ISMEMBER|>,% <matlab:webpub(whichpath('SETDIFF')) |SETDIFF|>,% <matlab:webpub(whichpath('UNIQUE')) |UNIQUE|>,% <matlab:webpub(whichpath('TRIU')) |TRIU|>,% <matlab:webpub(whichpath('CELLFUN')) |CELLFUN|>.%% Function implementation%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction P = triprofile(P, junction, neighbors, rec) if nargin<4 || isempty(rec),  rec=false;  end%%% easy case: no junction, a single connected componentif isempty(junction),  return;  end%%% * first, consider all the paths and concatenate them (in head and/or tail% position(s)) with the junction vertex(s) they are connected with%%% we define a utility function for extracting head and tail verticesheadortail = @(P,d) cellfun(@(p) p(1+d*(length(p)-1)), P, 'Uniform', false);                                 headtail = @(P)  cellfun(@(x,y) [x y], headortail(P,0), headortail(P,1), ...    'Uniform', false); % note: the use of 'end' instead of length(p) is prohibited...%%% first prolong the heads and the tails of all other profiles (those identified% with length>1) with the junction vertex they are connected to, if any; note% that the head (ibid, the tail) of a vertex profile is connected to at most% one junction vertex... otherwise it would have itself been identified as a% junction vertex!I = cellfun(@(p) length(p)>1, P); if any(I)    %%     % connect the junction vertices to the heads and/or tails of the profiles        % retrieve the first vertex of each path    ht = headortail(P(I),0);        % find the (unique) junction vertex connected to the head of the profiles    % (NaN when it does not exist)    T = junctionleave(ht, neighbors, junction);    % prolong the head of the profiles (when possible, nothing otherwise)    P(I) = cellfun(@(p,t) [t(~isnan(t)); p], P(I), T, 'Uniform', false);    %%    % ibid, prolong the tails of the profile with its connected junction vertices    % when possible    ht = headortail(P(I),1);    T = junctionleave(ht, neighbors, junction);    P(I) = cellfun(@(p,t) [p; t(~isnan(t))], P(I), T, 'Uniform', false);else % we are done...    return;end%%% some vertices may be left 'alone': typically isolated vertices not discarded% because they do link to an endpoint;% this should happen only if we have not discarded isolated vertex component % made of 1 vertex (see also function |TRIPATH|); ie. if we use the command%%    P(cellfun(@(p) length(p)<1,P)) = [];%% in the line code prior to the last one, instead of:%%    |P(cellfun(@(p) length(p)<=1,P)) = [];|I = cellfun(@(p) length(p)==1, P);  if ~isempty(I)    I = find(I);    % retrieve the 1st vertex of the profiles: this is the only vertex in    % the case of profiles in I    ht = headortail(P(I),0);    % compute, when they exist, the connected junction vertex    T = junctionleave(ht, neighbors, junction);    % update the profiles by concatenating the isolated vertices with their    % connected vertices    T = cellfun(@(t) t(~isnan(t)), T, 'Uniform', false);    % note that some vertices may be connected to two junction vertices: thus    % they will have two neighbour vertices and they should be connected in    % between those two neighbours    K = cellfun(@isempty,T);  I(K) = [];  T(K) = [];    P(I) = cellfun(@(p,t) [t(1); p], P(I), T, 'Uniform', false);    K = cellfun(@(t)length(t)~=2,T);  I(K) = [];  T(K) = [];    if any(I),        P(I) = cellfun(@(p,t) [p; t(2)], P(I), T, 'Uniform', false);    end    % the others: unchangedend    %%% * then, we focus on multiple junctions: junction vertex neighbour of other% junction vertices%%% identify the junction vertices that are also connected to (an)other junction% vertice(s)I = sum(ismember(neighbors(junction,:),junction),2);%%% consider the situation where multiple junction vertices are connected to% each other; we build optimal profiles of junction vertices from 'leave' % junction vertices (connected to only one other junction vertex) to similar% leave junction vertices, and going through junction vertices flanking more% than one other junction vertex ...uff!%if any(I)    % we define the 'leaves' of the set of junction vertices: they are those    % junction vertices that connect to another non junction vertex at least:    % those 'leaves' will help up reconnect with the set of vertices profiles    leave = find(I==1);        % we apply Dijkstra's algorithm to build (shortest) path of junction    % vertices joining the leaves between them    Pj = junctionprofile(neighbors(junction,:), junction, leave);else    Pj = [];% else do nothingend%%% * before going further, retrieve the set of 'independent' paths, ie. those % that are not completed, and therefore, that are left unchanged%%% retrieve the head and the tail of the profiles as before (but they may% have been naturally updated in the previous steps)ht = cell2mat(headtail(P));%%% we find those profiles that are not 'matched' with any other profile: none% of their head and tail vertices are shared by another profile; I = junction_no_connection(ht);%%% they should be kept as they are in the output profile listif ~isempty(I)    % we initialize the output with those profiles    PP = P(I);    % we discard those profiles from P: no more computation with them    P(I) = [];else    PP = [];end%%% * proceed now with the merging of the profiles through the identification% and matching of the junction vertices they connect to%%% create a utility handle function for merging: it returns |profile(end:-1:1)|% when |dir==-1| (flipped) and |profile(1:1:end)| when |dir==1| (unchanged)flipp = @(p, dir) ...  % flip a profile depending on dir    p(((1-length(p))*dir+length(p)+1)/2 : ...    dir : ...    ((length(p)-1)*dir+length(p)+1)/2);%% % we go back to consider the multiple junction profiles to ensure that they% can be connected to other profiles when possibleif ~isempty(P) && ~isempty(Pj)    nP = numel(P);    % first merge both profiles lists    P(end+1:end+numel(Pj)) = Pj(:);    % note: ? why does P = {P(:) Pj(:)} not work?!!!    % find which profiles connect to each other    ht = cell2mat(headtail(P));    I = junctionconnection(ht);    % however, we are interested only on those connections involving at    % least one multiple junctions profile    I = I(any(abs(I)>nP,2),:);        % then we do merge for those connections only    if ~isempty(I),          ni = size(I,1); % number of completions        % sort the index so that the lower indices are always on the left:        % multiple junction indices are on the right        [~,i] = sort(abs(I),2);  i = ni*(i-1)+ndgrid(1:ni,1:2);  I = I(i);        % identify which multiple junctions are reconnected        i = sign(I);  nm = unique(abs(I(I.*i>nP)));  i = i(:,1);        % two passes: first complete the head, then the tail (so that we do        % not duplicate the entries)        P(end+1:end+ni) = ...            cellfun(@(p1,s1,p2,s2) [flipp(p1,-s1); flipp(p2,s2)], ...            P(abs(I(:,1))), num2cell(i), ...            P(abs(I(:,2))), num2cell(sign(I(:,2))), ...            'Uniform', false);        % discard the multiple junctions that have been reconnected at        % least once        P(nm) = [];        % discard the reconnected profiles        P(abs(I(:,1))) = [];        % just to be sure... not really necessary         P = cellnumsubtrim(P, 0);    endendif rec    % finally, we can connect all profiles to each other    if ~isempty(P)        % we shall update again the head/tail matrix        ht = cell2mat(headtail(P));        I = junctionconnection(ht);            if ~isempty(I)            % finally merge together by concatenation the profiles whose head of            % tails match together            P = cellfun(@(p1,s1,p2,s2) [flipp(p1,-s1); flipp(p2,s2)], ...                P(abs(I(:,1))), num2cell(sign(I(:,1))), ...                P(abs(I(:,2))), num2cell(sign(I(:,2))), ...                'Uniform', false);                % trim to avoid redundant profiles            P = cellnumsubtrim(P, 0);        end    endend%%% final mergeP(end+1:end+numel(PP)) = PP(:);%%% final clean up: get rid of the junction vertices left alone in 1-length% paths (they have been merged to other paths anyway)P(cellfun(@(p) length(p)==1, P)) = [];%%% get rid of those inserted junction that appear in both profiles connected% through when concatenatingP = cellfun(@(p) p([diff(p)~=0; true]), P, 'Uniform', false);end % end of triprofile%% Subfunctions%%% |JUNCTIONLEAVE|%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction T = junctionleave(ht, neighbors, junction)% retrieve the neighbors of the leave verticesT = cellfun(@(ht) neighbors(ht(1),:), ht, 'Uniform', false);% check which one is a junction vertex: there should at most 1 (0 in some% cases) J = cellfun(@(t) ismember(t,junction), T, 'Uniform', false);T = cellfun(@(t,j) t(j), T, J, 'Uniform', false);T(cellfun(@isempty,T)) = {NaN};% other solution, using isJunction and edges=Tri.edges% T = cell(size(ht,1),1);% % retrieve the neighbors of the leave vertices% TT = cellfun(@(ht) neighbors(ht(1),:), ht, 'Uniform', false);% % check for NaN's% TT = cellfun(@(t) t(~isnan(t)), TT, 'Uniform', false);% J = cellfun(@isempty,TT);% % those with% T(J) = {NaN};  TT(J) = [];  ht(J) = [];% % find the edge that is a junction edge (not more than one for% % those vertices), discard those vertices that are not flanking any% % junction edge% E = cellfun(@(T,ht) ...%     cell2mat(arrayfun(@(t) ...%     intersect(edges(t,:),edges(ht(1),:)), T, 'Uniform', false)), ...%     TT, ht, 'Uniform', false);% E = cellfun(@(e) isJunction(e), E, 'Uniform', false);% % retrieve the corresponding vertices% T(~J) = cellfun(@(t,e) t(e), TT, E, 'Uniform', false);% T(cellfun(@isempty,T)) = {NaN};end%%% |JUNCTIONPROFILE|%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction Pj = junctionprofile(neighbors, junction, leave)% countnJunction = numel(junction);% rearrange the neightbors and junction in order to have a (1 <-> 1)% correspondance matrix between junction vertices and their neighboursTT = [repmat((1:nJunction)',[3 1]) neighbors(:)];[~,TT(:,2)] = ismember(TT(:,2),junction);TT = TT(TT(:,2)~=0,:);% remark: no need to duplicate T as the entries are already present% twice considering we deal with 'doubled' junctionsG  = sparse(TT(:,1), TT(:,2), ones(size(TT(:,1))), nJunction, nJunction);% we use Dijkstra here to extract paths going through junction vertices% only[~,Pj] = dijkadvanced(G, G, leave, leave);nPj = size(Pj,1); % length(leave)% transform the output paths to keep the non redundant onesPj = Pj(logical(triu(ones(nPj,nPj),1)));% get rid of the NaN paths: set of junction vertices not connected togetherPj(cellfun(@(p) isnan(p(1)), Pj)) = [];% retrieve the ID of the junction vertex along the pathsPj = cellfun(@(p) junction(p), Pj, 'Uniform', false);end%%% |JUNCTION_NO_CONNECTION|%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction J = junction_no_connection(ht)np = numel(ht) / 2;[m, ~] = accumarrayset(ht(:), [(1:np) (1:np)], true);% note that closed shapes may induce closed vertices profiles (cycles) where% the head and the tail coincidem = cellfun(@unique, m, 'Uniform', false);J = cellfun(@(m) length(m) == 1,  m);J = setdiff(cell2mat(m(J)), cell2mat(m(~J)));end%%% |JUNCTIONCONNECTION|%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction J = junctionconnection(ht)np = numel(ht) / 2; % in fact, the number of profiles% !careful not to write nP: the scope of the function interferes% with the outside nP, which we do not want% group together the profiles' indices (positive for head, negative for tail)% corresponding to an identical junction profileJ = accumarrayset(ht(:), ([1:np -1:-1:-np]'),true);% find all possible combinations for a same junction vertex IDJ = cellfun(@(x) allcombs(x,x), J, 'Uniform', false);% get rid of double entries in the matrixJ = cellfun(@(x) unique(sort(x,2),'rows'), J, 'Uniform', false);% get rid of row doublons (same absolute value, head and tail% together): a profile would be connected to itself otherwiseJ = cellfun(@(x) x(abs(x(:,1))~=abs(x(:,2)),:), J, 'Uniform', false);% transform it into a (n,2) matrixJ = cell2mat(J); %  nonzeros(cell2mat(J));end##### SOURCE END #####-->  </body></html>