<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html>  <head>    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">    <!--This HTML was auto-generated from MATLAB code.To make changes, update the MATLAB code and republish this document.      -->    <title>DIJKSTRA - Launch Dijkstra algorithm.</title>    <meta name="generator" content="MATLAB 7.14">    <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">    <meta name="DC.date" content="2012-05-31">    <meta name="DC.source" content="dijkstra.m">    <style type="text/css">html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}html { min-height:100%; margin-bottom:1px; }html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }html body td { vertical-align:top; text-align:left; }h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }a { color:#005fce; text-decoration:none; }a:hover { color:#005fce; text-decoration:underline; }a:visited { color:#004aa0; text-decoration:none; }p { padding:0px; margin:0px 0px 20px; }img { padding:0px; margin:0px 0px 20px; border:none; }p img, pre img, tt img, li img { margin-bottom:0px; } ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }ul li { padding:0px; margin:0px 0px 7px 0px; }ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }ul li ol li { list-style:decimal; }ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }ol li ol li { list-style-type:lower-alpha; }ol li ul { padding-top:7px; }ol li ul li { list-style:square; }.content { font-size:1.2em; line-height:140%; padding: 20px; }pre, tt, code { font-size:12px; }pre { margin:0px 0px 20px; }pre.error { color:red; }pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }span.keyword { color:#0000FF }span.comment { color:#228B22 }span.string { color:#A020F0 }span.untermstring { color:#B20000 }span.syscmd { color:#B28C00 }.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }.footer p { margin:0px; }  </style>  </head>  <body>    <div class="content">      <h1>DIJKSTRA - Launch Dijkstra algorithm.</h1>      <!--introduction--><!--/introduction-->      <h2>Contents</h2>      <div>        <ul>          <li><a href="#1">Description</a></li>          <li><a href="#2">Syntax</a></li>          <li><a href="#3">Inputs</a></li>          <li><a href="#4">Outputs</a></li>          <li><a href="#5">Remarks</a></li>          <li><a href="#6">References</a></li>          <li><a href="#8">See also</a></li>          <li><a href="#9">Function implementation</a></li>        </ul>      </div>      <h2>Description<a name="1"></a></h2>      <p>Launch the Dijkstra algorithm [Dijks59]. Enables single and multiple        sources distance calculation from starting points.</p>      <h2>Syntax<a name="2"></a></h2>      <pre class="language-matlab">[dist, path] = DIJKSTRA(W, start_pts, end_pts, m_seed, niter);</pre>      <pre class="language-matlab"><span class="comment">% all-pairs shortest distance</span>dist = DIJKSTRA(W);dist = DIJKSTRA(W, [], [], <span class="string">'allpairs'</span>);dist = DIJKSTRA(W, 1:length(W), 1:length(W), <span class="string">'sing'</span>);</pre>      <pre class="language-matlab"><span class="comment">% distance and paths from the set of start_pts to all others points in</span><span class="comment">% the graph</span>[dist, path] = dijkstra(W, start_pts, [], <span class="string">'mult'</span>, Inf);</pre>      <h2>Inputs<a name="3"></a></h2>      <p><b><tt>W</tt></b> : weight matrix, <tt>W(i,j)</tt> gives the cost of        moving from <tt>i</tt> to <tt>j</tt>:</p>      <p><tt>W(i,j) = 0 =&gt; edge(i,j)</tt> does not exist, ie. no connexion,</p>      <p><tt>W(i,j) = NaN =&gt; edge(i,j)</tt> exists with null weight;</p>      <p><tt>W</tt> should be sparse matrix; we also expect <tt>W</tt> to be a        symmetric, ie the graph should be undirected: <tt>W(i,j) = W(j,i)</tt>;        still, the 'single source' approaches (see <tt>m_seed='sing'</tt> or <tt>'sing1'</tt>        below) can compute paths and distances for directed graph; however, the        'multiple sources' approach cannot.</p>      <p><b><tt>start_pts</tt></b> : <tt>(1,n)</tt> array, <tt>start_points(:,i)</tt>        is the ith starting point; default: <tt>start_pts</tt> is made of all        points in the graph.</p>      <p><b><tt>end_pts</tt></b> : array of end points to which the distance        should be computed; note that in the case <tt>m_seed='mult'</tt> (see        below), the calculation stops as soon as these points are reached;        default: <tt>end_pts</tt> is made of all points in the graph (see        remark below).</p>      <p><b><tt>m_seed</tt></b> : string setting the function used for        Dijsktra's algorithm; it is either:</p>      <div>        <ul>          <li><tt>'sing'</tt> or <tt>'sing1'</tt> for calculating the distance            and the shortest paths from single sourced graph using the functions            <tt>DIJK</tt> and <tt>DIJKADVANCED</tt> resp.,</li>          <li><tt>'mult'</tt> for calculating shortest paths through propagation            from multiple sources using the function <tt>DIJKSTRAPROPAGATION</tt>:            in that case, the outputs <tt>dist</tt> and <tt>path</tt> (see            below) are resp. the shortest distance and the shortest path from            any point in the list of points given by <tt>start_pts</tt>,</li>          <li><tt>'allpairs'</tt> for calculating allpairs shortest paths in the            graph (it is in fact the same as <tt>'sing'</tt>, renamed for            convenience);</li>        </ul>      </div>      <p>default: <tt>m_seed = 'sing'</tt>.</p>      <p><b><tt>niter</tt></b> : (optional) scalar used with <tt>m_seed='mult'</tt>        for stopping the propagation when a given number of iterations is        reached.</p>      <h2>Outputs<a name="4"></a></h2>      <p><b><tt>dist</tt></b> : distance from <tt>start_pts</tt>; if <tt>m_seed='mult'</tt>,        then <tt>dist</tt> is a vector of size <tt>(1,m)</tt>, with <tt>m</tt>        the number of points in <tt>end_pts</tt>: it gives in fact the distance        from every <tt>end_pts</tt> to the set of <tt>start_pts</tt> (except        in the case <tt>start_pts=end_pts</tt> - see remarks below); if <tt>m_seed='sing'</tt>,        then <tt>dist</tt> is a matrix <tt>(n,m)</tt> with <tt>n</tt> the        number of points in <tt>start_pts</tt>: <tt>dist(i,j)</tt> is the        distance from <tt>start_pts(i)</tt> to <tt>end_pts(j)</tt>.</p>      <p><b><tt>path</tt></b> : paths from <tt>start_pts</tt>; similarly, if <tt>m_seed='mult'</tt>,        then <tt>path</tt> is a cell of size <tt>(1,m)</tt> where each cell <tt>p{j}</tt>        gives the shortest path (as the array of indices of the points belonging        to this path in the graph) from any point in <tt>start_pts</tt> to <tt>end_pts(j)</tt>;        if <tt>m_seed='sing'</tt>, then <tt>path</tt> is a cell <tt>(n,m)</tt>        with <tt>path{i,j}</tt> the shortest path linking <tt>start_pts(i)</tt>        to <tt>end_pts(j)</tt>.</p>      <h2>Remarks<a name="5"></a></h2>      <div>        <ul>          <li>Calls to <tt>DIJKSTRA(W, start_pts, end_pts, 'sing' (or 'sing1'))</tt>            and <tt>DIJKSTRA(W, start_pts, end_pts, 'mult')</tt> are equivalent            when <tt>start_pts</tt> and <tt>end_pts</tt> are equal (all pair            paths are then computed, instead of simply returning a distance null            everywhere).</li>        </ul>      </div>      <div>        <ul>          <li>The <tt>m_seed='mult'</tt> stops as soon as one point among the <tt>end_pts</tt>            is reached. This means that some points may be reached from the <tt>start_pts</tt>            through a path of length <tt>l1</tt> but still have their distance            value equal to <tt>Inf</tt> as some <tt>end_pts</tt> may have been            reached through paths of length <tt>l0&lt;l1</tt>. (note that here            we talk in terms of paths lenghts, not distances).</li>        </ul>      </div>      <div>        <ul>          <li>points which can be reached from any other points in the graph can            be found by launching:</li>        </ul>      </div>      <pre>     d = DIJKSTRA(I, start_pts, end_pts, 'sing');</pre>      <pre class="language-matlab">where <span class="string">|I=logical(W &amp; isnan(W))|</span> <spanclass="string">is</span> <spanclass="string">the</span> <spanclass="string">adjacency</span> <spanclass="string">matrix</span> <spanclass="string">(1 for an edge, 0</span><span class="keyword">for</span> no connection), then <span class="string">calling:</span> <spanclass="string">|d</span> <spanclass="string">&gt;=</span> <spanclass="string">1|.</span>In <span class="string">particular</span>, those <span class="string">points</span> <spanclass="string">mentioned</span> <spanclass="string">in</span> <spanclass="string">the</span> <spanclass="string">previous</span> <spanclass="string">remark</span> <spanclass="string">are</span> <spanclass="string">those</span>satisfying:  |d &gt; 1|.</pre>      <h2>References<a name="6"></a></h2>      <p>[Krusk56] J.B. Kruskal: "On the shortest spanning subtree of a graph        and the travelling salesman problem", Proc. Amer. Math. Soc., 7:48-50,        1956.</p>      <p>[Dijks59] E.W. Dijkstra: "A note on two problems in connexion with        graphs", Numerische Mathematik, 1:269?271, 1959 - available at <a href="http://www-m3.ma.tum.de/twiki/pub/MN0506/WebHome/dijkstra.pdf">http://www-m3.ma.tum.de/twiki/pub/MN0506/WebHome/dijkstra.pdf</a></p>      <p>[CLRS01] T.H. Cormen, C.E. Leiserson, R.L. Rivest and C. Stein:        "Introduction to Algorithms", "Section 24.3: Dijkstra's algorithm", pp.        595?601, MIT Press and McGraw-Hill, 2001.</p>      <h2>See also<a name="8"></a></h2>      <p>Related: <a href="dijkadvanced.html"><tt>DIJKADVANCED</tt></a>, <a href="dijk.html"><tt>DIJK</tt></a>,        <a href="../propagation/dijkstrapropagation.html"><tt>DIJKSTRAPROPAGATION</tt></a>,        <a href="../propagation/fmm_base.html"><tt>FMM_BASE</tt></a>.        Called: <a href="dijkstra_base.html"><tt>DIJKSTRA_BASE</tt></a>.</p>      <h2>Function implementation<a name="9"></a></h2>      <pre class="codeinput"><span class="keyword">function</span> [dist, path] = dijkstra(W, varargin)</pre>      <p>parsing parameters</p>      <pre class="codeinput">error(nargchk(1, 13, nargin, <span class="string">'struct'</span>));error(nargoutchk(1, 2, nargout, <span class="string">'struct'</span>));<span class="comment">% mandatory parameter</span><span class="keyword">if</span> ~(isnumeric(W) || islogical(W))    error(<span class="string">'dijkstra:inputerror'</span>,<span class="string">'matrix required in input'</span>);<span class="keyword">end</span><span class="comment">% optional parameters</span>p = createParser(<span class="string">'DIJKSTRA'</span>);<span class="comment">% principal optional parameters</span>p.addOptional(<span class="string">'start_pts'</span>, [], @(x)isempty(x) || (isvector(x) &amp;&amp; all(x&gt;=1)));p.addOptional(<span class="string">'end_pts'</span>, [], @(x)isempty(x) || (isvector(x) &amp;&amp; all(x&gt;=1)));p.addOptional(<span class="string">'m_seed'</span>, <span class="string">'sing'</span>, @(x)ischar(x) &amp;&amp; <spanclass="keyword">...</span>    any(strcmpi(x,{<span class="string">'allpairs'</span>,<span class="string">'sing'</span>,<spanclass="string">'sing1'</span>,<spanclass="string">'mult'</span>})));<span class="comment">% additional optional parameters</span>p.addOptional(<span class="string">'iter'</span>,Inf, @(x)isscalar(x) &amp; x&gt;0);<span class="comment">% parse and validate all input arguments</span>p.parse(varargin{:});p = getvarParser(p);</pre>      <p>checking/setting the variables</p>      <pre class="codeinput">n = length(W);  <span class="comment">% number of points in the graph</span><span class="keyword">if</span> isempty(p.end_pts),  p.end_pts = 1:n;   <span class="keyword">end</span><span class="keyword">if</span> isempty(p.start_pts),  p.start_pts = 1:n;   <spanclass="keyword">end</span><span class="keyword">if</span> strcmpi(p.m_seed,<span class="string">'allpairs'</span>) || isequal(p.start_pts,p.end_pts)    p.m_seed = <span class="string">'sing'</span>;    <span class="comment">% so that 'allpair' and 'sing' are equivalent</span><span class="keyword">end</span></pre>      <p>main calculation</p>      <pre class="codeinput">[dist, path] = dijkstra_base(W, p.start_pts, p.end_pts, p.m_seed, p.iter);</pre>      <pre class="codeinput"><span class="keyword">end</span> <span class="comment">% end of dijkstra</span></pre></div>    <!--##### SOURCE BEGIN #####%% DIJKSTRA - Launch Dijkstra algorithm.%%% Description% Launch the Dijkstra algorithm [Dijks59]. Enables single and % multiple sources distance calculation from starting points. %%% Syntax%   [dist, path] = DIJKSTRA(W, start_pts, end_pts, m_seed, niter);%%   % all-pairs shortest distance%   dist = DIJKSTRA(W);   %   dist = DIJKSTRA(W, [], [], 'allpairs');   %   dist = DIJKSTRA(W, 1:length(W), 1:length(W), 'sing');   %%   % distance and paths from the set of start_pts to all others points in%   % the graph%   [dist, path] = dijkstra(W, start_pts, [], 'mult', Inf);  %%% Inputs% *|W|* : weight matrix, |W(i,j)| gives the cost of moving from |i| to |j|:%% |W(i,j) = 0 => edge(i,j)| does not exist, ie. no connexion,%% |W(i,j) = NaN => edge(i,j)| exists with null weight;%% |W| should be sparse matrix; we also expect |W| to be a symmetric, ie%     the graph should be undirected: |W(i,j) = W(j,i)|; still, the 'single%     source' approaches (see |m_seed='sing'| or |'sing1'| below) can compute%     paths and distances for directed graph; however,  the 'multiple sources' %     approach cannot. %% *|start_pts|* : |(1,n)| array, |start_points(:,i)| is the ith starting point; %     default: |start_pts| is made of all points in the graph.%% *|end_pts|* : array of end points to which the distance should be computed;%     note that in the case |m_seed='mult'| (see below), the calculation stops%     as soon as these points are reached; default: |end_pts| is made of all %     points in the graph (see remark below).%% *|m_seed|* : string setting the function used for Dijsktra's algorithm; it%     is either: %% * |'sing'| or |'sing1'| for calculating the distance and the shortest%          paths from single sourced graph using the functions |DIJK| and%          |DIJKADVANCED| resp.,% * |'mult'| for calculating shortest paths through propagation from%          multiple sources using the function |DIJKSTRAPROPAGATION|: in%          that case, the outputs |dist| and |path| (see below) are resp. the%          shortest distance and the shortest path from any point in the list%          of points given by |start_pts|,% * |'allpairs'| for calculating allpairs shortest paths in the graph%          (it is in fact the same as |'sing'|, renamed for convenience);%% default: |m_seed = 'sing'|. %% *|niter|* : (optional) scalar used with |m_seed='mult'| for stopping the %     propagation when a given number of iterations is reached.%%% Outputs% *|dist|* : distance from |start_pts|; if |m_seed='mult'|, then |dist| is a%     vector of size |(1,m)|, with |m| the number of points in |end_pts|: it%     gives in fact the distance from every |end_pts| to the set of |start_pts| %     (except in the case |start_pts=end_pts| - see remarks below); if%     |m_seed='sing'|, then |dist| is a matrix |(n,m)| with |n| the number of%     points in |start_pts|: |dist(i,j)| is the distance from |start_pts(i)| to%     |end_pts(j)|.%% *|path|* : paths from |start_pts|; similarly, if |m_seed='mult'|, then |path|%     is a cell of size |(1,m)| where each cell |p{j}| gives the shortest path %     (as the array of indices of the points belonging to this path in the%     graph) from any point in |start_pts| to |end_pts(j)|; if |m_seed='sing'|, %     then |path| is a cell |(n,m)| with |path{i,j}| the shortest path linking%     |start_pts(i)| to |end_pts(j)|.%%% Remarks% * Calls to |DIJKSTRA(W, start_pts, end_pts, 'sing' (or 'sing1'))| and%   |DIJKSTRA(W, start_pts, end_pts, 'mult')| are equivalent when |start_pts| %   and |end_pts| are equal (all pair paths are then computed, instead of%   simply returning a distance null everywhere). %% * The |m_seed='mult'| stops as soon as one point among the |end_pts| is%   reached. This means that some points may be reached from the |start_pts|%   through a path of length |l1| but still have their distance value equal to%   |Inf| as some |end_pts| may have been reached through paths of length |l0<l1|.%   (note that here we talk in terms of paths lenghts, not distances).%% * points which can be reached from any other points in the graph can%   be found by launching: %%       d = DIJKSTRA(I, start_pts, end_pts, 'sing');%%   where |I=logical(W & isnan(W))| is the adjacency matrix (1 for an edge, 0%   for no connection), then calling: |d >= 1|.%   In particular, those points mentioned in the previous remark are those%   satisfying:  |d > 1|.%%% References% [Krusk56]  J.B. Kruskal: "On the shortest spanning subtree of a graph%      and the travelling salesman problem", Proc. Amer. Math. Soc., %      7:48-50, 1956.%% [Dijks59]  E.W. Dijkstra: "A note on two problems in connexion with %      graphs", Numerische Mathematik, 1:269?271, 1959 - available at%          http://www-m3.ma.tum.de/twiki/pub/MN0506/WebHome/dijkstra.pdf %% [CLRS01]  T.H. Cormen, C.E. Leiserson, R.L. Rivest and C. Stein: %      "Introduction to Algorithms", "Section 24.3: Dijkstra's algorithm",%      pp. 595?601, MIT Press and McGraw-Hill, 2001. %%% Credit% <mailto:grazzja@lanl.gov J.Grazzini> (ISR-2/LANL)%%% See also% Related:% <dijkadvanced.html |DIJKADVANCED|>,% <dijk.html |DIJK|>,% <../propagation/dijkstrapropagation.html |DIJKSTRAPROPAGATION|>,% <../propagation/fmm_base.html |FMM_BASE|>.% Called:% <dijkstra_base.html |DIJKSTRA_BASE|>.%% Function implementationfunction [dist, path] = dijkstra(W, varargin)%%% parsing parameterserror(nargchk(1, 13, nargin, 'struct'));error(nargoutchk(1, 2, nargout, 'struct'));% mandatory parameterif ~(isnumeric(W) || islogical(W))    error('dijkstra:inputerror','matrix required in input'); end% optional parametersp = createParser('DIJKSTRA');   % principal optional parametersp.addOptional('start_pts', [], @(x)isempty(x) || (isvector(x) && all(x>=1)));p.addOptional('end_pts', [], @(x)isempty(x) || (isvector(x) && all(x>=1)));p.addOptional('m_seed', 'sing', @(x)ischar(x) && ...    any(strcmpi(x,{'allpairs','sing','sing1','mult'})));% additional optional parametersp.addOptional('iter',Inf, @(x)isscalar(x) & x>0);% parse and validate all input argumentsp.parse(varargin{:}); p = getvarParser(p);                                                            %% % checking/setting the variablesn = length(W);  % number of points in the graphif isempty(p.end_pts),  p.end_pts = 1:n;   endif isempty(p.start_pts),  p.start_pts = 1:n;   endif strcmpi(p.m_seed,'allpairs') || isequal(p.start_pts,p.end_pts)    p.m_seed = 'sing';     % so that 'allpair' and 'sing' are equivalentend%% % main calculation[dist, path] = dijkstra_base(W, p.start_pts, p.end_pts, p.m_seed, p.iter);end % end of dijkstra##### SOURCE END #####--></body></html>