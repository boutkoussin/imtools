<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html>  <head>    <meta content="text/html; charset=utf-8" http-equiv="content-type">    <!--This HTML was auto-generated from MATLAB code.To make changes, update the MATLAB code and republish this document.      -->    <title>GRAPH2MAP_BASE - From a weighted graph to a map.</title>    <meta name="generator" content="MATLAB 7.14">    <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">    <meta name="DC.date" content="2012-05-31">    <meta name="DC.source" content="graph2map_base.m">    <style type="text/css">html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}html { min-height:100%; margin-bottom:1px; }html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }html body td { vertical-align:top; text-align:left; }h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }a { color:#005fce; text-decoration:none; }a:hover { color:#005fce; text-decoration:underline; }a:visited { color:#004aa0; text-decoration:none; }p { padding:0px; margin:0px 0px 20px; }img { padding:0px; margin:0px 0px 20px; border:none; }p img, pre img, tt img, li img { margin-bottom:0px; } ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }ul li { padding:0px; margin:0px 0px 7px 0px; }ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }ul li ol li { list-style:decimal; }ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }ol li ol li { list-style-type:lower-alpha; }ol li ul { padding-top:7px; }ol li ul li { list-style:square; }.content { font-size:1.2em; line-height:140%; padding: 20px; }pre, tt, code { font-size:12px; }pre { margin:0px 0px 20px; }pre.error { color:red; }pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }span.keyword { color:#0000FF }span.comment { color:#228B22 }span.string { color:#A020F0 }span.untermstring { color:#B20000 }span.syscmd { color:#B28C00 }.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }.footer p { margin:0px; }  </style>  </head>  <body>    <div class="content">      <h1>GRAPH2MAP_BASE - From a weighted graph to a map.</h1>      <!--introduction--><!--/introduction-->      <h2>Contents</h2>      <div>        <ul>          <li><a href="#1">Description</a></li>          <li><a href="#2">Syntax</a></li>          <li><a href="#3">Remark</a></li>          <li><a href="#5">See also</a></li>          <li><a href="#6">Function implementation</a></li>        </ul>      </div>      <h2>Description<a name="1"></a></h2>      <p>Convert a spatial (undirected) unweighted graph (given% by an adjacency        matrix and a set of vertices) into a 2D logical map in the domain with        pixels connecting the vertices of the graph through straight lines set        to true. Weights of the edges between the vertices of the network are        also calculated when an implicit 2D cost map is passed.</p>      <h2>Syntax<a name="2"></a></h2>      <pre>     [map, edges] = GRAPH2MAP_BASE(graph, vertex, domain);     [map, edges, wedges] = GRAPH2MAP_BASE(graph, vertex, cost);</pre>      <h2>Remark<a name="3"></a></h2>      <p>Edges between vertices are regarded as straight lines and approximated        using Bresenham's algorithm.</p>      <h2>See also<a name="5"></a></h2>      <p>Related: <a href="GRAPHMAP.html"><tt>GRAPHMAP</tt></a>, <a href="MAP2GRAPH_BASE.html"><tt>MAP2GRAPH_BASE</tt></a>,        <a href="matlab:webpub%28whichpath%28%27GPLOT%27%29%29"><tt>GPLOT</tt></a>.        Called: <a href="BRESENHAMLINE_BASE.html"><tt>BRESENHAMLINE_BASE</tt></a>,        <a href="matlab:webpub%28whichpath%28%27UNIQUE%27%29%29"><tt>SPARSE</tt></a>.</p>      <h2>Function implementation<a name="6"></a></h2>      <pre class="codeinput"><span class="keyword">function</span> [map, edges, wedges] = graph2map_base(graph, vertex, W)</pre>      <p>define the right map domain and reset the vertex</p>      <pre class="codeinput"><span class="keyword">if</span> nb_dims(W)==1    x1 = W(1); y1 = W(2);    <span class="keyword">if</span> length(grid)&gt;=4,  x0 = W(3); y0 = W(4);        <span class="keyword">if</span> length(grid)==6,  stepx = W(5); stepy = W(6);        <span class="keyword">else</span>                 stepx = 1; stepy = 1;        <span class="keyword">end</span>    <span class="keyword">else</span>          x0 = 1; y0 = 1;          stepx = 1; stepy = 1;    <span class="keyword">end</span>    X = length(x0:stepx:x1);    Y = length(y0:stepy:y1);    vertex(:,1) = round( X*(vertex(:,1) - x0 + 1) / (x1 - x0 + 1));    vertex(:,2) = round( Y*(vertex(:,2) - y0 + 1) / (y1 - y0 + 1));    <span class="comment">% +1 because we start counting at 1</span><span class="keyword">else</span>    [X,Y] = size(W);    <span class="comment">% do nothing regarding the vertices: we suppose that they are passed as</span>    <span class="comment">% the coordinates in the appropriate map</span><span class="keyword">end</span>map = false(X,Y);</pre>      <p>extract the vertices</p>      <pre class="codeinput"><span class="comment">% find all the vertices of the graph (note that endpoints are also in this</span><span class="comment">% list)</span>[i,j] = find(graph);<span class="comment">% avoid repeated entries: the graph is supposed to be symmetric</span>edges = unique(sort([i,j],2),<span class="string">'rows'</span>);svert = vertex(edges(:,1),:); <span class="comment">% starting point</span>evert = vertex(edges(:,2),:); <span class="comment">%ending point</span></pre>      <p>define the edges joining the vertices over the map domain</p>      <pre class="codeinput"><span class="comment">% find the coordinates of the pixels laying on the edges linking the</span><span class="comment">% vertices (startvert,endvert)</span>[x y pts] = <span class="keyword">...</span>    bresenhamline_base(svert(:,1),svert(:,2),evert(:,1),evert(:,2));<span class="comment">% (x,y,pts) have the same number of rows as the vectors (svert,evert)</span><span class="comment">% note that BRESENHAMLINE_BASE rounds coordinates</span></pre>      <p>compute the weight of the different edges of the graph</p>      <pre class="codeinput"><span class="keyword">if</span> nb_dims(W)&gt;1 <spanclass="comment">% a cost map</span>    [n,m] = size(x);    x(~pts) = 1;    y(~pts) = 1;    wedges = reshape(W(x+X*(y-1)), [n,m]);    <span class="comment">% the ith-line of wE contains the weight of the pixel liying on the ith</span>    <span class="comment">% edge, then compute the total weight of each edge</span>    wedges = sum(wedges .* pts,2);<span class="keyword">end</span></pre>      <p>'draw' the edges onto the map</p>      <pre class="codeinput">x = x(:); y = y(:); pts = pts(:);x(~pts) = [];    y(~pts) = [];map(x(:)+X*(y(:)-1)) = true;</pre>      <pre class="codeinput"><span class="keyword">end</span> <span class="comment">% end of graph2map_base</span></pre></div>    <!--##### SOURCE BEGIN #####%% GRAPH2MAP_BASE - From a weighted graph to a map. %%% Description% Convert a spatial (undirected) unweighted graph (given% by an adjacency% matrix and a set of vertices) into a 2D logical map in the domain with % pixels connecting the vertices of the graph through straight lines set to% true. Weights of the edges between the vertices of the network are also% calculated when an implicit 2D cost map is passed.%%% Syntax%       [map, edges] = GRAPH2MAP_BASE(graph, vertex, domain);%       [map, edges, wedges] = GRAPH2MAP_BASE(graph, vertex, cost);%%% Remark% Edges between vertices are regarded as straight lines and approximated% using Bresenham's algorithm.% %% Credit% <mailto:grazzja@lanl.gov J.Grazzini> (ISR-2/LANL)%%% See also% Related:% <GRAPHMAP.html |GRAPHMAP|>,% <MAP2GRAPH_BASE.html |MAP2GRAPH_BASE|>,% <matlab:webpub(whichpath('GPLOT')) |GPLOT|>.% Called:% <BRESENHAMLINE_BASE.html |BRESENHAMLINE_BASE|>,% <matlab:webpub(whichpath('UNIQUE')) |SPARSE|>.%% Function implementationfunction [map, edges, wedges] = graph2map_base(graph, vertex, W)%% % define the right map domain and reset the vertexif nb_dims(W)==1    x1 = W(1); y1 = W(2);     if length(grid)>=4,  x0 = W(3); y0 = W(4);        if length(grid)==6,  stepx = W(5); stepy = W(6);        else                 stepx = 1; stepy = 1;          end    else          x0 = 1; y0 = 1;            stepx = 1; stepy = 1;      end        X = length(x0:stepx:x1);    Y = length(y0:stepy:y1);            vertex(:,1) = round( X*(vertex(:,1) - x0 + 1) / (x1 - x0 + 1));    vertex(:,2) = round( Y*(vertex(:,2) - y0 + 1) / (y1 - y0 + 1));    % +1 because we start counting at 1else    [X,Y] = size(W);    % do nothing regarding the vertices: we suppose that they are passed as    % the coordinates in the appropriate mapendmap = false(X,Y);%% % extract the vertices% find all the vertices of the graph (note that endpoints are also in this% list)[i,j] = find(graph);% avoid repeated entries: the graph is supposed to be symmetricedges = unique(sort([i,j],2),'rows'); svert = vertex(edges(:,1),:); % starting pointevert = vertex(edges(:,2),:); %ending point%% % define the edges joining the vertices over the map domain% find the coordinates of the pixels laying on the edges linking the% vertices (startvert,endvert)[x y pts] = ...    bresenhamline_base(svert(:,1),svert(:,2),evert(:,1),evert(:,2));% (x,y,pts) have the same number of rows as the vectors (svert,evert)% note that BRESENHAMLINE_BASE rounds coordinates%% % compute the weight of the different edges of the graphif nb_dims(W)>1 % a cost map    [n,m] = size(x);    x(~pts) = 1;    y(~pts) = 1;    wedges = reshape(W(x+X*(y-1)), [n,m]);    % the ith-line of wE contains the weight of the pixel liying on the ith    % edge, then compute the total weight of each edge    wedges = sum(wedges .* pts,2);end%% % 'draw' the edges onto the mapx = x(:); y = y(:); pts = pts(:);x(~pts) = [];    y(~pts) = [];map(x(:)+X*(y(:)-1)) = true;end % end of graph2map_base##### SOURCE END #####--></body></html>