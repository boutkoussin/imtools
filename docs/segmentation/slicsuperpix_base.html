<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html>  <head>    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">    <!--This HTML was auto-generated from MATLAB code.To make changes, update the MATLAB code and republish this document.      -->    <title>SLICSUPERPIX_BASE - Base function for SLICSUPERPIX.</title>    <meta name="generator" content="MATLAB 7.14">    <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">    <meta name="DC.date" content="2012-05-31">    <meta name="DC.source" content="slicsuperpix_base.m">    <style type="text/css">html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}html { min-height:100%; margin-bottom:1px; }html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }html body td { vertical-align:top; text-align:left; }h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }a { color:#005fce; text-decoration:none; }a:hover { color:#005fce; text-decoration:underline; }a:visited { color:#004aa0; text-decoration:none; }p { padding:0px; margin:0px 0px 20px; }img { padding:0px; margin:0px 0px 20px; border:none; }p img, pre img, tt img, li img { margin-bottom:0px; } ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }ul li { padding:0px; margin:0px 0px 7px 0px; }ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }ul li ol li { list-style:decimal; }ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }ol li ol li { list-style-type:lower-alpha; }ol li ul { padding-top:7px; }ol li ul li { list-style:square; }.content { font-size:1.2em; line-height:140%; padding: 20px; }pre, tt, code { font-size:12px; }pre { margin:0px 0px 20px; }pre.error { color:red; }pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }span.keyword { color:#0000FF }span.comment { color:#228B22 }span.string { color:#A020F0 }span.untermstring { color:#B20000 }span.syscmd { color:#B28C00 }.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }.footer p { margin:0px; }  </style>  </head>  <body>    <div class="content">      <h1>SLICSUPERPIX_BASE - Base function for SLICSUPERPIX.</h1>      <!--introduction--><!--/introduction-->      <h2>Contents</h2>      <div>        <ul>          <li><a href="#1">Syntax</a></li>          <li><a href="#3">See also</a></li>          <li><a href="#4">Function implementation</a></li>        </ul>      </div>      <h2>Syntax<a name="1"></a></h2>      <pre>  [Q, Ck, LabCk] = SLICSUPERPIX_BASE(I, K, isLab, T, win, m, k, maxiter);</pre>      <h2>See also<a name="3"></a></h2>      <p>Related: <a href="SLICSUPERPIX.html"><tt>SLICSUPERPIX</tt></a>, <a href="AMOEBASUPERPIX_BASE.html"><tt>AMOEBASUPERPIX_BASE</tt></a>,        <a href="GEOSUPERPIX_BASE.html"><tt>GEOSUPERPIX_BASE</tt></a>. Called: <a          href="matlab:web%28whichpath%28%27RGB2LAB%27%29%29"><tt>RGB2LAB</tt></a>,        <a href="../../graph/html/SCOMPONENTS.html"><tt>SCOMPONENTS</tt></a>, <a          href="../../kernel/html/EUCLIDKERNEL.html"><tt>EUCLIDKERNEL</tt></a>,        <a href="../../kernel/html/NEIPOSKERNEL.html"><tt>NEIPOSKERNEL</tt></a>.</p>      <h2>Function implementation<a name="4"></a></h2>      <pre class="codeinput"><span class="keyword">function</span> [Q, Ck, LabCk, D] = slicsuperpix_base(I, K, isLab, T, n, m, k, maxiter)</pre>      <p>checking/setting parameters</p>      <pre class="codeinput"><span class="keyword">if</span> nargin&lt;7,  maxiter = Inf;    <span class="keyword">if</span> nargin&lt;6,  k = 3;        <span class="keyword">if</span> nargin&lt;5,  m = 10;            <span class="keyword">if</span> nargin&lt;4,  n = 2;  <span class="keyword">end</span>        <span class="keyword">end</span>    <span class="keyword">end</span><span class="keyword">end</span>[X,Y,C] = size(I);<span class="keyword">if</span> C~=3    warning(<span class="string">'slicsuperpix_base:inputwarning'</span>,<span class="string">'RGB image required in input'</span>);    <span class="keyword">if</span> C==1,   I = repmat(I, [1 1 3]);    <span class="keyword">else</span>       I = I(:,:,1:3);    <span class="keyword">end</span><span class="keyword">end</span></pre>      <p>for an image with N=X*Y pixels, the approximate size of each superpixel        is N/K pixels; therefore, for roughly equally sized superpixels there        would be a superpixel center at every grid interval S</p>      <pre class="codeinput">S = floor(sqrt(X*Y/K));<span class="keyword">if</span> mod(n,2)~=0,  n = n+1;  <span class="keyword">end</span>;win = S*n;pad = win / 2;</pre>      <p>possibly convert the image to RGB</p>      <pre class="codeinput"><span class="keyword">if</span> isLab    Lab = RGB2Lab(I(:,:,1), I(:,:,2), I(:,:,3));<span class="keyword">else</span>    Lab = I;<span class="keyword">end</span></pre>      <p>distance functions</p>      <pre class="codeinput"><span class="comment">% L1 distance: see function UPDATERRROR below</span>distL1 = @(v0, v1) sum(abs(v1-v0), 2);                                 <span class="comment">%#ok</span><span class="comment">% L2 distance: see functions UPDATERRROR and CALCLABSPACE below</span>distL2 = @(v0, v1) sqrt(sum((v1-v0).^2, 2));<span class="comment">%   %----------------------------------------------------------------------</span>    <span class="keyword">function</span> Ds = calclabspace(p0, p1, Lab0, Lab1, S, m) <spanclass="comment">% see Eq.(1) of [ASSLFS10]</span>        ddxy =  distL2(p0, p1);        ddlab = distL2(Lab0, Lab1);        <span class="comment">% Ds is the sum of the lab distance and the xy plane distance normalized by</span>        <span class="comment">% the grid interval S; the variable m is introduced in Ds that enables to</span>        <span class="comment">% control the compactness of a superpixel.</span>        Ds = ddlab + m * ddxy / S;        <span class="comment">% note: the greater the value of m, the more spatial proximity is emphasized</span>        <span class="comment">% and the more compact the cluster.</span>    <span class="keyword">end</span><span class="comment">%   %----------------------------------------------------------------------</span><span class="comment">% function dlab = distlab(p0, p1, Lab)</span><span class="comment">% dlab =  sqrt((Lab(p0(:,1),p0(:,2),3) -  Lab(p1(:,1),p1(:,2),3)).^2 + ...</span><span class="comment">%     (Lab(p0(:,1),p0(:,2),2) - Lab(p1(:,1),p1(:,2),2)).^2 + ...</span><span class="comment">%     (Lab(p0(:,1),p0(:,2),1) - Lab(p1(:,1),p1(:,2),1)).^2);</span><span class="comment">% end</span><span class="comment">%   %----------------------------------------------------------------------</span></pre>      <p>main calculation</p>      <p>we begin by sampling K regularly spaced cluster centers</p>      <pre class="codeinput">[Ck, LabCk] = initcenters(Lab, S);</pre>      <p>since the spatial extent of any superpixel is approximately S^2 (the        area of a superpixel), we can safely assume that pixels that are        associated with this cluster center lie within a [nS Ã— nS] window around        the superpixel center on the xy plane</p>      <pre class="codeinput">nk = size(Ck,1);<span class="comment">%   %----------------------------------------------------------------------</span>    <span class="keyword">function</span> [Ck, LabCk] = initcenters(Lab, S)        <span class="comment">% [X,Y] = size(Lab(:,:,1));</span>        xk = round(X / S);        <span class="keyword">if</span> xk==0,  xk = floor(X/2);        <span class="keyword">else</span>       xk = floor(S * (0:xk-1) + S/2);        <span class="keyword">end</span>        yk = round(Y / S);        <span class="keyword">if</span> yk==0,  yk = floor(X/2);        <span class="keyword">else</span>       yk = floor(S * (0:yk-1) + S/2);        <span class="keyword">end</span>        LabCk = reshape(Lab(xk,yk,:), [length(xk)*length(yk) 3]);        [xk yk] = meshgrid(xk, yk);        Ck = [xk(:), yk(:)];        <span class="comment">% Ck = sub2ind([X,Y], xk(:), yk(:));</span>    <span class="keyword">end</span><span class="comment">%   %----------------------------------------------------------------------</span><span class="comment">%     function [Ck, LabCk, S] = initcenters(I, K)</span><span class="comment">%         [Ck, S] = gridblk(I, K);</span><span class="comment">%</span><span class="comment">%         LabCk = zeros(length(Ck),C);</span><span class="comment">%         for ic=1:C</span><span class="comment">%             x = blkproc(I(:,:,ic), S, @(x)mean(x(:)));</span><span class="comment">%             LabCk(:,ic) = x(:);</span><span class="comment">%         end</span><span class="comment">%</span><span class="comment">%     end</span><span class="comment">% %   %--------------------------------------------------------------------</span></pre>      <p>we move the centers to seed locations corresponding to the lowest        gradient position in a [k x k] neighborhood.</p>      <pre class="codeinput"><span class="keyword">if</span> k&gt;0    [Ck, LabCk] = movecenters(Lab, Ck, k);<span class="keyword">end</span><span class="comment">%   %----------------------------------------------------------------------</span>    <span class="keyword">function</span> [Ck, LabCk] = movecenters(Lab, Ck, k)        <span class="comment">% note that in Eq.(2), the L2 norm is used for computing the</span>        <span class="comment">% distance in Lab space, not the pseudo norm defined in Eq.(1)</span>        Lab0 = Lab([2:X X], (1:Y));        Lab1 = Lab([1 1:(X-1)], (1:Y));        <span class="comment">% p0 = [[2:X X]', (1:Y)'];  Lab0 = Lab(p0(:,1),p0(:,2));</span>        <span class="comment">% p1 = [[1 1:(X-1)]', (1:Y)']; Lab1 = Lab(p1(:,1),p1(:,2));</span>        <span class="comment">% [i,j] = ind2sub([X,Y], meshgrid(p0(:,1),p0(:,2)));</span>        <span class="comment">% p0 = [i(:), j(:)];</span>        <span class="comment">% [i,j] = ind2sub([X,Y], meshgrid(p1(:,1),p1(:,2)));</span>        <span class="comment">% p1 = [i(:), j(:)];</span>        G = sum((Lab0(:)-Lab1(:)).^2, 2);        <span class="comment">%   distL2(Lab0(:), Lab1(:)).^2; % we avoid calling sqrt then (^2)</span>        <span class="comment">%   calclabspace(p0, p1, Lab0(:), Lab1(:), S, m);</span>        Lab0 = Lab((1:X), [2:Y Y]);        Lab1 = Lab((1:X), [1 1:(Y-1)]);        <span class="comment">% p0 = [(1:X)' [2:Y Y]'];      Lab0 = Lab(p0(:,1),p0(:,2));</span>        <span class="comment">% p1 = [(1:X)' [1 1:(Y-1)]'];  Lab1 = Lab(p1(:,1),p1(:,2));</span>        <span class="comment">% [i,j] = ind2sub([X,Y], meshgrid(p0(:,1),p0(:,2)));</span>        <span class="comment">% p0 = [i(:), j(:)];</span>        <span class="comment">% [i,j] = ind2sub([X,Y], meshgrid(p1(:,1),p1(:,2)));</span>        <span class="comment">% p1 = [i(:), j(:)];</span>        G = G + sum((Lab0(:)-Lab1(:)).^2, 2);        <span class="comment">%       distL2(Lab0(:), Lab1(:)).^2;</span>        <span class="comment">%       calclabspace(p0, p1, Lab0(:), Lab1(:), S, m);</span>        G = reshape(G,[X,Y]); <span class="comment">% see Eq.(2) of [ASSLFS10]</span>        [ind, ix, iy] = neiposkernel(k,X);        ind = ind(:);  ix = ix(:);  iy = iy(:);        cind = sub2ind([X,Y], Ck(:,1), Ck(:,2));        ind = repmat(cind, [1 numel(ind)]) + repmat(ind', [length(cind) 1]);        ind(ind&gt;X*Y) = X*Y;        ind(ind&lt;=0) = 1;        [~,pos] = min(G(ind), [], 2);        Ck = [Ck(:,1) + ix(pos), Ck(:,2) + iy(pos)];        <span class="comment">% check that the Ck are not outside the limit of the image</span>        Ck(:,1) = min([max([Ck(:,1), ones(nk,1)],[],2), X*ones(nk,1)], [], 2);        Ck(:,2) = min([max([Ck(:,2), ones(nk,1)],[],2), Y*ones(nk,1)], [], 2);        cind = sub2ind([X,Y], Ck(:,1), Ck(:,2));        cind = [cind cind+X*Y cind+2*X*Y];        LabCk = reshape(Lab(cind), [nk 3]);    <span class="keyword">end</span><span class="comment">%   %----------------------------------------------------------------------</span></pre>      <p>% define the spatial distance: it is calculated once for all: WRONG!!!</p>      <pre class="codeinput">dxy = euclidkernel(win + 1);dxy = dxy(:);<span class="comment">% w = numel(dxy);</span>w = (win+1)^2;A = padarray(Lab, [pad pad 0], <span class="string">'both'</span>, <span class="string">'symmetric'</span>);[M,N] = size(A(:,:,1));</pre>      <p>initial labels and distances matrices</p>      <pre class="codeinput">Q0 = zeros(M,N);D0 = Inf(M,N);</pre>      <p>define some utility indices</p>      <pre class="codeinput"><span class="comment">% position indices</span>pixindex = reshape(1:M*N,M,N);pixin = pixindex(pad+1:pad+X,pad+1:pad+Y);<span class="comment">% iindex of the centered neighbour window of analysis</span>[x,y] = ndgrid(-pad:pad); ind = x + M*y;<span class="comment">% ind = repmat(-pad:pad,[2*pad+1 1]); ind = ind' + M*ind;</span>ind = ind(:);</pre>      <p>start 'looping'</p>      <pre class="codeinput">niter = 1;err = Inf(nk,1);ierr = 1:nk; <span class="comment">% ierr = find(err&gt;T);</span><span class="keyword">while</span> niter&lt;=maxiter</pre>      <pre class="codeinput">    <span class="keyword">if</span> ~any(err&gt;T),  <spanclass="keyword">break</span>;  <spanclass="keyword">end</span></pre>      <p>update labels and distance</p>      <pre class="codeinput">    [D0,Q0] = updatedistance(ierr, D0, Q0, Ck, LabCk );    Q = Q0(pixin);</pre>      <p>update labels' centroids</p>      <pre class="codeinput">    [nCk, nLabCk] = updatecentroids(ierr, Q);</pre>      <p>merge regions</p>      <pre class="codeinput">    closeness = 10;    [Q, i, j] = mergeregions(ierr, Q, nCk, nLabCk, closeness);    <span class="keyword">if</span> ~isempty(j)        [nCk(i,:), nLabCk(i,:)] = updatecentroids(i, Q);        nCk(j,:) = []; nLabCk(j,:) = [];        Ck(j,:) = [];  LabCk(j,:) = [];        nk = size(Ck,1);        Q = compressregions(Q, unique(Q(:)));        Q0(pixin) = Q;    <span class="keyword">end</span></pre>      <p>update errors</p>      <pre class="codeinput">    ierr = 1:nk; <span class="comment">% we update all of them everytime</span>    err = updaterror(ierr, Ck, nCk, LabCk, nLabCk);</pre>      <p>update labels</p>      <pre class="codeinput">    Ck = nCk;    LabCk = nLabCk;    niter = niter + 1;</pre>      <pre class="codeinput"><span class="keyword">end</span><span class="comment">%   %----------------------------------------------------------------------</span>    <span class="keyword">function</span> [D,Q] = updatedistance(ierr, D, Q, Ck, LabCk)        <span class="keyword">for</span> l=1:length(ierr) <span class="comment">%nk</span>            <span class="comment">% "assign the best matching pixels from a (2S Ã— 2S) neighborhood</span>            <span class="comment">% around the cluster center according to the distance measure"</span>            ll = ierr(l);            <span class="comment">% ll = l; % we recompute all of them, even those unchanged</span>            <span class="comment">% coordinates of the neighbourhood centered around the cluster</span>            <span class="comment">% center</span>            <span class="comment">% if any(isnan([Ck(ll,1) Ck(ll,2)])),  continue;  end</span>            c = pixin(Ck(ll,1),Ck(ll,2));            c3 =  [c, c+N*M, c+2*N*M];            cind = c + ind;            cind3 = repmat(c3,[w 1]) + repmat(ind,[1 3]);            q = Q(cind);            d = D(cind);            dlab = distL2(A(cind3), repmat(LabCk(ll,:),[size(cind3,1) 1]));            Ds = dlab + m * dxy; <span class="comment">% see remark in function UPDATERROR</span>            [d, r] = min(cat(2,d,Ds(:)),[],2);            q(r==2) = ll;            <span class="comment">% each pixel in the image is associated with the nearest cluster</span>            <span class="comment">% center whose (nS Ã— nS) search area overlaps this pixel</span>            Q(cind) = q;  D(cind) = d;        <span class="keyword">end</span>    <span class="keyword">end</span><span class="comment">%   %----------------------------------------------------------------------</span>    <span class="keyword">function</span> [Ck, LabCk] = updatecentroids(ierr, Q)        labels = cellfun(@(k) find(Q==k), num2cell(ierr(:)), <span class="string">'UniformOutput'</span>, false);        <span class="comment">% if we sum the Lab values over the component with same label</span>        <span class="comment">% LabCk = cellfun(@(x) sum(Lab([x x+X*Y x+2*X*Y]),1) / length(x), ...</span>        <span class="comment">%    labels, 'UniformOutput', false);</span>        labels = cellfun(@(x) [ind2cr(X,x,<span class="string">'r'</span>), ind2cr(X,x,<spanclass="string">'c'</span>)], labels, <spanclass="keyword">...</span>            <span class="string">'UniformOutput'</span>, false);        Ck = cellfun(@(x) floor([sum(x(:,1)), sum(x(:,2))]/length(x(:,1))), <spanclass="keyword">...</span>            labels, <span class="string">'UniformOutput'</span>, false);        <span class="comment">% note that instead we choose the Lab value of the (point closest to</span>        <span class="comment">% the) centroid point as a representative value</span>        LabCk = cellfun(@(x) squeeze(Lab(floor(x(1)),floor(x(2)),:))', <span class="keyword">...</span>            Ck, <span class="string">'UniformOutput'</span>, false);        Ck = cell2mat(Ck);        LabCk = cell2mat(LabCk);        <span class="comment">% if we wanted to use the Image Processing toolbox instead: no loop</span>        <span class="comment">% props = regionprops(Q,'centroid', 'PixelIdxList');</span>        <span class="comment">% Ck = floor(cat(1, props.Centroid));  Ck = fliplr(Ck(ierr,:));</span>        <span class="comment">% LabCk = 'loop on numel(props)...';</span>    <span class="keyword">end</span><span class="comment">%   %----------------------------------------------------------------------</span>    <span class="keyword">function</span> err = updaterror(ierr, Ck, nCk, LabCk, nLabCk)        <span class="comment">% algorithm 1 in [ASSLFS10] : residual error = L1 distance between</span>        <span class="comment">% previous centers and recomputed centers</span>        <span class="comment">% err = distL1(Ck(ierr,:), nCk);</span>        <span class="comment">% instead we choose:</span>        err = calclabspace(Ck(ierr,:), nCk, LabCk(ierr,:), nLabCk, 1 , m);        <span class="comment">% note that here, by setting S=1, we replace the original expression</span>        <span class="comment">% Ds = ddlab + m * ddxy / S with Ds = ddlab + m * ddxy for clarity</span>        <span class="comment">% as it is easier to control the compactness of the clusters using</span>        <span class="comment">% m only</span>    <span class="keyword">end</span><span class="comment">%   %----------------------------------------------------------------------</span>    <span class="keyword">function</span> [Q, i, j] = mergeregions(ierr, Q, Ck, LabCk, closeness)        [i,j] = find(regionadjacency_base(Q, ierr, 8)); <span class="comment">% note: it is symmetric</span>        i = unique(sort([i j],2),<span class="string">'rows'</span>); j = i(:,2); i = i(:,1);        dist =  calclabspace(Ck(ierr(i),:), Ck(ierr(j),:), <span class="keyword">...</span>            LabCk(ierr(i),:), LabCk(ierr(j),:), 1, m);        l = dist &lt; m*closeness;        <span class="comment">% naive merging</span>        <span class="keyword">if</span> any(l)            i = ierr(i(l)); j = ierr(j(l));            V = sparse(i, j, ones(length(i),1), max([i(:);j(:)]),  max([i(:);j(:)]));            V = V | V';            [~, comp] = scomponents(V, find(sum(V,2)==1));            i = cellfun(@(x) x(1), comp);            j = cellfun(@(x) x(2:end), comp, <span class="string">'UniformOutput'</span>, false);            <span class="keyword">for</span> l=1:length(i),  Q(ismember(Q,j{l})) = i(l);  <spanclass="keyword">end</span>            j = cell2mat(cellfun(@(x) x(:), j, <span class="string">'UniformOutput'</span>, false));        <span class="keyword">else</span>            i = []; j = [];        <span class="keyword">end</span>    <span class="keyword">end</span><span class="comment">%   %----------------------------------------------------------------------</span>    <span class="keyword">function</span> L = compressregions(L, labels)        <span class="keyword">if</span> labels(1)~=0, labels = [0; labels];  <spanclass="keyword">end</span>        V = cumsum(diff(labels)-1);        labels = labels(2:end);        V = labels - V;        <span class="keyword">for</span> l=1:length(labels),  L(L==labels(l)) = V(l);  <spanclass="keyword">end</span>    <span class="keyword">end</span><span class="comment">%   %----------------------------------------------------------------------</span><span class="keyword">if</span> nargout==4,  D = D0(pixin);  <span class="keyword">end</span></pre>      <pre class="codeinput"><span class="keyword">end</span> <span class="comment">% end of slicsuperpix_base</span></pre></div>    <!--##### SOURCE BEGIN #####%% SLICSUPERPIX_BASE - Base function for SLICSUPERPIX.%%% Syntax%    [Q, Ck, LabCk] = SLICSUPERPIX_BASE(I, K, isLab, T, win, m, k, maxiter);%%% Credit% <mailto:grazzja@lanl.gov J.Grazzini> (ISR-2/LANL)%%% See also% Related:% <SLICSUPERPIX.html |SLICSUPERPIX|>,% <AMOEBASUPERPIX_BASE.html |AMOEBASUPERPIX_BASE|>,% <GEOSUPERPIX_BASE.html |GEOSUPERPIX_BASE|>.% Called:% <matlab:web(whichpath('RGB2LAB')) |RGB2LAB|>,% <../../graph/html/SCOMPONENTS.html |SCOMPONENTS|>,% <../../kernel/html/EUCLIDKERNEL.html |EUCLIDKERNEL|>,% <../../kernel/html/NEIPOSKERNEL.html |NEIPOSKERNEL|>.%% Function implementationfunction [Q, Ck, LabCk, D] = slicsuperpix_base(I, K, isLab, T, n, m, k, maxiter)%%% checking/setting parametersif nargin<7,  maxiter = Inf;    if nargin<6,  k = 3;        if nargin<5,  m = 10;            if nargin<4,  n = 2;  end        end    endend[X,Y,C] = size(I);if C~=3    warning('slicsuperpix_base:inputwarning','RGB image required in input');    if C==1,   I = repmat(I, [1 1 3]);    else       I = I(:,:,1:3);     endend%%% for an image with N=X*Y pixels, the approximate size of each superpixel is% N/K pixels; therefore, for roughly equally sized superpixels there would% be a superpixel center at every grid interval SS = floor(sqrt(X*Y/K));if mod(n,2)~=0,  n = n+1;  end;win = S*n;pad = win / 2;%%% possibly convert the image to RGBif isLab    Lab = RGB2Lab(I(:,:,1), I(:,:,2), I(:,:,3));else    Lab = I;end%%% distance functions% L1 distance: see function UPDATERRROR below distL1 = @(v0, v1) sum(abs(v1-v0), 2);                                 %#ok% L2 distance: see functions UPDATERRROR and CALCLABSPACE belowdistL2 = @(v0, v1) sqrt(sum((v1-v0).^2, 2)); %   %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH    function Ds = calclabspace(p0, p1, Lab0, Lab1, S, m) % see Eq.(1) of [ASSLFS10]               ddxy =  distL2(p0, p1);        ddlab = distL2(Lab0, Lab1);        % Ds is the sum of the lab distance and the xy plane distance normalized by        % the grid interval S; the variable m is introduced in Ds that enables to        % control the compactness of a superpixel.        Ds = ddlab + m * ddxy / S;        % note: the greater the value of m, the more spatial proximity is emphasized        % and the more compact the cluster.    end%   %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH% function dlab = distlab(p0, p1, Lab)% dlab =  sqrt((Lab(p0(:,1),p0(:,2),3) -  Lab(p1(:,1),p1(:,2),3)).^2 + ...%     (Lab(p0(:,1),p0(:,2),2) - Lab(p1(:,1),p1(:,2),2)).^2 + ...%     (Lab(p0(:,1),p0(:,2),1) - Lab(p1(:,1),p1(:,2),1)).^2);% end%   %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH%% % main calculation%%% we begin by sampling K regularly spaced cluster centers[Ck, LabCk] = initcenters(Lab, S);%%% since the spatial extent of any superpixel is approximately S^2 (the area% of a superpixel), we can safely assume that pixels that are associated% with this cluster center lie within a [nS Ã— nS] window around the superpixel% center on the xy planenk = size(Ck,1);%   %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH    function [Ck, LabCk] = initcenters(Lab, S)        % [X,Y] = size(Lab(:,:,1));        xk = round(X / S);        if xk==0,  xk = floor(X/2);        else       xk = floor(S * (0:xk-1) + S/2);        end        yk = round(Y / S);        if yk==0,  yk = floor(X/2);        else       yk = floor(S * (0:yk-1) + S/2);        end                LabCk = reshape(Lab(xk,yk,:), [length(xk)*length(yk) 3]);                [xk yk] = meshgrid(xk, yk);        Ck = [xk(:), yk(:)];        % Ck = sub2ind([X,Y], xk(:), yk(:));    end%   %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH%     function [Ck, LabCk, S] = initcenters(I, K)%         [Ck, S] = gridblk(I, K);%        %         LabCk = zeros(length(Ck),C);%         for ic=1:C%             x = blkproc(I(:,:,ic), S, @(x)mean(x(:)));%             LabCk(:,ic) = x(:);%         end%         %     end% %   %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH%%% we move the centers to seed locations corresponding to the lowest gradient% position in a [k x k] neighborhood.if k>0    [Ck, LabCk] = movecenters(Lab, Ck, k);end%   %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH    function [Ck, LabCk] = movecenters(Lab, Ck, k)               % note that in Eq.(2), the L2 norm is used for computing the        % distance in Lab space, not the pseudo norm defined in Eq.(1)               Lab0 = Lab([2:X X], (1:Y));        Lab1 = Lab([1 1:(X-1)], (1:Y));        % p0 = [[2:X X]', (1:Y)'];  Lab0 = Lab(p0(:,1),p0(:,2));        % p1 = [[1 1:(X-1)]', (1:Y)']; Lab1 = Lab(p1(:,1),p1(:,2));        % [i,j] = ind2sub([X,Y], meshgrid(p0(:,1),p0(:,2)));        % p0 = [i(:), j(:)];        % [i,j] = ind2sub([X,Y], meshgrid(p1(:,1),p1(:,2)));        % p1 = [i(:), j(:)];        G = sum((Lab0(:)-Lab1(:)).^2, 2);        %   distL2(Lab0(:), Lab1(:)).^2; % we avoid calling sqrt then (^2)        %   calclabspace(p0, p1, Lab0(:), Lab1(:), S, m);                Lab0 = Lab((1:X), [2:Y Y]);        Lab1 = Lab((1:X), [1 1:(Y-1)]);        % p0 = [(1:X)' [2:Y Y]'];      Lab0 = Lab(p0(:,1),p0(:,2));        % p1 = [(1:X)' [1 1:(Y-1)]'];  Lab1 = Lab(p1(:,1),p1(:,2));        % [i,j] = ind2sub([X,Y], meshgrid(p0(:,1),p0(:,2)));        % p0 = [i(:), j(:)];        % [i,j] = ind2sub([X,Y], meshgrid(p1(:,1),p1(:,2)));        % p1 = [i(:), j(:)];        G = G + sum((Lab0(:)-Lab1(:)).^2, 2);        %       distL2(Lab0(:), Lab1(:)).^2;        %       calclabspace(p0, p1, Lab0(:), Lab1(:), S, m);                G = reshape(G,[X,Y]); % see Eq.(2) of [ASSLFS10]        [ind, ix, iy] = neiposkernel(k,X);        ind = ind(:);  ix = ix(:);  iy = iy(:);                cind = sub2ind([X,Y], Ck(:,1), Ck(:,2));        ind = repmat(cind, [1 numel(ind)]) + repmat(ind', [length(cind) 1]);        ind(ind>X*Y) = X*Y;        ind(ind<=0) = 1;        [~,pos] = min(G(ind), [], 2);                Ck = [Ck(:,1) + ix(pos), Ck(:,2) + iy(pos)];        % check that the Ck are not outside the limit of the image        Ck(:,1) = min([max([Ck(:,1), ones(nk,1)],[],2), X*ones(nk,1)], [], 2);        Ck(:,2) = min([max([Ck(:,2), ones(nk,1)],[],2), Y*ones(nk,1)], [], 2);                cind = sub2ind([X,Y], Ck(:,1), Ck(:,2));        cind = [cind cind+X*Y cind+2*X*Y];        LabCk = reshape(Lab(cind), [nk 3]);            end%   %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH%%% % define the spatial distance: it is calculated once for all: WRONG!!!dxy = euclidkernel(win + 1);dxy = dxy(:);% w = numel(dxy);w = (win+1)^2;A = padarray(Lab, [pad pad 0], 'both', 'symmetric');[M,N] = size(A(:,:,1));                                           %%% initial labels and distances matricesQ0 = zeros(M,N);D0 = Inf(M,N);%%% define some utility indices% position indicespixindex = reshape(1:M*N,M,N);pixin = pixindex(pad+1:pad+X,pad+1:pad+Y);% iindex of the centered neighbour window of analysis [x,y] = ndgrid(-pad:pad); ind = x + M*y;% ind = repmat(-pad:pad,[2*pad+1 1]); ind = ind' + M*ind;ind = ind(:);%%% start 'looping'niter = 1;err = Inf(nk,1);ierr = 1:nk; % ierr = find(err>T);    while niter<=maxiter    if ~any(err>T),  break;  end        %%     % update labels and distance    [D0,Q0] = updatedistance(ierr, D0, Q0, Ck, LabCk );        Q = Q0(pixin);        %%    % update labels' centroids    [nCk, nLabCk] = updatecentroids(ierr, Q);        %%    % merge regions    closeness = 10;    [Q, i, j] = mergeregions(ierr, Q, nCk, nLabCk, closeness);    if ~isempty(j)        [nCk(i,:), nLabCk(i,:)] = updatecentroids(i, Q);        nCk(j,:) = []; nLabCk(j,:) = [];        Ck(j,:) = [];  LabCk(j,:) = [];        nk = size(Ck,1);        Q = compressregions(Q, unique(Q(:)));        Q0(pixin) = Q;    end        %%     % update errors    ierr = 1:nk; % we update all of them everytime    err = updaterror(ierr, Ck, nCk, LabCk, nLabCk);        %%     % update labels    Ck = nCk;    LabCk = nLabCk;        niter = niter + 1;end%   %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH    function [D,Q] = updatedistance(ierr, D, Q, Ck, LabCk)        for l=1:length(ierr) %nk            % "assign the best matching pixels from a (2S Ã— 2S) neighborhood            % around the cluster center according to the distance measure"            ll = ierr(l);            % ll = l; % we recompute all of them, even those unchanged                        % coordinates of the neighbourhood centered around the cluster            % center            % if any(isnan([Ck(ll,1) Ck(ll,2)])),  continue;  end            c = pixin(Ck(ll,1),Ck(ll,2));            c3 =  [c, c+N*M, c+2*N*M];            cind = c + ind;            cind3 = repmat(c3,[w 1]) + repmat(ind,[1 3]);                        q = Q(cind);            d = D(cind);                        dlab = distL2(A(cind3), repmat(LabCk(ll,:),[size(cind3,1) 1]));            Ds = dlab + m * dxy; % see remark in function UPDATERROR                        [d, r] = min(cat(2,d,Ds(:)),[],2);            q(r==2) = ll;                        % each pixel in the image is associated with the nearest cluster            % center whose (nS Ã— nS) search area overlaps this pixel            Q(cind) = q;  D(cind) = d;        end    end%   %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH    function [Ck, LabCk] = updatecentroids(ierr, Q)        labels = cellfun(@(k) find(Q==k), num2cell(ierr(:)), 'UniformOutput', false);        % if we sum the Lab values over the component with same label        % LabCk = cellfun(@(x) sum(Lab([x x+X*Y x+2*X*Y]),1) / length(x), ...        %    labels, 'UniformOutput', false);        labels = cellfun(@(x) [ind2cr(X,x,'r'), ind2cr(X,x,'c')], labels, ...            'UniformOutput', false);        Ck = cellfun(@(x) floor([sum(x(:,1)), sum(x(:,2))]/length(x(:,1))), ...            labels, 'UniformOutput', false);        % note that instead we choose the Lab value of the (point closest to        % the) centroid point as a representative value        LabCk = cellfun(@(x) squeeze(Lab(floor(x(1)),floor(x(2)),:))', ...            Ck, 'UniformOutput', false);        Ck = cell2mat(Ck);        LabCk = cell2mat(LabCk);        % if we wanted to use the Image Processing toolbox instead: no loop        % props = regionprops(Q,'centroid', 'PixelIdxList');        % Ck = floor(cat(1, props.Centroid));  Ck = fliplr(Ck(ierr,:));        % LabCk = 'loop on numel(props)...';    end%   %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH    function err = updaterror(ierr, Ck, nCk, LabCk, nLabCk)        % algorithm 1 in [ASSLFS10] : residual error = L1 distance between        % previous centers and recomputed centers        % err = distL1(Ck(ierr,:), nCk);        % instead we choose:        err = calclabspace(Ck(ierr,:), nCk, LabCk(ierr,:), nLabCk, 1 , m);        % note that here, by setting S=1, we replace the original expression        % Ds = ddlab + m * ddxy / S with Ds = ddlab + m * ddxy for clarity        % as it is easier to control the compactness of the clusters using        % m only    end%   %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH    function [Q, i, j] = mergeregions(ierr, Q, Ck, LabCk, closeness)        [i,j] = find(regionadjacency_base(Q, ierr, 8)); % note: it is symmetric        i = unique(sort([i j],2),'rows'); j = i(:,2); i = i(:,1);        dist =  calclabspace(Ck(ierr(i),:), Ck(ierr(j),:), ...            LabCk(ierr(i),:), LabCk(ierr(j),:), 1, m);        l = dist < m*closeness;        % naive merging        if any(l)            i = ierr(i(l)); j = ierr(j(l));            V = sparse(i, j, ones(length(i),1), max([i(:);j(:)]),  max([i(:);j(:)]));            V = V | V';            [~, comp] = scomponents(V, find(sum(V,2)==1));            i = cellfun(@(x) x(1), comp);            j = cellfun(@(x) x(2:end), comp, 'UniformOutput', false);            for l=1:length(i),  Q(ismember(Q,j{l})) = i(l);  end            j = cell2mat(cellfun(@(x) x(:), j, 'UniformOutput', false));        else            i = []; j = [];        end    end%   %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH    function L = compressregions(L, labels)        if labels(1)~=0, labels = [0; labels];  end        V = cumsum(diff(labels)-1);        labels = labels(2:end);        V = labels - V;        for l=1:length(labels),  L(L==labels(l)) = V(l);  end    end%   %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHif nargout==4,  D = D0(pixin);  endend % end of slicsuperpix_base##### SOURCE END #####-->  </body></html>