<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html>  <head>    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">    <!--This HTML was auto-generated from MATLAB code.To make changes, update the MATLAB code and republish this document.      -->    <title>REGIONCLEAN_BASE - Base function for REGIONCLEAN.</title>    <meta name="generator" content="MATLAB 7.14">    <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">    <meta name="DC.date" content="2012-05-31">    <meta name="DC.source" content="regionclean_base.m">    <style type="text/css">html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}html { min-height:100%; margin-bottom:1px; }html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }html body td { vertical-align:top; text-align:left; }h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }a { color:#005fce; text-decoration:none; }a:hover { color:#005fce; text-decoration:underline; }a:visited { color:#004aa0; text-decoration:none; }p { padding:0px; margin:0px 0px 20px; }img { padding:0px; margin:0px 0px 20px; border:none; }p img, pre img, tt img, li img { margin-bottom:0px; } ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }ul li { padding:0px; margin:0px 0px 7px 0px; }ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }ul li ol li { list-style:decimal; }ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }ol li ol li { list-style-type:lower-alpha; }ol li ul { padding-top:7px; }ol li ul li { list-style:square; }.content { font-size:1.2em; line-height:140%; padding: 20px; }pre, tt, code { font-size:12px; }pre { margin:0px 0px 20px; }pre.error { color:red; }pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }span.keyword { color:#0000FF }span.comment { color:#228B22 }span.string { color:#A020F0 }span.untermstring { color:#B20000 }span.syscmd { color:#B28C00 }.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }.footer p { margin:0px; }  </style>  </head>  <body>    <div class="content">      <h1>REGIONCLEAN_BASE - Base function for REGIONCLEAN.</h1>      <!--introduction--><!--/introduction-->      <h2>Contents</h2>      <div>        <ul>          <li><a href="#1">Syntax</a></li>          <li><a href="#3">See also</a></li>          <li><a href="#4">Function implementation</a></li>        </ul>      </div>      <h2>Syntax<a name="1"></a></h2>      <pre class="language-matlab">[S, Ck, ColCk] = <span class="keyword">...</span>      REGIONCLEAN_BASE(L, Ck, ColCk, I, conn, m, features, thresholds);</pre>      <h2>See also<a name="3"></a></h2>      <p>Ressembles: <a href="regionclean.html"><tt>REGIONCLEAN</tt></a>, <a href="matlab:webpub%28whichpath%28%27REGIONPROPS%27%29%29"><tt>REGIONPROPS</tt></a>,        <a href="imlabel.html"><tt>IMLABEL</tt></a>. Requires: <a href="regionadjacency_base.html"><tt>REGIONADJACENCY_BASE</tt></a>,        <a href="matlab:webpub%28whichpath%28%27REGIONPROPS%27%29%29"><tt>REGIONPROPS</tt></a>,        <a href="matlab:webpub%28whichpath%28%27BWLABEL%27%29%29"><tt>BWLABEL</tt></a>.</p>      <h2>Function implementation<a name="4"></a></h2>      <pre class="codeinput"><span class="keyword">function</span> [S, Ck, ColCk] = <spanclass="keyword">...</span>    regionclean_base(S, Ck, ColCk, I, conn, m, features, thresholds)</pre>      <p>check/set parameters</p>      <pre class="codeinput"><span class="keyword">if</span> ~isequal(length(features),length(thresholds))    error(<span class="string">'regionclean_base:inputerror'</span>, <span class="keyword">...</span>        <span class="string">'vectors of feature names and threshold values must have same length'</span> );<span class="keyword">elseif</span> ~all(ismember(features,{<span class="string">'Area'</span>,<spanclass="string">'Solidity'</span>,<spanclass="string">'Extent'</span>}))    <span class="comment">% 'Perimeter','Eccentricity'</span>    error(<span class="string">'regionclean_base:inputerror'</span>, <span class="keyword">...</span>        <span class="string">'unknown feature - see REGIONCLEAN and REGIONPROPS helps'</span>);<span class="keyword">end</span>[X,Y] = size(S);</pre>      <p>initialize the labels</p>      <pre class="codeinput"><span class="comment">% if there is a label of 0 ensure we do not renumber that region by removing</span><span class="comment">% it from the list of labels to be renumbered</span>labels = unique(S(:));<span class="comment">% labels = sort(S(:)); labels(labels(1:end-1)==labels(2:end)) = []; % inline UNIQUE</span>labels = setdiff(labels,0);nlabels = max(labels);<span class="comment">% % cc = imlabel(S,8); % we can extract the connected components</span><span class="comment">% % ncc = max(cc(:));</span><span class="comment">% if ~isequal(nlabels,length(labels))</span><span class="comment">%     S = compressregions(S, labels);</span><span class="comment">%     labels = setdiff(unique(S(:)),0); % update</span><span class="comment">% end</span><span class="comment">% %   %----------------------------------------------------------------------</span><span class="comment">%     function L = compressregions(L, labels)</span><span class="comment">%         % this function ensures that the labels are set in sequential order</span><span class="comment">%         % 0 values in the original image are left with the label 0</span><span class="comment">%         if labels(1)~=0, labels = [0; labels];  end</span><span class="comment">%         A = cumsum(diff(labels)-1);</span><span class="comment">%         labels = labels(2:end);</span><span class="comment">%         A = labels - A;</span><span class="comment">%         % do the relabeling: compress</span><span class="comment">%         for l=1:length(labels),    L(L==labels(l)) = A(l);  end</span><span class="comment">%     end</span><span class="comment">% %   %----------------------------------------------------------------------</span></pre>      <p>break regions by assigning a new label to unconnected sub-regions        checking that there is only one region for each segment label; if there        is more than one region they are given unique labels</p>      <pre class="codeinput">[S, ischanged] = splitregions(S, conn, labels, nlabels);<span class="comment">%   %----------------------------------------------------------------------</span>    <span class="keyword">function</span> [S, ischanged] = splitregions(S, conn, labels, nlabels)        nl = nlabels;  ischanged = [];        <span class="keyword">for</span> l = labels'            <span class="comment">% define the number of connected objects found for each label</span>            [bl,num] = bwlabel(S==l, conn);  <span class="comment">% use given connectedness</span>            <span class="keyword">if</span> num &gt; 1  <span class="comment">% more than one region with the same label</span>                Ibl = bl&gt;1; <span class="comment">% therefore bl(Ibl)&gt;=2</span>                S(Ibl) = bl(Ibl) + nl - 1;                ischanged = [ischanged; l];                            <span class="comment">%#ok</span>                nl = nl + (num - 1); <span class="comment">% updated nlabels</span>            <span class="keyword">end</span>        <span class="keyword">end</span>        <span class="keyword">if</span> nl&gt;nlabels,  ischanged = [ischanged; (nlabels+1:nl)'];  <spanclass="keyword">end</span>        <span class="comment">% note that we do keep the initial labelling of most of the regions</span>        <span class="comment">% as we add new regions with labels starting after the larger label</span>        <span class="comment">% found in the input image</span>    <span class="keyword">end</span><span class="comment">%   %----------------------------------------------------------------------</span><span class="keyword">if</span> ~isempty(ischanged)  <span class="comment">% possibly update</span>    labels = setdiff(unique(S(:)),0);    nlabels = max(labels);<span class="keyword">end</span></pre>      <p>update (or not) the centroids of the regions</p>      <pre class="codeinput"><span class="keyword">if</span> isempty(Ck) || ~isempty(ischanged)    <span class="comment">% here, we recompute all centroids for simplicity...</span>    Ck = nan(nlabels,2);  ColCk = nan(nlabels,3);    [Ck(labels,:), ColCk(labels,:)] = updatecentroids(S, I, labels);    <span class="comment">% elseif ~isempty(ischanged)</span>    <span class="comment">%  [Ck(ischanged,:), ColCk(ischanged,:)] = updatecentroids(S, I, ischanged);</span><span class="keyword">end</span><span class="comment">%   %----------------------------------------------------------------------</span>    <span class="keyword">function</span> [Ck, ColCk] = updatecentroids(Q, I, k)        <span class="keyword">if</span> nargin==3 &amp;&amp; ~isempty(k)  <spanclass="comment">% get segments' centroids</span>            props = regionprops(Q .* ismember(Q,k),<span class="string">'centroid'</span>);        <span class="keyword">else</span> <span class="comment">% perform for all</span>            props = regionprops(Q,<span class="string">'centroid'</span>);        <span class="keyword">end</span>        <span class="comment">% note in calling REGIONPROPS: non represented labels in the input</span>        <span class="comment">% matrix Q are assigned NaN values into the corresponding cells of</span>        <span class="comment">% the calculated feature(s)</span>        Ck = floor(cat(1, props.Centroid));        <span class="keyword">if</span> nargin&lt;3 || isempty(k),  k = 1:size(Ck,1);  <spanclass="keyword">end</span>        Ck = fliplr(Ck(k,:)); <span class="comment">% keep only those we are interested in</span>        <span class="comment">% Ck = fliplr(floor(cat(1, props.Centroid))); % keep even NaN values</span>        cind = Ck(:,1) + ((Ck(:,2)-1)*Y);  <span class="comment">% A = isnan(cind);</span>        cind = [cind cind+X*Y cind+2*X*Y];  <span class="comment">% cind(A,:) = [];</span>        ColCk = nan(size(Ck,1),3); <span class="comment">% default output</span>        <span class="keyword">if</span> ~isempty(I),            ColCk = reshape(I(cind), [size(Ck,1) 3]);            <span class="comment">% ColCk(~A,:) = reshape(I(cind), [sum(~A) 3]);</span>        <span class="keyword">end</span>    <span class="keyword">end</span><span class="comment">%   %----------------------------------------------------------------------</span></pre>      <p>get the sparse adjacency matrix for all represented labels</p>      <pre class="codeinput">G = regionadjacency_base(S, labels, conn);<span class="comment">% figure, imagesc(label2rgb(S))</span></pre>      <p>find regions whose features do not respect the given thresholds</p>      <pre class="codeinput">R = criteriaregions(S, features, thresholds);</pre>      <p>simple case: get rid of completely isolated regions</p>      <pre class="codeinput">isdeleted = find(R);<span class="keyword">if</span> isempty(isdeleted)     <span class="comment">% nothing more to do: none of the current regions desobey the given</span>     <span class="comment">% criterion</span>     <span class="keyword">return</span>;<span class="keyword">end</span><span class="comment">%   %----------------------------------------------------------------------</span>    <span class="keyword">function</span> C = criteriaregions(S, features, thresholds, k)        <span class="keyword">if</span> nargin==4 &amp;&amp; ~isempty(k)  <spanclass="comment">% get segment(s)' area(s)</span>            props = regionprops(S.*ismember(S,k),features);        <span class="keyword">else</span>            props = regionprops(S,features);        <span class="keyword">end</span>        <span class="comment">% initialize with the first criterion</span>        C = cat(1,props.(features{1}));        <span class="comment">% C = C&lt;thresholds(1) &amp; ~isnan(C);</span>        <span class="keyword">if</span> nargin&lt;4 || isempty(k),  k = 1:length(C);  <spanclass="keyword">end</span>        C = C(k,:)&lt;thresholds(1) &amp; ~isnan(C(k,:));        <span class="comment">% complete with other possible criteria</span>        <span class="keyword">for</span> ip=2:numel(features)            <span class="comment">%if ~isfield(props,features{ip})</span>            <span class="comment">% eval([genvarname(features{ip}) '= cat(1,props.(features{ip}));']);</span>            A = cat(1,props.(features{ip}));            C = C | (A(k,:)&lt;thresholds(ip) &amp; ~isnan(A(k,:)));            <span class="comment">% end</span>        <span class="keyword">end</span>    <span class="keyword">end</span><span class="comment">%   %----------------------------------------------------------------------</span></pre>      <p>fill holes by cleaning completely surrounded regions</p>      <pre class="codeinput">[S, ischanged] = fillregions(S, G, isdeleted);<span class="comment">%   %----------------------------------------------------------------------</span>    <span class="keyword">function</span> [S, ischanged] = fillregions(S, G, isolated)        ischanged = [];        <span class="comment">% remove isolated regions embodied in another (unique) region</span>        <span class="keyword">for</span> l=isolated'            ind = find(full(G(l,:)));            <span class="keyword">if</span> length(ind)==1                ischanged = [ischanged; ind];                          <span class="comment">%#ok</span>                S(S==l) = ind;            <span class="keyword">end</span>        <span class="keyword">end</span>    <span class="keyword">end</span><span class="comment">%   %----------------------------------------------------------------------</span><span class="comment">%     function S = fillholes(S)</span><span class="comment">%         % remove isolated pixels embodied in another (unique) region</span><span class="comment">%         isolated = ismember(S,find(area==1 &amp; ~isnan(area)));</span><span class="comment">%         [ic,icd] = ixneighbours(S,isolated);</span><span class="comment">%         P = accumarray(ic, S(icd), [], @(x){x});</span><span class="comment">%         A = cellfun(@(p) length(p)&lt;1,P);</span><span class="comment">%         P(A) = [];</span><span class="comment">%         A = find(~A);</span><span class="comment">%         I = cellfun(@(x) sum(diff([x(end);x(:)],1))==0, P);</span><span class="comment">%         S(A(I)) = P{I}(1);</span><span class="comment">%     end</span><span class="comment">% %   %----------------------------------------------------------------------</span></pre>      <p>update if any change</p>      <pre class="codeinput"><span class="keyword">if</span> ~isempty(ischanged)    <span class="comment">% % recompress</span>    <span class="comment">% S = compressregions(S, unique(S(:)));</span>    <span class="comment">% update the list of available labels</span>    labels = setdiff(unique(S(:)),0);    nlabels = max(labels);    <span class="comment">% update all the representative centroids</span>    Ck = nan(nlabels,2);  ColCk = nan(nlabels,3);    [Ck(labels,:), ColCk(labels,:)] = updatecentroids(S, I, labels);    <span class="comment">% update the sparse adjacency matrix</span>    G = regionadjacency_base(S, labels, conn);    <span class="comment">% update the area vector</span>    R = criteriaregions(S, features, thresholds);    isdeleted = find(R);<span class="keyword">end</span>s = floor(sqrt(X*Y/length(labels))); <span class="comment">% kind of arbitrary...</span></pre>      <p>assign those regions the label of the adjacent region whose centroid is        closest to the centroid of the current region</p>      <pre class="codeinput"><span class="keyword">for</span> k = isdeleted'</pre>      <pre class="codeinput">    <span class="comment">% k is a label index of a region we will have to merge to another one</span>    r = true; <span class="comment">% as said, we will merge it for sure</span>    <span class="comment">% find regions adjacent to k</span>    ind = find(full(G(k,:)));</pre>      <p>keep merging with the closest element in the adjacency matrix until we        obtain an area &gt;= tharea, or we run out of regions to merge</p>      <pre class="codeinput">    <span class="keyword">while</span> ~isempty(ind) &amp;&amp; r</pre>      <p>compute the distances between the centroid of the current region and        the centroids of all its neighbours</p>      <pre class="codeinput">        <span class="keyword">if</span> length(ind)&gt;1            ds = calclabspace(Ck(repmat(k,size(ind)),:), Ck(ind,:), <span class="keyword">...</span>                ColCk(repmat(k,size(ind)),:), ColCk(ind,:), s, m);            [~,i] = min(ds);        <span class="keyword">else</span>            i = 1; <span class="comment">% one neighbour only</span>        <span class="keyword">end</span></pre>      <p>merge both regions k and ind(i) and store the new merged region in k;        also update the connecting graph</p>      <pre class="codeinput">        [S, G] = updateregions(S, G, k, ind(i));</pre>      <p>update regions' centroids for the merged region k only</p>      <pre class="codeinput">        [Ck(k,:), ColCk(k,:)] = updatecentroids(S, I, k);</pre>      <p>update the criteria on the merged region k only</p>      <pre class="codeinput">        r = criteriaregions(S, features, thresholds, k);        ind = find(full(G(k,:))); <span class="comment">% the adjacency matrix has changed</span></pre>      <pre class="codeinput">    <span class="keyword">end</span></pre>      <pre class="codeinput"><span class="keyword">end</span></pre>      <p>note that this is an arbitrary merging, depending in particular of the        order the different regions are merged to others...</p>      <pre class="codeinput"><span class="comment">%   %----------------------------------------------------------------------</span>    <span class="keyword">function</span> [S, G] = updateregions(S, G, s1, s2)        <span class="comment">% function to merge segment s2 into s1: the segmentation image, the</span>        <span class="comment">% adjacency matrix and the area vector are updated.</span>        <span class="comment">% update the label image: relabel s2 with s1 in the segment image</span>        S(S==s2) = s1;        <span class="comment">% update the connecting graph: s1 inherits the adjacancy matrix</span>        <span class="comment">% entries of s2</span>        G(s1,:) = G(s1,:) | G(s2,:);        G(:,s1) = G(:,s1) | G(:,s2);        G(s1,s1) = 0;  <span class="comment">% ensure s1 is not connected to itself</span>        <span class="comment">% disconnect s2 from the adjacency matrix</span>        G(s2,:) = 0;        G(:,s2) = 0;    <span class="keyword">end</span><span class="comment">%   %----------------------------------------------------------------------</span>    <span class="keyword">function</span> Ds = calclabspace(p0, p1, Lab0, Lab1, s, m)        distL2 = @(v0, v1) sqrt(sum(abs(v1-v0).^2, 2));        dxy =  distL2(p0, p1);        dlab = distL2(Lab0, Lab1);        <span class="comment">% Ds is the sum of the lab distance and the xy plane distance</span>        <span class="comment">% normalized by the grid interval S.</span>        <span class="keyword">if</span> isempty(dlab),  dlab=0;  <span class="keyword">end</span>        <span class="keyword">if</span> isempty(dxy),   dxy=0;  <span class="keyword">end</span>        Ds = dlab + m * dxy / s;        <span class="comment">% note: the greater the value of m, the more spatial proximity is</span>        <span class="comment">% emphasized and the more compact the cluster.</span>    <span class="keyword">end</span><span class="comment">%   %----------------------------------------------------------------------</span><span class="comment">% % as some regions will have been absorbed into others and no longer exist</span><span class="comment">% % we now renumber the regions so that they sequentially increase from 1</span><span class="comment">% labels = unique(S(:));  % sorted list of unique labels</span><span class="comment">% S = compressregions(S, labels);</span><span class="comment">% % Ck and ColCk unchanged</span></pre>      <pre class="codeinput"><span class="keyword">end</span> <span class="comment">% end of regionclean_base</span></pre>    </div>    <!--##### SOURCE BEGIN #####%% REGIONCLEAN_BASE - Base function for REGIONCLEAN.%%% Syntax%   [S, Ck, ColCk] = ...%         REGIONCLEAN_BASE(L, Ck, ColCk, I, conn, m, features, thresholds);%%% Credit% <mailto:grazzja@lanl.gov J.Grazzini> (ISR-2/LANL)%%% See also% Ressembles:% <regionclean.html |REGIONCLEAN|>,% <matlab:webpub(whichpath('REGIONPROPS')) |REGIONPROPS|>,% <imlabel.html |IMLABEL|>.% Requires:% <regionadjacency_base.html |REGIONADJACENCY_BASE|>,% <matlab:webpub(whichpath('REGIONPROPS')) |REGIONPROPS|>,% <matlab:webpub(whichpath('BWLABEL')) |BWLABEL|>.%% Function implementationfunction [S, Ck, ColCk] = ...    regionclean_base(S, Ck, ColCk, I, conn, m, features, thresholds)%%% check/set parametersif ~isequal(length(features),length(thresholds))    error('regionclean_base:inputerror', ...        'vectors of feature names and threshold values must have same length' );elseif ~all(ismember(features,{'Area','Solidity','Extent'}))    % 'Perimeter','Eccentricity'    error('regionclean_base:inputerror', ...        'unknown feature - see REGIONCLEAN and REGIONPROPS helps');end[X,Y] = size(S);%% % initialize the labels% if there is a label of 0 ensure we do not renumber that region by removing% it from the list of labels to be renumberedlabels = unique(S(:)); % labels = sort(S(:)); labels(labels(1:end-1)==labels(2:end)) = []; % inline UNIQUElabels = setdiff(labels,0);nlabels = max(labels);% % cc = imlabel(S,8); % we can extract the connected components% % ncc = max(cc(:)); % if ~isequal(nlabels,length(labels))%     S = compressregions(S, labels);%     labels = setdiff(unique(S(:)),0); % update% end% %   %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH%     function L = compressregions(L, labels)%         % this function ensures that the labels are set in sequential order%         % 0 values in the original image are left with the label 0%         if labels(1)~=0, labels = [0; labels];  end%         A = cumsum(diff(labels)-1);%         labels = labels(2:end);%         A = labels - A;%         % do the relabeling: compress%         for l=1:length(labels),    L(L==labels(l)) = A(l);  end%     end% %   %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH%%% break regions by assigning a new label to unconnected sub-regions % checking that there is only one region for each segment label; if there% is more than one region they are given unique labels[S, ischanged] = splitregions(S, conn, labels, nlabels);%   %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH    function [S, ischanged] = splitregions(S, conn, labels, nlabels)        nl = nlabels;  ischanged = [];        for l = labels'            % define the number of connected objects found for each label            [bl,num] = bwlabel(S==l, conn);  % use given connectedness            if num > 1  % more than one region with the same label                Ibl = bl>1; % therefore bl(Ibl)>=2                S(Ibl) = bl(Ibl) + nl - 1;                ischanged = [ischanged; l];                            %#ok                nl = nl + (num - 1); % updated nlabels            end        end        if nl>nlabels,  ischanged = [ischanged; (nlabels+1:nl)'];  end        % note that we do keep the initial labelling of most of the regions        % as we add new regions with labels starting after the larger label        % found in the input image    end%   %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHif ~isempty(ischanged)  % possibly update    labels = setdiff(unique(S(:)),0);    nlabels = max(labels);end%%% update (or not) the centroids of the regionsif isempty(Ck) || ~isempty(ischanged)    % here, we recompute all centroids for simplicity...    Ck = nan(nlabels,2);  ColCk = nan(nlabels,3);    [Ck(labels,:), ColCk(labels,:)] = updatecentroids(S, I, labels);    % elseif ~isempty(ischanged)    %  [Ck(ischanged,:), ColCk(ischanged,:)] = updatecentroids(S, I, ischanged);end%   %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH    function [Ck, ColCk] = updatecentroids(Q, I, k)        if nargin==3 && ~isempty(k)  % get segments' centroids            props = regionprops(Q .* ismember(Q,k),'centroid');        else % perform for all            props = regionprops(Q,'centroid');        end        % note in calling REGIONPROPS: non represented labels in the input         % matrix Q are assigned NaN values into the corresponding cells of        % the calculated feature(s)        Ck = floor(cat(1, props.Centroid));        if nargin<3 || isempty(k),  k = 1:size(Ck,1);  end        Ck = fliplr(Ck(k,:)); % keep only those we are interested in        % Ck = fliplr(floor(cat(1, props.Centroid))); % keep even NaN values        cind = Ck(:,1) + ((Ck(:,2)-1)*Y);  % A = isnan(cind);        cind = [cind cind+X*Y cind+2*X*Y];  % cind(A,:) = [];        ColCk = nan(size(Ck,1),3); % default output        if ~isempty(I),            ColCk = reshape(I(cind), [size(Ck,1) 3]);            % ColCk(~A,:) = reshape(I(cind), [sum(~A) 3]);        end    end%   %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH%%% get the sparse adjacency matrix for all represented labelsG = regionadjacency_base(S, labels, conn);% figure, imagesc(label2rgb(S))%%% find regions whose features do not respect the given thresholdsR = criteriaregions(S, features, thresholds);%%% simple case: get rid of completely isolated regionsisdeleted = find(R);if isempty(isdeleted)     % nothing more to do: none of the current regions desobey the given      % criterion     return;end%   %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH    function C = criteriaregions(S, features, thresholds, k)        if nargin==4 && ~isempty(k)  % get segment(s)' area(s)            props = regionprops(S.*ismember(S,k),features);        else            props = regionprops(S,features);        end        % initialize with the first criterion        C = cat(1,props.(features{1}));        % C = C<thresholds(1) & ~isnan(C);        if nargin<4 || isempty(k),  k = 1:length(C);  end        C = C(k,:)<thresholds(1) & ~isnan(C(k,:));        % complete with other possible criteria        for ip=2:numel(features)            %if ~isfield(props,features{ip})            % eval([genvarname(features{ip}) '= cat(1,props.(features{ip}));']);            A = cat(1,props.(features{ip}));            C = C | (A(k,:)<thresholds(ip) & ~isnan(A(k,:)));            % end        end    end%   %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH%%% fill holes by cleaning completely surrounded regions[S, ischanged] = fillregions(S, G, isdeleted);%   %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH    function [S, ischanged] = fillregions(S, G, isolated)        ischanged = [];        % remove isolated regions embodied in another (unique) region        for l=isolated'            ind = find(full(G(l,:)));            if length(ind)==1                ischanged = [ischanged; ind];                          %#ok                S(S==l) = ind;            end        end    end%   %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH%     function S = fillholes(S)%         % remove isolated pixels embodied in another (unique) region%         isolated = ismember(S,find(area==1 & ~isnan(area)));%         [ic,icd] = ixneighbours(S,isolated);%         P = accumarray(ic, S(icd), [], @(x){x});%         A = cellfun(@(p) length(p)<1,P);%         P(A) = [];%         A = find(~A);%         I = cellfun(@(x) sum(diff([x(end);x(:)],1))==0, P);%         S(A(I)) = P{I}(1);%     end% %   %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH%%% update if any changeif ~isempty(ischanged)    % % recompress    % S = compressregions(S, unique(S(:)));    % update the list of available labels    labels = setdiff(unique(S(:)),0);    nlabels = max(labels);    % update all the representative centroids    Ck = nan(nlabels,2);  ColCk = nan(nlabels,3);    [Ck(labels,:), ColCk(labels,:)] = updatecentroids(S, I, labels);    % update the sparse adjacency matrix    G = regionadjacency_base(S, labels, conn);    % update the area vector    R = criteriaregions(S, features, thresholds);    isdeleted = find(R);ends = floor(sqrt(X*Y/length(labels))); % kind of arbitrary...%%% assign those regions the label of the adjacent region whose centroid is% closest to the centroid of the current regionfor k = isdeleted'     % k is a label index of a region we will have to merge to another one    r = true; % as said, we will merge it for sure        % find regions adjacent to k    ind = find(full(G(k,:)));        %%    % keep merging with the closest element in the adjacency matrix until    % we obtain an area >= tharea, or we run out of regions to merge    while ~isempty(ind) && r        %%        % compute the distances between the centroid of the current        % region and the centroids of all its neighbours        if length(ind)>1            ds = calclabspace(Ck(repmat(k,size(ind)),:), Ck(ind,:), ...                ColCk(repmat(k,size(ind)),:), ColCk(ind,:), s, m);            [~,i] = min(ds);        else            i = 1; % one neighbour only        end        %%        % merge both regions k and ind(i) and store the new merged region        % in k; also update the connecting graph        [S, G] = updateregions(S, G, k, ind(i));        %%        % update regions' centroids for the merged region k only        [Ck(k,:), ColCk(k,:)] = updatecentroids(S, I, k);        %%        % update the criteria on the merged region k only        r = criteriaregions(S, features, thresholds, k);        ind = find(full(G(k,:))); % the adjacency matrix has changed    end    end%%% note that this is an arbitrary merging, depending in particular of the% order the different regions are merged to others...%   %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH    function [S, G] = updateregions(S, G, s1, s2)        % function to merge segment s2 into s1: the segmentation image, the        % adjacency matrix and the area vector are updated.                % update the label image: relabel s2 with s1 in the segment image        S(S==s2) = s1;                % update the connecting graph: s1 inherits the adjacancy matrix        % entries of s2        G(s1,:) = G(s1,:) | G(s2,:);        G(:,s1) = G(:,s1) | G(:,s2);        G(s1,s1) = 0;  % ensure s1 is not connected to itself        % disconnect s2 from the adjacency matrix        G(s2,:) = 0;        G(:,s2) = 0;    end%   %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH    function Ds = calclabspace(p0, p1, Lab0, Lab1, s, m)        distL2 = @(v0, v1) sqrt(sum(abs(v1-v0).^2, 2));                dxy =  distL2(p0, p1);        dlab = distL2(Lab0, Lab1);        % Ds is the sum of the lab distance and the xy plane distance        % normalized by the grid interval S.        if isempty(dlab),  dlab=0;  end        if isempty(dxy),   dxy=0;  end        Ds = dlab + m * dxy / s;        % note: the greater the value of m, the more spatial proximity is        % emphasized and the more compact the cluster.    end%   %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH% % as some regions will have been absorbed into others and no longer exist% % we now renumber the regions so that they sequentially increase from 1% labels = unique(S(:));  % sorted list of unique labels% S = compressregions(S, labels);% % Ck and ColCk unchangedend % end of regionclean_base##### SOURCE END #####--></body></html>