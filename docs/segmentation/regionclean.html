<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html>  <head>    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">    <!--This HTML was auto-generated from MATLAB code.To make changes, update the MATLAB code and republish this document.      -->    <title>REGIONCLEAN - Clean up a label image.</title>    <meta name="generator" content="MATLAB 7.14">    <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">    <meta name="DC.date" content="2012-05-31">    <meta name="DC.source" content="regionclean.m">    <style type="text/css">html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}html { min-height:100%; margin-bottom:1px; }html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }html body td { vertical-align:top; text-align:left; }h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }a { color:#005fce; text-decoration:none; }a:hover { color:#005fce; text-decoration:underline; }a:visited { color:#004aa0; text-decoration:none; }p { padding:0px; margin:0px 0px 20px; }img { padding:0px; margin:0px 0px 20px; border:none; }p img, pre img, tt img, li img { margin-bottom:0px; } ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }ul li { padding:0px; margin:0px 0px 7px 0px; }ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }ul li ol li { list-style:decimal; }ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }ol li ol li { list-style-type:lower-alpha; }ol li ul { padding-top:7px; }ol li ul li { list-style:square; }.content { font-size:1.2em; line-height:140%; padding: 20px; }pre, tt, code { font-size:12px; }pre { margin:0px 0px 20px; }pre.error { color:red; }pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }span.keyword { color:#0000FF }span.comment { color:#228B22 }span.string { color:#A020F0 }span.untermstring { color:#B20000 }span.syscmd { color:#B28C00 }.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }.footer p { margin:0px; }  </style>  </head>  <body>    <div class="content">      <h1>REGIONCLEAN - Clean up a label image.</h1>      <!--introduction--><!--/introduction-->      <h2>Contents</h2>      <div>        <ul>          <li><a href="#1">Description</a></li>          <li><a href="#2">Syntax</a></li>          <li><a href="#3">Inputs</a></li>          <li><a href="#4">Property [propertyname propertyvalues]</a></li>          <li><a href="#5">Outputs</a></li>          <li><a href="#6">Example</a></li>          <li><a href="#7">Remarks</a></li>          <li><a href="#8">References</a></li>          <li><a href="#10">See also</a></li>          <li><a href="#11">Function implementation</a></li>        </ul>      </div>      <h2>Description<a name="1"></a></h2>      <p>Clean up a label image of segmentation by merging regions which do not        verify certain shape/area criteria to those satisfying it.</p>      <h2>Syntax<a name="2"></a></h2>      <pre>   S = REGIONCLEAN(L);   [S, Ck, ColCk]  = REGIONCLEAN(L, 'Property', propertyvalue, ...);</pre>      <h2>Inputs<a name="3"></a></h2>      <p>*<tt>L : a segmentation image, where each pixel is assigned the          (integer) label of the region it belongs to; positive integer elements          of |L</tt> correspond to different regions; labels are found in the        range <tt>[0,N]</tt>, but are not all necessarly represented.</p>      <h2>Property [propertyname propertyvalues]<a name="4"></a></h2>      <p><b><tt>'area'</tt></b> : (optional) threshold <tt>area&gt;0</tt> upon        regions' area; when <tt>area&gt;1</tt>, regions whose area in pixels is        below thres are merged with an adjacent segment; when <tt>0&lt;area&lt;1</tt>,        regions whose area is less than this treshold times the mean segment        area are merged with an adjacent segment; default: <tt>area=0.1</tt>        and it is estimated using <tt>REGIONPROPS</tt>.</p>      <p><b><tt>'solid'</tt></b> : (optional) threshold <tt>0&lt;solid&lt;1</tt>        upon regions' solidity (defined, for each region, as the proportion of        the pixels in the convex hull of this region that are also in the region        and it computed as the ratio Area/ConvexArea; regions whose solidity is        less than this treshold are merged with an adjacent segment; default: <tt>solid=1</tt>,        ie. this is not taken into account, otherwise it is estimated using <tt>REGIONPROPS</tt>.</p>      <p><b><tt>'extent'</tt></b> : (optional) threshold <tt>0&lt;extent&lt;1</tt>        upon regions' extent (defined as the ratio of pixels in the region to        pixels in the total bounding box and computed as Area/BoundingArea);        regions whose extent is less than this threshold are deleted/merged;        default: <tt>extent=1</tt>, ie. this is not taken into account,        otherwise it is estimated using <tt>REGIONPROPS</tt>.</p>      <p><b><tt>'I'</tt></b> : (optional) input image over which labels were        defined; it must be of same (x,y)-dimensions as the input label image <tt>L</tt>,        it can however also be multichannel (RGB or Lab); it is used in the        estimation of the combined spatial/spectral distance between centroids;        default: <tt>I=[]</tt>, ie. the spectral component is ignored and the        distance between centroids is simply the spatial one.</p>      <p><b><tt>'m'</tt></b> : (optional) scalar defining the combined        spatial/spectral metric used to compute distance between centroids when        a small region has to be merged to a larger one; the greater this value,        the more spatial proximity is emphasized in the calculation of distances        and the more compact the clusters are; this value can be in the range <tt>[1,          20]</tt>; default: <tt>m=1</tt>.</p>      <p><b><tt>'Ck'</tt></b> : (optional) coordinates of the centroids of the        corresponding regions; it is a matrix of size <tt>(N,2)</tt>, where <tt>N</tt>        is the maximal value of labels found in <tt>L</tt>; in particular, non        represented labels in <tt>L</tt> must have <tt>NaN</tt> entries in <tt>Ck</tt>;        default: <tt>Ck=[]</tt>, centroids of the given image segmentation are        estimated using <tt>REGIONPROPS</tt>.</p>      <p><b><tt>'ColCk'</tt></b> : (optional) representative color (e.g. RGB or        Lab) values of the segments; it is a matrix of size <tt>(N,3)</tt>        default: <tt>ColCk=[]</tt>, so that the representative color is not        considered when estimating the centroid distance.</p>      <p><b><tt>'compress'</tt></b> : (optional) flag stating if the output        label image should be compressed or not, ie. the range of label values        is reduced; in that case, <tt>NaN</tt> entries of the output <tt>[Ck,ColCk]</tt>        (see below) are also deleted; default: <tt>compress=false</tt>.</p>      <h2>Outputs<a name="5"></a></h2>      <p><b><tt>S</tt></b> : updated segmentation image with new/refined        labelled regions.</p>      <p><b><tt>Ck</tt></b> : coordinates of the centroids of the regions; it is        a matrix of size <tt>[K 2]</tt>, with <tt>K</tt> the maximum label        entry found in <tt>S</tt>.</p>      <p><b><tt>ColCk</tt></b> : representative values of the filtered labelled        regions; it is a matrix of size <tt>[K 3]</tt>.</p>      <h2>Example<a name="6"></a></h2>      <pre>  I = imread('autumn.tif');  L = slicsuperpix(I, 20, 'disp', true);  S = REGIONCLEAN(L, 'I', I, 'area', 100, 'conn', 4, 'disp', true);  S = REGIONCLEAN(L, 'area', 0.1, 'conn', 8, 'm', 1); % default command</pre>      <h2>Remarks<a name="7"></a></h2>      <div>        <ul>          <li>The Image Processing toolbox is required. See <tt>REGIONPROPS</tt>.</li>        </ul>      </div>      <div>        <ul>          <li>The rule for merging regions must naturally follow decreasing            predicates For remind, "a (logical) predicate is said to be            decreasing if and only if every subset of any set satisfying this            predicate also satisfies it" [SG09]. For instance, the predicate 'is            the region's area less than a given threshold?" (herein implemented            through the use of the 'area' option) is an example of such            predicate.</li>        </ul>      </div>      <div>        <ul>          <li>Regions are suppressed and/or merged at the cost of some arbitrary            decisions: <i>(i)</i> in the presence of regions whose smallest            distance (in the combined spatial/spectral domain) to their            neighbouring regions is obtained for more than one region, <i>(ii)</i>            the regrouping process (and therefore its ouput) depends on the            order those regions to be merged are considered.</li>        </ul>      </div>      <div>        <ul>          <li>The metric used to compute the distance between labelled regions'            centroids is derived from that proposed in [ASSLFS10].</li>        </ul>      </div>      <h2>References<a name="8"></a></h2>      <p>[SG09] P. Soille and J. Grazzini: "Constrained connectivity and        transition regions", Proc. of ISMM, LNCS 5720, pp. 59?69,        Springer-Verlag, 2009. <a href="http://www.springerlink.com/content/g6h8mk8447041532/">http://www.springerlink.com/content/g6h8mk8447041532/</a></p>      <p>[ASSLFS10] R. Achanta, A. Shaji, K. Smith, A. Lucchi, P. Fua and S.        Susstrunk: "SLIC superpixels", EPFL Technical Report no. 149300, 2010. <a          href="http://infoscience.epfl.ch/record/149300/files/SLIC_Superpixels_TR_2.pdf">http://infoscience.epfl.ch/record/149300/files/SLIC_Superpixels_TR_2.pdf</a></p>      <h2>See also<a name="10"></a></h2>      <p>Related: <a href="regionadjacency.html"><tt>REGIONADJACENCY</tt></a>,        <a href="matlab:webpub%28whichpath%28%27REGIONPROPS%27%29%29"><tt>REGIONPROPS</tt></a>,        <a href="imlabel.html"><tt>IMLABEL</tt></a>. Called: <a href="regionclean_base.html"><tt>REGIONCLEAN_BASE</tt></a>.</p>      <h2>Function implementation<a name="11"></a></h2>      <pre class="codeinput"><span class="keyword">function</span> [S, varargout] = regionclean(L, varargin)</pre>      <pre class="codeinput"><span class="keyword">if</span> isempty(ver(<span class="string">'images'</span>))    <span class="comment">% note that REGIONPROPS is used in REGIONCLEAN_BASE</span>    error(<span class="string">'regionclean:errortoolbox'</span>, <span class="keyword">...</span>        <span class="string">'Image Processing toolbox required for calling REGIONPROPS'</span>);<span class="keyword">end</span></pre>      <p>parsing parameters</p>      <pre class="codeinput">error(nargchk(1, 27, nargin, <span class="string">'struct'</span>));error(nargoutchk(1, 1, nargout, <span class="string">'struct'</span>));<span class="comment">% mandatory parameter</span><span class="keyword">if</span> ~isnumeric(L)    error(<span class="string">'regionadjacency:inputerror'</span>,<span class="string">'image of integer labels required in entry'</span>);<span class="keyword">end</span>p = createParser(<span class="string">'REGIONCLEAN'</span>);   <span class="comment">% create an instance of the inputParser class.</span>p.addParamValue(<span class="string">'area'</span>, 0.1, @(x)isempty(x) || (isscalar(x) &amp;&amp; x&gt;0));p.addParamValue(<span class="string">'solid'</span>, [], @(x)isempty(x) || (isscalar(x) &amp;&amp; x&gt;0 &amp;&amp; x&lt;=1));<span class="comment">% p.addParamValue('isoper', [], @(x)isempty(x) || (isscalar(x) &amp;&amp; x&gt;=0 &amp;&amp; x&lt;=1));</span><span class="comment">% %   'isoper' : (optional) threshold 0&lt;isoper&lt;1 upon regions' isoperimetric</span><span class="comment">% %     quotient (defined as the ratio of Area/CircleArea, where CircleArea is</span><span class="comment">% %     the area of the circle having the same perimeter); default: isoper=1,</span><span class="comment">% %     ie. this is not taken into account.</span>p.addParamValue(<span class="string">'extent'</span>, [], @(x)isempty(x) || (isscalar(x) &amp;&amp; x&gt;=0 &amp;&amp; x&lt;=1));<span class="comment">% p.addParamValue('eccent', [], @(x)isempty(x) || (isscalar(x) &amp;&amp; x&gt;=0 &amp;&amp; x&lt;=1));</span><span class="comment">% %   'eccent' : (optional) threshold 0&lt;eccent&lt;1 upon regions' eccentricity</span><span class="comment">% %     (specifying the eccentricity of the ellipse that has the same second</span><span class="comment">% %     moments as the region and computed as the ratio of the distance between</span><span class="comment">% %     the foci of the ellipse and its major axis length);</span>p.addParamValue(<span class="string">'conn'</span>, 8, @(x)isscalar(x) &amp;&amp; (x==4 || x==8));p.addParamValue(<span class="string">'I'</span>, [], @(x)isnumeric(x));p.addParamValue(<span class="string">'m'</span>, 1, @(x)isscalar(x) &amp;&amp; x&gt;=1 &amp;&amp; x&lt;=20);p.addParamValue(<span class="string">'Ck'</span>, [], @(x)isempty(x) || (isnumeric(x) &amp;&amp; all(x(:)&gt;=0)));p.addParamValue(<span class="string">'ColCk'</span>, [], @(x)isempty(x) || isnumeric(x));p.addParamValue(<span class="string">'compress'</span>, false, @islogical);<span class="comment">% parse and validate all input arguments</span>p.parse(varargin{:});p = getvarParser(p);</pre>      <p>setting variables</p>      <pre class="codeinput">[X,Y] = size(L);<span class="keyword">if</span> ~isempty(p.Ck) &amp;&amp; ~isequal(max(unique(L(:))),size(Ck,1))    error(<span class="string">'regionclean:errorinput'</span>, <span class="keyword">...</span>        [<span class="string">'the length of the centroid matrix must be equal to the maximal '</span> <spanclass="keyword">...</span>        <span class="string">'label value found in the input segmentation image '</span>]);<span class="keyword">elseif</span> ~isempty(p.ColCk) &amp;&amp; ~isempty(p.Ck) &amp;&amp; <spanclass="keyword">...</span>        ~isequal(size(ColCk,1),size(Ck,1))    error(<span class="string">'regionclean:errorinput'</span>, <span class="keyword">...</span>        <span class="string">'centroid matrix and representative matrix must have same length'</span>);<span class="keyword">end</span>features = {<span class="string">''</span>}; thresholds = [];<span class="keyword">if</span> ~isempty(p.area) &amp;&amp; p.area&lt;X*Y,    features = [features, <span class="string">'Area'</span>];    <span class="keyword">if</span> p.area&lt;1,        props = regionprops(L,<span class="string">'Area'</span>);        p.area = p.area * mean(cat(1,props.Area));    <span class="keyword">end</span>    thresholds = [thresholds; p.area];<span class="keyword">end</span><span class="keyword">if</span> ~isempty(p.solid) &amp;&amp; p.solid&lt;1,    features = [features, <span class="string">'Solidity'</span>];    thresholds = [thresholds; p.solid];<span class="keyword">end</span><span class="comment">% if ~isempty(p.isoper) &amp;&amp; p.isoper&lt;1,</span><span class="comment">%     features = [features, 'Perimeter', 'Area'];</span><span class="comment">%     thresholds = [thresholds; p.isoper];</span><span class="comment">% end</span><span class="comment">% if ~isempty(p.eccent) &amp;&amp; p.eccent&lt;1,</span><span class="comment">%     features = [features, 'Eccentricity'];</span><span class="comment">%     thresholds = [thresholds; p.eccent];</span><span class="comment">% end</span><span class="keyword">if</span> ~isempty(p.extent) &amp;&amp; p.extent&lt;1,    features = [features, <span class="string">'Extent'</span>];    thresholds = [thresholds; p.extent];<span class="keyword">end</span>features(cellfun(@isempty,features)) = []; <span class="comment">% get rid of empty strings</span><span class="keyword">if</span> isempty(features) <span class="comment">% and isempty(thresholds)</span>    error(<span class="string">'regionclean:inputerror'</span>, <span class="keyword">...</span>    <span class="string">'at least one discriminating feature needs to be selected'</span>);<span class="keyword">end</span><span class="comment">% features = unique(features); % avoid repeated 'Area' entry</span></pre>      <p>main calculation</p>      <pre class="codeinput">[S, p.Ck, p.ColCk] = regionclean_base(L, p.Ck, p.ColCk, p.I, p.conn, p.m, <spanclass="keyword">...</span>    features, thresholds);<span class="keyword">if</span> nargout&gt;1, varargout{1} = p.Ck;    <span class="keyword">if</span> nargout&gt;2,  varargout{2} = p.ColCk;  <spanclass="keyword">end</span><span class="keyword">end</span><span class="keyword">if</span> p.compress,    S = compressrange(S);  <span class="keyword">end</span></pre>      <p>display</p>      <pre class="codeinput"><span class="keyword">if</span> p.disp    figure,    subplot(1,2,1), imagesc(label2rgb(L.*(imdilate(L,ones(3,3))-L==0)));    axis <span class="string">image</span> <span class="string">off</span>, title(<spanclass="string">'input regions'</span>);    subplot(1,2,2), imagesc(label2rgb(S.*(imdilate(S,ones(3,3))-S==0)));    axis <span class="string">image</span> <span class="string">off</span>, title(<spanclass="string">'cleaned regions'</span>);<span class="keyword">end</span></pre>      <pre class="codeinput"><span class="keyword">end</span> <span class="comment">% end of regionclean</span></pre></div>    <!--##### SOURCE BEGIN #####%% REGIONCLEAN - Clean up a label image.%%% Description% Clean up a label image of segmentation by merging regions which do not % verify certain shape/area criteria to those satisfying it.%%% Syntax%     S = REGIONCLEAN(L);%     [S, Ck, ColCk]  = REGIONCLEAN(L, 'Property', propertyvalue, ...);%%% Inputs% *|L : a segmentation image, where each pixel is assigned the (integer) label%     of the region it belongs to; positive integer elements of |L| correspond%     to different regions; labels are found in the range |[0,N]|, but are not%     all necessarly represented.             % %% Property [propertyname  propertyvalues]% *|'area'|* : (optional) threshold |area>0| upon regions' area; when |area>1|,%     regions whose area in pixels is below thres are merged with an adjacent%     segment; when |0<area<1|, regions whose area is less than this treshold%     times the mean segment area are merged with an adjacent segment;%     default: |area=0.1| and it is estimated using |REGIONPROPS|.% % *|'solid'|* : (optional) threshold |0<solid<1| upon regions' solidity (defined, %     for each region, as the proportion of the pixels in the convex hull of%     this region that are also in the region and it computed as the ratio%     Area/ConvexArea; regions whose solidity is less than this treshold are%     merged with an adjacent segment; default: |solid=1|, ie. this is not%     taken into account, otherwise it is estimated using |REGIONPROPS|.% % *|'extent'|* : (optional) threshold |0<extent<1| upon regions' extent (defined%     as the ratio of pixels in the region to pixels in the total bounding%     box and computed as Area/BoundingArea); regions whose extent is less%     than this threshold are deleted/merged; default: |extent=1|, ie. this is%     not taken into account,  otherwise it is estimated using |REGIONPROPS|.% % *|'I'|* : (optional) input image over which labels were defined; it must be%     of same (x,y)-dimensions as the input label image |L|, it can however%     also be multichannel (RGB or Lab); it is used in the estimation of the%     combined spatial/spectral distance between centroids; default: |I=[]|,%     ie. the spectral component is ignored and the distance between centroids %     is simply the spatial one.% % *|'m'|* : (optional) scalar defining the combined spatial/spectral metric used%     to compute distance between centroids when a small region has to be%     merged to a larger one; the greater this value, the more spatial proximity%     is emphasized in the calculation of distances and the more compact the %     clusters are; this value can be in the range |[1, 20]|; default: |m=1|. % % *|'Ck'|* : (optional) coordinates of the centroids of the corresponding regions;%     it is a matrix of size |(N,2)|, where |N| is the maximal value of labels%     found in |L|; in particular, non represented labels in |L| must have %     |NaN| entries in |Ck|; default: |Ck=[]|, centroids of the given image %     segmentation are estimated using |REGIONPROPS|.% % *|'ColCk'|* : (optional) representative color (e.g. RGB or Lab) values of the%     segments; it is a matrix of size |(N,3)| default: |ColCk=[]|, so that%     the representative color is not considered when estimating the centroid%     distance.% % *|'compress'|* : (optional) flag stating if the output label image should%     be compressed or not, ie. the range of label values is reduced; in that%     case, |NaN| entries of the output |[Ck,ColCk]| (see below) are also%     deleted; default: |compress=false|. %%% Outputs% *|S|* : updated segmentation image with new/refined labelled regions.% % *|Ck|* : coordinates of the centroids of the regions; it is a matrix of size%     |[K 2]|, with |K| the maximum label entry found in |S|.% % *|ColCk|* : representative values of the filtered labelled regions; it is a%     matrix of size |[K 3]|.%%% Example%    I = imread('autumn.tif'); %    L = slicsuperpix(I, 20, 'disp', true);%    S = REGIONCLEAN(L, 'I', I, 'area', 100, 'conn', 4, 'disp', true);%    S = REGIONCLEAN(L, 'area', 0.1, 'conn', 8, 'm', 1); % default command%%% Remarks% * The Image Processing toolbox is required. See |REGIONPROPS|.%% * The rule for merging regions must naturally follow decreasing predicates%    For remind, "a (logical) predicate is said to be decreasing if and only %    if every subset of any set satisfying this predicate also satisfies it"%    [SG09]. For instance, the predicate 'is the region's area less than a%    given threshold?" (herein implemented through the use of the 'area' %    option) is an example of such predicate.%% * Regions are suppressed and/or merged at the cost of some arbitrary%    decisions: _(i)_ in the presence of regions whose smallest distance (in %    the combined spatial/spectral domain) to their neighbouring regions is  %    obtained for more than one region, _(ii)_ the regrouping process (and%    therefore its ouput) depends on the order those regions to be merged are%    considered.%% * The metric used to compute the distance between labelled regions'%    centroids is derived from that proposed in [ASSLFS10].% %% References% [SG09]  P. Soille and J. Grazzini: "Constrained connectivity and transition %      regions", Proc. of ISMM, LNCS 5720, pp. 59?69, Springer-Verlag, 2009.%      <http://www.springerlink.com/content/g6h8mk8447041532/>%% [ASSLFS10]  R. Achanta, A. Shaji, K. Smith, A. Lucchi, P. Fua and S. %      Susstrunk: "SLIC superpixels", EPFL Technical Report no. 149300, 2010.%      <http://infoscience.epfl.ch/record/149300/files/SLIC_Superpixels_TR_2.pdf>%%% Credit% <mailto:grazzja@lanl.gov J.Grazzini> (ISR-2/LANL)%%% See also% Related:% <regionadjacency.html |REGIONADJACENCY|>,% <matlab:webpub(whichpath('REGIONPROPS')) |REGIONPROPS|>,% <imlabel.html |IMLABEL|>.% Called:% <regionclean_base.html |REGIONCLEAN_BASE|>.%% Function implementationfunction [S, varargout] = regionclean(L, varargin)if isempty(ver('images'))    % note that REGIONPROPS is used in REGIONCLEAN_BASE    error('regionclean:errortoolbox', ...        'Image Processing toolbox required for calling REGIONPROPS');end%%% parsing parameterserror(nargchk(1, 27, nargin, 'struct'));error(nargoutchk(1, 1, nargout, 'struct'));% mandatory parameterif ~isnumeric(L)    error('regionadjacency:inputerror','image of integer labels required in entry'); endp = createParser('REGIONCLEAN');   % create an instance of the inputParser class.p.addParamValue('area', 0.1, @(x)isempty(x) || (isscalar(x) && x>0));p.addParamValue('solid', [], @(x)isempty(x) || (isscalar(x) && x>0 && x<=1));% p.addParamValue('isoper', [], @(x)isempty(x) || (isscalar(x) && x>=0 && x<=1));% %   'isoper' : (optional) threshold 0<isoper<1 upon regions' isoperimetric% %     quotient (defined as the ratio of Area/CircleArea, where CircleArea is% %     the area of the circle having the same perimeter); default: isoper=1,% %     ie. this is not taken into account.p.addParamValue('extent', [], @(x)isempty(x) || (isscalar(x) && x>=0 && x<=1));% p.addParamValue('eccent', [], @(x)isempty(x) || (isscalar(x) && x>=0 && x<=1));% %   'eccent' : (optional) threshold 0<eccent<1 upon regions' eccentricity % %     (specifying the eccentricity of the ellipse that has the same second% %     moments as the region and computed as the ratio of the distance between% %     the foci of the ellipse and its major axis length);  p.addParamValue('conn', 8, @(x)isscalar(x) && (x==4 || x==8));p.addParamValue('I', [], @(x)isnumeric(x));p.addParamValue('m', 1, @(x)isscalar(x) && x>=1 && x<=20);p.addParamValue('Ck', [], @(x)isempty(x) || (isnumeric(x) && all(x(:)>=0)));p.addParamValue('ColCk', [], @(x)isempty(x) || isnumeric(x));p.addParamValue('compress', false, @islogical);% parse and validate all input argumentsp.parse(varargin{:}); p = getvarParser(p); %% % setting variables[X,Y] = size(L);if ~isempty(p.Ck) && ~isequal(max(unique(L(:))),size(Ck,1))    error('regionclean:errorinput', ...        ['the length of the centroid matrix must be equal to the maximal ' ...        'label value found in the input segmentation image ']);elseif ~isempty(p.ColCk) && ~isempty(p.Ck) && ...        ~isequal(size(ColCk,1),size(Ck,1))    error('regionclean:errorinput', ...        'centroid matrix and representative matrix must have same length');endfeatures = {''}; thresholds = [];if ~isempty(p.area) && p.area<X*Y,        features = [features, 'Area'];      if p.area<1,         props = regionprops(L,'Area');        p.area = p.area * mean(cat(1,props.Area));    end    thresholds = [thresholds; p.area]; end if ~isempty(p.solid) && p.solid<1,        features = [features, 'Solidity'];      thresholds = [thresholds; p.solid];   end% if ~isempty(p.isoper) && p.isoper<1,  %     features = [features, 'Perimeter', 'Area'];  %     thresholds = [thresholds; p.isoper];% end% if ~isempty(p.eccent) && p.eccent<1,  %     features = [features, 'Eccentricity'];  %     thresholds = [thresholds; p.eccent];% endif ~isempty(p.extent) && p.extent<1,      features = [features, 'Extent'];      thresholds = [thresholds; p.extent];endfeatures(cellfun(@isempty,features)) = []; % get rid of empty stringsif isempty(features) % and isempty(thresholds)    error('regionclean:inputerror', ...    'at least one discriminating feature needs to be selected');end% features = unique(features); % avoid repeated 'Area' entry%% % main calculation[S, p.Ck, p.ColCk] = regionclean_base(L, p.Ck, p.ColCk, p.I, p.conn, p.m, ...    features, thresholds);if nargout>1, varargout{1} = p.Ck;     if nargout>2,  varargout{2} = p.ColCk;  endendif p.compress,    S = compressrange(S);  end%% % displayif p.disp    figure,     subplot(1,2,1), imagesc(label2rgb(L.*(imdilate(L,ones(3,3))-L==0)));    axis image off, title('input regions');    subplot(1,2,2), imagesc(label2rgb(S.*(imdilate(S,ones(3,3))-S==0)));    axis image off, title('cleaned regions');endend % end of regionclean##### SOURCE END #####-->  </body></html>