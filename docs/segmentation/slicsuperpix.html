<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html>  <head>    <meta content="text/html; charset=utf-8" http-equiv="content-type">    <!--This HTML was auto-generated from MATLAB code.To make changes, update the MATLAB code and republish this document.      -->    <title>SLICSUPERPIX - Simple Linear Iterative Clustering.</title>    <meta name="generator" content="MATLAB 7.14">    <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">    <meta name="DC.date" content="2012-05-31">    <meta name="DC.source" content="slicsuperpix.m">    <style type="text/css">html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}html { min-height:100%; margin-bottom:1px; }html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }html body td { vertical-align:top; text-align:left; }h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }a { color:#005fce; text-decoration:none; }a:hover { color:#005fce; text-decoration:underline; }a:visited { color:#004aa0; text-decoration:none; }p { padding:0px; margin:0px 0px 20px; }img { padding:0px; margin:0px 0px 20px; border:none; }p img, pre img, tt img, li img { margin-bottom:0px; } ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }ul li { padding:0px; margin:0px 0px 7px 0px; }ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }ul li ol li { list-style:decimal; }ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }ol li ol li { list-style-type:lower-alpha; }ol li ul { padding-top:7px; }ol li ul li { list-style:square; }.content { font-size:1.2em; line-height:140%; padding: 20px; }pre, tt, code { font-size:12px; }pre { margin:0px 0px 20px; }pre.error { color:red; }pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }span.keyword { color:#0000FF }span.comment { color:#228B22 }span.string { color:#A020F0 }span.untermstring { color:#B20000 }span.syscmd { color:#B28C00 }.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }.footer p { margin:0px; }  </style>  </head>  <body>    <div class="content">      <h1>SLICSUPERPIX - Simple Linear Iterative Clustering.</h1>      <!--introduction--><!--/introduction-->      <h2>Contents</h2>      <div>        <ul>          <li><a href="#1">Description</a></li>          <li><a href="#2">Syntax</a></li>          <li><a href="#3">Inputs</a></li>          <li><a href="#4">Property [propertyname propertyvalues]</a></li>          <li><a href="#5">Outputs</a></li>          <li><a href="#6">Example</a></li>          <li><a href="#7">References</a></li>          <li><a href="#9">See also</a></li>          <li><a href="#10">Function implementation</a></li>        </ul>      </div>      <h2>Description<a name="1"></a></h2>      <p>Implement the SLIC (Simple Linear Iterative Clustering) superpixel        segmentation of [ASSLFS10,LSALF10]. The SLIC approach clusters pixels in        the combined five-dimensional color and image plane space.</p>      <p>See also software [SLIC].</p>      <h2>Syntax<a name="2"></a></h2>      <pre>  Q = SLICSUPERPIX(I);  [Q, Ck, ColCk] = SLICSUPERPIX(I, S);  [Q, Ck, ColCk] = SLICSUPERPIX(I, S, 'Property', propertyvalue, ... );</pre>      <h2>Inputs<a name="3"></a></h2>      <p><b><tt>I</tt></b> : input color image of size <tt>(X,Y,C)</tt>        (multispectral with <tt>C=3</tt> bands).</p>      <p><b><tt>S</tt></b> : (optional) variable setting the scale of the        superpixel segmentation; when <tt>S&gt;=1</tt>, it represents an upper        bound for the desired number of clusters, ie. the approximate number of        approximately equally-sized superpixels (and the approximate size of        each superpixel is <tt>(X*Y)/S</tt> pixels); when <tt>0&lt;S&lt;1</tt>,        it represents the size of the superpixel as a proportion of the size of        the input image, ie. the superpixels will have a size of approximately <tt>(min(X,Y)*S)^2</tt>        pixels; default: <tt>S=0.05</tt>, ie. if the input image is of size        (100,100), the superpixel segments are expected to have a size of        approximately 25 pixels.</p>      <h2>Property [propertyname propertyvalues]<a name="4"></a></h2>      <p><b><tt>'T'</tt></b> : (optional) stopping criterion; it is defined as a        threshold on the errror for relocating all the superpixel regions'        centers; default: <tt>T=eps</tt>.</p>      <p><b><tt>'n'</tt></b> : (optional) multiplying factor used for the search        area around each superpixel region's center; default: <tt>n=2</tt>.</p>      <p><b><tt>'m'</tt></b> : (optional) scalar; the greater this value, the        more spatial proximity is emphasized in the calculation of distances and        the more compact the clusters are; this value can be &gt;=0; we did        however replace the original expression Eq.(1): <img src="slicsuperpix_eq31039.png"          alt="$D_s = d_{lab} + m * d_{xy} / S$">        with a simpler one: <img src="slicsuperpix_eq84998.png" alt="$D_s = d_{lab} + m * d_{xy}$">        as it is easier to control the compactness of the clusters this way        (using <tt>m</tt> only); default: <tt>m=1</tt>.</p>      <p><b><tt>'k'</tt></b> : (optional) size of the neighbourood considered        when correcting the location of the superpixel regions' centers; when        set to 0, the first initial initialization is kept as it is; default: <tt>k=3</tt>.</p>      <p><b><tt>'iter'</tt></b> : (optional) maximum number of iterations;        default: <tt>iter=Inf</tt>, ie. the segmentation process is iterated        till convergence.</p>      <p><b><tt>'lab'</tt></b> : (optional) boolean flag set to true for        transforming, prior to the processing, a 3D image (assumed to be RGB)        into the Lab color space; default: <tt>lab=true</tt>.</p>      <h2>Outputs<a name="5"></a></h2>      <p><b><tt>Q</tt></b> : diagram of superpixels regions; it takes values in        the range <tt>[1,K]</tt> where <tt>K</tt> is the final number of        superpixel regions; it is a matrix of size <tt>(X,Y)</tt>.</p>      <p><b><tt>Ck</tt></b> : coordinates of the centers of the corresponding        superpixels; it is a matrix of size <tt>(K,2)</tt>.</p>      <p><b><tt>ColCk</tt></b> : representative values of the superpixels; it is        a matrix of size <tt>(K,3)</tt>, whose values are in Lab space if the        flag <tt>lab</tt> (see above) is set to <tt>true</tt>.</p>      <h2>Example<a name="6"></a></h2>      <pre>  I = imread('autumn.tif');  L = SLICSUPERPIX(I, 20, 'disp', true);  [Q, Ck, ColCk] = SLICSUPERPIX(I, 0.05, 'T', eps, 'n', 2, 'm', 10, 'k', 3, 'i', Inf);  % default</pre>      <h2>References<a name="7"></a></h2>      <p>[ASSLFS10] R. Achanta, A. Shaji, K. Smith, A. Lucchi, P. Fua and S.        Susstrunk: "SLIC superpixels", EPFL Technical Report no. 149300, 2010. <a          href="http://infoscience.epfl.ch/record/149300/files/SLIC_Superpixels_TR_2.pdf">http://infoscience.epfl.ch/record/149300/files/SLIC_Superpixels_TR_2.pdf</a></p>      <p>[LSALF10] A. Lucchi, K. Smith, R. Achanta, V. Lepetit and P. Fua: "A        fully automated approach to segmentation of irregularly shaped cellular        structures in EM images", Proc. MICCAI, 2010. <a href="http://cvlab.epfl.ch/publications/publications/2010/LucchiSALF10.pdf">http://cvlab.epfl.ch/publications/publications/2010/LucchiSALF10.pdf</a></p>      <p>[SLIC] executable available at: <a href="http://ivrg.epfl.ch/supplementary_material/RK_SLICSuperpixels/index.html">http://ivrg.epfl.ch/supplementary_material/RK_SLICSuperpixels/index.html</a>.</p>      <h2>See also<a name="9"></a></h2>      <p>Related: <a href="SLICSUPERPIX.html"><tt>SLICSUPERPIX</tt></a>, <a href="GEOSUPERPIX.html"><tt>GEOSUPERPIX</tt></a>,        <a href="AMOEBASUPERPIX.html"><tt>AMOEBASUPERPIX</tt></a>. Called: <a href="SLICSUPERPIX_BASE.html"><tt>SLICSUPERPIX_BASE</tt></a>.</p>      <h2>Function implementation<a name="10"></a></h2>      <pre class="codeinput"><span class="keyword">function</span> [Q, varargout] = slicsuperpix(I, varargin)</pre>      <p>parsing parameters</p>      <pre class="codeinput">error(nargchk(1, 22, nargin, <span class="string">'struct'</span>));error(nargoutchk(0, 3, nargout, <span class="string">'struct'</span>));<span class="comment">% mandatory parameter</span><span class="keyword">if</span> ~isnumeric(I)    error(<span class="string">'slicsuperpix:inputerror'</span>,<span class="string">'a matrix is required in input'</span>);<span class="keyword">end</span>p = createParser(<span class="string">'SLICSUPERPIX'</span>);   <span class="comment">% create an instance of the inputParser class.</span><span class="comment">% optional parameter</span>p.addOptional(<span class="string">'S'</span>, 0.05, @(x)isscalar(x) &amp;&amp; ((x&gt;0 &amp;&amp; x&lt;1) || (x&gt;1 &amp;&amp; x==round(x))));<span class="comment">% additional optional parameters</span>p.addParamValue(<span class="string">'m'</span>, 1, @(x)isscalar(x) &amp;&amp; x&gt;=0);p.addParamValue(<span class="string">'T'</span>, eps, @(x) isscalar(x) &amp;&amp; x&gt;=0);p.addParamValue(<span class="string">'n'</span>, 2, @(x)isscalar(x) &amp;&amp; x&gt;=1 &amp;&amp; x==round(x));p.addParamValue(<span class="string">'k'</span>, 3, @(x)isscalar(x) &amp;&amp; (x==0 || x&gt;=3));p.addParamValue(<span class="string">'iter'</span>, Inf, @(x)isscalar(x) &amp;&amp; x&gt;=1);p.addParamValue(<span class="string">'lab'</span>, true, @islogical);<span class="comment">% parse and validate all input arguments</span>p.parse(varargin{:});p = getvarParser(p);</pre>      <p>setting variables</p>      <pre class="codeinput">C = size(I,3);<span class="keyword">if</span> C~=3    warning(<span class="string">'slicsuperpix_base:inputwarning'</span>, <spanclass="keyword">...</span>        <span class="string">'RGB/Lab image required in input - input image is converted'</span>);    <span class="keyword">if</span> C==1,   I = repmat(I, [1 1 3]);    <span class="keyword">else</span>       I = I(:,:,1:3);    <span class="keyword">end</span><span class="keyword">end</span><span class="keyword">if</span> p.S&lt;1    <span class="comment">% p.S = p.S * min(size(I,1),size(I,2));</span>    p.S = numel(I(:,:,1)) ./ (p.S * min(size(I,1),size(I,2)))^2;<span class="keyword">end</span><span class="keyword">if</span> nargout==0,  p.disp = true;  <span class="keyword">end</span>;</pre>      <p>main calculation</p>      <pre class="codeinput">[Q, Ck, ColCk] = slicsuperpix_base(I, p.S, p.lab, p.T, p.n, p.m, p.k, p.iter);<span class="comment">%[Q, Ck, ColCk] = slicsuperpix_base2(I, p.S, p.lab, p.T, p.n, p.m, p.k, p.iter);</span><span class="keyword">if</span> any(~Q(:))    i = find(~Q);    warning(<span class="string">'slicsuperpix:outputwarning'</span>, <span class="keyword">...</span>        [<span class="string">'not all pixels reached by the classifier - '</span> <spanclass="keyword">...</span>        <span class="string">'increase the range of the exploration domain (''n'') '</span> <spanclass="keyword">...</span>        <span class="string">'or, when possible, the number of iterations (''i'')'</span>]);    Q(i) = 1;<span class="keyword">end</span><span class="keyword">if</span> nargout&gt;=2    varargout{1} = Ck;    <span class="keyword">if</span> nargout&gt;=3,  varargout{2} = ColCk;  <spanclass="keyword">end</span><span class="keyword">end</span></pre>      <p>display</p>      <pre class="codeinput"><span class="keyword">if</span> p.disp    figure;    <span class="keyword">if</span> isempty(ver(<span class="string">'images'</span>))        subplot(1,2,1), imagesc(rescale(I));        subplot(1,2,2), imagesc(Q), colormap <span class="string">jet</span>;    <span class="keyword">else</span>        M = (imdilate(Q,ones(3,3))-Q==0);      <span class="comment">%  subplot(1,2,2), imagesc(label2rgb(Q.*M)), axis image off;</span>       subplot(1,2,2), imagesc(label2rgb(Q)), axis <span class="string">image</span> <spanclass="string">off</span>;        M = cat(3,M,M,M);        subplot(1,2,1), imagesc(rescale(I.*M)+(1-M)), axis <span class="string">image</span> <spanclass="string">off</span>;    <span class="keyword">end</span>     suptitle(<span class="string">'SLIC superpixel regions'</span>);    figure;    subplot(1,2,1), imagesc(rescale(I)), axis <span class="string">image</span> <spanclass="string">off</span>;    <span class="keyword">if</span> p.lab,  rgb = Lab2RGB(ColCk(:,1),ColCk(:,2),ColCk(:,3)); <spanclass="comment">% convert back</span>    <span class="keyword">else</span>       rgb = cat(3,ColCk(:,1),ColCk(:,2),ColCk(:,3));    <span class="keyword">end</span>    <span class="comment">% rgb(size(rgb,1)+1,1,:) = [0 0 0]; Q(Q==0) = size(rgb,1);</span>    rgb = double(reshape(rgb(Q(:),:), size(I)));    <span class="keyword">if</span> exist(<span class="string">'i'</span>,<spanclass="string">'var'</span>),  rgb([i; i+numel(Q); i+2*numel(Q)]) = 0;  <spanclass="keyword">end</span>    subplot(1,2,2), imagesc(rescale(rgb)), axis <span class="string">image</span> <spanclass="string">off</span>;    suptitle(<span class="string">'SLIC superpixel approximation'</span>);<span class="keyword">end</span></pre>      <pre class="codeinput"><span class="keyword">end</span> <span class="comment">% end of slicsuperpix</span></pre></div>    <!--##### SOURCE BEGIN #####%% SLICSUPERPIX - Simple Linear Iterative Clustering. %%% Description% Implement the SLIC (Simple Linear Iterative Clustering) superpixel% segmentation of [ASSLFS10,LSALF10]. The SLIC approach clusters pixels in% the combined five-dimensional color and image plane space.%% See also software [SLIC].%%% Syntax%    Q = SLICSUPERPIX(I);%    [Q, Ck, ColCk] = SLICSUPERPIX(I, S);%    [Q, Ck, ColCk] = SLICSUPERPIX(I, S, 'Property', propertyvalue, ... );%%% Inputs% *|I|* : input color image of size |(X,Y,C)| (multispectral with |C=3| bands).%% *|S|* : (optional) variable setting the scale of the superpixel segmentation;%     when |S>=1|, it represents an upper bound for the desired number of %     clusters, ie. the approximate number of approximately equally-sized%     superpixels (and the approximate size of each superpixel is |(X*Y)/S| %     pixels); when |0<S<1|, it represents the size of the superpixel as a%     proportion of the size of the input image, ie. the superpixels will%     have a size of approximately |(min(X,Y)*S)^2|  pixels; default: |S=0.05|,%     ie. if the input image is of size (100,100), the superpixel segments%     are expected to have a size of approximately 25 pixels.% %% Property [propertyname  propertyvalues]% *|'T'|* : (optional) stopping criterion; it is defined as a threshold on the%     errror for relocating all the superpixel regions' centers; default:%     |T=eps|.%% *|'n'|* : (optional) multiplying factor used for the search area around each%     superpixel region's center; default: |n=2|.%% *|'m'|* : (optional) scalar; the greater this value, the more spatial proximity%     is emphasized in the calculation of distances and the more compact the %     clusters are; this value can be >=0; we did however replace the original%     expression Eq.(1): $D_s = d_{lab} + m * d_{xy} / S$ with a simpler %     one: $D_s = d_{lab} + m * d_{xy}$ as it is easier to control the %     compactness of the clusters this way (using |m| only); default: |m=1|.%% *|'k'|* : (optional) size of the neighbourood considered when correcting the%     location of the superpixel regions' centers; when set to 0, the first%     initial initialization is kept as it is; default: |k=3|.%% *|'iter'|* : (optional) maximum number of iterations; default: |iter=Inf|,%     ie. the segmentation process is iterated till convergence.%% *|'lab'|* : (optional) boolean flag set to true for transforming, prior to%     the processing, a 3D image (assumed to be RGB) into the Lab color%     space; default: |lab=true|.%%% Outputs % *|Q|* : diagram of superpixels regions; it takes values in the range |[1,K]| %     where |K| is the final number of superpixel regions; it is a matrix of%     size |(X,Y)|.%% *|Ck|* : coordinates of the centers of the corresponding superpixels; it is%     a matrix of size |(K,2)|.%% *|ColCk|* : representative values of the superpixels; it is a matrix of%     size |(K,3)|, whose values are in Lab space if the flag |lab| (see above)%     is set to |true|.% %% Example%    I = imread('autumn.tif'); %    L = SLICSUPERPIX(I, 20, 'disp', true);%    [Q, Ck, ColCk] = SLICSUPERPIX(I, 0.05, 'T', eps, 'n', 2, 'm', 10, 'k', 3, 'i', Inf);  % default%%% References% [ASSLFS10]  R. Achanta, A. Shaji, K. Smith, A. Lucchi, P. Fua and S. %      Susstrunk: "SLIC superpixels", EPFL Technical Report no. 149300, 2010.%      <http://infoscience.epfl.ch/record/149300/files/SLIC_Superpixels_TR_2.pdf>%% [LSALF10]  A. Lucchi, K. Smith, R. Achanta, V. Lepetit and P. Fua: "A %      fully automated approach to segmentation of irregularly shaped cellular%      structures in EM images", Proc. MICCAI, 2010. %      <http://cvlab.epfl.ch/publications/publications/2010/LucchiSALF10.pdf>%% [SLIC]  executable available at:%      <http://ivrg.epfl.ch/supplementary_material/RK_SLICSuperpixels/index.html>.%%% Credit% <mailto:grazzja@lanl.gov J.Grazzini> (ISR-2/LANL)%%% See also% Related:% <SLICSUPERPIX.html |SLICSUPERPIX|>,% <GEOSUPERPIX.html |GEOSUPERPIX|>,% <AMOEBASUPERPIX.html |AMOEBASUPERPIX|>.% Called:% <SLICSUPERPIX_BASE.html |SLICSUPERPIX_BASE|>.%% Function implementationfunction [Q, varargout] = slicsuperpix(I, varargin)%%% parsing parameterserror(nargchk(1, 22, nargin, 'struct'));error(nargoutchk(0, 3, nargout, 'struct'));% mandatory parameterif ~isnumeric(I)    error('slicsuperpix:inputerror','a matrix is required in input'); endp = createParser('SLICSUPERPIX');   % create an instance of the inputParser class.% optional parameterp.addOptional('S', 0.05, @(x)isscalar(x) && ((x>0 && x<1) || (x>1 && x==round(x))));% additional optional parametersp.addParamValue('m', 1, @(x)isscalar(x) && x>=0);p.addParamValue('T', eps, @(x) isscalar(x) && x>=0);p.addParamValue('n', 2, @(x)isscalar(x) && x>=1 && x==round(x));p.addParamValue('k', 3, @(x)isscalar(x) && (x==0 || x>=3));p.addParamValue('iter', Inf, @(x)isscalar(x) && x>=1);p.addParamValue('lab', true, @islogical);% parse and validate all input argumentsp.parse(varargin{:}); p = getvarParser(p); %%% setting variablesC = size(I,3);if C~=3    warning('slicsuperpix_base:inputwarning', ...        'RGB/Lab image required in input - input image is converted');    if C==1,   I = repmat(I, [1 1 3]);    else       I = I(:,:,1:3);    endendif p.S<1    % p.S = p.S * min(size(I,1),size(I,2));     p.S = numel(I(:,:,1)) ./ (p.S * min(size(I,1),size(I,2)))^2;endif nargout==0,  p.disp = true;  end;%%% main calculation [Q, Ck, ColCk] = slicsuperpix_base(I, p.S, p.lab, p.T, p.n, p.m, p.k, p.iter);%[Q, Ck, ColCk] = slicsuperpix_base2(I, p.S, p.lab, p.T, p.n, p.m, p.k, p.iter);if any(~Q(:))    i = find(~Q);    warning('slicsuperpix:outputwarning', ...        ['not all pixels reached by the classifier - ' ...        'increase the range of the exploration domain (''n'') ' ...        'or, when possible, the number of iterations (''i'')']);    Q(i) = 1;endif nargout>=2    varargout{1} = Ck;    if nargout>=3,  varargout{2} = ColCk;  endend%%% displayif p.disp    figure;    if isempty(ver('images'))        subplot(1,2,1), imagesc(rescale(I));        subplot(1,2,2), imagesc(Q), colormap jet;    else        M = (imdilate(Q,ones(3,3))-Q==0);      %  subplot(1,2,2), imagesc(label2rgb(Q.*M)), axis image off;       subplot(1,2,2), imagesc(label2rgb(Q)), axis image off;        M = cat(3,M,M,M);        subplot(1,2,1), imagesc(rescale(I.*M)+(1-M)), axis image off;    end     suptitle('SLIC superpixel regions');    figure;    subplot(1,2,1), imagesc(rescale(I)), axis image off;    if p.lab,  rgb = Lab2RGB(ColCk(:,1),ColCk(:,2),ColCk(:,3)); % convert back    else       rgb = cat(3,ColCk(:,1),ColCk(:,2),ColCk(:,3));    end    % rgb(size(rgb,1)+1,1,:) = [0 0 0]; Q(Q==0) = size(rgb,1);    rgb = double(reshape(rgb(Q(:),:), size(I)));    if exist('i','var'),  rgb([i; i+numel(Q); i+2*numel(Q)]) = 0;  end    subplot(1,2,2), imagesc(rescale(rgb)), axis image off;    suptitle('SLIC superpixel approximation');endend % end of slicsuperpix##### SOURCE END #####-->  </body></html>