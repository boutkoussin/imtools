<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html>  <head>    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">    <!--This HTML was auto-generated from MATLAB code.To make changes, update the MATLAB code and republish this document.      -->    <title>GEOSUPERPIX_BASE - Base function for GEOSUPERPIX.</title>    <meta name="generator" content="MATLAB 7.14">    <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">    <meta name="DC.date" content="2012-05-31">    <meta name="DC.source" content="geosuperpix_base.m">    <style type="text/css">html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}html { min-height:100%; margin-bottom:1px; }html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }html body td { vertical-align:top; text-align:left; }h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }a { color:#005fce; text-decoration:none; }a:hover { color:#005fce; text-decoration:underline; }a:visited { color:#004aa0; text-decoration:none; }p { padding:0px; margin:0px 0px 20px; }img { padding:0px; margin:0px 0px 20px; border:none; }p img, pre img, tt img, li img { margin-bottom:0px; } ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }ul li { padding:0px; margin:0px 0px 7px 0px; }ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }ul li ol li { list-style:decimal; }ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }ol li ol li { list-style-type:lower-alpha; }ol li ul { padding-top:7px; }ol li ul li { list-style:square; }.content { font-size:1.2em; line-height:140%; padding: 20px; }pre, tt, code { font-size:12px; }pre { margin:0px 0px 20px; }pre.error { color:red; }pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }span.keyword { color:#0000FF }span.comment { color:#228B22 }span.string { color:#A020F0 }span.untermstring { color:#B20000 }span.syscmd { color:#B28C00 }.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }.footer p { margin:0px; }  </style>  </head>  <body>    <div class="content">      <h1>GEOSUPERPIX_BASE - Base function for GEOSUPERPIX.</h1>      <!--introduction--><!--/introduction-->      <h2>Contents</h2>      <div>        <ul>          <li><a href="#1">Syntax</a></li>          <li><a href="#3">See also</a></li>          <li><a href="#4">Function implementation</a></li>          <li><a href="#11">Subfunction</a></li>        </ul>      </div>      <h2>Syntax<a name="1"></a></h2>      <pre>  [Q, LabCk, Ck] = geosuperpix_base(I, K, T, n, k, maxiter, method, ...                               rho, sigma, a, der, int, samp, eign);</pre>      <h2>See also<a name="3"></a></h2>      <p>Related: <a href="geosuperpix.html"><tt>GEOSUPERPIX</tt></a>, <a href="amoebasuperpix_base.html"><tt>AMOEBASUPERPIX_BASE</tt></a>,        <a href="slicsuperpix_base.html"><tt>SLICSUPERPIX_BASE</tt></a>. Called:        <a href="matlab:web%28whichpath%28%27RGB2LAB%27%29%29"><tt>RGB2LAB</tt></a>,        <a href="../propagation/im2potential.html"><tt>IM2POTENTIAL</tt></a>,        <a href="../propagation/potential2front.html"><tt>POTENTIAL2FRONT</tt></a>,        <a href="../derive/gstdecomp.html"><tt>GSTDECOMP</tt></a>.</p>      <h2>Function implementation<a name="4"></a></h2>      <pre class="codeinput"><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> [Q, Ck, LabCk] = <span class="keyword">...</span>    geosuperpix_base(I, K, T, n, k, maxiter, method, <span class="keyword">...</span>    rho, sigma, a, der, int, samp, eign)</pre>      <pre class="codeinput"><span class="comment">% compute the set of gradient minima and their influence zone</span><span class="comment">% select seeds on an uniform grid</span><span class="comment">% for iteration</span><span class="comment">% compute the distance to the seeds</span><span class="comment">% end</span><span class="comment">% we accept a variable number of inputs</span><span class="keyword">if</span> nargin&lt;14,     eign = <span class="string">'l1'</span>;    <span class="keyword">if</span> nargin&lt;13,     samp = 1;        <span class="keyword">if</span> nargin&lt;12,     int = <span class="string">'fast'</span>;            <span class="keyword">if</span> nargin&lt;11,     der = <span class="string">'fast'</span>;                <span class="keyword">if</span> nargin&lt;10,     a = [1 2];                    <span class="keyword">if</span> nargin&lt;9,     sigma = 1;                        <span class="keyword">if</span> nargin&lt;8,     rho = 1;                            <span class="keyword">if</span> nargin7,    method = <spanclass="string">'ani'</span>;                                <span class="keyword">if</span> nargin&lt;6,  maxiter = Inf;                                    <span class="keyword">if</span> nargin&lt;5,  k = 3;                                    <span class="keyword">end</span>                                <span class="keyword">end</span>                            <span class="keyword">end</span>                        <span class="keyword">end</span>                    <span class="keyword">end</span>                <span class="keyword">end</span>            <span class="keyword">end</span>        <span class="keyword">end</span>    <span class="keyword">end</span><span class="keyword">end</span>[X,Y,C] = size(I);<span class="keyword">if</span> C~=3    warning(<span class="string">'geosuperpix_base:inputwarning'</span>,<span class="string">'RGB image required in input'</span>);    <span class="keyword">if</span> C==1,   I = repmat(I, [1 1 3]);    <span class="keyword">else</span>       I = I(:,:,1:3);    <span class="keyword">end</span><span class="keyword">end</span></pre>      <p>distance</p>      <pre class="codeinput">distL2 = @(v0, v1) sqrt(sum((v1-v0).^2, 2));</pre>      <p>for an image with N=X*Y pixels, the approximate size of each superpixel        is N/K pixels; therefore, for roughly equally sized superpixels there        would be a superpixel center at every grid interval S:</p>      <pre class="codeinput">S = floor(sqrt(X*Y/K));<span class="keyword">if</span> mod(n,2)~=0,  n = n+1;  <span class="keyword">end</span>;win = S*n;pad = win / 2;Lab = RGB2Lab(I(:,:,1), I(:,:,2), I(:,:,3));A = padarray(Lab, [pad pad 0], <span class="string">'both'</span>, <span class="string">'replicate'</span>);[M,N] = size(A(:,:,1));</pre>      <p>we begin by sampling K regularly spaced cluster centers</p>      <pre class="codeinput">[Ck, LabCk] = initcenters(I, K);nk = length(Ck);<span class="comment">% % and we move the centers to seed locations corresponding to the lowest</span><span class="comment">% % gradient position in a [k x k] neighborhood.</span><span class="comment">% if k&gt;0</span><span class="comment">%     [Ck, LabCk] = movecenters(distL2, Lab, Ck, k, S, m);</span><span class="comment">% end</span></pre>      <p>compute once for all the potential function based on the gradient        and/or the gradient structure tensor of the multispectral input image        and define the propagation function: it is either a scalar field        (isotropic case) providing with the speed (strenght) for the propagation        (the higher the value at one point, the faster the propagation through        this point) or a tensor field (anisotropic case) providing with a speed        and a direction for the propagation.</p>      <pre class="codeinput">[TT, L] = im2potential(A, method, a, rho, sigma, der, int, samp, eign); <spanclass="comment">%#ok</span>[~, L2, E1, E2] = gstdecomp(TT);<span class="comment">%A = padarray(Lab, [pad pad 0], 'both', 'replicate');</span><span class="comment">%[M,N] = size(A(:,:,1));</span>Q = zeros(X,Y);D = Inf(M,N); <span class="comment">% D = D(:);</span><span class="comment">% indexes</span>pixindex = reshape(1:M*N,M,N);pixin = pixindex(pad+1:pad+X,pad+1:pad+Y);<span class="comment">% Index of the centered neighbour window of analysis</span>ind = repmat(-pad:pad,[2*pad+1 1]);[x,y] = size(ind);ind = ind' + M*ind;ind = ind(:);<span class="comment">% start looping</span>niter = 1;err = Inf(nk,1);<span class="keyword">while</span> niter&lt;=maxiter    ierr = find(err&gt;T);    <span class="keyword">if</span> isempty(ierr),  <span class="keyword">break</span>;  <spanclass="keyword">end</span>    Q = padarray(Q, [pad pad], <span class="string">'both'</span>, <span class="string">'replicate'</span>);    <span class="keyword">for</span> k=1:nk <span class="comment">%length(ierr)</span>        kk = k;        c = pixin(Ck(kk,1),Ck(kk,2));        c3 =  [c, c+N*M, c+2*N*M];        cind = c + ind;        cind2 = repmat(c3(1:2),[x*y 1]) + repmat(ind,[1 2]);        cind3 = repmat(c3,[x*y 1]) + repmat(ind,[1 3]);        q = Q(cind);        d = D(cind);        l2 = reshape(L2(cind), [x y]);  <span class="comment">% l1 = reshape(L1(cind), [x y]);</span>        e2 = reshape(E2(cind2), [x y 2]);  e1 = reshape(E1(cind2), [x y 2]);        <span class="comment">% a = reshape(distL2(A(cind3), squeeze(repmat(LabCk(k,:),[x*y 1]))), [x y]);</span>         a = reshape(distL2(A(cind3), repmat(LabCk(k,:),[x*y 1])), [x y]);        <span class="comment">% no, should average value</span>        l1 = 1 ./ (1+a);        l2 = l2 ./ (1+a);        ss = gstdecomp(l1, l2, e1, e2);        dd = potential2front(ss, [pad+1;pad+1]);        [d, r] = min(cat(2,d(:),dd(:)), [], 2);        q(r==2) = k;        Q(cind) = q;        D(cind) = d;    <span class="keyword">end</span>    Q = Q(pad+1:pad+X,pad+1:pad+Y);    [nCk, nLabCk] = updatecenters(ierr, Q, Lab);    warning(<span class="string">'geosuperpix_base:warning'</span>,<span class="string">'!!!update error vector!!!'</span>);    Ck(ierr,:) = nCk;    LabCk(ierr,:) = nLabCk;    niter = niter + 1;<span class="keyword">end</span></pre>      <pre class="codeinput"><span class="keyword">end</span> <span class="comment">% end of geosuperpix_base</span></pre>      <h2>Subfunction<a name="11"></a></h2>      <pre class="codeinput"><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> [Ck, LabCk] = initcenters(Lab, S)[X,Y] = size(Lab(:,:,1));xk = round(X / S);<span class="keyword">if</span> xk==0,  xk = floor(X/2);<span class="keyword">else</span>       xk = floor(S * (0:xk-1) + S/2);<span class="keyword">end</span>yk = round(Y / S);<span class="keyword">if</span> yk==0,  yk = floor(X/2);<span class="keyword">else</span>       yk = floor(S * (0:yk-1) + S/2);<span class="keyword">end</span>LabCk = reshape(Lab(xk,yk,:), [length(xk)*length(yk) 3]);[xk yk] = meshgrid(xk, yk);Ck = [xk(:), yk(:)];<span class="comment">% Ck = sub2ind([X,Y], xk(:), yk(:));</span><span class="keyword">end</span><span class="comment">% %----------------------------------------------------------------------</span><span class="comment">% function [Ck, LabCk, S] = initcenters(I, K)</span><span class="comment">% [Ck, S] = gridblk(I, K);</span><span class="comment">%</span><span class="comment">% LabCk = zeros(length(Ck),C);</span><span class="comment">% for ic=1:C</span><span class="comment">%     x = blkproc(I(:,:,ic), S, @(x)mean(x(:)));</span><span class="comment">%     LabCk(:,ic) = x(:);</span><span class="comment">% end</span><span class="comment">%</span><span class="comment">% end</span><span class="comment">% %--------------------------------------------------------------------</span><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> [Ck, LabCk] = updatecenters(ierr, Q, I)[X,Y,C] = size(I);indC = X*Y*(0:C-1);nk = length(ierr);Ck = ones(nk,2);LabCk = zeros(nk,3);<span class="keyword">for</span> k=1:nk    kk = ierr(k);    [i,j] = find(Q==kk);  <span class="comment">% or ind2sub([X Y],Q==kk);</span>    <span class="comment">% Ck(k) = sub2ind([X Y], floor(sum(i)/length(i)), floor(sum(j)/length(j)));</span>    Ck(k,:) = [floor(sum(i)/length(i)), floor(sum(j)/length(j))];    ij = sub2ind([X Y],i,j);    LabCk(k,:) = mean(I(repmat(ij,[1 C])+repmat(indC,[length(ij) 1])));<span class="keyword">end</span><span class="keyword">end</span></pre></div>    <!--##### SOURCE BEGIN #####%% GEOSUPERPIX_BASE - Base function for GEOSUPERPIX.%%% Syntax%    [Q, LabCk, Ck] = geosuperpix_base(I, K, T, n, k, maxiter, method, ...%                                 rho, sigma, a, der, int, samp, eign);%%% Credit% <mailto:grazzja@lanl.gov J.Grazzini> (ISR-2/LANL)%%% See also% Related:% <geosuperpix.html |GEOSUPERPIX|>,% <amoebasuperpix_base.html |AMOEBASUPERPIX_BASE|>,% <slicsuperpix_base.html |SLICSUPERPIX_BASE|>.% Called:% <matlab:web(whichpath('RGB2LAB')) |RGB2LAB|>,% <../propagation/im2potential.html |IM2POTENTIAL|>,% <../propagation/potential2front.html |POTENTIAL2FRONT|>,% <../derive/gstdecomp.html |GSTDECOMP|>.%% Function implementation%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction [Q, Ck, LabCk] = ...    geosuperpix_base(I, K, T, n, k, maxiter, method, ...    rho, sigma, a, der, int, samp, eign)% compute the set of gradient minima and their influence zone% select seeds on an uniform grid% for iteration% compute the distance to the seeds% end% we accept a variable number of inputsif nargin<14,     eign = 'l1';    if nargin<13,     samp = 1;        if nargin<12,     int = 'fast';            if nargin<11,     der = 'fast';                if nargin<10,     a = [1 2];                    if nargin<9,     sigma = 1;                        if nargin<8,     rho = 1;                            if nargin7,    method = 'ani';                                if nargin<6,  maxiter = Inf;                                    if nargin<5,  k = 3;                                    end                                end                            end                        end                    end                end            end        end    endend[X,Y,C] = size(I);                                                 if C~=3    warning('geosuperpix_base:inputwarning','RGB image required in input');    if C==1,   I = repmat(I, [1 1 3]);    else       I = I(:,:,1:3);     endend%%% distancedistL2 = @(v0, v1) sqrt(sum((v1-v0).^2, 2));%%% for an image with N=X*Y pixels, the approximate size of each superpixel is% N/K pixels; therefore, for roughly equally sized superpixels there would % be a superpixel center at every grid interval S:S = floor(sqrt(X*Y/K));if mod(n,2)~=0,  n = n+1;  end;win = S*n;pad = win / 2;Lab = RGB2Lab(I(:,:,1), I(:,:,2), I(:,:,3));A = padarray(Lab, [pad pad 0], 'both', 'replicate');[M,N] = size(A(:,:,1));                                           %%% we begin by sampling K regularly spaced cluster centers[Ck, LabCk] = initcenters(I, K);nk = length(Ck);% % and we move the centers to seed locations corresponding to the lowest % % gradient position in a [k x k] neighborhood.% if k>0%     [Ck, LabCk] = movecenters(distL2, Lab, Ck, k, S, m);% end%%% compute once for all the potential function based on the gradient and/or% the gradient structure tensor of the multispectral input image and define % the propagation function: it is either a scalar field (isotropic case) % providing with the speed (strenght) for the propagation (the higher the % value at one point, the faster the propagation through this point) or a % tensor field (anisotropic case) providing with a speed and a direction for% the propagation.     [TT, L] = im2potential(A, method, a, rho, sigma, der, int, samp, eign); %#ok[~, L2, E1, E2] = gstdecomp(TT);%A = padarray(Lab, [pad pad 0], 'both', 'replicate');%[M,N] = size(A(:,:,1));                                           Q = zeros(X,Y);D = Inf(M,N); % D = D(:);% indexespixindex = reshape(1:M*N,M,N);pixin = pixindex(pad+1:pad+X,pad+1:pad+Y);% Index of the centered neighbour window of analysis ind = repmat(-pad:pad,[2*pad+1 1]);[x,y] = size(ind);ind = ind' + M*ind;ind = ind(:);% start loopingniter = 1;err = Inf(nk,1);while niter<=maxiter        ierr = find(err>T);        if isempty(ierr),  break;  end             Q = padarray(Q, [pad pad], 'both', 'replicate');       for k=1:nk %length(ierr)         kk = k;         c = pixin(Ck(kk,1),Ck(kk,2));        c3 =  [c, c+N*M, c+2*N*M];        cind = c + ind;        cind2 = repmat(c3(1:2),[x*y 1]) + repmat(ind,[1 2]);        cind3 = repmat(c3,[x*y 1]) + repmat(ind,[1 3]);        q = Q(cind);        d = D(cind);        l2 = reshape(L2(cind), [x y]);  % l1 = reshape(L1(cind), [x y]);        e2 = reshape(E2(cind2), [x y 2]);  e1 = reshape(E1(cind2), [x y 2]);                % a = reshape(distL2(A(cind3), squeeze(repmat(LabCk(k,:),[x*y 1]))), [x y]);         a = reshape(distL2(A(cind3), repmat(LabCk(k,:),[x*y 1])), [x y]);        % no, should average value        l1 = 1 ./ (1+a);        l2 = l2 ./ (1+a);        ss = gstdecomp(l1, l2, e1, e2);        dd = potential2front(ss, [pad+1;pad+1]);                [d, r] = min(cat(2,d(:),dd(:)), [], 2);        q(r==2) = k;                Q(cind) = q;        D(cind) = d;    end        Q = Q(pad+1:pad+X,pad+1:pad+Y);    [nCk, nLabCk] = updatecenters(ierr, Q, Lab);    warning('geosuperpix_base:warning','!!!update error vector!!!');        Ck(ierr,:) = nCk;    LabCk(ierr,:) = nLabCk;        niter = niter + 1;endend % end of geosuperpix_base%% Subfunction%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction [Ck, LabCk] = initcenters(Lab, S)[X,Y] = size(Lab(:,:,1));xk = round(X / S);if xk==0,  xk = floor(X/2);else       xk = floor(S * (0:xk-1) + S/2);endyk = round(Y / S);if yk==0,  yk = floor(X/2);else       yk = floor(S * (0:yk-1) + S/2);endLabCk = reshape(Lab(xk,yk,:), [length(xk)*length(yk) 3]);[xk yk] = meshgrid(xk, yk);Ck = [xk(:), yk(:)];% Ck = sub2ind([X,Y], xk(:), yk(:));end% %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH% function [Ck, LabCk, S] = initcenters(I, K)% [Ck, S] = gridblk(I, K);% % LabCk = zeros(length(Ck),C);% for ic=1:C%     x = blkproc(I(:,:,ic), S, @(x)mean(x(:)));%     LabCk(:,ic) = x(:);% end% % end% %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction [Ck, LabCk] = updatecenters(ierr, Q, I)[X,Y,C] = size(I);indC = X*Y*(0:C-1);nk = length(ierr);Ck = ones(nk,2);LabCk = zeros(nk,3);for k=1:nk    kk = ierr(k);    [i,j] = find(Q==kk);  % or ind2sub([X Y],Q==kk);    % Ck(k) = sub2ind([X Y], floor(sum(i)/length(i)), floor(sum(j)/length(j)));    Ck(k,:) = [floor(sum(i)/length(i)), floor(sum(j)/length(j))];    ij = sub2ind([X Y],i,j);    LabCk(k,:) = mean(I(repmat(ij,[1 C])+repmat(indC,[length(ij) 1])));endend##### SOURCE END #####--></body></html>