<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html>  <head>    <meta content="text/html; charset=utf-8" http-equiv="content-type">    <!--This HTML was auto-generated from MATLAB code.To make changes, update the MATLAB code and republish this document.      -->    <title>CELLNUMSUBTRIM - Trim a set of numerical sequences from its      subsequences.</title>    <meta name="generator" content="MATLAB 7.14">    <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">    <meta name="DC.date" content="2012-05-31">    <meta name="DC.source" content="cellnumsubtrim.m">    <style type="text/css">html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}html { min-height:100%; margin-bottom:1px; }html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }html body td { vertical-align:top; text-align:left; }h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }a { color:#005fce; text-decoration:none; }a:hover { color:#005fce; text-decoration:underline; }a:visited { color:#004aa0; text-decoration:none; }p { padding:0px; margin:0px 0px 20px; }img { padding:0px; margin:0px 0px 20px; border:none; }p img, pre img, tt img, li img { margin-bottom:0px; } ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }ul li { padding:0px; margin:0px 0px 7px 0px; }ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }ul li ol li { list-style:decimal; }ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }ol li ol li { list-style-type:lower-alpha; }ol li ul { padding-top:7px; }ol li ul li { list-style:square; }.content { font-size:1.2em; line-height:140%; padding: 20px; }pre, tt, code { font-size:12px; }pre { margin:0px 0px 20px; }pre.error { color:red; }pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }span.keyword { color:#0000FF }span.comment { color:#228B22 }span.string { color:#A020F0 }span.untermstring { color:#B20000 }span.syscmd { color:#B28C00 }.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }.footer p { margin:0px; }  </style>  </head>  <body>    <div class="content">      <h1>CELLNUMSUBTRIM - Trim a set of numerical sequences from its        subsequences.</h1>      <!--introduction--><!--/introduction-->      <h2>Contents</h2>      <div>        <ul>          <li><a href="#1">Description</a></li>          <li><a href="#2">Syntax</a></li>          <li><a href="#3">Inputs</a></li>          <li><a href="#4">Outputs</a></li>          <li><a href="#7">See also</a></li>          <li><a href="#8">Function implementation</a></li>        </ul>      </div>      <h2>Description<a name="1"></a></h2>      <p>Discard all the elements of a set (cell) of numerical sequences that        match subsequences of longer elements in the same set.</p>      <h2>Syntax<a name="2"></a></h2>      <pre>     [C, I] = CELLNUMSUBTRIM(S);     [C, I] = CELLNUMSUBTRIM(S, traversal);</pre>      <h2>Inputs<a name="3"></a></h2>      <p><b><tt>S</tt></b> : cell of numerical sequences from which redundant        elements matching subsequences of longer sequences are removed.</p>      <p><b><tt>traversal</tt></b> : (optional) flag setting the rule for        defining subsequences; a numerical sequence in <tt>S</tt> is regarded        as a subsequence if it matches a subsequence of a longer numerical        sequence of <tt>S</tt>:</p>      <div>        <ul>          <li>when reading both of them <b>from left to right</b> in the case <tt>traversal=1</tt>,</li>          <li>when reading both of them <b>from right to left</b> in the case <tt>traversal=-1</tt>,</li>          <li><b>indepently of the order these strings are read</b> in the case            <tt>traversal=0</tt>;</li>        </ul>      </div>      <p>see also <tt>CELLSTRSUBTRIM</tt> for string comparison; default: <tt>traversal=0</tt>.</p>      <h2>Outputs<a name="4"></a></h2>      <p><b><tt>C</tt></b> : output cell of numerical sequences where the        subsequences of <tt>S</tt> have been removed following the rule defined        by <tt>traversal</tt>; note that <tt>C</tt> is ordered according to        the length of the sequences.</p>      <p><b><tt>I</tt></b> : indices (referring to the input <tt>S</tt>) of the        numerical sequences present in the output.</p>      <h2>See also<a name="7"></a></h2>      <p>Related: <a href="../../misc/html/CELLSTRSUBTRIM.html"><tt>CELLSTRSUBTRIM</tt></a>.        Called: <a href="../algebra/MAT2RC.html"><tt>MAT2RC</tt></a>. <a          href="matlab:webpub%28whichpath%28%27TRIL%27%29%29"><tt>TRIL</tt></a>,        <a href="matlab:webpub%28whichpath%28%27STRNCMP%27%29%29"><tt>STRNCMP</tt></a>,        <a href="matlab:webpub%28whichpath%28%27ISSPACE%27%29%29"><tt>ISSPACE</tt></a>,        <a href="matlab:webpub%28whichpath%28%27CELLSTR%27%29%29"><tt>CELLSTR</tt></a>,        <a href="matlab:webpub%28whichpath%28%27CELL2MAT%27%29%29"><tt>CELL2MAT</tt></a>,        <a href="matlab:webpub%28whichpath%28%27CELLFUN%27%29%29"><tt>CELLFUN</tt></a>,        <a href="matlab:webpub%28whichpath%28%27RESHAPE%27%29%29"><tt>RESHAPE</tt></a>.</p>      <h2>Function implementation<a name="8"></a></h2>      <pre class="codeinput"><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> [C, I] = cellnumsubtrim(C, traversal)</pre>      <p>check/set variables</p>      <pre class="codeinput"><span class="keyword">if</span> nargin&lt;2,  traversal = 0;  <spanclass="keyword">end</span><span class="keyword">if</span> ~iscell(C)    error(<span class="string">'cellnumsubtrim:errorinput'</span>, <span class="keyword">...</span>        <span class="string">'input variable ''C'' must be a cell of vectors'</span>);<span class="keyword">elseif</span> ~isscalar(traversal) || ~ismember(traversal,[0 1 -1])    error(<span class="string">'cellnumsubtrim:errorinput'</span>, <span class="keyword">...</span>        <span class="string">'input variable ''traversal'' takes values in {-1,0,1}'</span>);<span class="keyword">end</span>nC = numel(C);ind = 1:nC;</pre>      <p>in general, get rid of empty sequences</p>      <pre class="codeinput">I = cellfun(@isempty, C);<span class="comment">% update</span><span class="keyword">if</span> any(I),  C(I) = [];  ind(I) = [];  nC = numel(C);  <spanclass="keyword">end</span></pre>      <p>check if one sequence only: then nothing to do</p>      <pre class="codeinput"><span class="keyword">if</span> nC==1,  <span class="keyword">return</span>;  <spanclass="keyword">end</span></pre>      <p>sort the sequences according to their (increasing) length</p>      <pre class="codeinput">[~,I] = sort(cellfun(@length,C));C = C(I);  ind = ind(I);</pre>      <p>now we use a trick to get rid of redundant sequences: we transform the        numerical sequences into strings and we compare the strings using the        standard <tt>STRNCMP</tt> function, likewise we do in <tt>CELLSTRSUBTRIM</tt></p>      <pre class="codeinput">A = cellfun(@(c) num2str(mat2rc(c,<span class="string">'r'</span>)), C, <spanclass="string">'Uniform'</span>, false);<span class="comment">% note that we also ensure that the (string) sequences are row vectors...</span></pre>      <p>build the cell of inverted strings</p>      <pre class="codeinput"><span class="keyword">if</span> traversal&lt;=0    flipA = cellfun(@(c) num2str(fliplr(mat2rc(c,<span class="string">'r'</span>))), C, <spanclass="string">'Uniform'</span>, false);<span class="keyword">end</span></pre>      <p>clean up a bit: first deblank (remove leading and trailing whitespace        characters from string, not optional), then possibly'despace' (trim all        internal whitespaces)</p>      <pre class="codeinput">A = cellfun(@strtrim, A, <span class="string">'Uniform'</span>, false);<span class="keyword">if</span> traversal&lt;=0,  flipA = cellfun(@strtrim, flipA, <spanclass="string">'Uniform'</span>, false);  <spanclass="keyword">end</span></pre>      <p>check the presence of substrings</p>      <pre class="codeinput"><span class="keyword">if</span> traversal==1    I = cellfun(@(a) strncmp(a, A, length(a)), A, <span class="string">'Uniform'</span>, false);<span class="keyword">elseif</span> traversal==-1    I = cellfun(@(flipa) strncmp(flipa, flipA, length(flipa)), <span class="keyword">...</span>        flipA, <span class="string">'Uniform'</span>, false);<span class="keyword">else</span>    I = cellfun(@(a,flipa) <span class="keyword">...</span>        strncmp(a, A, length(a)) | strncmp(flipa, A, length(a)) | <span class="keyword">...</span>        strncmp(a, flipA, length(a)) | strncmp(flipa, flipA, length(a)), <span class="keyword">...</span>        A, flipA, <span class="string">'Uniform'</span>, false);    <span class="comment">% note that, in its first occurence, A is used as a constant (and,</span>    <span class="comment">% similarly, flipA), so that every single string of A (second occurrence)</span>    <span class="comment">% is compared with every other strings</span><span class="keyword">end</span>I = reshape(transpose(cell2mat(I)),[nC nC]); <span class="comment">% square matrix</span></pre>      <p>retrieve the lower triangular part of the diagonal; we do not want the        diagonal as it is always true (the substring is compared with itself)        and we do not want the upper triangular part as it means that two        substrings are equal (considering that the strings were initially        ordered according to their length) and one of them only (but not both)        should be discarded</p>      <pre class="codeinput">I = tril(I,-1) ;</pre>      <p>find the strings that are substrings of longer strings already in C:        they are repeated entries given by the indices of the non null columns        of I</p>      <pre class="codeinput">[~,I] = find(I);  I = unique(I);</pre>      <p>clean up: get rid of those substrings and reconvert back to the        original format</p>      <pre class="codeinput"><span class="keyword">if</span> any(I),  C(I) = [];  ind(I) = [];  <spanclass="keyword">end</span>I = ind;</pre>      <pre class="codeinput"><span class="keyword">end</span> <span class="comment">% end of cellnumsubtrim</span></pre></div>    <!--##### SOURCE BEGIN #####%% CELLNUMSUBTRIM - Trim a set of numerical sequences from its subsequences. %%% Description% Discard all the elements of a set (cell) of numerical sequences that match% subsequences of longer elements in the same set.%%% Syntax%       [C, I] = CELLNUMSUBTRIM(S);%       [C, I] = CELLNUMSUBTRIM(S, traversal);%%% Inputs% *|S|* : cell of numerical sequences from which redundant elements matching%     subsequences of longer sequences are removed.%% *|traversal|* : (optional) flag setting the rule for defining subsequences;%     a numerical sequence in |S| is regarded as a subsequence if it matches%     a subsequence of a longer numerical sequence of |S|:          %  % * when reading both of them *from left to right* in the case |traversal=1|,          % * when reading both of them *from right to left* in the case |traversal=-1|,  % * *indepently of the order these strings are read* in the case |traversal=0|;     %          % see also |CELLSTRSUBTRIM| for string comparison; default: |traversal=0|.    %%% Outputs% *|C|* : output cell of numerical sequences where the subsequences of |S|%     have been removed following the rule defined by |traversal|; note%     that |C| is ordered according to the length of the sequences.%     % *|I|* : indices (referring to the input |S|) of the numerical sequences %     present in the output.%     %% Example%%% Credit% <mailto:grazzja@lanl.gov J.Grazzini> (ISR-2/LANL)%%% See also% Related:% <../../misc/html/CELLSTRSUBTRIM.html |CELLSTRSUBTRIM|>.% Called:% <../algebra/MAT2RC.html |MAT2RC|>.% <matlab:webpub(whichpath('TRIL')) |TRIL|>,% <matlab:webpub(whichpath('STRNCMP')) |STRNCMP|>,% <matlab:webpub(whichpath('ISSPACE')) |ISSPACE|>,% <matlab:webpub(whichpath('CELLSTR')) |CELLSTR|>,% <matlab:webpub(whichpath('CELL2MAT')) |CELL2MAT|>,% <matlab:webpub(whichpath('CELLFUN')) |CELLFUN|>,% <matlab:webpub(whichpath('RESHAPE')) |RESHAPE|>.%% Function implementation%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction [C, I] = cellnumsubtrim(C, traversal)%%% check/set variablesif nargin<2,  traversal = 0;  endif ~iscell(C)    error('cellnumsubtrim:errorinput', ...        'input variable ''C'' must be a cell of vectors');    elseif ~isscalar(traversal) || ~ismember(traversal,[0 1 -1])    error('cellnumsubtrim:errorinput', ...        'input variable ''traversal'' takes values in {-1,0,1}');endnC = numel(C); ind = 1:nC;%%% in general, get rid of empty sequencesI = cellfun(@isempty, C);% updateif any(I),  C(I) = [];  ind(I) = [];  nC = numel(C);  end%%% check if one sequence only: then nothing to doif nC==1,  return;  end%%% sort the sequences according to their (increasing) length[~,I] = sort(cellfun(@length,C));  C = C(I);  ind = ind(I);%%% now we use a trick to get rid of redundant sequences: we transform the% numerical sequences into strings and we compare the strings using the% standard |STRNCMP| function, likewise we do in |CELLSTRSUBTRIM|A = cellfun(@(c) num2str(mat2rc(c,'r')), C, 'Uniform', false);% note that we also ensure that the (string) sequences are row vectors...%%% build the cell of inverted stringsif traversal<=0    flipA = cellfun(@(c) num2str(fliplr(mat2rc(c,'r'))), C, 'Uniform', false);end%%% clean up a bit: first deblank (remove leading and trailing whitespace% characters from string, not optional), then possibly'despace' (trim all% internal whitespaces)A = cellfun(@strtrim, A, 'Uniform', false);if traversal<=0,  flipA = cellfun(@strtrim, flipA, 'Uniform', false);  end%%% check the presence of substringsif traversal==1    I = cellfun(@(a) strncmp(a, A, length(a)), A, 'Uniform', false);elseif traversal==-1    I = cellfun(@(flipa) strncmp(flipa, flipA, length(flipa)), ...        flipA, 'Uniform', false);else    I = cellfun(@(a,flipa) ...        strncmp(a, A, length(a)) | strncmp(flipa, A, length(a)) | ...        strncmp(a, flipA, length(a)) | strncmp(flipa, flipA, length(a)), ...        A, flipA, 'Uniform', false);    % note that, in its first occurence, A is used as a constant (and,    % similarly, flipA), so that every single string of A (second occurrence)    % is compared with every other stringsendI = reshape(transpose(cell2mat(I)),[nC nC]); % square matrix %%% retrieve the lower triangular part of the diagonal; we do not want the% diagonal as it is always true (the substring is compared with itself) and% we do not want the upper triangular part as it means that two substrings% are equal (considering that the strings were initially ordered according% to their length) and one of them only (but not both) should be discardedI = tril(I,-1) ;%%% find the strings that are substrings of longer strings already in C: they% are repeated entries given by the indices of the non null columns of I[~,I] = find(I);  I = unique(I);%%% clean up: get rid of those substrings and reconvert back to the original% formatif any(I),  C(I) = [];  ind(I) = [];  endI = ind;end % end of cellnumsubtrim##### SOURCE END #####-->  </body></html>