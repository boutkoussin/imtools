<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html>  <head>    <meta content="text/html; charset=utf-8" http-equiv="content-type">    <!--This HTML was auto-generated from MATLAB code.To make changes, update the MATLAB code and republish this document.      -->    <title>BILATERAL_BASE - Base function for standard Gaussian bilateral      filter.</title>    <meta name="generator" content="MATLAB 7.14">    <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">    <meta name="DC.date" content="2012-11-14">    <meta name="DC.source" content="bilateral_base.m">    <style type="text/css">html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}html { min-height:100%; margin-bottom:1px; }html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }html body td { vertical-align:top; text-align:left; }h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }a { color:#005fce; text-decoration:none; }a:hover { color:#005fce; text-decoration:underline; }a:visited { color:#004aa0; text-decoration:none; }p { padding:0px; margin:0px 0px 20px; }img { padding:0px; margin:0px 0px 20px; border:none; }p img, pre img, tt img, li img { margin-bottom:0px; } ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }ul li { padding:0px; margin:0px 0px 7px 0px; }ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }ul li ol li { list-style:decimal; }ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }ol li ol li { list-style-type:lower-alpha; }ol li ul { padding-top:7px; }ol li ul li { list-style:square; }.content { font-size:1.2em; line-height:140%; padding: 20px; }pre, tt, code { font-size:12px; }pre { margin:0px 0px 20px; }pre.error { color:red; }pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }span.keyword { color:#0000FF }span.comment { color:#228B22 }span.string { color:#A020F0 }span.untermstring { color:#B20000 }span.syscmd { color:#B28C00 }.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }.footer p { margin:0px; }  </style>  </head>  <body>    <div class="content">      <h1>BILATERAL_BASE - Base function for standard Gaussian bilateral filter.</h1>      <!--introduction--><!--/introduction-->      <h2>Contents</h2>      <div>        <ul>          <li><a href="#1">Description</a></li>          <li><a href="#2">Algorithm</a></li>          <li><a href="#3">Syntax</a></li>          <li><a href="#4">Inputs</a></li>          <li><a href="#5">Output</a></li>          <li><a href="#6">Reference</a></li>          <li><a href="#8">See also</a></li>          <li><a href="#9">Function implementation</a></li>        </ul>      </div>      <h2>Description<a name="1"></a></h2>      <p>Perform bilateral filtering on monochrome images following the approach        of [TM98]. Both the domain and range filters are Gaussian filters.</p>      <h2>Algorithm<a name="2"></a></h2>      <p>The bilateral filter is a spatially varying filter that better        preserves edges than the Gaussian filter.</p>      <p>Given a spacial width <img src="bilateral_base_eq71255.png" alt="$\sigma_x$">        and a range width <img src="bilateral_base_eq67897.png" alt="$\sigma_r$">,        the filter opterates as:</p>      <p><img src="bilateral_base_eq67187.png" alt="$$    \mbox{BF}(I)(x) = \frac{1}{C_x}    \sum_y G_{\sigma_x}(x-y) \cdot G_{\sigma_r}(I(x)-I(y)) \cdot I(y)$$"></p>      <p>with the normalization factor:</p>      <p><img src="bilateral_base_eq00828.png" alt="$$    C_x = \sum_y G_{\sigma_x}(x-y) \cdot G_{\sigma_r}(I(x)-I(y))$$"></p>      <p>at a given pixel <tt>x</tt>, it corresponds to an averaring with the        data-dependant kernel <img src="bilateral_base_eq52911.png" alt="$G_{\sigma_x}(x-y) \cdot G_{\sigma_r}(I(x)-I(y))$">.</p>      <h2>Syntax<a name="3"></a></h2>      <pre>    F = BILATERAL_BASE(I, sigma_d, sigma_r);</pre>      <h2>Inputs<a name="4"></a></h2>      <p><b><tt>I</tt></b> : input image, possibly multispectral.</p>      <p><b><tt>sigma_d</tt></b> : standard deviation of domain filter (in        pixels); sub-pixel values quantized to even fractions, i.e. in steps of        0.2.</p>      <p><b><tt>sigma_r</tt></b> : standard deviation of range filter; value in        range [0,1] (relative to colorspace range which is normalized to 0 - 1).</p>      <h2>Output<a name="5"></a></h2>      <p><b><tt>F</tt></b> : filtered image.</p>      <h2>Reference<a name="6"></a></h2>      <p>[TM98] C. Tomasi and R. Manduchi: "Bilateral filtering for gray and        color images", Proc. IEEE ICCV, 1998. <a href="http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=710815&amp;tag=1">http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=710815&amp;tag=1</a></p>      <h2>See also<a name="8"></a></h2>      <p>Related: <a href="BILATERAL.html"><tt>BILATERAL</tt></a>, <a href="BILATERALSTACK_BASE.html"><tt>BILATERALSTACK_BASE</tt></a>.        Called: <a href="matlab:webpub%28whichpath%28%27GAUSSWIN%27%29%29"><tt>GAUSSWIN</tt></a>.</p>      <h2>Function implementation<a name="9"></a></h2>      <pre class="codeinput"><span class="keyword">function</span>  F = bilateral_base(I, sigma_d, sigma_r)</pre>      <pre class="codeinput">[X,Y,C] = size(I);</pre>      <p>deal with multispectral images</p>      <pre class="codeinput"><span class="keyword">if</span> C&gt;1    F = I;    <span class="keyword">for</span> i=1:C        F(:,:,i) = bilateral_base(I(:,:,i), sigma_d, sigma_r);    <span class="keyword">end</span>    <span class="keyword">return</span><span class="keyword">end</span></pre>      <p>main computation</p>      <pre class="codeinput">I = rescale(I);   <span class="comment">% normalize image range to 0 - 1</span>F = I; <span class="comment">% initialize output;</span></pre>      <p>initialize domain filter kernel</p>      <pre class="codeinput">d_filter = gausswin(5*sigma_d);  <span class="comment">% see "doc gausswin" for details</span>filtlength = length(d_filter);   <span class="comment">% filter length determined by domain</span><span class="keyword">if</span> filtlength == 0    F = I;    <span class="keyword">return</span>;<span class="keyword">end</span>d_filter = d_filter*d_filter';  <span class="comment">% 2D filter</span></pre>      <p>initialize range filter</p>      <pre class="codeinput"><span class="keyword">if</span> sigma_r == 0    sigma_r = eps;<span class="keyword">end</span>mu_r = I;       <span class="comment">% Extract means for range filter</span>I = padarray(I, floor(filtlength/2)*[1,1]);    <span class="comment">% zero-padding for filtering</span>k = zeros(size(F));     <span class="comment">% Initialize normalizing factor</span></pre>      <p>filter using sliding window and accumulate (more efficient than px by        px)</p>      <pre class="codeinput"><span class="keyword">for</span> a = 1:filtlength    <span class="keyword">for</span> b = 1:filtlength        win = I(a:a+Y-1,b:b+X-1);    <span class="comment">% sliding window</span>        r_coeffs = exp(-((win-mu_r).^2)./(2*sigma_r^2));  <span class="comment">% range filter coefficients</span>        d_coeff = d_filter(a,b);    <span class="comment">% domain filter coefficient</span>        F = F + d_coeff*r_coeffs.*win;  <span class="comment">% accumulate</span>        k = k + d_coeff*r_coeffs;    <span class="keyword">end</span><span class="keyword">end</span></pre>      <p>normalize filter to 0 gain</p>      <pre class="codeinput">F = F ./ k;</pre>      <pre class="codeinput"><span class="keyword">end</span> <span class="comment">% end of bilateral_base</span></pre></div>    <!--##### SOURCE BEGIN #####%% BILATERAL_BASE - Base function for standard Gaussian bilateral filter.%   %% Description% Perform bilateral filtering on monochrome images following the approach of% [TM98]. Both the domain and range filters are Gaussian filters. %%% Algorithm% The bilateral filter is a spatially varying filter that better preserves % edges than the Gaussian filter.%% Given a spacial width $\sigma_x$ and a range width $\sigma_r$, the filter% opterates as:%% $$%     \mbox{BF}(I)(x) = \frac{1}{C_x} %     \sum_y G_{\sigma_x}(x-y) \cdot G_{\sigma_r}(I(x)-I(y)) \cdot I(y)% $$%% with the normalization factor:%% $$%     C_x = \sum_y G_{\sigma_x}(x-y) \cdot G_{\sigma_r}(I(x)-I(y))% $$%% at a given pixel |x|, it corresponds to an averaring with the data-dependant % kernel $G_{\sigma_x}(x-y) \cdot G_{\sigma_r}(I(x)-I(y))$. %%% Syntax%      F = BILATERAL_BASE(I, sigma_d, sigma_r);% %% Inputs% *|I|* : input image, possibly multispectral.%% *|sigma_d|* : standard deviation of domain filter (in pixels); sub-pixel%     values quantized to even fractions, i.e. in steps of 0.2.%% *|sigma_r|* : standard deviation of range filter; value in range [0,1]%     (relative to colorspace range which is normalized to 0 - 1).% %% Output% *|F|* : filtered image.%       %% Reference % [TM98]  C. Tomasi and R. Manduchi: "Bilateral filtering for gray and color%      images", Proc. IEEE ICCV, 1998.%      <http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=710815&tag=1>%%% Credit% <mailto:grazzja@lanl.gov J.Grazzini> (ISR-2/LANL)%%% See also% Related:% <BILATERAL.html |BILATERAL|>,% <BILATERALSTACK_BASE.html |BILATERALSTACK_BASE|>.% Called:% <matlab:webpub(whichpath('GAUSSWIN')) |GAUSSWIN|>.%% Function implementationfunction  F = bilateral_base(I, sigma_d, sigma_r)[X,Y,C] = size(I);  %%% deal with multispectral imagesif C>1    F = I;    for i=1:C        F(:,:,i) = bilateral_base(I(:,:,i), sigma_d, sigma_r);    end    returnend%% % main computation I = rescale(I);   % normalize image range to 0 - 1F = I; % initialize output;%%% initialize domain filter kerneld_filter = gausswin(5*sigma_d);  % see "doc gausswin" for detailsfiltlength = length(d_filter);   % filter length determined by domainif filtlength == 0    F = I;    return;endd_filter = d_filter*d_filter';  % 2D filter%%% initialize range filterif sigma_r == 0    sigma_r = eps;endmu_r = I;       % Extract means for range filterI = padarray(I, floor(filtlength/2)*[1,1]);    % zero-padding for filteringk = zeros(size(F));     % Initialize normalizing factor%%% filter using sliding window and accumulate (more efficient than px by px)for a = 1:filtlength    for b = 1:filtlength        win = I(a:a+Y-1,b:b+X-1);    % sliding window        r_coeffs = exp(-((win-mu_r).^2)./(2*sigma_r^2));  % range filter coefficients        d_coeff = d_filter(a,b);    % domain filter coefficient        F = F + d_coeff*r_coeffs.*win;  % accumulate        k = k + d_coeff*r_coeffs;    endend%%% normalize filter to 0 gainF = F ./ k;   end % end of bilateral_base##### SOURCE END #####-->  </body></html>