<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html>  <head>    <meta content="text/html; charset=utf-8" http-equiv="content-type">    <!--This HTML was auto-generated from MATLAB code.To make changes, update the MATLAB code and republish this document.      -->    <title>TENSCALEDIRFILT_BASE - Base function for TENSCALEDIRFILT.</title>    <meta name="generator" content="MATLAB 7.14">    <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">    <meta name="DC.date" content="2012-11-14">    <meta name="DC.source" content="tenscaledirfilt_base.m">    <style type="text/css">html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}html { min-height:100%; margin-bottom:1px; }html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }html body td { vertical-align:top; text-align:left; }h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }a { color:#005fce; text-decoration:none; }a:hover { color:#005fce; text-decoration:underline; }a:visited { color:#004aa0; text-decoration:none; }p { padding:0px; margin:0px 0px 20px; }img { padding:0px; margin:0px 0px 20px; border:none; }p img, pre img, tt img, li img { margin-bottom:0px; } ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }ul li { padding:0px; margin:0px 0px 7px 0px; }ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }ul li ol li { list-style:decimal; }ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }ol li ol li { list-style-type:lower-alpha; }ol li ul { padding-top:7px; }ol li ul li { list-style:square; }.content { font-size:1.2em; line-height:140%; padding: 20px; }pre, tt, code { font-size:12px; }pre { margin:0px 0px 20px; }pre.error { color:red; }pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }span.keyword { color:#0000FF }span.comment { color:#228B22 }span.string { color:#A020F0 }span.untermstring { color:#B20000 }span.syscmd { color:#B28C00 }.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }.footer p { margin:0px; }  </style>  </head>  <body>    <div class="content">      <h1>TENSCALEDIRFILT_BASE - Base function for TENSCALEDIRFILT.</h1>      <!--introduction--><!--/introduction-->      <h2>Contents</h2>      <div>        <ul>          <li><a href="#1">Syntax</a></li>          <li><a href="#3">See also</a></li>          <li><a href="#4">Function implementation</a></li>          <li><a href="#16">Subfunction</a></li>        </ul>      </div>      <h2>Syntax<a name="1"></a></h2>      <pre>   F = TENSCALEDIRFILT_BASE(I, T, S, sig1, sig2, nsig, nthe, nani, aecc, ani);</pre>      <h2>See also<a name="3"></a></h2>      <p>Related: <a href="TENSCALEDIRFILT.html"><tt>TENSCALEDIRFILT</tt></a>,        <a href="CONVOLUTION_BASE.html"><tt>CONVOLUTION_BASE</tt></a>, <a href="TENSANIFILT_BASE.html"><tt>TENSANIFILT_BASE</tt></a>,        <a href="ADAPTIVEFILT_BASE.html"><tt>ADAPTIVEFILT_BASE</tt></a>, <a href="GEODESICFILT_BASE.html"><tt>GEODESICFILT_BASE</tt></a>,        <a href="MDLFILT_BASE.html"><tt>MDLFILT_BASE</tt></a>. Called: <a href="ADAPTIVEFILT_BASE.html"><tt>ADAPTIVEFILT_BASE</tt></a>,        <a href="../../kernel/html/DIRGAUSSKERNEL.html"><tt>DIRGAUSSKERNEL</tt></a>.</p>      <h2>Function implementation<a name="4"></a></h2>      <pre class="codeinput"><span class="keyword">function</span> F = <span class="keyword">...</span></pre>      <pre class="codeinput">    tenscaledirfilt_base(I, T, S, sig1, sig2, nsig, nthe, nani, aecc, ani)  <spanclass="comment">%#ok</span>[x y] = size(I(:,:,1));v = sqrt(x*x + y*y);m = max(I(:)) - min(I(:));</pre>      <p>possibly build a tensor field</p>      <pre class="codeinput"><span class="keyword">if</span> size(T,4)==2   [sig1,sig2,~,~,theta] = gstdecomp(T);    <span class="comment">% theta = mod( atan2(e1(:,:,2), e1(:,:,1)), pi );</span><span class="keyword">elseif</span> size(T,4)==1    e1 = perform_vf_normalization(T);    <span class="comment">%  e2 = e1(:,:,2:-1:1); e2(:,:,1) = -e2(:,:,1);</span>    sig1 = sig1 * ones(size(T,1));    sig2 = sig2 * ones(size(T,1));    theta = mod( atan2(e1(:,:,2), e1(:,:,1)), pi );<span class="keyword">end</span>sig1 = v * sig1 / m;sig2 = v * sig2 / m;</pre>      <p>compute the anisotropy of the tensor field</p>      <pre class="codeinput"><span class="keyword">if</span> ani    A = (sig1 - sig2) ./ (sig1 + sig2);    <span class="comment">%</span><span class="keyword">else</span>    A = sig1 ./ sig2;<span class="keyword">end</span></pre>      <p>compute the sigma product</p>      <pre class="codeinput"><span class="keyword">if</span> isempty(S)    S = sig1 .* sig2; <span class="comment">% square of the sigma deviations</span><span class="keyword">elseif</span> isscalar(S)    S = S * ones(x,y);<span class="keyword">end</span><span class="keyword">if</span> std(A(:))&lt;1e-5,    nani = 1;  <span class="keyword">end</span><span class="keyword">if</span> std(S(:))&lt;1e-5,    nsig = 1;  <span class="keyword">end</span></pre>      <p>setting the local filters</p>      <p>compute the ranges of sigma for which different filters need to be        built</p>      <pre class="codeinput">s = sort(S(:)); a = sort(A(:));k = round(0.05*length(s));s_list = linspace(s(k), s(end-k), nsig);a_list = linspace(a(k), a(end-k), nani);<span class="comment">% quantize the orientation</span>t_list = linspace(0,pi,nthe+1); t_list(end) = [];<span class="comment">% compute the parameters of the filters</span></pre>      <p>generation of arrays for 3D function and interpolation</p>      <pre class="codeinput">[the_list,sig1_list,ani_list] = ndgrid(t_list,s_list,a_list);the_list = the_list(:);ani_list = ani_list(:);aecc = sqrt(ani_list);<span class="comment">% aecc = (aecc + ani_list(:)) / aecc;</span></pre>      <p>compute the deviation along short and long axis</p>      <pre class="codeinput"><span class="comment">% deviation along the short axis</span>sig2_list = sqrt(sig1_list(:)) ./ aecc;<span class="comment">% deviation along the long axis</span>sig1_list = sqrt(sig1_list(:)) .* aecc;m = length(the_list);</pre>      <p>quantize</p>      <pre class="codeinput">T = repmat( reshape(the_list,[1 1 m]), [x y 1] );S1 = repmat( reshape(sig1_list,[1 1 m]), [x y 1] );S2 = repmat( reshape(sig2_list,[1 1 m]), [x y 1] );t = repmat( theta, [1 1 m] );s1 = repmat( sig1, [1 1 m] );s2 = repmat( sig2, [1 1 m] );E = abs(T-t) + abs(S1-s1) + abs(S2-s2);[~,A] = min(E,[],3);</pre>      <p>performing the adaptive filtering</p>      <pre class="codeinput">H =  dirgausskernel(sig1_list, sig2_list, the_list, min(x,y), <spanclass="string">'geu'</span>);F = adaptivefilt_base(I, H, A);</pre>      <pre class="codeinput"><span class="keyword">end</span> <span class="comment">% end of tenscaledirfilt_base</span></pre>      <h2>Subfunction<a name="16"></a></h2>      <p><tt>PERFORM_V_NORMALIZATION</tt> - Renormalize a vector field.</p>      <pre class="codeinput"><span class="comment">%--------------------------------------------------------------------------</span><span class="keyword">function</span> v = perform_vf_normalization(v)a = nb_dims(v);d = sqrt( sum(v.^2,a) );d(d&lt;eps) = 1;v = v .* repmat( 1./d, [ones(a-1,1)' size(v,a)] );<span class="keyword">end</span> <span class="comment">% end of perform_vf_normalization</span></pre></div>    <!--##### SOURCE BEGIN #####%% TENSCALEDIRFILT_BASE - Base function for TENSCALEDIRFILT.%%% Syntax%     F = TENSCALEDIRFILT_BASE(I, T, S, sig1, sig2, nsig, nthe, nani, aecc, ani);%%% Credit% <mailto:grazzja@lanl.gov J.Grazzini> (ISR-2/LANL)% %% See also% Related:% <TENSCALEDIRFILT.html |TENSCALEDIRFILT|>,% <CONVOLUTION_BASE.html |CONVOLUTION_BASE|>,% <TENSANIFILT_BASE.html |TENSANIFILT_BASE|>,% <ADAPTIVEFILT_BASE.html |ADAPTIVEFILT_BASE|>,% <GEODESICFILT_BASE.html |GEODESICFILT_BASE|>,% <MDLFILT_BASE.html |MDLFILT_BASE|>.% Called:% <ADAPTIVEFILT_BASE.html |ADAPTIVEFILT_BASE|>,% <../../kernel/html/DIRGAUSSKERNEL.html |DIRGAUSSKERNEL|>.%% Function implementationfunction F = ...    tenscaledirfilt_base(I, T, S, sig1, sig2, nsig, nthe, nani, aecc, ani)  %#ok[x y] = size(I(:,:,1));                                         v = sqrt(x*x + y*y);m = max(I(:)) - min(I(:));%%% possibly build a tensor fieldif size(T,4)==2   [sig1,sig2,~,~,theta] = gstdecomp(T);    % theta = mod( atan2(e1(:,:,2), e1(:,:,1)), pi );    elseif size(T,4)==1    e1 = perform_vf_normalization(T);    %  e2 = e1(:,:,2:-1:1); e2(:,:,1) = -e2(:,:,1);    sig1 = sig1 * ones(size(T,1));    sig2 = sig2 * ones(size(T,1));    theta = mod( atan2(e1(:,:,2), e1(:,:,1)), pi );endsig1 = v * sig1 / m;sig2 = v * sig2 / m;%%% compute the anisotropy of the tensor fieldif ani    A = (sig1 - sig2) ./ (sig1 + sig2);    % else    A = sig1 ./ sig2;end%%% compute the sigma productif isempty(S)    S = sig1 .* sig2; % square of the sigma deviationselseif isscalar(S)    S = S * ones(x,y);endif std(A(:))<1e-5,    nani = 1;  endif std(S(:))<1e-5,    nsig = 1;  end%% % setting the local filters%%% compute the ranges of sigma for which different filters need to be builts = sort(S(:)); a = sort(A(:));k = round(0.05*length(s));s_list = linspace(s(k), s(end-k), nsig);a_list = linspace(a(k), a(end-k), nani);% quantize the orientationt_list = linspace(0,pi,nthe+1); t_list(end) = [];% compute the parameters of the filters%%% generation of arrays for 3D function and interpolation[the_list,sig1_list,ani_list] = ndgrid(t_list,s_list,a_list);the_list = the_list(:);ani_list = ani_list(:);aecc = sqrt(ani_list);% aecc = (aecc + ani_list(:)) / aecc;%%% compute the deviation along short and long axis% deviation along the short axissig2_list = sqrt(sig1_list(:)) ./ aecc;% deviation along the long axissig1_list = sqrt(sig1_list(:)) .* aecc;m = length(the_list);%%% quantizeT = repmat( reshape(the_list,[1 1 m]), [x y 1] );S1 = repmat( reshape(sig1_list,[1 1 m]), [x y 1] );S2 = repmat( reshape(sig2_list,[1 1 m]), [x y 1] );t = repmat( theta, [1 1 m] );s1 = repmat( sig1, [1 1 m] );s2 = repmat( sig2, [1 1 m] );E = abs(T-t) + abs(S1-s1) + abs(S2-s2);[~,A] = min(E,[],3);%% % performing the adaptive filteringH =  dirgausskernel(sig1_list, sig2_list, the_list, min(x,y), 'geu');F = adaptivefilt_base(I, H, A);end % end of tenscaledirfilt_base%% Subfunction%%% |PERFORM_V_NORMALIZATION| - Renormalize a vector field.%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHfunction v = perform_vf_normalization(v)a = nb_dims(v);d = sqrt( sum(v.^2,a) );d(d<eps) = 1;v = v .* repmat( 1./d, [ones(a-1,1)' size(v,a)] );end % end of perform_vf_normalization##### SOURCE END #####--></body></html>