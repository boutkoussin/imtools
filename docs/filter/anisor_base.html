<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html>  <head>    <meta content="text/html; charset=utf-8" http-equiv="content-type">    <!--This HTML was auto-generated from MATLAB code.To make changes, update the MATLAB code and republish this document.      -->    <title>ANISOR_BASE - Base function for ANISOR.</title>    <meta name="generator" content="MATLAB 7.14">    <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">    <meta name="DC.date" content="2012-11-14">    <meta name="DC.source" content="anisor_base.m">    <style type="text/css">html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}html { min-height:100%; margin-bottom:1px; }html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }html body td { vertical-align:top; text-align:left; }h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }a { color:#005fce; text-decoration:none; }a:hover { color:#005fce; text-decoration:underline; }a:visited { color:#004aa0; text-decoration:none; }p { padding:0px; margin:0px 0px 20px; }img { padding:0px; margin:0px 0px 20px; border:none; }p img, pre img, tt img, li img { margin-bottom:0px; } ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }ul li { padding:0px; margin:0px 0px 7px 0px; }ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }ul li ol li { list-style:decimal; }ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }ol li ol li { list-style-type:lower-alpha; }ol li ul { padding-top:7px; }ol li ul li { list-style:square; }.content { font-size:1.2em; line-height:140%; padding: 20px; }pre, tt, code { font-size:12px; }pre { margin:0px 0px 20px; }pre.error { color:red; }pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }span.keyword { color:#0000FF }span.comment { color:#228B22 }span.string { color:#A020F0 }span.untermstring { color:#B20000 }span.syscmd { color:#B28C00 }.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }.footer p { margin:0px; }  </style>  </head>  <body>    <div class="content">      <h1>ANISOR_BASE - Base function for ANISOR.</h1>      <!--introduction--><!--/introduction-->      <h2>Contents</h2>      <div>        <ul>          <li><a href="#1">Syntax</a></li>          <li><a href="#3">See also</a></li>          <li><a href="#4">Function implementation</a></li>        </ul>      </div>      <h2>Syntax<a name="1"></a></h2>      <pre>   kappa = ANISOR_BASE(I, mu, rho, sigma, der, int, samp);</pre>      <h2>See also<a name="3"></a></h2>      <p>Related: <a href="ANISOR.html"><tt>ANISOR</tt></a>. Called: <a href="../../derive/html/GSTSMOOTH_BASE.html"><tt>GSTSMOOTH_BASE</tt></a>,        <a href="../../derive/html/GSTDECOMP.html"><tt>GSTDECOMP</tt></a>, <a href="matlab:webpub%28whichpath%28%27DOT%27%29%29"><tt>DOT</tt></a>.</p>      <h2>Function implementation<a name="4"></a></h2>      <pre class="codeinput"><span class="keyword">function</span> kappa = anisor_base(I, mu, rho, sigma, der, int, samp)</pre>      <pre class="codeinput">C = size(I,3);<span class="comment">% possibly multichannel when C&gt;1...or not!!!</span><span class="keyword">if</span>(C&gt;1)    error(<span class="string">'anisor_base:inputerror'</span>,<span class="keyword">...</span>        [<span class="string">'TODO: method not implemented yet for multichannel images - need '</span> <spanclass="keyword">...</span>        <span class="string">'to define an appropriate multichannel gradient for such images - a '</span> <spanclass="keyword">...</span>        <span class="string">'possible solution can be given by Scheunders approach as we are '</span><spanclass="keyword">...</span>        <span class="string">'interested in the orientation only (see subfunction GSTREORIENT in '</span> <spanclass="keyword">...</span>        <span class="string">'GSTFEATURE_BASE)'</span>]);<span class="keyword">end</span></pre>      <p>compute the gradient (given by the directional derivatives) and the        gradient structure tensor</p>      <p>compute the structure tensor <tt>S</tt> of Eq.(8)</p>      <pre class="codeinput">[S, gx, gy] = <span class="keyword">...</span>    gstsmooth_base(I, rho, sigma, der, int, samp, [], false, false, 8, .4);<span class="comment">%  |rho|: integration scale</span><span class="comment">%  |sigma|: differentiation scale</span><span class="comment">%  |der, int|: methods used for derivating and smoothing resp. see |GRDSMOOTH|,</span><span class="comment">%   |GSTSMOOTH| and |SMOOTHFILT| helps.</span></pre>      <p>note: the components of <tt>S</tt> and the directional derivatives <tt>(gx,gy)</tt>        were computed using the same <tt>sigma</tt></p>      <p>perform the eigen decomposition</p>      <pre class="codeinput">[~, ~, ~, v2] = gstdecomp(S);<span class="comment">% in [l1, l2, v1, v2] = gstdecomp(S), we have:</span><span class="comment">%  l1, l2 : eigenvalues of the tensor, l1&gt;=l2.</span><span class="comment">%  v1, v2 : corresponding eigenvectors; "v1 describes the orientation of</span><span class="comment">%   highest contrast variation", ie. it gives the direction of maximal</span><span class="comment">%   local change  within the window given the integration scale rho, and v2</span><span class="comment">%   is orthogonal to v1.</span></pre>      <p>in the case of scalar image, l1 \approx <tt>grad</tt>, v1 \approx        orient(grad) note that however there is an undetermination in the        direction (sign) of the eigenvectors. But it is something dealt with <tt>eta</tt>        in the following (see remark below)</p>      <pre class="codeinput"><span class="comment">% figure, quiver(gx,gy),title('gx gy');</span><span class="comment">% figure, quiver(v1(:,:,1),v1(:,:,2)),title('v2');</span><span class="comment">% figure, quiver(v2(:,:,1),v2(:,:,2)),title('v2');</span></pre>      <p>compute the orientation information</p>      <pre class="codeinput">nabla = cat(3, gx, gy); <span class="comment">% this is the gradient field \nabla u_{\sigma}</span></pre>      <p>compute the <tt>eta</tt> of Eq.(9)</p>      <pre class="codeinput">eta = abs(dot(nabla, v2, 3) ./ (sqrt(dot(nabla,nabla,3) .* dot(v2,v2,3))));eta(isnan(eta))=0; <span class="comment">% consider the case 0/0</span></pre>      <p>note: when <tt>A</tt> and <tt>B</tt> are two vector fields defined        over the domain <tt>[X,Y]</tt> (therefore, <tt>A</tt> - ibid with <tt>B</tt>        - is a matrix of size <tt>(X,Y,2)</tt> whose X- and Y-coordinates are        defined in <tt>A(:,:,1)</tt> and <tt>A(:,:,2)</tt> resp. - ibid with <tt>B</tt>),        <tt>dot(A,B,3)</tt> is the scalar product of <tt>A</tt> and <tt>B</tt>        calculated all over the the domain <tt>[X,Y]</tt>. Consequently, <tt>dot(A,A,2)</tt>        is the (squared) norm of the vector field <tt>A</tt> defined on the        domain <tt>[X,Y]</tt></p>      <p>remark: at that point, <tt>eta</tt> depends only on the respective        orientations of the vectors nabla and <tt>v2</tt>, not on their        directions</p>      <p>compute the kappa of Eq.(10), where <tt>mu</tt> is a non-negative        integer which influences the propagation of the structures in <tt>v2</tt>        direction</p>      <pre class="codeinput">kappa = eta .^ mu;</pre>      <pre class="codeinput"><span class="keyword">end</span> <span class="comment">% end of anisor_base</span></pre></div>    <!--##### SOURCE BEGIN #####%% ANISOR_BASE - Base function for ANISOR.%%% Syntax%     kappa = ANISOR_BASE(I, mu, rho, sigma, der, int, samp);%%% Credit% <mailto:grazzja@lanl.gov J.Grazzini> & <mailto:prasad@lanl.gov L.Prasad> (ISR-2/LANL)%%% See also% Related:% <ANISOR.html |ANISOR|>.% Called:% <../../derive/html/GSTSMOOTH_BASE.html |GSTSMOOTH_BASE|>,% <../../derive/html/GSTDECOMP.html |GSTDECOMP|>,% <matlab:webpub(whichpath('DOT')) |DOT|>.%% Function implementationfunction kappa = anisor_base(I, mu, rho, sigma, der, int, samp)C = size(I,3);% possibly multichannel when C>1...or not!!!                       if(C>1)     error('anisor_base:inputerror',...        ['TODO: method not implemented yet for multichannel images - need ' ...        'to define an appropriate multichannel gradient for such images - a ' ...        'possible solution can be given by Scheunders approach as we are '...         'interested in the orientation only (see subfunction GSTREORIENT in ' ...        'GSTFEATURE_BASE)']);end%%% compute the gradient (given by the directional derivatives) and the % gradient structure tensor%%% compute the structure tensor |S| of Eq.(8)[S, gx, gy] = ...    gstsmooth_base(I, rho, sigma, der, int, samp, [], false, false, 8, .4);%  |rho|: integration scale%  |sigma|: differentiation scale%  |der, int|: methods used for derivating and smoothing resp. see |GRDSMOOTH|,%   |GSTSMOOTH| and |SMOOTHFILT| helps.%%% note: the components of |S| and the directional derivatives |(gx,gy)| were% computed using the same |sigma|%% % perform the eigen decomposition[~, ~, ~, v2] = gstdecomp(S); % in [l1, l2, v1, v2] = gstdecomp(S), we have: %  l1, l2 : eigenvalues of the tensor, l1>=l2. %  v1, v2 : corresponding eigenvectors; "v1 describes the orientation of %   highest contrast variation", ie. it gives the direction of maximal %   local change  within the window given the integration scale rho, and v2%   is orthogonal to v1.%%% in the case of scalar image, l1 \approx |grad|, v1 \approx orient(grad) % note that however there is an undetermination in the direction (sign) of% the eigenvectors. But it is something dealt with |eta| in the following% (see remark below)% figure, quiver(gx,gy),title('gx gy');% figure, quiver(v1(:,:,1),v1(:,:,2)),title('v2');% figure, quiver(v2(:,:,1),v2(:,:,2)),title('v2');%% % compute the orientation informationnabla = cat(3, gx, gy); % this is the gradient field \nabla u_{\sigma}%%% compute the |eta| of Eq.(9)eta = abs(dot(nabla, v2, 3) ./ (sqrt(dot(nabla,nabla,3) .* dot(v2,v2,3))));eta(isnan(eta))=0; % consider the case 0/0%%% note: when |A| and |B| are two vector fields defined over the domain |[X,Y]| % (therefore, |A| - ibid with |B| - is a matrix of size |(X,Y,2)| whose X- % and Y-coordinates are defined in |A(:,:,1)| and |A(:,:,2)| resp. - ibid with% |B|), |dot(A,B,3)| is the scalar product of |A| and |B| calculated all over% the the domain |[X,Y]|. Consequently, |dot(A,A,2)| is the (squared) norm % of the vector field |A| defined on the domain |[X,Y]|%%% remark: at that point, |eta| depends only on the respective orientations of% the vectors nabla and |v2|, not on their directions%%% compute the kappa of Eq.(10), where |mu| is a non-negative integer which % influences the propagation of the structures in |v2| directionkappa = eta .^ mu;end % end of anisor_base##### SOURCE END #####--></body></html>