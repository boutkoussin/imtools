<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html>  <head>    <meta content="text/html; charset=utf-8" http-equiv="content-type">    <!--This HTML was auto-generated from MATLAB code.To make changes, update the MATLAB code and republish this document.      -->    <title>RAMPSHARP - Iterative ramp sharpening of multispectral images.</title>    <meta name="generator" content="MATLAB 7.11">    <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">    <meta name="DC.date" content="2011-07-11">    <meta name="DC.source" content="rampsharp.m">    <style type="text/css">body {  background-color: white;  margin:10px;}h1 {  color: #990000;   font-size: x-large;}h2 {  color: #990000;  font-size: medium;}/* Make the text shrink to fit narrow windows, but not stretch too far in wide windows. */ p,h1,h2,div.content div {  max-width: 600px;  /* Hack for IE6 */  width: auto !important; width: 600px;}pre.codeinput {  background: #EEEEEE;  padding: 10px;}@media print {  pre.codeinput {word-wrap:break-word; width:100%;}} span.keyword {color: #0000FF}span.comment {color: #228B22}span.string {color: #A020F0}span.untermstring {color: #B20000}span.syscmd {color: #B28C00}pre.codeoutput {  color: #666666;  padding: 10px;}pre.error {  color: red;}p.footer {  text-align: right;  font-size: xx-small;  font-weight: lighter;  font-style: italic;  color: gray;}  </style>  </head>  <body>    <div class="content">      <h1>RAMPSHARP - Iterative ramp sharpening of multispectral images.</h1>      <!--introduction--><!--/introduction-->      <h2>Contents</h2>      <div>        <ul>          <li><a href="#1">Description</a></li>          <li><a href="#2">Syntax</a></li>          <li><a href="#3">Inputs</a></li>          <li><a href="#4">Property [propertyname propertyvalues]</a></li>          <li><a href="#5">Outputs</a></li>          <li><a href="#6">References</a></li>          <li><a href="#7">Credit</a></li>          <li><a href="#8">Function implementation</a></li>          <li><a href="#13">construct beforehand the predefined local 3x3              kernels defined for each</a></li>          <li><a href="#25">Subfunctions</a></li>        </ul>      </div>      <h2>Description<a name="1"></a></h2>      <p>Perform (multispectral) image enhancement through iterative local ramp        sharpening as described in [GS10].</p>      <h2>Syntax<a name="2"></a></h2>      <pre>   [SH,TR] = RAMPSHARP(I);   [SH,TR] = RAMPSHARP(I, niter, method, sigma, rho);   [SH,TR] = RAMPSHARP(I, niter, method, sigma, rho,                          'Property', propertyvalue, ...);</pre>      <h2>Inputs<a name="3"></a></h2>      <p><b><tt>I</tt></b> : input image with dimension <tt>C</tt>, possibly        multispectral (<tt>C&gt;1</tt> bands).</p>      <p>*<tt>niter: optional positive parameter setting the number of          iterations of the sharpening algorithm; when |niter=0</tt>, the        sharpening is iterated till convergence; default: <tt>niter=1</tt>.</p>      <p><b><tt>method</tt></b> :</p>      <p><b><tt>sigma</tt></b> : pre-smoothing width (half-window size in        pixels); this parameter sets the differentiation scale in the case the        image is smoothed prior to the differentiation through Gaussian        filtering; sigma typically controls the size of the objects whose        orientation has to be estimated; default: <tt>sigma=0.5</tt>, i.e.        Gaussian regularisation is used for estimating the derivatives.</p>      <p><b><tt>rho</tt></b> : post-smoothing width (half-window size in        pixels); this parameter sets the integration scale for spatial        averaging, that controls the size of the neighbourhood in which an        orientation is dominant; it is used for averaging the partial        directional derivatives of the tensor with a Gaussian kernel; if <tt>rho&lt;0.05</tt>,        then no smoothing is performed; default: <tt>rho=0.5</tt>.</p>      <p><b><tt>der</tt></b> : flag defining the original <tt>(3,3)</tt>        gradient mask used for estimating the directional derivatives of the        input image; it is either (see <tt>GRADMASK</tt>):</p>      <div>        <ul>          <li><tt>'sob'</tt> for Sobel mask,</li>          <li><tt>'dif'</tt> for central differences,</li>          <li><tt>'for'</tt> when forward differences are computed,</li>          <li><tt>'bac'</tt> when backward differences are computed,</li>          <li><tt>'pre'</tt> for Prewitt mask,</li>          <li><tt>'iso'</tt> for Frei-Chen's isotropic mask,</li>          <li><tt>'opt'</tt> for Ando's optimal mask,</li>          <li><tt>'cir'</tt> for Davies' circular mask;</li>        </ul>      </div>      <p>default: <tt>der='dif'</tt>.</p>      <h2>Property [propertyname propertyvalues]<a name="4"></a></h2>      <p><b><tt>'pilot'</tt></b> :</p>      <p><b><tt>'alpha'</tt></b> : flag setting the correction factor alpha when        updating a pixel value; the correction alpha is based on the estimated        gradient indices <img src="rampsharp_eq69112.png" alt="$G_M$">, <img src="rampsharp_eq58870.png"          alt="$G_L$">        and <img src="rampsharp_eq93923.png" alt="$G_H$"> (see [Leu00]) for        further definition of the gradient indices); therefore, alpha is        expected to be either:</p>      <div>        <ul>          <li><tt>'f0'</tt> then <img src="rampsharp_eq82294.png" alt="$F = (G_1 - G_M) / (G_M - G_2)$">            (following [Leu00]),</li>          <li><tt>'f1'</tt> then <img src="rampsharp_eq28639.png" alt="$F = (G_2 + G_M) / (1 + 2*G_M)$">,            (default)</li>          <li><tt>'f2'</tt> then <img src="rampsharp_eq41678.png" alt="$F = (G_1 + G_2 - G_M) / (1 + 3*G_M)$">,</li>          <li><tt>'f3'</tt> then <img src="rampsharp_eq88158.png" alt="$F = (G_1 + G_2) / (1 + 2*G_M)$">,</li>          <li><tt>'f4'</tt> then <img src="rampsharp_eq59049.png" alt="$F = (G_1 + G_M) / (1 + 2*G_M)$">,</li>          <li><tt>'f5'</tt> then <img src="rampsharp_eq28668.png" alt="$F = (G_1 + G_2 + G_M) / (1 + 3*G_M)$">,</li>        </ul>      </div>      <p>where <img src="rampsharp_eq29495.png" alt="$G_1$"> and <img src="rampsharp_eq95775.png"          alt="$G_2$">        stand for either <img src="rampsharp_eq58870.png" alt="$G_L$"> or <img          src="rampsharp_eq93923.png"          alt="$G_H$">,        depending on which part of of the ramp (lower or higher) the pixel        belongs to.</p>      <p><b><tt>'fE'</tt></b> : optional parameter setting the factor effect        (see [Leu00]) as a multiplicative effect on the correction factor, so        that: <img src="rampsharp_eq26916.png" alt="$F = F \cdot fE$">.</p>      <p><b><tt>'win'</tt></b> : set the parameters of the local kernel windows        used for estimating the local gradient and intensity indices</p>      <div>        <ul>          <li><tt>'w0'</tt> : the kernel weights are identical to those of Leu's            approach,</li>          <li><tt>'w1'</tt> : new kernel weights.</li>        </ul>      </div>      <p><b><tt>'adjust'</tt></b> : 'shift' or 'control'</p>      <p><b><tt>'crit'</tt></b> : optional flag for deciding how vectorial        components are taken into account in the ramp decision, depending on the        estimated intensity indices <img src="rampsharp_eq12112.png" alt="$I_M$">,        <img src="rampsharp_eq30616.png" alt="$I_L$"> and <img src="rampsharp_eq81471.png"          alt="$I_H$">        (see [Leu00]) for further definition of the intensity indices); it        provides the adju for deciding when a (vector) pixel has to be        considered as a ramp pixel - useful only when <tt>C&gt;1</tt>; it is        either:</p>      <div>        <ul>          <li>'all': then for each pixel, we check if it exists one band where            its <img src="rampsharp_eq81471.png" alt="$I_H$"> is greater than            its <img src="rampsharp_eq12112.png" alt="$I_M$"> and its <img src="rampsharp_eq12112.png"              alt="$I_M$">            is greater than its <img src="rampsharp_eq30616.png" alt="$I_L$">,            and we verify that there is no band where its <img src="rampsharp_eq81471.png"              alt="$I_H$">            is lower than its <img src="rampsharp_eq12112.png" alt="$I_M$"> or            its <img src="rampsharp_eq12112.png" alt="$I_M$"> is lower than its            <img src="rampsharp_eq30616.png" alt="$I_L$">, ie.: <img src="rampsharp_eq09668.png"              alt="$$                  \exists i, I_H(i) &gt; I_M(i) &gt; I_L(i)  \quad  \&amp;  \quad                  \forall j \neq i, I_H(j) \geq I_M(j) \geq I_L(j) $$"></li>        </ul>      </div>      <p>note that in the case <tt>nc=1</tt>, the previous condition is        equivalent to that proposed in [Leu00],</p>      <div>        <ul>          <li>'one': it is enough that the relationship regarding neighbour            pixels intensity is verified in one channel to perform the local            adjustment, ie.: <img src="rampsharp_eq43681.png" alt="$$                  \exists i, I_H(i) &gt; I_M(i) &gt; I_L(i) $$"></li>        </ul>      </div>      <p>(more flexible than the previous option in the multispectral case,        equivalent in the monospectral one)</p>      <p><b><tt>'derive'</tt></b> :</p>      <pre>         * |'grd'|         * |'tens'|</pre>      <p><b><tt>'sigma'</tt></b> :</p>      <p><b><tt>'rho'</tt></b> :</p>      <p><b><tt>'hsize'</tt></b> : optional filter size; default: estimated        depending on <tt>sigma</tt>, typically <tt>hsize=6*sigma+1</tt>.</p>      <p><b><tt>'eigen'</tt></b> :</p>      <p><b><tt>samp</tt></b> : to perform <tt>(*samp)</tt> interpolation of        the gradient to avoid aliasing.</p>      <h2>Outputs<a name="5"></a></h2>      <p><b><tt>SH</tt></b> :</p>      <p><b><tt>TR</tt></b> : transition map, where a positive graylevel        intensity indicates the last iteration the pixel was detected as a        transition</p>      <h2>References<a name="6"></a></h2>      <p>[Leu00] J.G. Leu: "Edge sharpening through ramd width reduction", Image        and Vision Computing, 18: 501-514, 2000. <a href="http://www.sciencedirect.com/science/article/pii/S0262885699000414">http://www.sciencedirect.com/science/article/pii/S0262885699000414</a></p>      <p>[GS10] J. Grazzini and P. Soille: "Iterative ramp sharpening for        structure/signature-preserving simplification of images", Proc. ICPR,        2010. <a href="http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=5597348">http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=5597348</a></p>      <h2>Function implementation<a name="8"></a></h2>      <pre class="codeinput"><span class="keyword">function</span> [SH,TH,pl, pch] = rampsharp(I,varargin)</pre>      <pre class="codeinput">error(nargchk(1, 33, nargin, <span class="string">'struct'</span>));error(nargoutchk(1, 4, nargout, <span class="string">'struct'</span>));</pre>      <p>parsing parameters</p>      <pre class="codeinput"><span class="keyword">if</span> ~isnumeric(I)    error(<span class="string">'rampsharp:errorinput'</span>,<span class="string">'a matrix is required in input'</span>);<span class="keyword">end</span><span class="comment">% Optional parameters</span>p = createParser(<span class="string">'RAMPSHARP'</span>);   <span class="comment">% create an instance of the inputParser class.</span><span class="comment">% mandatory (required) variables</span><span class="comment">%p.addRequired('I', @isnumeric);</span><span class="comment">% principal optional parameters</span>p.addOptional(<span class="string">'niter'</span>, 1, @(x)isscalar(x) &amp;&amp; x&gt;=0);p.addOptional(<span class="string">'method'</span>, <span class="string">'control'</span>, @(x)ischar(x) &amp;&amp; <spanclass="keyword">...</span>    any(strcmpi(x,{<span class="string">'shift'</span>, <span class="string">'leu'</span>, <spanclass="string">'control'</span>})));p.addOptional(<span class="string">'sigma'</span>, 0.5, @(x)isscalar(x) &amp;&amp; isfloat(x) &amp;&amp; x&gt;=0);p.addOptional(<span class="string">'rho'</span>, 1, @(x)isscalar(x) &amp;&amp; isfloat(x) &amp;&amp; x&gt;=0);<span class="comment">% other optional parameters</span>p.addOptional(<span class="string">'der'</span>, <span class="string">'fast'</span>, @(x)islogical(x) || (ischar(x) &amp;&amp; <spanclass="keyword">...</span>    any(strcmpi(x,{<span class="string">'matlab'</span>,<span class="string">'vista'</span>,<spanclass="string">'fast'</span>,<spanclass="string">'conv'</span>,<spanclass="string">'fleck'</span>, <spanclass="keyword">...</span>    <span class="string">'tap5'</span>,<span class="string">'tap7'</span>,<spanclass="string">'sob'</span>,<spanclass="string">'opt'</span>,<spanclass="string">'ana'</span>}))));p.addOptional(<span class="string">'int'</span>, <span class="string">'fast'</span>, @(x)islogical(x) || (ischar(x) &amp;&amp; <spanclass="keyword">...</span>    any(strcmpi(x,{<span class="string">'matlab'</span>,<span class="string">'conv'</span>,<spanclass="string">'fast'</span>,<spanclass="string">'ani'</span>}))));p.addParamValue(<span class="string">'hsize'</span>,5, @(x)isscalar(x));p.addParamValue(<span class="string">'samp'</span>, 1, @(x)isscalar(x) &amp;&amp; round(x)==x &amp;&amp; x&gt;=1 &amp;&amp; x&lt;=5);p.addParamValue(<span class="string">'pilot'</span>, <span class="string">'ave'</span>, @(x)ischar(x) &amp;&amp; any(strcmpi(x,{<spanclass="string">'ave'</span>, <spanclass="string">'int'</span>})));p.addParamValue(<span class="string">'fac'</span>, <span class="string">'f5'</span>, @(x)ischar(x) &amp;&amp; <spanclass="keyword">...</span>    any(strcmpi(x,{<span class="string">'f0'</span>, <span class="string">'f1'</span>, <spanclass="string">'f2'</span>, <spanclass="string">'f3'</span>, <spanclass="string">'f4'</span>, <spanclass="string">'f5'</span>, <spanclass="string">'leu'</span>})));p.addParamValue(<span class="string">'kern'</span>, <span class="string">'leu'</span>, @(x)ischar(x) &amp;&amp; <spanclass="keyword">...</span>    any(strcmpi(x,{<span class="string">'new'</span>, <span class="string">'leu'</span>})));p.addParamValue(<span class="string">'fE'</span>, 1, @(x)isscalar(x) &amp;&amp; isfloat(x));p.addParamValue(<span class="string">'nz'</span>, 8, @(x)x==8 || x==16);p.addParamValue(<span class="string">'interp'</span>, 0, @(x)isscalar(x) &amp;&amp; x&gt;=1);p.addParamValue(<span class="string">'crit'</span>, <span class="string">'all'</span>, @(x)ischar(x) &amp;&amp; any(strcmpi(x,{<spanclass="string">'all'</span>, <spanclass="string">'one'</span>})));p.addParamValue(<span class="string">'eign'</span>, <span class="string">'zen'</span>, @(x)ischar(x) &amp;&amp; <spanclass="keyword">...</span>    any(strcmpi(x,{<span class="string">'abs'</span>,<span class="string">'zen'</span>, <spanclass="string">'sap'</span>,<spanclass="string">'sum'</span>, <spanclass="string">'dif'</span>, <spanclass="string">'ndi'</span>})));p.addParamValue(<span class="string">'gthres'</span>, 0, @(x)isscalar(x) &amp;&amp; isfloat(x) &amp;&amp; x&gt;=0 &amp;&amp; x&lt;=1);p.addParamValue(<span class="string">'pctch'</span>, 0.01, @(x)isscalar(x) &amp;&amp; isfloat(x) &amp;&amp; x&gt;=0 &amp;&amp; x&lt;=1);p.addParamValue(<span class="string">'trans'</span>, <span class="string">'indice'</span>, @(x)ischar(x) &amp;&amp; <spanclass="keyword">...</span>    any(strcmpi(x,{<span class="string">'indice'</span>, <span class="string">'morph'</span>})));<span class="comment">% parse and validate all input arguments</span>p.parse(varargin{:});p = getvarParser(p);<span class="comment">% default choice parameters when the option 'method' has been set to 'leu',</span><span class="comment">% ie'. the original implementation of  [Leu00] is to be ran.</span><span class="keyword">if</span> strcmp(p.method,<span class="string">'leu'</span>)    p.method = <span class="string">'shift'</span>; <span class="comment">% just shift the value, without controlling its extent</span>    p.kern = <span class="string">'leu'</span>;    <span class="comment">% original weights for computing the indices</span>    p.der    = <span class="string">'sob'</span>;   <span class="comment">% sobel gradient for estimating the derivatives</span>    p.nz = <span class="string">'8'</span>;     <span class="comment">% 8 zones to be used in interpolation of indices</span>    p.fac = <span class="string">'f0'</span>;    <span class="comment">% factor used in shifting</span>    p.crit   = <span class="string">'one'</span>;   <span class="comment">% check only if assertion is true on single band</span>    p.interp = 0;       <span class="comment">% no prior interpolation of input image</span>    p.sigma  = 0;       <span class="comment">% no smoothing</span>    p.rho    = 0;       <span class="comment">% no integration</span>    p.fE     = 1;       <span class="comment">% no correction factor</span><span class="keyword">end</span><span class="comment">% switch p.der</span><span class="comment">%     case 'pey'</span><span class="comment">%         p.hsize = max(1+round(p.sigma)*2, 7);</span><span class="comment">%     case {'rad','mat','kro'}</span><span class="comment">%         p.hsize = ceil(4 * p.sigma); % approximation</span><span class="comment">%     otherwise</span><span class="comment">%         p.hsize = ceil(6 * p.sigma);</span><span class="comment">% end</span></pre>      <p>internal variables</p>      <pre class="codeinput"><span class="comment">% check the dimension of the input image:</span>nbdims = nb_dims(I); <span class="comment">% instead of ndims</span><span class="keyword">if</span> nbdims&lt;2 || nbdims&gt;3    error(<span class="string">'matrix or array of matrices are expected as inputs'</span>);<span class="keyword">end</span><span class="comment">% number of spectral components</span>Z = size(I,3);<span class="comment">% possibly overwrite</span><span class="keyword">if</span> Z~=3 &amp;&amp; strcmp(p.pilot,<span class="string">'int'</span>)    warning(<span class="string">'ramspharp:inputparameter'</span>,<span class="keyword">...</span>        <span class="string">'pilot image as intensity implemented only for RGB images'</span>);    p.pilot = <span class="string">'ave'</span>;<span class="keyword">end</span></pre>      <p>internal parameters (do not modify) Initializing variables</p>      <pre class="codeinput">pchange = p.pctch +1;<span class="comment">% We adopt the following index representation for the directed components</span><span class="comment">% used for the intensity and gradient indices used (matlab indexing)</span><span class="comment">%          ---------------         -------------</span><span class="comment">%          | NW | N | NE |         | 1 | 4 | 7 |</span><span class="comment">%          ---------------         -------------</span><span class="comment">%          | W  |   | E  |    =&gt;   | 2 | 5 | 8 |</span><span class="comment">%          ---------------         -------------</span><span class="comment">%          | SW | S | SE |         | 3 | 6 | 9 |</span><span class="comment">%          ---------------         -------------</span>direction_indices = struct(<span class="string">'east'</span>, 8, <span class="string">'northeast'</span>, 7, <spanclass="string">'north'</span>, 4, <spanclass="keyword">...</span>    <span class="string">'northwest'</span>, 1, <span class="string">'west'</span>, 2, <spanclass="string">'southwest'</span>, 3, <spanclass="keyword">...</span>    <span class="string">'south'</span>, 6, <span class="string">'southeast'</span>, 9, <spanclass="string">'central'</span>, 5);                         <spanclass="comment">%#ok</span><span class="comment">%directions = fieldnames(direction_indices);</span><span class="comment">%ndirections = length(directions);</span><span class="comment">% note: not used in the following</span>level_indices = struct( <span class="string">'L'</span>, 1, <span class="string">'M'</span>, 2, <spanclass="string">'H'</span>, 3);L = level_indices.(<span class="string">'L'</span>); M = level_indices.(<span class="string">'M'</span>); H = level_indices.(<spanclass="string">'H'</span>);<span class="comment">% Remember: mapping from indexes to subscripts for a 3x3 matrix in matlab</span><span class="comment">%          -------------------         -------------</span><span class="comment">%          | 1,1 | 1,2 | 1,3 |         | 1 | 4 | 7 |</span><span class="comment">%          -------------------         -------------</span><span class="comment">%          | 2,1 | 2,2 | 2,3 |    =&gt;   | 2 | 5 | 8 |</span><span class="comment">%          -------------------         -------------</span><span class="comment">%          | 3,1 | 3,2 | 3,3 |         | 3 | 6 | 9 |</span><span class="comment">%          -------------------         -------------</span><span class="comment">%                (ii,jj)          =&gt;    ii+3*(jj-1)</span></pre>      <h2>construct beforehand the predefined local 3x3 kernels defined for each<a          name="13"></a></h2>      <p>different zone and level, and used for the estimation of the gradient        and intensity indices (used once at the beginning of the code).        Intensity and gradient masks are built for both zones 1 and 2, and all        the other zones derived by rotation</p>      <pre class="codeinput"><span class="keyword">switch</span> p.kern    <span class="keyword">case</span> <span class="string">'leu'</span>        matI = local3x3kernel(<span class="string">'ker'</span>,<span class="string">'i0'</span>,<spanclass="string">'norm'</span>,true);        matG = local3x3kernel(<span class="string">'ker'</span>,<span class="string">'g0'</span>,<spanclass="string">'norm'</span>,true);    <span class="keyword">case</span> <span class="string">'new'</span>        matI = local3x3kernel(<span class="string">'ker'</span>,<span class="string">'i1'</span>,<spanclass="string">'norm'</span>,true);        matG = local3x3kernel(<span class="string">'ker'</span>,<span class="string">'g1'</span>,<spanclass="string">'norm'</span>,true);<span class="keyword">end</span><span class="comment">% mote: matI and matG are indexed by [size(x,y),zone,level]</span></pre>      <p>main computation through iterative filtering</p>      <pre class="codeinput"><span class="comment">% possibly resize the input matrix</span><span class="keyword">if</span> p.interp    A = upscalexy(I,[2 2],<span class="string">'cubic'</span>);<span class="keyword">else</span>    A = I;<span class="keyword">end</span><span class="comment">% initialize the output matrix</span><span class="comment">% SH = A;</span><span class="comment">% dimension of the frame</span>[X,Y] = size(A(:,:,1));XY = X * Y; <span class="comment">% numel(A(:,:,1));</span><span class="comment">% index of all pixels in the input image</span><span class="comment">% pixindex = reshape(1:XY,[X Y]);</span><span class="comment">% indexes of the border pixels</span><span class="comment">% pixbord = [1:X, (1:Y-2)*X+1, (2:Y-1)*X, (1+X*(Y-1)):XY]';</span><span class="comment">% create the 'pilot' for gradient orientation</span><span class="keyword">if</span> Z==3 &amp;&amp; strcmp(p.pilot,<span class="string">'bright'</span>)    p.pilot = rgb2gray(A); <span class="comment">% pilot will be the brightness image</span><span class="keyword">elseif</span> Z&gt;=2    p.pilot = sum(A,3) / Z; <span class="comment">% pilot will be the average image</span><span class="keyword">end</span><span class="comment">% construct the variation sparse matrices measuring the amount of change</span><span class="comment">% occurring in the image after each of the iterative filtering</span>deltaI = zeros(XY,Z);dirdeltaI = deltaI;<span class="comment">% index of transition pixels for each step of the iterations</span>Itrans = cell(p.niter);<span class="comment">% set the number of estimated gradient</span>nZ = Z + (Z&gt;1); <span class="comment">% ie: ng=1 if Z==1, ng=Z+1 otherwise</span>G = zeros(X,Y,nZ);pl = A(110, :);pch = [];TH = zeros(X,Y);</pre>      <p>proceed iteratively</p>      <pre class="codeinput"><span class="keyword">for</span> iter=1:p.niter</pre>      <pre class="codeinput">   <span class="comment">%  A = smoothfilt(A, p.sigma, 'sm', p.sm, 'hsize',p.hsize);</span>   <span class="comment">% estimation of the structure tensor (see function GSTSMOOTH)</span>    <span class="comment">% compute the gradient (gy: vertical, gx: horizontal) for each channel</span>    <span class="comment">% hsize = max(1+round(p.sigma)*2, 7);</span>    <span class="comment">% [gy,gx,G(:,:,1:Z)] = grdsmooth(I,p.sigma,'hsize',hsize,...</span>    <span class="comment">%    'der','peyre', 'axis', 'xy');</span>    <span class="comment">%  gy = -gy;</span>    <span class="comment">%same as first compute: [gx,gy]=grdsmooth(I,sigma,'der',der,'hsize',hsize);</span>    <span class="comment">%and then take the vector orthogonal to the gradient: tmp=gx; gx=gy; gy=-tmp;</span>    <span class="comment">%                           /|\</span>    <span class="comment">%                       gy   |</span>    <span class="comment">%  at that point:            |</span>    <span class="comment">%                            ------&gt;  gx</span>    <span class="comment">% note that the output directional derivatives have size [X Y Z]</span>    <span class="comment">% estimation of the gradient structure tensor</span>    <span class="comment">% [gx2,gy2,gxy,G(:,:,nZ),Theta] = grd2gst(gx, gy, p.rho, ...</span>    <span class="comment">%     'int', 'peyre', 'axis', 'hv', 'eign','zenzo');</span>    [T,gx,gy] = gstsmooth(A,p.rho,p.sigma,<span class="string">'der'</span>,p.der, <spanclass="string">'int'</span>, p.int, <spanclass="keyword">...</span>        <span class="string">'hsize'</span>,p.hsize,<span class="string">'samp'</span>, p.samp);    <span class="comment">% norm and orientation are extracted features</span>    <span class="keyword">if</span> p.rho&gt;eps        theta = mod(atan2(mean(gy,3),mean(gx,3)),pi);        gx = smoothfilt( gx, p.rho, <span class="string">'sm'</span>, p.int, <spanclass="string">'theta'</span>, theta, <spanclass="keyword">...</span><spanclass="comment"> % or Theta?</span>            <span class="string">'hsize'</span>,p.hsize,<span class="string">'samp'</span>, p.samp );        gy = smoothfilt( gy, p.rho, <span class="string">'sm'</span>, p.int, <spanclass="string">'theta'</span>, theta, <spanclass="keyword">...</span>            <span class="string">'hsize'</span>,p.hsize,<span class="string">'samp'</span>, p.samp );    <span class="keyword">end</span>    <span class="keyword">if</span> Z&gt;1        <span class="comment">% norm channel by channel</span>        G(:,:,1:Z) = sqrt(gx.^2 + gy.^2);        <span class="comment">% update the value of the gradient to set it to the gradient of</span>        <span class="comment">% the average image</span>        gx = sum(gx,3) / Z;        gy = sum(gy,3) / Z;    <span class="keyword">end</span></pre>      <p>estimation of the orientation of the ramp sharpening reroriented tensor        taking into account the average gradient</p>      <pre class="codeinput">    Theta = gstfeature(T(:,:,1,1), T(:,:,2,2), T(:,:,1,2), <spanclass="string">'orvec'</span>, <spanclass="keyword">...</span>        <span class="string">'ex'</span>, gx, <span class="string">'ey'</span>, gy);    size(Theta)    figure, imagesc(rescale(Theta))   <span class="comment">%Theta=theta;</span>    T = gstdecomp(T, Theta);    <span class="comment">%   figure, imagesc(Theta),colormap jet, axis image, title('theta')</span>    <span class="comment">% tensorial norm</span>    [G(:,:,nZ), C] = gstfeature(T(:,:,1,1), T(:,:,2,2), T(:,:,1,2), <span class="keyword">...</span>        [<span class="string">'eigenorm'</span> <span class="string">'coherence'</span>], <spanclass="string">'eign'</span>, p.eign);    max(G(:))     <span class="comment">% find the orientation and the interpolation parameters over the image</span>    [Zones,Omega] = localorientzone(Theta,p.nz);    <span class="comment">% compute the compensation factor</span>    S = 1 - (1-sqrt(2.)) * Omega;</pre>      <p>local estimation of intensity indices</p>      <pre class="codeinput">    <span class="comment">% prior computation of the intensity indices over the different</span>    <span class="comment">% spectral components</span>    mI = localorientfeature(A, <span class="string">'filt'</span>, <span class="string">'mean'</span>, <spanclass="keyword">...</span><spanclass="comment"> % 'filt','med'</span>        <span class="string">'Kernel'</span>,matI,<span class="string">'Zones'</span>,Zones,<spanclass="string">'Omega'</span>,Omega);    <span class="comment">% mI = round(mI);</span></pre>      <p>local estimation and characterization of ramp/transition pixels</p>      <pre class="codeinput">    Iramp = maptransition(mI,p.trans,<span class="string">'const'</span>,<spanclass="string">'strong'</span>);   figure, imagesc(reshape(Iramp,[X,Y]));    <span class="comment">% get rid of flat area:</span>    <span class="keyword">if</span> p.gthres &gt; 0        m = max(max(G(:,:,nZ)));    <span class="keyword">else</span>        m=0;    <span class="keyword">end</span>    Iramp = Iramp &amp; reshape(G(:,:,nZ),[XY 1])&gt;m*p.gthres;    <span class="comment">% if no consideration for this condition:  Iramp = ones(XY,1);</span>    <span class="comment">%figure, imagesc(reshape(Iramp(:,:,1),X,Y)), axis image, colormap gray;</span>    Iramp = find(Iramp);    <span class="comment">% proceed only if such pixels have been found</span>    <span class="keyword">if</span> isempty(Iramp) <span class="comment">% this is very improbable</span>        <span class="keyword">break</span>;    <span class="keyword">end</span></pre>      <p>local estimation of the gradient indices</p>      <pre class="codeinput">    <span class="comment">%mG = zeros(lenght(Iramp), nelevels, Z);</span>    mG  = localorientfeature(G,<span class="string">'filt'</span>,<span class="string">'mean'</span>, <spanclass="keyword">...</span>        <span class="string">'Kernel'</span>,matG,<span class="string">'Zones'</span>,Zones,<spanclass="string">'Omega'</span>,Omega);    <span class="comment">% reduce the problem to potential ramp pixels: restrict the set of</span>    <span class="comment">% pixels which are examined to pixels on the ramp</span>    mI = mI(Iramp,:,:);    mG = mG(Iramp,:,:);    <span class="keyword">if</span> strcmp(p.method,<span class="string">'control'</span>)        D = deltaI(Iramp,:);        ID = dirdeltaI(Iramp,:);    <span class="keyword">else</span>        D = zeros(length(Iramp),Z);        ID = [];    <span class="keyword">end</span>    S = S(Iramp);    <span class="comment">% extraction of transition pixels (located on a ramp) with the</span>    <span class="comment">% criterion GM&gt;GH and GM&gt;GL</span>    iR = mG(:,M,nZ)&gt;mG(:,H,nZ) &amp; mG(:,M,nZ)&gt;mG(:,L,nZ);    Itrans{iter} = Iramp(iR); <span class="comment">% a subset of the ramp pixels</span>    a = zeros(X,Y);  a(Itrans{iter}) = 1;    figure, imagesc(a),colormap <span class="string">gray</span>, title(<span class="string">'ramp'</span>)</pre>      <p>image sharpening</p>      <pre class="codeinput">    <span class="comment">% reshape the input and initialize the output</span>    A = reshape(A,[XY Z]);    SH = A;    <span class="comment">% extract ramp pixels of type 1:    GL &lt;(or&lt;=) GM &lt;= GH</span>    iR = findcase(p.method, mG(:,H,nZ), mG(:,L,nZ), mG(:,M,nZ));    <span class="comment">% note : iR are the  coordinates of the pixels considered in the domain</span>    <span class="comment">% of the reduced image and Iramp(iR) are the correponding coordinates in</span>    <span class="comment">% the domain of the original image</span>    <span class="comment">% possibly update those pixels</span>    <span class="keyword">if</span> ~isempty(iR)        <span class="keyword">for</span> c=1:Z            F = factorvalue(p.fac, mG(iR,H,c), mG(iR,L,c), mG(iR,M,c));           <span class="keyword">if</span> strcmp(p.method,<span class="string">'shift'</span>)                R = adjustleu(F, mI(iR,L,c), mI(iR,M,c), S(iR), p.fE);                SH(Iramp(iR),c) = updateleu(A(Iramp(iR),c), R, -1);            <span class="keyword">elseif</span> strcmp(p.method,<span class="string">'control'</span>)                R = adjustcontrol(F, mI(iR,L,c), mI(iR,M,c), D(iR,c), ID(iR,c), <spanclass="keyword">...</span>                    S(iR), p.fE);                 SH(Iramp(iR),c) = updatecontrol(A(Iramp(iR),c),R,mI(iR,L,c));            <span class="keyword">end</span>        <span class="keyword">end</span>    <span class="keyword">end</span>    <span class="comment">% extract ramp pixels of type 2:    GH &lt;(or&lt;=) GM &lt;= GL</span>    iR = findcase(p.method, mG(:,L,nZ), mG(:,H,nZ), mG(:,M,nZ));    <span class="keyword">if</span> ~isempty(iR)        <span class="keyword">for</span> c=1:Z            F = factorvalue(p.fac, mG(iR,L,c), mG(iR,H,c), mG(iR,M,c));            <span class="keyword">if</span> strcmp(p.method,<span class="string">'shift'</span>)                R = adjustleu(F, mI(iR,H,c), mI(iR,M,c), S(iR), p.fE);                SH(Iramp(iR),c) = updateleu(A(Iramp(iR),c), R, 1);            <span class="keyword">elseif</span> strcmp(p.method,<span class="string">'control'</span>)                R = adjustcontrol(F, mI(iR,H,c), mI(iR,M,c), D(iR,c), ID(iR,c), <spanclass="keyword">...</span>                    S(iR), p.fE);                SH(Iramp(iR),c) = updatecontrol(A(Iramp(iR),c),R,mI(iR,H,c));            <span class="keyword">end</span>        <span class="keyword">end</span>    <span class="keyword">end</span>    <span class="comment">% SH = round(SH);</span>    <span class="keyword">if</span> p.niter&gt;1       <span class="comment">% updates:</span>        <span class="comment">%  - matrices delta of intensity variation changes</span>        delta = A(Iramp,:) - SH(Iramp,:);        <span class="comment">%  - matrices dirdelta of change in intensity variation direction</span>        <span class="keyword">for</span> c=1:Z            dirdeltaI(Iramp(delta(:,c) .* deltaI(Iramp,c) &lt; 0),c) = 1; <spanclass="comment">% sign change</span>        <span class="keyword">end</span>        deltaI(Iramp,:) = delta;        pchange = sum(abs(delta),2)&gt;eps; <span class="comment">% matrix of modified pixels</span>        pchange = sum(pchange(:)) / XY;  <span class="comment">% pct of change</span>        <span class="keyword">if</span> p.verb            disp([<span class="string">'iter: '</span> num2str(iter) <span class="string">' - '</span> <spanclass="keyword">...</span>                <span class="string">'modified pix: '</span> num2str(pchange) <spanclass="string">' %'</span>]);        <span class="keyword">end</span>        <span class="comment">% note : the first sum: sum(abs(delta),3) operates over the channnel</span>        <span class="comment">% account for pixels modified in any of their channel</span>    <span class="keyword">end</span></pre>      <p>process for update for next loop in the iteration</p>      <pre class="codeinput">    A = reshape(SH, [X, Y, Z]);     pl = [pl ; A(110, :)];     pch = [pch ; pchange];    <span class="keyword">if</span> pchange &lt;= p.pctch        <span class="keyword">break</span>;    <span class="keyword">end</span><span class="comment">% TH: final ramp after the last iteration</span>iR = findramp(p.method, mG(:,L,nZ), mG(:,H,nZ), mG(:,M,nZ));TH(Iramp(iR)) = TH(Iramp(iR))+1;</pre>      <pre class="codeinput"><span class="keyword">end</span><span class="comment">% final output</span>SH = A;</pre>      <pre class="codeinput"><span class="keyword">end</span><span class="comment">% end of rampsharp</span></pre>      <h2>Subfunctions<a name="25"></a></h2>      <p><tt>FINDCASE</tt>        -------------------------------------------------------------------------</p>      <pre class="codeinput"><span class="keyword">function</span> iR = findcase(method, G1, G2, Gm)iR = G1&gt;=Gm &amp; Gm&gt;G2; <span class="comment">% standard Leu condition</span><span class="keyword">if</span> ~strcmp(method,<span class="string">'leu'</span>)    iR = iR | (G1&gt;=Gm &amp; Gm==G2); <span class="comment">% add flexible condition</span><span class="keyword">end</span><span class="comment">%iR = find(iR);</span><span class="keyword">end</span><span class="comment">% end of findcase</span></pre>      <p><tt>FINDRAMP</tt>        -------------------------------------------------------------------------</p>      <pre class="codeinput"><span class="keyword">function</span> iR = findramp(method, G1, G2, Gm)iR = Gm&gt;=G1 &amp; Gm&gt;=G2; <span class="comment">%</span><span class="comment">%iR = find(iR);</span><span class="keyword">end</span><span class="comment">% end of findramp</span></pre>      <p><tt>UPDATECONTROL</tt>        -------------------------------------------------------------------------</p>      <pre class="codeinput"><span class="keyword">function</span> SH = updatecontrol(A, R, I1)SH =  (A &gt; I1) .* max(A - R, I1) + (A &lt;= I1) .* min(A + R, I1);<span class="keyword">end</span><span class="comment">% end of updatecase</span></pre>      <p><tt>UPDATELEU</tt>        -------------------------------------------------------------------------</p>      <pre class="codeinput"><span class="keyword">function</span> SH = updateleu(A, R, s)SH =  A + s * R;<span class="keyword">end</span><span class="comment">% end of updateleu</span></pre>      <p><tt>ADJUSTCONTROL</tt>        -------------------------------------------------------------------------</p>      <pre class="codeinput"><span class="keyword">function</span> R = adjustcontrol(F, I1, I2, D, ID, S, fE)R = 0.5 + fE .* F .* S .* abs(I1-I2);iR0 = D~=0 &amp; ID==1;<span class="comment">% control the current correction amount by the previous correction amount</span><span class="keyword">if</span> ~isempty(iR0)    R(iR0) = max(min(R(iR0), abs(D(iR0))-1), 0);<span class="keyword">end</span><span class="keyword">end</span><span class="comment">% end of adjustcase</span></pre>      <p><tt>ADJUSTLEU</tt>        -------------------------------------------------------------------------</p>      <pre class="codeinput"><span class="keyword">function</span> R = adjustleu(F, I1, I2, S, fE)R = fE .* S .* abs(I1-I2);R = (F &gt;= 0.5) .* R + 2. * (F &lt; 0.5) .* F .* R;<span class="keyword">end</span><span class="comment">% end of adjustleu</span></pre>      <p><tt>FACTORVALUE</tt>        -------------------------------------------------------------------------</p>      <pre class="codeinput"><span class="keyword">function</span> F = factorvalue(alpha, G1, G2, Gm)<span class="comment">% compute the correction factor based on the estimated gradient indices</span><span class="comment">% Gm, Gl (either G1 or G2) and Gh (ibid)</span><span class="comment">% G1 and G2 stand for Gl or Gh depending on the part of the ramp (lower or</span><span class="comment">% higher) the pixel belongs to</span><span class="keyword">switch</span> alpha    <span class="keyword">case</span> {<span class="string">'leu'</span>,<span class="string">'f0'</span>}  <spanclass="comment">% original leu</span>        F = (G1 - Gm) ./ (Gm - G2); <span class="comment">% leu-like</span>    <span class="keyword">case</span> <span class="string">'f1'</span>  <span class="comment">% default choice</span>        F = (G2 + Gm) ./ (1 + 2*Gm);    <span class="keyword">case</span> <span class="string">'f2'</span>        F = (G1 + G2 - Gm) ./ (1 + 3*Gm);    <span class="keyword">case</span> <span class="string">'f3'</span>        F = (G1 + G2) ./ (1 + 2*Gm);    <span class="keyword">case</span> <span class="string">'f4'</span>        F = (G1 + Gm) ./ (1 + 2*Gm);    <span class="keyword">case</span> <span class="string">'f5'</span>        F = (G1 + G2 + Gm) ./ (1 + 3*Gm);<span class="keyword">end</span><span class="keyword">end</span><span class="comment">% end of factorvalue</span></pre></div>    <!--##### SOURCE BEGIN #####%% RAMPSHARP - Iterative ramp sharpening of multispectral images.%%% Description% Perform (multispectral) image enhancement through iterative local ramp% sharpening as described in [GS10].%%% Syntax%     [SH,TR] = RAMPSHARP(I);%     [SH,TR] = RAMPSHARP(I, niter, method, sigma, rho);%     [SH,TR] = RAMPSHARP(I, niter, method, sigma, rho,%                            'Property', propertyvalue, ...);% %% Inputs% *|I|* : input image with dimension |C|, possibly multispectral (|C>1| bands).%% *|niter: optional positive parameter setting the number of iterations of %     the sharpening algorithm; when |niter=0|, the sharpening is iterated %     till convergence; default: |niter=1|.%% *|method|* :%% *|sigma|* : pre-smoothing width (half-window size in pixels); this parameter  %     sets the differentiation scale in the case the image is smoothed prior  %     to the differentiation through Gaussian filtering; sigma typically %     controls the size of the objects whose orientation has to be estimated;%     default: |sigma=0.5|, i.e. Gaussian regularisation is used for estimating  %     the derivatives.%% *|rho|* : post-smoothing width (half-window size in pixels); this parameter%     sets the integration scale for spatial averaging, that controls the %     size of the neighbourhood in which an orientation is dominant; it is %     used for averaging the partial directional derivatives of the tensor %     with a Gaussian kernel; if |rho<0.05|, then no smoothing is performed; %     default: |rho=0.5|.%% *|der|* : flag defining the original |(3,3)| gradient mask used for estimating%     the directional derivatives of the input image; it is either (see%     |GRADMASK|):%% * |'sob'| for Sobel mask,% * |'dif'| for central differences,% * |'for'| when forward differences are computed,% * |'bac'| when backward differences are computed,% * |'pre'| for Prewitt mask,% * |'iso'| for Frei-Chen's isotropic mask,% * |'opt'| for Ando's optimal mask,% * |'cir'| for Davies' circular mask;%% default: |der='dif'|.%%% Property [propertyname  propertyvalues]% *|'pilot'|* :%% *|'alpha'|* : flag setting the correction factor alpha when updating a pixel %     value; the correction alpha is based on the estimated gradient indices%     $G_M$, $G_L$ and $G_H$ (see [Leu00]) for further definition of the gradient%     indices); therefore, alpha is expected to be either:%% * |'f0'|  then $F = (G_1 - G_M) / (G_M - G_2)$ (following [Leu00]),% * |'f1'|  then $F = (G_2 + G_M) / (1 + 2*G_M)$, (default)% * |'f2'|  then $F = (G_1 + G_2 - G_M) / (1 + 3*G_M)$,% * |'f3'|  then $F = (G_1 + G_2) / (1 + 2*G_M)$,% * |'f4'|  then $F = (G_1 + G_M) / (1 + 2*G_M)$,% * |'f5'|  then $F = (G_1 + G_2 + G_M) / (1 + 3*G_M)$,%% where $G_1$ and $G_2$ stand for either $G_L$ or $G_H$, depending on which%     part of of the ramp (lower or higher) the pixel belongs to.%% *|'fE'|* : optional parameter setting the factor effect (see [Leu00]) as a%     multiplicative effect on the correction factor, so that:%     $F = F \cdot fE$.%% *|'win'|* : set the parameters of the local kernel windows used for estimating%     the local gradient and intensity indices%% * |'w0'| : the kernel weights are identical to those of Leu's approach,% * |'w1'| : new kernel weights.%% *|'adjust'|* : 'shift' or 'control'%% *|'crit'|* : optional flag for deciding how vectorial components are taken%     into account in the ramp decision, depending on the estimated intensity%     indices $I_M$, $I_L$ and $I_H$ (see [Leu00]) for further definition of%     the intensity indices); it provides the adju for deciding when a (vector) %     pixel has to be considered as a ramp pixel - useful only when |C>1|; %     it is either:%% * 'all': then for each pixel, we check if it exists one band where its $I_H$%          is greater than its $I_M$ and its $I_M$ is greater than its $I_L$, %          and we verify that there is no band where its $I_H$ is lower than %          its $I_M$ or its $I_M$ is lower than its $I_L$, ie.:% $$%                  \exists i, I_H(i) > I_M(i) > I_L(i)  \quad  \&  \quad %                  \forall j \neq i, I_H(j) \geq I_M(j) \geq I_L(j)% $$%% note that in the case |nc=1|, the previous condition is equivalent%          to that proposed in [Leu00],%% * 'one': it is enough that the relationship regarding neighbour pixels%          intensity is verified in one channel to perform the local%          adjustment, ie.:% $$%                  \exists i, I_H(i) > I_M(i) > I_L(i) % $$%% (more flexible than the previous option in the multispectral %          case, equivalent in the monospectral one)%% *|'derive'|* :%%           * |'grd'|%           * |'tens'|%% *|'sigma'|* :%% *|'rho'|* : %% *|'hsize'|* : optional filter size; default: estimated depending on |sigma|, %     typically |hsize=6*sigma+1|.%% *|'eigen'|* :%% *|samp|* : to perform |(*samp)| interpolation of the gradient to avoid aliasing.%%% Outputs% *|SH|* :%% *|TR|* : transition map, where a positive graylevel intensity indicates the%     last iteration the pixel was detected as a transition%%% References% [Leu00] J.G. Leu: "Edge sharpening through ramd width reduction", Image%      and Vision Computing, 18: 501-514, 2000.%      <http://www.sciencedirect.com/science/article/pii/S0262885699000414>%% [GS10]  J. Grazzini and P. Soille: "Iterative ramp sharpening for %      structure/signature-preserving simplification of images", Proc.%      ICPR, 2010.%      <http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=5597348>%%% Credit% <mailto:grazzja@lanl.gov J.Grazzini> (ISR-2/LANL)%% Function implementationfunction [SH,TH,pl, pch] = rampsharp(I,varargin)error(nargchk(1, 33, nargin, 'struct'));error(nargoutchk(1, 4, nargout, 'struct'));%% % parsing parameters if ~isnumeric(I)    error('rampsharp:errorinput','a matrix is required in input');end% Optional parametersp = createParser('RAMPSHARP');   % create an instance of the inputParser class.% mandatory (required) variables%p.addRequired('I', @isnumeric);% principal optional parametersp.addOptional('niter', 1, @(x)isscalar(x) && x>=0);p.addOptional('method', 'control', @(x)ischar(x) && ...    any(strcmpi(x,{'shift', 'leu', 'control'})));p.addOptional('sigma', 0.5, @(x)isscalar(x) && isfloat(x) && x>=0);p.addOptional('rho', 1, @(x)isscalar(x) && isfloat(x) && x>=0);% other optional parametersp.addOptional('der', 'fast', @(x)islogical(x) || (ischar(x) && ...    any(strcmpi(x,{'matlab','vista','fast','conv','fleck', ...    'tap5','tap7','sob','opt','ana'}))));p.addOptional('int', 'fast', @(x)islogical(x) || (ischar(x) && ...    any(strcmpi(x,{'matlab','conv','fast','ani'}))));p.addParamValue('hsize',5, @(x)isscalar(x));p.addParamValue('samp', 1, @(x)isscalar(x) && round(x)==x && x>=1 && x<=5);p.addParamValue('pilot', 'ave', @(x)ischar(x) && any(strcmpi(x,{'ave', 'int'})));p.addParamValue('fac', 'f5', @(x)ischar(x) && ...    any(strcmpi(x,{'f0', 'f1', 'f2', 'f3', 'f4', 'f5', 'leu'})));p.addParamValue('kern', 'leu', @(x)ischar(x) && ...    any(strcmpi(x,{'new', 'leu'})));p.addParamValue('fE', 1, @(x)isscalar(x) && isfloat(x));p.addParamValue('nz', 8, @(x)x==8 || x==16);p.addParamValue('interp', 0, @(x)isscalar(x) && x>=1);p.addParamValue('crit', 'all', @(x)ischar(x) && any(strcmpi(x,{'all', 'one'})));p.addParamValue('eign', 'zen', @(x)ischar(x) && ...    any(strcmpi(x,{'abs','zen', 'sap','sum', 'dif', 'ndi'})));p.addParamValue('gthres', 0, @(x)isscalar(x) && isfloat(x) && x>=0 && x<=1);p.addParamValue('pctch', 0.01, @(x)isscalar(x) && isfloat(x) && x>=0 && x<=1);p.addParamValue('trans', 'indice', @(x)ischar(x) && ...    any(strcmpi(x,{'indice', 'morph'})));% parse and validate all input argumentsp.parse(varargin{:}); p = getvarParser(p);                                                            % default choice parameters when the option 'method' has been set to 'leu',% ie'. the original implementation of  [Leu00] is to be ran.if strcmp(p.method,'leu')                                                   p.method = 'shift'; % just shift the value, without controlling its extent     p.kern = 'leu';    % original weights for computing the indices    p.der    = 'sob';   % sobel gradient for estimating the derivatives    p.nz = '8';     % 8 zones to be used in interpolation of indices    p.fac = 'f0';    % factor used in shifting    p.crit   = 'one';   % check only if assertion is true on single band    p.interp = 0;       % no prior interpolation of input image    p.sigma  = 0;       % no smoothing    p.rho    = 0;       % no integration    p.fE     = 1;       % no correction factorend% switch p.der%     case 'pey'%         p.hsize = max(1+round(p.sigma)*2, 7);%     case {'rad','mat','kro'}%         p.hsize = ceil(4 * p.sigma); % approximation%     otherwise%         p.hsize = ceil(6 * p.sigma);% end%%% internal variables% check the dimension of the input image:nbdims = nb_dims(I); % instead of ndimsif nbdims<2 || nbdims>3    error('matrix or array of matrices are expected as inputs');end% number of spectral componentsZ = size(I,3);% possibly overwriteif Z~=3 && strcmp(p.pilot,'int')                                           warning('ramspharp:inputparameter',...        'pilot image as intensity implemented only for RGB images');    p.pilot = 'ave';end%%% internal parameters (do not modify)% Initializing variablespchange = p.pctch +1;% We adopt the following index representation for the directed components% used for the intensity and gradient indices used (matlab indexing)%          REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-         REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-%          | NW | N | NE |         | 1 | 4 | 7 |%          REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-         REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-%          | W  |   | E  |    =>   | 2 | 5 | 8 |%          REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-         REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-%          | SW | S | SE |         | 3 | 6 | 9 |%          REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-         REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-direction_indices = struct('east', 8, 'northeast', 7, 'north', 4, ...    'northwest', 1, 'west', 2, 'southwest', 3, ...    'south', 6, 'southeast', 9, 'central', 5);                         %#ok%directions = fieldnames(direction_indices);%ndirections = length(directions);% note: not used in the followinglevel_indices = struct( 'L', 1, 'M', 2, 'H', 3);L = level_indices.('L'); M = level_indices.('M'); H = level_indices.('H');% Remember: mapping from indexes to subscripts for a 3x3 matrix in matlab%          REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-         REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-%          | 1,1 | 1,2 | 1,3 |         | 1 | 4 | 7 |%          REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-         REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-%          | 2,1 | 2,2 | 2,3 |    =>   | 2 | 5 | 8 |%          REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-         REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-%          | 3,1 | 3,2 | 3,3 |         | 3 | 6 | 9 |%          REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-         REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-%                (ii,jj)          =>    ii+3*(jj-1)%% construct beforehand the predefined local 3x3 kernels defined for each % different zone and level, and used for the estimation of the gradient and% intensity indices (used once at the beginning of the code).% Intensity and gradient masks are built for both zones 1 and 2, and all% the other zones derived by rotationswitch p.kern    case 'leu'        matI = local3x3kernel('ker','i0','norm',true);        matG = local3x3kernel('ker','g0','norm',true);    case 'new'        matI = local3x3kernel('ker','i1','norm',true);        matG = local3x3kernel('ker','g1','norm',true);end% mote: matI and matG are indexed by [size(x,y),zone,level]%% % main computation through iterative filtering% possibly resize the input matrixif p.interp    A = upscalexy(I,[2 2],'cubic');else    A = I;end% initialize the output matrix% SH = A;% dimension of the frame[X,Y] = size(A(:,:,1)); XY = X * Y; % numel(A(:,:,1));% index of all pixels in the input image% pixindex = reshape(1:XY,[X Y]);% indexes of the border pixels% pixbord = [1:X, (1:Y-2)*X+1, (2:Y-1)*X, (1+X*(Y-1)):XY]'; % create the 'pilot' for gradient orientationif Z==3 && strcmp(p.pilot,'bright')    p.pilot = rgb2gray(A); % pilot will be the brightness imageelseif Z>=2    p.pilot = sum(A,3) / Z; % pilot will be the average imageend% construct the variation sparse matrices measuring the amount of change% occurring in the image after each of the iterative filteringdeltaI = zeros(XY,Z);   dirdeltaI = deltaI; % index of transition pixels for each step of the iterationsItrans = cell(p.niter);% set the number of estimated gradientnZ = Z + (Z>1); % ie: ng=1 if Z==1, ng=Z+1 otherwiseG = zeros(X,Y,nZ);pl = A(110, :);pch = [];TH = zeros(X,Y);%%% proceed iterativelyfor iter=1:p.niter       %  A = smoothfilt(A, p.sigma, 'sm', p.sm, 'hsize',p.hsize);   % estimation of the structure tensor (see function GSTSMOOTH)    % compute the gradient (gy: vertical, gx: horizontal) for each channel    % hsize = max(1+round(p.sigma)*2, 7);    % [gy,gx,G(:,:,1:Z)] = grdsmooth(I,p.sigma,'hsize',hsize,...    %    'der','peyre', 'axis', 'xy');    %  gy = -gy;    %same as first compute: [gx,gy]=grdsmooth(I,sigma,'der',der,'hsize',hsize);    %and then take the vector orthogonal to the gradient: tmp=gx; gx=gy; gy=-tmp;    %                           /|\    %                       gy   |    %  at that point:            |    %                            REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH>  gx    % note that the output directional derivatives have size [X Y Z]    % estimation of the gradient structure tensor    % [gx2,gy2,gxy,G(:,:,nZ),Theta] = grd2gst(gx, gy, p.rho, ...    %     'int', 'peyre', 'axis', 'hv', 'eign','zenzo');    [T,gx,gy] = gstsmooth(A,p.rho,p.sigma,'der',p.der, 'int', p.int, ...        'hsize',p.hsize,'samp', p.samp);        % norm and orientation are extracted features    if p.rho>eps        theta = mod(atan2(mean(gy,3),mean(gx,3)),pi);        gx = smoothfilt( gx, p.rho, 'sm', p.int, 'theta', theta, ... % or Theta?            'hsize',p.hsize,'samp', p.samp );        gy = smoothfilt( gy, p.rho, 'sm', p.int, 'theta', theta, ...            'hsize',p.hsize,'samp', p.samp );    end    if Z>1                % norm channel by channel        G(:,:,1:Z) = sqrt(gx.^2 + gy.^2);        % update the value of the gradient to set it to the gradient of        % the average image        gx = sum(gx,3) / Z;        gy = sum(gy,3) / Z;    end       %%    % estimation of the orientation of the ramp sharpening    % reroriented tensor taking into account the average gradient    Theta = gstfeature(T(:,:,1,1), T(:,:,2,2), T(:,:,1,2), 'orvec', ...        'ex', gx, 'ey', gy);    size(Theta)    figure, imagesc(rescale(Theta))   %Theta=theta;    T = gstdecomp(T, Theta);    %   figure, imagesc(Theta),colormap jet, axis image, title('theta')    % tensorial norm    [G(:,:,nZ), C] = gstfeature(T(:,:,1,1), T(:,:,2,2), T(:,:,1,2), ...        ['eigenorm' 'coherence'], 'eign', p.eign);        max(G(:))     % find the orientation and the interpolation parameters over the image    [Zones,Omega] = localorientzone(Theta,p.nz);    % compute the compensation factor    S = 1 - (1-sqrt(2.)) * Omega;      %%    % local estimation of intensity indices        % prior computation of the intensity indices over the different    % spectral components    mI = localorientfeature(A, 'filt', 'mean', ... % 'filt','med'        'Kernel',matI,'Zones',Zones,'Omega',Omega);       % mI = round(mI);    %%    % local estimation and characterization of ramp/transition pixels        Iramp = maptransition(mI,p.trans,'const','strong');   figure, imagesc(reshape(Iramp,[X,Y]));       % get rid of flat area:    if p.gthres > 0        m = max(max(G(:,:,nZ)));    else         m=0;    end    Iramp = Iramp & reshape(G(:,:,nZ),[XY 1])>m*p.gthres;                % if no consideration for this condition:  Iramp = ones(XY,1);    %figure, imagesc(reshape(Iramp(:,:,1),X,Y)), axis image, colormap gray;    Iramp = find(Iramp);        % proceed only if such pixels have been found    if isempty(Iramp) % this is very improbable        break;    end            %%    % local estimation of the gradient indices    %mG = zeros(lenght(Iramp), nelevels, Z);    mG  = localorientfeature(G,'filt','mean', ...        'Kernel',matG,'Zones',Zones,'Omega',Omega);        % reduce the problem to potential ramp pixels: restrict the set of    % pixels which are examined to pixels on the ramp    mI = mI(Iramp,:,:);    mG = mG(Iramp,:,:);        if strcmp(p.method,'control')        D = deltaI(Iramp,:);        ID = dirdeltaI(Iramp,:);    else        D = zeros(length(Iramp),Z);        ID = [];    end    S = S(Iramp);        % extraction of transition pixels (located on a ramp) with the    % criterion GM>GH and GM>GL    iR = mG(:,M,nZ)>mG(:,H,nZ) & mG(:,M,nZ)>mG(:,L,nZ);    Itrans{iter} = Iramp(iR); % a subset of the ramp pixels    a = zeros(X,Y);  a(Itrans{iter}) = 1;    figure, imagesc(a),colormap gray, title('ramp')            %%    % image sharpening        % reshape the input and initialize the output    A = reshape(A,[XY Z]);    SH = A;        % extract ramp pixels of type 1:    GL <(or<=) GM <= GH    iR = findcase(p.method, mG(:,H,nZ), mG(:,L,nZ), mG(:,M,nZ));    % note : iR are the  coordinates of the pixels considered in the domain    % of the reduced image and Iramp(iR) are the correponding coordinates in    % the domain of the original image    % possibly update those pixels    if ~isempty(iR)        for c=1:Z            F = factorvalue(p.fac, mG(iR,H,c), mG(iR,L,c), mG(iR,M,c));           if strcmp(p.method,'shift')                R = adjustleu(F, mI(iR,L,c), mI(iR,M,c), S(iR), p.fE);                SH(Iramp(iR),c) = updateleu(A(Iramp(iR),c), R, -1);            elseif strcmp(p.method,'control')                R = adjustcontrol(F, mI(iR,L,c), mI(iR,M,c), D(iR,c), ID(iR,c), ...                    S(iR), p.fE);                 SH(Iramp(iR),c) = updatecontrol(A(Iramp(iR),c),R,mI(iR,L,c));            end        end    end        % extract ramp pixels of type 2:    GH <(or<=) GM <= GL    iR = findcase(p.method, mG(:,L,nZ), mG(:,H,nZ), mG(:,M,nZ));    if ~isempty(iR)        for c=1:Z            F = factorvalue(p.fac, mG(iR,L,c), mG(iR,H,c), mG(iR,M,c));            if strcmp(p.method,'shift')                R = adjustleu(F, mI(iR,H,c), mI(iR,M,c), S(iR), p.fE);                SH(Iramp(iR),c) = updateleu(A(Iramp(iR),c), R, 1);            elseif strcmp(p.method,'control')                R = adjustcontrol(F, mI(iR,H,c), mI(iR,M,c), D(iR,c), ID(iR,c), ...                    S(iR), p.fE);                                 SH(Iramp(iR),c) = updatecontrol(A(Iramp(iR),c),R,mI(iR,H,c));            end        end    end        % SH = round(SH);        if p.niter>1       % updates:        %  - matrices delta of intensity variation changes        delta = A(Iramp,:) - SH(Iramp,:);                %  - matrices dirdelta of change in intensity variation direction        for c=1:Z            dirdeltaI(Iramp(delta(:,c) .* deltaI(Iramp,c) < 0),c) = 1; % sign change        end        deltaI(Iramp,:) = delta;        pchange = sum(abs(delta),2)>eps; % matrix of modified pixels        pchange = sum(pchange(:)) / XY;  % pct of change        if p.verb            disp(['iter: ' num2str(iter) ' - ' ...                'modified pix: ' num2str(pchange) ' %']);        end            % note : the first sum: sum(abs(delta),3) operates over the channnel        % account for pixels modified in any of their channel            end            %%     % process for update for next loop in the iteration    A = reshape(SH, [X, Y, Z]);         pl = [pl ; A(110, :)];     pch = [pch ; pchange];        if pchange <= p.pctch        break;    end% TH: final ramp after the last iterationiR = findramp(p.method, mG(:,L,nZ), mG(:,H,nZ), mG(:,M,nZ));TH(Iramp(iR)) = TH(Iramp(iR))+1;    end% final outputSH = A;end% end of rampsharp%% Subfunctions %%% |FINDCASE|% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-function iR = findcase(method, G1, G2, Gm)iR = G1>=Gm & Gm>G2; % standard Leu conditionif ~strcmp(method,'leu')    iR = iR | (G1>=Gm & Gm==G2); % add flexible conditionend%iR = find(iR);end% end of findcase %%% |FINDRAMP|% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-function iR = findramp(method, G1, G2, Gm)iR = Gm>=G1 & Gm>=G2; % %iR = find(iR);end% end of findramp%%% |UPDATECONTROL|% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-function SH = updatecontrol(A, R, I1)SH =  (A > I1) .* max(A - R, I1) + (A <= I1) .* min(A + R, I1);end% end of updatecase%%% |UPDATELEU|% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-function SH = updateleu(A, R, s)SH =  A + s * R;end% end of updateleu%%% |ADJUSTCONTROL|% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-function R = adjustcontrol(F, I1, I2, D, ID, S, fE)R = 0.5 + fE .* F .* S .* abs(I1-I2);iR0 = D~=0 & ID==1;% control the current correction amount by the previous correction amountif ~isempty(iR0)    R(iR0) = max(min(R(iR0), abs(D(iR0))-1), 0);endend% end of adjustcase%%% |ADJUSTLEU|% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-function R = adjustleu(F, I1, I2, S, fE)R = fE .* S .* abs(I1-I2);R = (F >= 0.5) .* R + 2. * (F < 0.5) .* F .* R;end% end of adjustleu%%% |FACTORVALUE|% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-function F = factorvalue(alpha, G1, G2, Gm)% compute the correction factor based on the estimated gradient indices% Gm, Gl (either G1 or G2) and Gh (ibid)% G1 and G2 stand for Gl or Gh depending on the part of the ramp (lower or% higher) the pixel belongs toswitch alpha    case {'leu','f0'}  % original leu        F = (G1 - Gm) ./ (Gm - G2); % leu-like    case 'f1'  % default choice        F = (G2 + Gm) ./ (1 + 2*Gm);    case 'f2'        F = (G1 + G2 - Gm) ./ (1 + 3*Gm);    case 'f3'        F = (G1 + G2) ./ (1 + 2*Gm);    case 'f4'        F = (G1 + Gm) ./ (1 + 2*Gm);    case 'f5'           F = (G1 + G2 + Gm) ./ (1 + 3*Gm);endend% end of factorvalue##### SOURCE END #####-->  </body></html>