<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html>  <head>    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">    <!--This HTML was auto-generated from MATLAB code.To make changes, update the MATLAB code and republish this document.      -->    <title>IMLABEL - Labelling of connected components in 2-D arrays</title>    <meta name="generator" content="MATLAB 7.14">    <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">    <meta name="DC.date" content="2012-05-31">    <meta name="DC.source" content="imlabel.m">    <style type="text/css">html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}html { min-height:100%; margin-bottom:1px; }html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }html body td { vertical-align:top; text-align:left; }h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }a { color:#005fce; text-decoration:none; }a:hover { color:#005fce; text-decoration:underline; }a:visited { color:#004aa0; text-decoration:none; }p { padding:0px; margin:0px 0px 20px; }img { padding:0px; margin:0px 0px 20px; border:none; }p img, pre img, tt img, li img { margin-bottom:0px; } ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }ul li { padding:0px; margin:0px 0px 7px 0px; }ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }ul li ol li { list-style:decimal; }ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }ol li ol li { list-style-type:lower-alpha; }ol li ul { padding-top:7px; }ol li ul li { list-style:square; }.content { font-size:1.2em; line-height:140%; padding: 20px; }pre, tt, code { font-size:12px; }pre { margin:0px 0px 20px; }pre.error { color:red; }pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }span.keyword { color:#0000FF }span.comment { color:#228B22 }span.string { color:#A020F0 }span.untermstring { color:#B20000 }span.syscmd { color:#B28C00 }.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }.footer p { margin:0px; }  </style>  </head>  <body>    <div class="content">      <h1>IMLABEL - Labelling of connected components in 2-D arrays</h1>      <!--introduction--><!--/introduction-->      <h2>Contents</h2>      <div>        <ul>          <li><a href="#1">Description</a></li>          <li><a href="#2">Syntax</a></li>          <li><a href="#3">Inputs</a></li>          <li><a href="#4">Outputs</a></li>          <li><a href="#5">Examples</a></li>          <li><a href="#6">Acknowledgments</a></li>          <li><a href="#7">Remarks</a></li>          <li><a href="#9">See also</a></li>          <li><a href="#10">Function implementation</a></li>        </ul>      </div>      <h2>Description<a name="1"></a></h2>      <p>Label connected components in 2-D arrays. It is a generalization of <tt>BWLABEL</tt>:        <tt>BWLABEL</tt> works with 2-D binary images only, whereas <tt>IMLABEL</tt>        works with 2-D arrays of any class.</p>      <h2>Syntax<a name="2"></a></h2>      <pre>   L = IMLABEL(I);   [L, num, sz] = IMLABEL(I, n);</pre>      <h2>Inputs<a name="3"></a></h2>      <p><b><tt>I</tt></b> : input (logical or numeric) image.</p>      <p><b><tt>N</tt></b> : (optional) integer variable specifying the graph        connectivity; it can have a value of either 4 (4-connected objects) or 8        (8-connected objects); default: <tt>N=8</tt>.</p>      <h2>Outputs<a name="4"></a></h2>      <p><b><tt>L</tt></b> : matrix of the same size as <tt>I</tt>, containing        labels for the connected components in <tt>I</tt>; the elements of <tt>L</tt>        are integer values greater than or equal to 0; the pixels labeled 0 are        the background, corresponding to the <tt>NaN</tt> components of the        input array; two adjacent components (pixels), of respective indexes <tt>IDX1</tt>        and <tt>IDX2</tt>, are connected if <tt>I(IDX1)</tt> and <tt>I(IDX2)</tt>        are equal.</p>      <p><b><tt>num</tt></b> : (optional) number of connected objects found in <tt>I</tt>.</p>      <p><b><tt>sz</tt></b> : matrix of the same size as <tt>I</tt> that        contains the sizes of the connected objects: for a pixel whose index is        <tt>IDX</tt>, we have: <tt>sz(IDX) = nnz(L==L(IDX))</tt>.</p>      <h2>Examples<a name="5"></a></h2>      <pre>  I = [3 3 3 0 0 0 0 0       3 3 1 0 6.1 6.1 9 0       1 3 1 3 6.1 6.1 0 0       1 3 1 3 0 0 1 0       1 3 3 3 3 3 1 0       1 3 1 0 0 3 1 0       1 3 1 0 0 1 1 0       1 1 1 1 1 0 0 0];  L4 = IMLABEL(I,4);  L8 = IMLABEL(I,8);  subplot(211), imagesc(L4), axis image off  title('pixels of same color belong to the same region (4-connection)')  subplot(212), imagesc(L8), axis image off  title('pixels of same color belong to the same region (8-connection)')  % Comparison between BWLABEL and LABEL:  BW = logical([1 1 1 0 0 0 0 0                1 1 1 0 1 1 0 0                1 1 1 0 1 1 0 0                1 1 1 0 0 0 1 0                1 1 1 0 0 0 1 0                1 1 1 0 0 0 1 0                1 1 1 0 0 1 1 0                1 1 1 0 0 0 0 0]);  L = bwlabel(BW,4);  % The same result can be obtained with LABEL:  BW2 = double(BW);  BW2(~BW) = NaN;  L2 = label(BW2,4);</pre>      <h2>Acknowledgments<a name="6"></a></h2>      <div>        <ul>          <li>This code is due to Damien Garcia -- <a href="http://www.biomecardio.com">http://www.biomecardio.com</a></li>          <li>The Union-Find algorithm is based on the following document: <a href="http://www.cs.duke.edu/courses/cps100e/fall09/notes/UnionFind.pdf">http://www.cs.duke.edu/courses/cps100e/fall09/notes/UnionFind.pdf</a></li>        </ul>      </div>      <h2>Remarks<a name="7"></a></h2>      <div>        <ul>          <li>Use <tt>BWLABEL</tt> if the input is binary since <tt>BWLABEL</tt>            will be much faster.</li>          <li>Note that <tt>NaN</tt> values are ignored and considered as            background; as <tt>IMLABEL</tt> works with arrays of any class, the            0s are NOT considered as the background.</li>        </ul>      </div>      <h2>See also<a name="9"></a></h2>      <p>Ressembles: <a href=".html"></a>, <a href="../..//html/.html"></a>, <a          href="matlab:web%28whichpath%28%27%27%29%29"></a>,        Ressembles: BWLABEL, BWLABELN, LABEL2RGB.</p>      <h2>Function implementation<a name="10"></a></h2>      <pre class="codeinput"><span class="keyword">function</span> [L,num,sz] = imlabel(I,n)</pre>      <p>check input arguments</p>      <pre class="codeinput">error(nargchk(1,2,nargin));<span class="keyword">if</span> nargin==1, n=8; <span class="keyword">end</span>assert(ndims(I)==2,<span class="string">'The input I must be a 2-D array'</span>)</pre>      <p>initialization of the two arrays (ID &amp; SZ) required during the        Union-Find algorithm.</p>      <pre class="codeinput">sizI = size(I);id = reshape(1:prod(sizI),sizI);sz = ones(sizI);<span class="comment">% indexes of the adjacent pixels</span>vec = @(x) x(:);<span class="keyword">if</span> n==4 <span class="comment">% 4-connected neighborhood</span>    idx1 = [vec(id(:,1:end-1)); vec(id(1:end-1,:))];    idx2 = [vec(id(:,2:end)); vec(id(2:end,:))];<span class="keyword">elseif</span> n==8 <span class="comment">% 8-connected neighborhood</span>    idx1 = [vec(id(:,1:end-1)); vec(id(1:end-1,:))];    idx2 = [vec(id(:,2:end)); vec(id(2:end,:))];    idx1 = [idx1; vec(id(1:end-1,1:end-1)); vec(id(2:end,1:end-1))];    idx2 = [idx2; vec(id(2:end,2:end)); vec(id(1:end-1,2:end))];<span class="keyword">else</span>    error(<span class="string">'The second input argument must be either 4 or 8.'</span>)<span class="keyword">end</span></pre>      <p>create the groups and merge them (Union/Find Algorithm)</p>      <pre class="codeinput"><span class="keyword">for</span> k = 1:length(idx1)    root1 = idx1(k);    root2 = idx2(k);    <span class="keyword">while</span> root1~=id(root1)        id(root1) = id(id(root1));        root1 = id(root1);    <span class="keyword">end</span>    <span class="keyword">while</span> root2~=id(root2)        id(root2) = id(id(root2));        root2 = id(root2);    <span class="keyword">end</span>    <span class="keyword">if</span> root1==root2, <span class="keyword">continue</span>, <spanclass="keyword">end</span>    <span class="comment">% (The two pixels belong to the same group)</span>    N1 = sz(root1); <span class="comment">% size of the group belonging to root1</span>    N2 = sz(root2); <span class="comment">% size of the group belonging to root2</span>    <span class="keyword">if</span> I(root1)==I(root2) <span class="comment">% then merge the two groups</span>        <span class="keyword">if</span> N1 &lt; N2            id(root1) = root2;            sz(root2) = N1+N2;        <span class="keyword">else</span>            id(root2) = root1;            sz(root1) = N1+N2;        <span class="keyword">end</span>    <span class="keyword">end</span><span class="keyword">end</span><span class="keyword">while</span> 1    id0 = id;    id = id(id);    <span class="keyword">if</span> isequal(id0,id), <span class="keyword">break</span>, <spanclass="keyword">end</span><span class="keyword">end</span>sz = sz(id);</pre>      <p>label matrix</p>      <pre class="codeinput">isNaNI = isnan(I);id(isNaNI) = NaN;[id,~,n] = unique(id);I = 1:length(id);L = reshape(I(n),sizI);L(isNaNI) = 0;<span class="keyword">if</span> nargin&gt;1, num = nnz(~isnan(id)); <span class="keyword">end</span></pre>      <pre class="codeinput"><span class="keyword">end</span> <span class="comment">% end of imlabel</span></pre></div>    <!--##### SOURCE BEGIN #####%% IMLABEL - Labelling of connected components in 2-D arrays%%% Description% Label connected components in 2-D arrays. It is a generalization of |BWLABEL|:% |BWLABEL| works with 2-D binary images only, whereas |IMLABEL| works with 2-D% arrays of any class. %%% Syntax%     L = IMLABEL(I);%     [L, num, sz] = IMLABEL(I, n);%%% Inputs% *|I|* : input (logical or numeric) image.%% *|N|* : (optional) integer variable specifying the graph connectivity; it%     can have a value of either 4 (4-connected objects) or 8 (8-connected %     objects); default: |N=8|. %    %% Outputs% *|L|* : matrix of the same size as |I|, containing labels for the connected%     components in |I|; the elements of |L| are integer values greater than%     or equal to 0; the pixels labeled 0 are the background, corresponding%     to the |NaN| components of the input array; two adjacent components%     (pixels), of respective indexes |IDX1| and |IDX2|, are connected if%     |I(IDX1)| and |I(IDX2)| are equal.  %% *|num|* : (optional) number of connected objects found in |I|.   %% *|sz|* : matrix of the same size as |I| that contains the sizes of the%     connected objects: for a pixel whose index is |IDX|, we have: %     |sz(IDX) = nnz(L==L(IDX))|.%%% Examples%    I = [3 3 3 0 0 0 0 0%         3 3 1 0 6.1 6.1 9 0%         1 3 1 3 6.1 6.1 0 0%         1 3 1 3 0 0 1 0%         1 3 3 3 3 3 1 0%         1 3 1 0 0 3 1 0%         1 3 1 0 0 1 1 0%         1 1 1 1 1 0 0 0];%    L4 = IMLABEL(I,4);%    L8 = IMLABEL(I,8);%    subplot(211), imagesc(L4), axis image off%    title('pixels of same color belong to the same region (4-connection)')%    subplot(212), imagesc(L8), axis image off    %    title('pixels of same color belong to the same region (8-connection)')%    % Comparison between BWLABEL and LABEL:%    BW = logical([1 1 1 0 0 0 0 0%                  1 1 1 0 1 1 0 0%                  1 1 1 0 1 1 0 0%                  1 1 1 0 0 0 1 0%                  1 1 1 0 0 0 1 0%                  1 1 1 0 0 0 1 0%                  1 1 1 0 0 1 1 0%                  1 1 1 0 0 0 0 0]);%    L = bwlabel(BW,4);%    % The same result can be obtained with LABEL:%    BW2 = double(BW);%    BW2(~BW) = NaN;%    L2 = label(BW2,4);%%% Acknowledgments% * This code is due to Damien Garcia REPLACE_WITH_DASH_DASH <http://www.biomecardio.com>% * The Union-Find algorithm is based on the following document:% <http://www.cs.duke.edu/courses/cps100e/fall09/notes/UnionFind.pdf>%%% Remarks% * Use |BWLABEL| if the input is binary since |BWLABEL| will be much faster.% * Note that |NaN| values are ignored and considered as background; as |IMLABEL|% works with arrays of any class, the 0s are NOT considered as the background. %%% Contact% <mailto:grazzja@lanl.gov J.Grazzini> (ISR-2/LANL)%%% See also% Ressembles:% <.html ||>,% <../..//html/.html ||>,% <matlab:web(whichpath('')) ||>,% Ressembles: BWLABEL, BWLABELN, LABEL2RGB.%% Function implementationfunction [L,num,sz] = imlabel(I,n)%% % check input argumentserror(nargchk(1,2,nargin));if nargin==1, n=8; endassert(ndims(I)==2,'The input I must be a 2-D array')%%% initialization of the two arrays (ID & SZ) required during the% Union-Find algorithm.sizI = size(I);id = reshape(1:prod(sizI),sizI);sz = ones(sizI);% indexes of the adjacent pixelsvec = @(x) x(:);if n==4 % 4-connected neighborhood    idx1 = [vec(id(:,1:end-1)); vec(id(1:end-1,:))];    idx2 = [vec(id(:,2:end)); vec(id(2:end,:))];elseif n==8 % 8-connected neighborhood    idx1 = [vec(id(:,1:end-1)); vec(id(1:end-1,:))];    idx2 = [vec(id(:,2:end)); vec(id(2:end,:))];    idx1 = [idx1; vec(id(1:end-1,1:end-1)); vec(id(2:end,1:end-1))];    idx2 = [idx2; vec(id(2:end,2:end)); vec(id(1:end-1,2:end))];else    error('The second input argument must be either 4 or 8.')end%%% create the groups and merge them (Union/Find Algorithm)for k = 1:length(idx1)    root1 = idx1(k);    root2 = idx2(k);        while root1~=id(root1)        id(root1) = id(id(root1));        root1 = id(root1);    end    while root2~=id(root2)        id(root2) = id(id(root2));        root2 = id(root2);    end        if root1==root2, continue, end    % (The two pixels belong to the same group)        N1 = sz(root1); % size of the group belonging to root1    N2 = sz(root2); % size of the group belonging to root2        if I(root1)==I(root2) % then merge the two groups        if N1 < N2            id(root1) = root2;            sz(root2) = N1+N2;        else            id(root2) = root1;            sz(root1) = N1+N2;        end    endendwhile 1    id0 = id;    id = id(id);    if isequal(id0,id), break, endendsz = sz(id);%%% label matrixisNaNI = isnan(I);id(isNaNI) = NaN;[id,~,n] = unique(id);I = 1:length(id);L = reshape(I(n),sizI);L(isNaNI) = 0;if nargin>1, num = nnz(~isnan(id)); endend % end of imlabel##### SOURCE END #####-->  </body></html>