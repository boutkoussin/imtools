<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html>  <head>    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">    <!--This HTML was auto-generated from MATLAB code.To make changes, update the MATLAB code and republish this document.      -->    <title>GRANULOMETRY - Morphological granulometry representation of an image.</title>    <meta name="generator" content="MATLAB 7.14">    <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">    <meta name="DC.date" content="2012-05-31">    <meta name="DC.source" content="granulometry.m">    <style type="text/css">html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}html { min-height:100%; margin-bottom:1px; }html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }html body td { vertical-align:top; text-align:left; }h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }a { color:#005fce; text-decoration:none; }a:hover { color:#005fce; text-decoration:underline; }a:visited { color:#004aa0; text-decoration:none; }p { padding:0px; margin:0px 0px 20px; }img { padding:0px; margin:0px 0px 20px; border:none; }p img, pre img, tt img, li img { margin-bottom:0px; } ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }ul li { padding:0px; margin:0px 0px 7px 0px; }ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }ul li ol li { list-style:decimal; }ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }ol li ol li { list-style-type:lower-alpha; }ol li ul { padding-top:7px; }ol li ul li { list-style:square; }.content { font-size:1.2em; line-height:140%; padding: 20px; }pre, tt, code { font-size:12px; }pre { margin:0px 0px 20px; }pre.error { color:red; }pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }span.keyword { color:#0000FF }span.comment { color:#228B22 }span.string { color:#A020F0 }span.untermstring { color:#B20000 }span.syscmd { color:#B28C00 }.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }.footer p { margin:0px; }  </style>  </head>  <body>    <div class="content">      <h1>GRANULOMETRY - Morphological granulometry representation of an image.</h1>      <!--introduction--><!--/introduction-->      <h2>Contents</h2>      <div>        <ul>          <li><a href="#1">Description</a></li>          <li><a href="#2">Syntax</a></li>          <li><a href="#3">Inputs</a></li>          <li><a href="#4">Property [propertyname propertyvalues]</a></li>          <li><a href="#5">Outputs</a></li>          <li><a href="#6">References</a></li>          <li><a href="#8">See also</a></li>          <li><a href="#9">Function implementation</a></li>        </ul>      </div>      <h2>Description<a name="1"></a></h2>      <p>Compute a granulometry through a series of morphological operations        (filters) following the various approaches described in        [Mathe75,Serra82,CD94,DC99].</p>      <h2>Syntax<a name="2"></a></h2>      <pre>   G = GRANULOMETRY(I);   G = GRANULOMETRY(I, op);   G = GRANULOMETRY(I, op, 'Property', propertyvalue, ... );</pre>      <h2>Inputs<a name="3"></a></h2>      <p><b><tt>I</tt></b> : input image of size <tt>(X,Y,C)</tt>, with <tt>C&gt;1</tt>        when <tt>I</tt> is multispectral.</p>      <p><b><tt>op</tt></b> : (optional) string setting the elementary        operations performed at each step for computing the final granulometry;        it can any of those strings: <tt>'o'</tt> (or <tt>'open'</tt>), <tt>'c'</tt>        (or <tt>'close'</tt>), <tt>'oc'</tt>, <tt>'co'</tt>, <tt>'oco'</tt>,        <tt>'coc'</tt>, <tt>'ro'</tt>, <tt>'rc'</tt>, <tt>'roc'</tt>, <tt>'rco'</tt>,        <tt>'rcoc'</tt>, <tt>'roco'</tt>, <tt>'e'</tt> (or <tt>'erode'</tt>)        or <tt>'d'</tt> (or <tt>'dilate'</tt>), where the <tt>'o'</tt>        represents the opening operation (see function <tt>IMOPEN</tt>), the        'c' represents the closing operation (see function <tt>IMCLOSE</tt>),        the prior 'r' means that the reconstruction version of these operators        are considered (see functions <tt>IMROPEN</tt> and <tt>IMRCLOSE</tt>),        and where the order of the letters represents the order those operators        are applied for computing the elementary operation at each step; for        instance, <tt>'roco'</tt> means that at each step, an opening by        reconstruction followed by a closing by reconstruction itself followed        by another opening by reconstruction are applied on the input image;        default: <tt>op='roc'</tt>.</p>      <p><b><tt>se</tt></b> : (optional) string or cell of defining the        structuring elements used for computing the granulometry; it can be        either a cell of <tt>N</tt> structures of type <tt>STREL</tt>, each <tt>se{i}</tt>        representing the SE used by the operator at step <tt>i&lt;=N</tt>, or a        string defining the shape of the elementary SE (see function <tt>FLATSTREL</tt>);        in this latter case, the size of the SE needs to be passed in the        variable <tt>s1</tt> (see below); default: <tt>se='disk'</tt>.</p>      <h2>Property [propertyname propertyvalues]<a name="4"></a></h2>      <p><b><tt>'s1', 's2'</tt></b> : optional argument(s) further defining the        series of SE's used by the elementary morphological operation at each        step in the case the variable <tt>se</tt> (see above) was passed as a        string (and not a cell of <tt>STREL</tt> structures); <tt>s1</tt> is a        vector of size <tt>N</tt>, each <tt>s1(i)</tt> providing the size of        the SE used by the operator at step <tt>i&lt;=N</tt>; <tt>s2</tt>        further completes the definition of the SE, depending on its type (see        function <tt>FLATSTREL</tt>); default: <tt>s1=2:2:10</tt> and <tt>s2=[]</tt>.</p>      <h2>Outputs<a name="5"></a></h2>      <p><b><tt>G</tt></b> : a cell of size <tt>N</tt> representing a        granulometry.</p>      <h2>References<a name="6"></a></h2>      <p>[Mathe75] G. Matheron: "Random Sets and Integral Geometry", Wiley, New        York (USA), 1975.</p>      <p>[Serra82] J. Serra: "Image Analysis and Mathematical Morphology",        Academic Press, New York (USA), 1982.</p>      <p>[CD94] Y. Chen and E.R. Dougherty: "Gray-scale morphological        granulometric texture classification", Opt. Eng. 33(8):2713-2722, 1994.        <a href="http://spiedigitallibrary.org/oe/resource/1/opegar/v33/i8/p2713_s1">http://spiedigitallibrary.org/oe/resource/1/opegar/v33/i8/p2713_s1</a></p>      <p>[DC99] E.R. Dougherty and Y. Chen: "Granulometric filters", in:        "Nonlinear Image Filtering", E.R. Dougherty and J. Astola eds., SPIE and        IEEE Presses, Belingham, pp. 121-162, 1999.</p>      <h2>See also<a name="8"></a></h2>      <p>Related: <a href="MORPHPROFILE.html"><tt>MORPHPROFILE</tt></a>, <a href="matlab:web%28whichpath%28%27WATERSHED%27%29%29"><tt>WATERSHED</tt></a>.        Called: <a href="GRANULOMETRY_BASE.html"><tt>GRANULOMETRY_BASE</tt></a>,        <a href="FLATSTREL.html"><tt>FLATSTREL</tt></a>.</p>      <h2>Function implementation<a name="9"></a></h2>      <pre class="codeinput"><span class="keyword">function</span> [G, varargout] = granulometry( I, varargin )</pre>      <p>parsing parameters</p>      <pre class="codeinput"><span class="keyword">if</span> isempty(ver(<span class="string">'images'</span>))    error(<span class="string">'morphprofile:errortoolbox'</span>, <span class="string">'Image Processing toolbox required'</span>);<span class="keyword">end</span>error(nargchk(1, 16, nargin, <span class="string">'struct'</span>));error(nargoutchk(1, 4, nargout, <span class="string">'struct'</span>));<span class="keyword">if</span> ~isnumeric(I)    error(<span class="string">'morphprofile:inputparameter'</span>,<span class="string">'a matrix is required in input'</span>);<span class="keyword">end</span>p = createParser(<span class="string">'MORPHPROFILE'</span>);p.addOptional(<span class="string">'op'</span>, <span class="string">'roc'</span>, @(x)ischar(x) &amp;&amp; <spanclass="keyword">...</span>    any(strcmpi(x,{<span class="string">'ro'</span>, <span class="string">'ropen'</span>, <spanclass="string">'rc'</span>, <spanclass="string">'rclose'</span>, <spanclass="string">'roc'</span>,<spanclass="string">'rocmax'</span>, <spanclass="keyword">...</span>    <span class="string">'o'</span>, <span class="string">'open'</span>, <span class="string">'c'</span>, <spanclass="string">'close'</span>, <spanclass="string">'oc'</span>, <spanclass="string">'ocmax'</span>, <spanclass="keyword">...</span>    <span class="string">'e'</span>, <span class="string">'erode'</span>, <spanclass="string">'d'</span>, <spanclass="string">'dilate'</span>})));p.addOptional(<span class="string">'se'</span>, <span class="string">'disk'</span>, @(x) (iscell(x) &amp;&amp; strcmp(class(x{1}),<spanclass="string">'strel'</span>)) || <spanclass="keyword">...</span>    (ischar(x) &amp;&amp; any(strcmpi(x,{<span class="string">'disk'</span>,<spanclass="string">'rectangle'</span>,<spanclass="string">'square'</span>,<spanclass="string">'diamond'</span>, <spanclass="keyword">...</span>                <span class="string">'line'</span>,<span class="string">'periodicline'</span>,<spanclass="string">'arbitrary'</span>,<spanclass="string">'octagon'</span>,<spanclass="string">'pair'</span>}))));p.addParamValue(<span class="string">'s1'</span>, 2:2:10, @(x)isnumeric(x));p.addParamValue(<span class="string">'s2'</span>, [], @(x)isnumeric(x));<span class="comment">% parse and validate all input arguments</span>p.parse(varargin{:});p = getvarParser(p);</pre>      <p>checking/setting variables</p>      <pre class="codeinput">C = size(I,3);<span class="keyword">if</span> ischar(p.se)    shape = p.se;    N = length(p.s1);    <span class="keyword">if</span> ~iscell(p.s1),        <span class="keyword">if</span> any(strcmp(shape,{<span class="string">'disk'</span>}))            p.s1 = floor(p.s1/2);        <span class="keyword">end</span>        p.s1 = num2cell(p.s1);    <span class="keyword">end</span>    <span class="keyword">if</span> ~iscell(p.s2),        <span class="keyword">if</span> isempty(p.s2)            p.s2 = cell(N,1);        <span class="keyword">else</span>            <span class="keyword">if</span> isscalar(p.s2),  p.s2 = repmat(p.s2, 1, N);  <spanclass="keyword">end</span>;            p.s2 = num2cell(p.s2);        <span class="keyword">end</span>    <span class="keyword">end</span>    p.se = cell(N,1);    <span class="keyword">for</span> i=1:N        p.se{i} = flatstrel(shape, p.s1{i}, p.s2{i});    <span class="keyword">end</span><span class="keyword">end</span></pre>      <p>main processing</p>      <pre class="codeinput">G = granulometry_base( I, p.op, p.se );<span class="keyword">if</span> nargout==2,  varargout{1} = p.se;  <span class="keyword">end</span></pre>      <p>display</p>      <pre class="codeinput"><span class="keyword">if</span> p.disp    <span class="keyword">if</span> any(strcmp(p.op,<span class="string">'o'</span>)),       p.op = <spanclass="string">'open'</span>;    <span class="keyword">elseif</span> any(strcmp(p.op,<span class="string">'c'</span>)),   p.op = <spanclass="string">'close'</span>;    <span class="keyword">elseif</span> strcmp(p.op,<span class="string">'oc'</span>),       p.op = <spanclass="string">'open-close'</span>;    <span class="keyword">elseif</span> strcmp(p.op,<span class="string">'co'</span>),       p.op = <spanclass="string">'close-open'</span>;    <span class="keyword">elseif</span> strcmp(p.op,<span class="string">'oco'</span>),      p.op = <spanclass="string">'open-close-open'</span>;    <span class="keyword">elseif</span> strcmp(p.op,<span class="string">'coc'</span>),      p.op = <spanclass="string">'close-open-close'</span>;    <span class="keyword">elseif</span> any(strcmp(p.op,<span class="string">'ro'</span>)),  p.op = <spanclass="string">'open-by-rec'</span>;    <span class="keyword">elseif</span> any(strcmp(p.op,<span class="string">'rc'</span>)),  p.op = <spanclass="string">'close-by-rec'</span>;    <span class="keyword">elseif</span> strcmp(p.op,<span class="string">'roc'</span>),      p.op = <spanclass="string">'open-close-by-rec'</span>;    <span class="keyword">elseif</span> strcmp(p.op,<span class="string">'rco'</span>),      p.op = <spanclass="string">'close-open-by-rec'</span>;    <span class="keyword">elseif</span> strcmp(p.op,<span class="string">'roco'</span>),     p.op = <spanclass="string">'open-close-open-by-rec'</span>;    <span class="keyword">elseif</span> strcmp(p.op,<span class="string">'rcoc'</span>),     p.op = <spanclass="string">'close-open-close-by-rec'</span>;    <span class="keyword">end</span>    N = length(G);    figure; ndisp = 3; mdisp = ceil(N/ndisp);    <span class="keyword">for</span> i=1:N        subplot(mdisp, ndisp, i),  imagesc(rescale(G{i})), axis <span class="string">image</span> <spanclass="string">off</span>;    <span class="keyword">end</span>    <span class="keyword">if</span> C==1,  colormap <span class="string">gray</span>; <spanclass="keyword">end</span>    suptitle([<span class="string">'MP of '</span> p.op]);<span class="keyword">end</span></pre>      <pre class="codeinput"><span class="keyword">end</span> <span class="comment">% end of granulometry</span></pre></div>    <!--##### SOURCE BEGIN #####%% GRANULOMETRY - Morphological granulometry representation of an image.%%% Description% Compute a granulometry through a series of morphological operations (filters)% following the various approaches described in [Mathe75,Serra82,CD94,DC99].%%% Syntax%     G = GRANULOMETRY(I);%     G = GRANULOMETRY(I, op);%     G = GRANULOMETRY(I, op, 'Property', propertyvalue, ... );%%% Inputs% *|I|* : input image of size |(X,Y,C)|, with |C>1| when |I| is multispectral.%% *|op|* : (optional) string setting the elementary operations performed at%     each step for computing the final granulometry; it can any of those%     strings: |'o'| (or |'open'|), |'c'| (or |'close'|), |'oc'|, |'co'|,%     |'oco'|, |'coc'|, |'ro'|, |'rc'|, |'roc'|, |'rco'|, |'rcoc'|, |'roco'|,%     |'e'| (or |'erode'|) or |'d'| (or |'dilate'|), where the |'o'| represents%     the opening operation (see function |IMOPEN|), the 'c' represents the%     closing operation (see function |IMCLOSE|), the prior 'r' means that%     the reconstruction version of these operators are considered (see%     functions |IMROPEN| and |IMRCLOSE|), and where the order of the letters%     represents the order those operators are applied for computing the%     elementary operation at each step; for instance, |'roco'| means that%     at each step, an opening by reconstruction followed by a closing by%     reconstruction itself followed by another opening by reconstruction are %     applied on the input image; default: |op='roc'|.%% *|se|* : (optional) string or cell of defining the structuring elements used%     for computing the granulometry; it can be either a cell of |N| structures %     of type |STREL|, each |se{i}| representing the SE used by the operator%     at step |i<=N|, or a string defining the shape of the elementary SE%     (see function |FLATSTREL|); in this latter case, the size of the SE%     needs to be passed in the variable |s1| (see below); default: |se='disk'|.% %% Property [propertyname  propertyvalues]% *|'s1', 's2'|* : optional argument(s) further defining the series of SE's %     used by the elementary morphological operation at each step in the case%     the variable |se| (see above) was passed as a string (and not a cell of%     |STREL| structures); |s1| is a vector of size |N|, each |s1(i)| providing%     the size of the SE used by the operator at step |i<=N|; |s2| further%     completes the definition of the SE, depending on its type (see function%     |FLATSTREL|); default: |s1=2:2:10| and |s2=[]|.%   %% Outputs% *|G|* : a cell of size |N| representing a granulometry.%%% References% [Mathe75]  G. Matheron: "Random Sets and Integral Geometry", Wiley, New%      York (USA), 1975.%% [Serra82]  J. Serra: "Image Analysis and Mathematical Morphology", Academic%      Press, New York (USA), 1982.%% [CD94]  Y. Chen and E.R. Dougherty: "Gray-scale morphological granulometric%      texture classification", Opt. Eng. 33(8):2713-2722, 1994.%      <http://spiedigitallibrary.org/oe/resource/1/opegar/v33/i8/p2713_s1>%% [DC99]  E.R. Dougherty and Y. Chen: "Granulometric filters", in: "Nonlinear%      Image Filtering", E.R. Dougherty and J. Astola eds., SPIE and IEEE %      Presses, Belingham, pp. 121-162, 1999.%%% Credit% <mailto:grazzja@lanl.gov J.Grazzini> (ISR-2/LANL)%%% See also% Related:% <MORPHPROFILE.html |MORPHPROFILE|>,% <matlab:web(whichpath('WATERSHED')) |WATERSHED|>.% Called:% <GRANULOMETRY_BASE.html |GRANULOMETRY_BASE|>,% <FLATSTREL.html |FLATSTREL|>.%% Function implementationfunction [G, varargout] = granulometry( I, varargin )%%% parsing parametersif isempty(ver('images'))    error('morphprofile:errortoolbox', 'Image Processing toolbox required');enderror(nargchk(1, 16, nargin, 'struct'));error(nargoutchk(1, 4, nargout, 'struct'));if ~isnumeric(I)    error('morphprofile:inputparameter','a matrix is required in input'); endp = createParser('MORPHPROFILE');   p.addOptional('op', 'roc', @(x)ischar(x) && ...    any(strcmpi(x,{'ro', 'ropen', 'rc', 'rclose', 'roc','rocmax', ...    'o', 'open', 'c', 'close', 'oc', 'ocmax', ...    'e', 'erode', 'd', 'dilate'})));p.addOptional('se', 'disk', @(x) (iscell(x) && strcmp(class(x{1}),'strel')) || ...    (ischar(x) && any(strcmpi(x,{'disk','rectangle','square','diamond', ...                'line','periodicline','arbitrary','octagon','pair'}))));p.addParamValue('s1', 2:2:10, @(x)isnumeric(x));p.addParamValue('s2', [], @(x)isnumeric(x));% parse and validate all input argumentsp.parse(varargin{:}); p = getvarParser(p);                                                            %%% checking/setting variablesC = size(I,3);if ischar(p.se)    shape = p.se;    N = length(p.s1);        if ~iscell(p.s1),        if any(strcmp(shape,{'disk'}))            p.s1 = floor(p.s1/2);        end        p.s1 = num2cell(p.s1);      end    if ~iscell(p.s2),        if isempty(p.s2)            p.s2 = cell(N,1);          else            if isscalar(p.s2),  p.s2 = repmat(p.s2, 1, N);  end;            p.s2 = num2cell(p.s2);         end    end        p.se = cell(N,1);    for i=1:N        p.se{i} = flatstrel(shape, p.s1{i}, p.s2{i});    end    end%% % main processingG = granulometry_base( I, p.op, p.se );    if nargout==2,  varargout{1} = p.se;  end%%% displayif p.disp        if any(strcmp(p.op,'o')),       p.op = 'open';    elseif any(strcmp(p.op,'c')),   p.op = 'close';    elseif strcmp(p.op,'oc'),       p.op = 'open-close';    elseif strcmp(p.op,'co'),       p.op = 'close-open';    elseif strcmp(p.op,'oco'),      p.op = 'open-close-open';    elseif strcmp(p.op,'coc'),      p.op = 'close-open-close';    elseif any(strcmp(p.op,'ro')),  p.op = 'open-by-rec';    elseif any(strcmp(p.op,'rc')),  p.op = 'close-by-rec';    elseif strcmp(p.op,'roc'),      p.op = 'open-close-by-rec';    elseif strcmp(p.op,'rco'),      p.op = 'close-open-by-rec';    elseif strcmp(p.op,'roco'),     p.op = 'open-close-open-by-rec';    elseif strcmp(p.op,'rcoc'),     p.op = 'close-open-close-by-rec';    end        N = length(G);    figure; ndisp = 3; mdisp = ceil(N/ndisp);    for i=1:N        subplot(mdisp, ndisp, i),  imagesc(rescale(G{i})), axis image off;    end    if C==1,  colormap gray; end    suptitle(['MP of ' p.op]);endend % end of granulometry##### SOURCE END #####--></body></html>