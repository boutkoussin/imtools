<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html>  <head>    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">    <!--This HTML was auto-generated from MATLAB code.To make changes, update the MATLAB code and republish this document.      -->    <title>FINDZEROEXTREMA1D_BASE - Base function for FINDZEROEXTREMA1D.</title>    <meta name="generator" content="MATLAB 7.14">    <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">    <meta name="DC.date" content="2012-05-31">    <meta name="DC.source" content="findzeroextrema1D_base.m">    <style type="text/css">html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}html { min-height:100%; margin-bottom:1px; }html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }html body td { vertical-align:top; text-align:left; }h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }a { color:#005fce; text-decoration:none; }a:hover { color:#005fce; text-decoration:underline; }a:visited { color:#004aa0; text-decoration:none; }p { padding:0px; margin:0px 0px 20px; }img { padding:0px; margin:0px 0px 20px; border:none; }p img, pre img, tt img, li img { margin-bottom:0px; } ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }ul li { padding:0px; margin:0px 0px 7px 0px; }ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }ul li ol li { list-style:decimal; }ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }ol li ol li { list-style-type:lower-alpha; }ol li ul { padding-top:7px; }ol li ul li { list-style:square; }.content { font-size:1.2em; line-height:140%; padding: 20px; }pre, tt, code { font-size:12px; }pre { margin:0px 0px 20px; }pre.error { color:red; }pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }span.keyword { color:#0000FF }span.comment { color:#228B22 }span.string { color:#A020F0 }span.untermstring { color:#B20000 }span.syscmd { color:#B28C00 }.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }.footer p { margin:0px; }  </style>  </head>  <body>    <div class="content">      <h1>FINDZEROEXTREMA1D_BASE - Base function for FINDZEROEXTREMA1D.</h1>      <!--introduction--><!--/introduction-->      <h2>Contents</h2>      <div>        <ul>          <li><a href="#1">Syntax</a></li>          <li><a href="#2">Remarks</a></li>          <li><a href="#4">See also</a></li>          <li><a href="#5">Function implementation</a></li>        </ul>      </div>      <h2>Syntax<a name="1"></a></h2>      <pre class="language-matlab">[Max, Min, Zero] = FINDZEROEXTREMA1D_BASE(X, x);[Max, Min, Zero] = FINDZEROEXTREMA1D_BASE(X, x, delta);[Max, Min, Zero] = FINDZEROEXTREMA1D_BASE(X, x, met_max, met_min, met_zeros);[Max, Min, Zero] = FINDZEROEXTREMA1D_BASE(X, x, <span class="keyword">...</span>           met_max, met_min, met_zeros, delta);[Max, Min] = FINDZEROEXTREMA1D_BASE(X, x, met_max, met_min, [], delta);Max = FINDZEROEXTREMA1D_BASE(X, x, met_max, [], [], delta);Min = FINDZEROEXTREMA1D_BASE(X, x, [], met_min, [], delta;Zero = FINDZEROEXTREMA1D_BASE(X, x, [], [], met_zeros, delta);</pre>      <h2>Remarks<a name="2"></a></h2>      <div>        <ul>          <li>A feature won't be computed only if its method is passed as an            empty string: eg., no <tt>Max</tt> is computed (and output) when <tt>met_max=[]</tt>;            however, a default feature is always computed when its method is not            passed (e.g. all features are output when calling <tt>FINDZEROEXTREMA1D_BASE(X,              x, delta))</tt>.</li>        </ul>      </div>      <div>        <ul>          <li><tt>delta</tt> is a <tt>(1,n)</tt> vector, with <tt>n&lt;=3</tt>,            of the form <tt>[delta mindelta valabs]</tt> (see help <tt>FINDZEROEXTREMA1D</tt>            for explanation).</li>        </ul>      </div>      <div>        <ul>          <li>When no extrema and/or zeros are found, this function returns a            row vector of null indices (<tt>[0 0]</tt> for <tt>Min</tt> and <tt>Max</tt>,            <tt>[0]</tt> for <tt>Zero</tt>). This is implemented this way to            enable further used of this function besides its call in the            function <tt>FINDZEROEXTREMA1D</tt> (which, on the contrary,            returns an empty vector in such case).</li>        </ul>      </div>      <h2>See also<a name="4"></a></h2>      <p>Related: <a href="FINDZEROEXTREMA1D.html"><tt>FINDZEROEXTREMA1D</tt></a>.        Called: <a href="matlab:webpub%28whichpath%28%27PEAKFINDER%27%29%29"><tt>PEAKFINDER</tt></a>,        <a href="matlab:webpub%28whichpath%28%27PEAKDET%27%29%29"><tt>PEAKDET</tt></a>,        <a href="matlab:webpub%28whichpath%28%27FINDEXTREMA%27%29%29"><tt>FINDEXTREMA</tt></a>,        <a href="matlab:webpub%28whichpath%28%27EXTREMA%27%29%29"><tt>EXTREMA</tt></a>,        <a href="matlab:webpub%28whichpath%28%27CROSSING%27%29%29"><tt>CROSSING</tt></a>,        <a href="matlab:webpub%28whichpath%28%27FIND%27%29%29"><tt>FIND</tt></a>.</p>      <h2>Function implementation<a name="5"></a></h2>      <pre class="codeinput"><span class="keyword">function</span> varargout = <spanclass="keyword">...</span>    findzeroextrema1D_base(X, x, met_max, met_min, met_zeros, delta )</pre>      <p>check/set internal parameters</p>      <pre class="codeinput"><span class="keyword">if</span> nb_dims(X)&gt;1    error(<span class="string">'findzeroextrema1D_base:inputerror'</span>, <spanclass="keyword">...</span>        <span class="string">'1D signal required in input'</span>);<span class="keyword">elseif</span> length(X)&lt;3    <span class="keyword">for</span> i=1:nargout,  varargout{i} = [0 0];  <spanclass="keyword">end</span>    <span class="keyword">return</span><span class="keyword">end</span><span class="comment">% special case</span><span class="keyword">if</span> nargin==3 &amp;&amp; isnumeric(met_max)    delta = met_max;    met_max = <span class="string">'peakfinder'</span>;<span class="keyword">elseif</span> nargin&lt;6,    delta = (max(X)-min(X))/4; <span class="comment">% see PEAKFINDER</span><span class="keyword">end</span><span class="comment">% default values for default approach</span><span class="keyword">if</span> nargin&lt;5,  met_zeros = <span class="string">'crossing'</span>; <spanclass="comment">% by default, we compute it</span>    <span class="keyword">if</span> nargin&lt;4,  met_min = <span class="string">'peakfinder'</span>;        <span class="keyword">if</span> nargin&lt;3,  met_max = <span class="string">'peakfinder'</span>;            <span class="keyword">if</span> nargin&lt;2,  x = []; <span class="keyword">end</span>        <span class="keyword">end</span>    <span class="keyword">end</span><span class="keyword">end</span><span class="keyword">if</span> isempty(x),  x = (1:length(X))';  <span class="keyword">end</span><span class="keyword">if</span> size(X,2)&gt;1,  X = transpose(X);  <span class="keyword">end</span><span class="keyword">if</span> size(x,2)&gt;1,  x = transpose(x);  <span class="keyword">end</span>interpol = false;<span class="comment">% default values when empty options are passed</span><span class="keyword">if</span> length(delta)&lt;3,  valabs = Inf;    <span class="keyword">if</span> length(delta)&lt;2,  mindelta = 0;        <span class="keyword">if</span> isempty(delta),  delta = 0;  <span class="keyword">end</span>    <span class="keyword">else</span>        mindelta = delta(2);    <span class="keyword">end</span><span class="keyword">else</span>    valabs = delta(3);    mindelta = delta(2);<span class="keyword">end</span>delta = delta(1);</pre>      <p>main computation starts here</p>      <pre class="codeinput">narg =0;<span class="keyword">if</span> any(strcmpi(<span class="string">'morph'</span>,{met_max,met_min,met_zeros}))    d = [X(2:end-1) X(3:end) X(1:end-2)];    I = find(max(abs(diff([d d(:,1)],1,2)),[],2)&lt;delta);<span class="keyword">end</span><span class="keyword">if</span> ~isempty(met_max)    <span class="comment">% no max computation takes place only when met_max is passed as an empty</span>    <span class="comment">% variable</span>    narg = narg+1;    <span class="keyword">switch</span> met_max         <span class="keyword">case</span> <span class="string">'ecke'</span></pre>      <p><tt>ECKE</tt> - Iterative filtering.</p>      <pre class="codeinput">            S = X;            <span class="keyword">for</span> j = 1:2                A = diff([X;X(1)]);                B = flipud(diff(flipud([X(end);X])));                <span class="comment">% min = find(~(((A&lt;0)&amp;(B&lt;=0))|((A&lt;=0)&amp;(B&lt;0))));</span>                S(~(((A&lt;0)&amp;(B&lt;=0)) | ((A&lt;=0)&amp;(B&lt;0)))) = 0;                <span class="comment">% figure, plot(X, 'x-')</span>            <span class="keyword">end</span>            Max = find(S);</pre>      <pre class="codeinput">        <span class="keyword">case</span> {<span class="string">'local3'</span>,<spanclass="string">'morph'</span>}</pre>      <p><tt>'local3'</tt> - Fast naive method for finding extrema in local        (3,1) neighbourhoods. since local maximum and minimum points of a signal        have zero derivative, their locations can be estimated from the zero-        crossings of <tt>diff(X)</tt>, provided the signal is sampled with        sufficiently fine resolution;</p>      <pre class="codeinput">            <span class="comment">% for a coarsely sampled signal, a better estimate is</span>            A = diff(X(1:end-1)); A(abs(A)&lt;eps) = 0;            B = diff(X(2:end));  B(abs(B)&lt;eps) = 0;            <span class="comment">% Max = find(sign(A)-sign(B)&gt;0 &amp; abs(A)&gt;delta &amp; abs(B)&gt;delta) + 1;</span>            Max = find(sign(A)-sign(B)&gt;0 &amp; <span class="keyword">...</span>                min(abs([A B]),[],2)&gt;=delta) + 1;</pre>      <pre class="codeinput">        <span class="keyword">case</span> <span class="string">'local5'</span></pre>      <p><tt>LOCAL5</tt> - Method for finding extrema in local (5x1)        neighbourhoods. typically, each signal value is compared to its 4        neighbours (2 left, 2 right) to check if it is a local extremum.        examples of accepted configurations ('o' represents the tested value,        the '_' represents a locally constant signal, while '/' represents a        locally increasing signal and '\' represents a locally decreasing        signal:</p>      <pre>    o       /o\   _/o\      o__    o_     o  _/ \_    /   \      \    /      /  \   / \_                          /      /      /examples of rejected configurations</pre>      <pre>   _o_       _     /  /   \    o/    o/   /\o/\  /\o       o      o_/         _/     /               \/    / \/   /               /                     /      /</pre>      <pre class="codeinput">            A = diff(X(2:end-2));  A(abs(A)&lt;eps) = 0;            B = diff(X(3:end-1));  B(abs(B)&lt;eps) = 0;            C = diff(X(1:end-3));  C(abs(C)&lt;eps) = 0;            D = diff(X(4:end));  D(abs(D)&lt;eps) = 0;            Max = find(sign(A)-sign(B)&gt;0 &amp; sign(C)-sign(D)&gt;0 &amp; <spanclass="keyword">...</span>                min(abs([A B]),[],2)&gt;=delta) + 2;</pre>      <pre class="codeinput">        <span class="keyword">case</span> <span class="string">'peakfinder'</span></pre>      <p><tt>PEAKFINDER</tt> - Noise tolerant fast peak finding algorithm. <tt>PEAKFINDER</tt>        quickly finds local peaks or valleys (local extrema) in a noisy vector        using a user-defined magnitude threshold to determine if each peak is        significantly larger (or smaller) than the data around it. The problem        with the strictly derivative based peak finding algorithms is that if        the signal is noisy many spurious peaks are found. However, more complex        methods often take much longer for large data sets, require a large        amount of user interaction, and still give highly variable results. This        function attempts to use the alternating nature of the derivatives along        with the user defined threshold to identify local maxima or minima in a        vector quickly and robustly.</p>      <pre class="codeinput">            [Max, vMax] = peakfinder(X, delta, 1);            <span class="comment">% [peakLoc, peakMag] = peakfinder(x0,thresh,extrema) returns the</span>            <span class="comment">% indices of the local maxima as well as the magnitudes of those</span>            <span class="comment">% maxima.</span>            <span class="comment">%   INPUTS:</span>            <span class="comment">%       x0 - A real vector from the maxima will be found (required)</span>            <span class="comment">%       thresh - The amount above surrounding data for a peak to</span>            <span class="comment">%           be identified (default = (max(x0)-min(x0))/4). Larger</span>            <span class="comment">%           values mean the algorithm is more selective in finding</span>            <span class="comment">%           peaks.</span>            <span class="comment">%       extrema - 1 if maxima are desired, -1 if minima are desired</span>            <span class="comment">%           (default = maxima, 1)</span>            <span class="comment">%   OUTPUTS:</span>            <span class="comment">%       peakLoc - The indicies of the identified peaks in x0</span>            <span class="comment">%       peakMag - The magnitude of the identified peaks</span></pre>      <pre class="codeinput">        <span class="keyword">case</span> <span class="string">'peakdet'</span></pre>      <p><tt>PEAKDET</tt> - Detect peaks in a vector. Using the well-known        zero-derivate method. Due to the noise, which is always there in        real-life signals, accidental zero- crossings of the first derivate        occur, yielding false detections. The typical solution is to smooth the        curve with some low-pass filter, usually killing the original signal at        the same time. The result is usually that the algorithm goes horribly        wrong where it's so obvious to the eye. The trick here is to realize,        that a peak is the highest point between "valleys". What makes a peak is        the fact that there are lower points around it. This strategy is adopted        by <tt>PEAKDET</tt>: look for the highest point, around which there are        points lower by X on both sides.</p>      <pre class="codeinput">            [Max, Min] = peakdet(X, delta); <span class="comment">% Max and Min are already complete</span>           <span class="comment">% [maxtab, mintab] = peakdet(v, delta, x) finds the local maxima</span>            <span class="comment">% and minima ("peaks").</span>            <span class="comment">%   INPUTS:</span>            <span class="comment">%       V - input vector.</span>            <span class="comment">%       delta - a point is considered a maximum peak if it has</span>            <span class="comment">%           the maximal value, and was preceded (to the left) by</span>            <span class="comment">%           a value lower by delta: we require a difference of</span>            <span class="comment">%           at least delta between a peak and its surrounding in</span>            <span class="comment">%           order to declare it as a peak.</span>            <span class="comment">%       x - the indices in MAXTAB and MINTAB (see below) will be</span>            <span class="comment">%           replaced with the corresponding x-values.</span>            <span class="comment">%   OUTPUTS:</span>            <span class="comment">%       MAXTAB, MINTAB - consist of two columns; column 1 contains</span>            <span class="comment">%           indices in V, and column 2 the found values.</span></pre>      <pre class="codeinput">        <span class="keyword">case</span> <span class="string">'fpeak'</span></pre>      <p><tt>FPEAK</tt> - Find peak value of data. <tt>FPEAK</tt> reports the        minimum data points and requires more inputs than the <tt>PEAKFINDER</tt>        method for instance.</p>      <pre class="codeinput">            varargout{1} = fpeak(x, X, delta);            <span class="comment">% peak = fpeak(x, y, s, Range)</span>            <span class="comment">%   INPUTS:</span>            <span class="comment">%       x, y - input signal coordinates and values</span>            <span class="comment">%       s - sensitivity of the function.</span>            <span class="comment">%       Range - peak value's range</span>            varargout{2} = [];</pre>      <pre class="codeinput">        <span class="keyword">case</span> <span class="string">'findextrema'</span></pre>      <p><tt>FINDEXTREMA</tt> - find indices of local extrema and        zero-crossings.</p>      <pre class="codeinput">            [Max, Min, Zero] = findextrema(X);             <span class="comment">% [IMAX,IMIN,ICRS] = FINDEXTREMA(X) returns the indices of local</span>            <span class="comment">% maxima in IMAX, minima in IMIN and zero-crossing in ICRS for</span>            <span class="comment">% input vector X</span></pre>      <pre class="codeinput">        <span class="keyword">case</span> <span class="string">'extrema'</span></pre>      <p><tt>EXTREMA</tt> - Gets the global extrema points from a time series. <tt>EXTREMA</tt>        reports many maxima peaks</p>      <pre class="codeinput">            [vMax,Max,vMin,Min] = extrema(X);            <span class="comment">% [XMAX,IMAX,XMIN,IMIN] = EXTREMA(X) returns the global minima</span>            <span class="comment">% and maxima points.</span>            <span class="comment">%   INPUTS:</span>            <span class="comment">%       X - input vector, possibly containing NaN values (ignored)</span>            <span class="comment">%   OUTPUTS:</span>            <span class="comment">%       XMAX - maxima points in descending order</span>            <span class="comment">%       IMAX - indexes of the XMAX</span>            <span class="comment">%       XMIN - minima points in descending order</span>            <span class="comment">%       IMIN - indexes of the XMIN</span></pre>      <pre class="codeinput">    <span class="keyword">end</span>    <span class="keyword">if</span> strcmpi(met_max,<span class="string">'morph'</span>)        S = X;        ero = min(d,[],2); ero(ero&lt;0) = 0;        S(I+1) = ero(I);        A = diff(S(1:end-1)); B = diff(S(2:end));        M = find(sign(A)-sign(B)&gt;0) + 1;        Max = Max(ismember(Max,M));    <span class="keyword">end</span>    <span class="keyword">if</span> ~isnan(mindelta) &amp;&amp; mindelta&gt;0        <span class="keyword">if</span> ~strcmpi(met_max,<span class="string">'local3'</span>)            A = diff(X(1:end-1)); B = diff(X(2:end));        <span class="keyword">end</span>        md = find(max(abs([A B]),[],2)&gt;mindelta)+1;        Max(~ismember(Max,md)) = [];        <span class="keyword">if</span> exist(<span class="string">'vMax'</span>,<spanclass="string">'var'</span>) &amp;&amp; ~isempty(vMax),            vMax(ismember(Max,md)) = [];        <span class="keyword">end</span>    <span class="keyword">end</span>    <span class="keyword">if</span> ~isnan(valabs) &amp;&amp; valabs&lt;Inf &amp;&amp; valabs&gt;0,        mv = find(abs(X)&lt;=valabs);        Max(ismember(Max,mv)) = [];        <span class="keyword">if</span> exist(<span class="string">'vMax'</span>,<spanclass="string">'var'</span>) &amp;&amp; ~isempty(vMax),            vMax(ismember(Max,mv)) = [];        <span class="keyword">end</span>    <span class="keyword">end</span>    <span class="keyword">if</span> ~strcmpi(met_max,<span class="string">'fpeak'</span>)        <span class="comment">% retrieve the coordinates of the extrema in the original system and</span>        <span class="comment">% determine the extrema values, if not done already</span>        <span class="keyword">if</span> size(Max,2)&lt;2,            <span class="keyword">if</span> ~exist(<span class="string">'vMax'</span>,<spanclass="string">'var'</span>) || isempty(vMax),  vMax = X(Max);  <spanclass="keyword">end</span>            varargout{narg} = [x(Max) vMax];        <span class="keyword">else</span>            varargout{narg} = Max;            varargout{narg}(:,1) = x(Max(:,1));        <span class="keyword">end</span>    <span class="keyword">end</span>    <span class="keyword">if</span> isempty(varargout{narg}), varargout{narg} = [0 0];  <spanclass="keyword">end</span><span class="keyword">end</span><span class="keyword">if</span> ~isempty(met_min)    <span class="comment">% no min computation takes place only when met_min is passed as an empty</span>    <span class="comment">% variable</span>    narg = narg+1;    <span class="keyword">switch</span> met_min        <span class="keyword">case</span> <span class="string">'ecke'</span> <spanclass="comment">% nothing output</span>            S = X;            <span class="keyword">for</span> j = 1:2                A = diff([X;X(1)]);                B = flipud(diff(flipud([X(end);X])));                S(~(((A&gt;0)&amp;(B&gt;=0)) | ((A&gt;=0)&amp;(B&gt;0)))) = 0;            <span class="keyword">end</span>            Min = find(S);        <span class="keyword">case</span> {<span class="string">'local3'</span>,<spanclass="string">'morph'</span>}            <span class="keyword">if</span> isempty(met_max) || ~strcmpi(met_max,<spanclass="string">'local3'</span>)                A = diff(X(1:end-1));  A(abs(A)&lt;eps) = 0;                B = diff(X(2:end));  B(abs(B)&lt;eps) = 0;                <span class="comment">% else: A and B have been already previously computed</span>            <span class="keyword">end</span>            <span class="comment">% Min = find(sign(A)-sign(B)&lt;0 &amp; abs(A)&gt;delta &amp; abs(B)&gt;delta) + 1;</span>            Min = find(sign(A)-sign(B)&lt;0 &amp; <span class="keyword">...</span>                min(abs([A B]),[],2)&gt;=delta &amp; <span class="keyword">...</span>                max(abs([A B]),[],2)&gt;mindelta) + 1;        <span class="keyword">case</span> <span class="string">'local5'</span>            <span class="keyword">if</span> isempty(met_max) || ~strcmpi(met_max,<spanclass="string">'local5'</span>)                A = diff(X(2:end-2));  A(abs(A)&lt;eps) = 0;                B = diff(X(3:end-1));  B(abs(B)&lt;eps) = 0;                C = diff(X(1:end-3));  C(abs(C)&lt;eps) = 0;                D = diff(X(4:end));  D(abs(D)&lt;eps) = 0;            <span class="keyword">end</span>            Min = find(sign(A)-sign(B)&lt;0 &amp; sign(C)-sign(D)&lt;0 &amp; <spanclass="keyword">...</span>                min(abs([A B]),[],2)&gt;=delta) + 2;        <span class="keyword">case</span> <span class="string">'peakfinder'</span>            [Min, vMin] = peakfinder(X,delta,-1);        <span class="keyword">case</span> <span class="string">'peakdet'</span>            <span class="keyword">if</span> isempty(met_max) || ~strcmpi(met_max,<spanclass="string">'peakdet'</span>)                [~, Min] = peakdet(X, delta);                <span class="comment">% else: we already computed a Min</span>            <span class="keyword">end</span>        <span class="keyword">case</span> <span class="string">'fpeak'</span>            <span class="keyword">if</span> isempty(met_max) || ~strcmpi(met_max,<spanclass="string">'fpeak'</span>)                varargout{narg} = fpeak(x, X, delta);            <span class="keyword">end</span>        <span class="keyword">case</span> <span class="string">'findextrema'</span>            <span class="keyword">if</span> isempty(met_max) || ~strcmpi(met_max,<spanclass="string">'findextrema'</span>)                [~, Min, Zero] = findextrema(X);                <span class="comment">% else: we already computed a Min</span>            <span class="keyword">end</span>        <span class="keyword">case</span> <span class="string">'extrema'</span>            <span class="keyword">if</span> isempty(met_max) || ~strcmpi(met_max,<spanclass="string">'extrema'</span>)                [~, ~, vMin, Min] = extrema(X);                <span class="comment">% else: we already computed Min, vMin</span>            <span class="keyword">end</span>    <span class="keyword">end</span>    <span class="keyword">if</span> strcmpi(met_max,<span class="string">'morph'</span>)        S = -X; d = -d;        ero = min(d,[],2); ero(ero&lt;0) = 0;        S(I+1) = ero(I);        A = diff(S(1:end-1)); B = diff(S(2:end));        m = find(sign(A)-sign(B)&gt;0) + 1;        Min = Min(ismember(Min,m));    <span class="keyword">end</span>    <span class="keyword">if</span> ~isnan(mindelta) &amp;&amp; mindelta&gt;0        <span class="keyword">if</span> ~strcmpi(met_min,<span class="string">'local3'</span>)            A = diff(X(1:end-1)); B = diff(X(2:end));        <span class="keyword">end</span>        md = find(max(abs([A B]),[],2)&gt;mindelta)+1;        Min(~ismember(Max,md)) = [];        <span class="keyword">if</span> exist(<span class="string">'vMin'</span>,<spanclass="string">'var'</span>) &amp;&amp; ~isempty(vMin),            vMin(ismember(Min,md)) = [];        <span class="keyword">end</span>    <span class="keyword">end</span>    <span class="keyword">if</span> ~isnan(valabs) &amp;&amp; valabs&lt;Inf &amp;&amp; valabs&gt;0,        <span class="keyword">if</span> ~exist(<span class="string">'mv'</span>,<spanclass="string">'var'</span>),  mv = find(abs(X)&lt;=valabs);  <spanclass="keyword">end</span>        Min(ismember(Min,mv)) = [];        <span class="keyword">if</span> exist(<span class="string">'vMin'</span>,<spanclass="string">'var'</span>) &amp;&amp; ~isempty(vMin),            vMin(ismember(Min,mv)) = [];        <span class="keyword">end</span>    <span class="keyword">end</span>    <span class="keyword">if</span> ~strcmpi(met_min,<span class="string">'fpeak'</span>)        <span class="keyword">if</span> ~isempty(Min)            <span class="keyword">if</span> size(Min,2)&lt;2,                <span class="keyword">if</span> ~exist(<span class="string">'vMin'</span>,<spanclass="string">'var'</span>) || isempty(vMin),  vMin = X(Min);  <spanclass="keyword">end</span>                varargout{narg} = [x(Min) vMin];            <span class="keyword">else</span>                varargout{narg} = Min;                varargout{narg}(:,1) = x(Min(:,1));            <span class="keyword">end</span>        <span class="keyword">else</span>            varargout{narg} = [];        <span class="keyword">end</span>    <span class="keyword">end</span>    <span class="keyword">if</span> isempty(varargout{narg}), varargout{narg} = [0 0];  <spanclass="keyword">end</span><span class="keyword">end</span><span class="keyword">if</span> strcmpi(met_zeros,<span class="string">'morph'</span>)    <span class="keyword">if</span> any(strcmpi(<span class="string">'morph'</span>,{met_max,met_min}))        X = S;    <span class="keyword">else</span>        ero = min(d,[],2); ero(ero&lt;0) = 0;        X(I+1) = ero(I);    <span class="keyword">end</span><span class="keyword">end</span><span class="keyword">if</span> ~isempty(met_zeros)    narg = narg+1;    <span class="keyword">switch</span> met_zeros        <span class="keyword">case</span> <span class="string">'naive'</span></pre>      <p>Naive method to obtain the indices where signal x crosses zero</p>      <pre class="codeinput">            i0 =  find(diff(sign(X)));            <span class="comment">% the kth zero-crossing lies between x(i(k))  and x(i(k)+1)</span>            <span class="comment">% linear interpolation can be used for subsample estimates of</span>            <span class="comment">% zero-crossings locations</span>            <span class="keyword">if</span> interpol     <span class="comment">% linear interpolation</span>                varargout{narg} = i0 - X(i0)./(X(i0+1) - X(i0));       <span class="comment">%#ok</span>            <span class="keyword">else</span>                varargout{narg} = i0;            <span class="keyword">end</span></pre>      <pre class="codeinput">        <span class="keyword">case</span> {<span class="string">'local3'</span>,<spanclass="string">'morph'</span>}</pre>      <p><tt>'local3'</tt> - Extraction of zero crossing by comparing a value        with its direct neighbours.</p>      <pre class="codeinput">            A = diff(X(1:end-1));  B = diff(X(2:end));            <span class="comment">% same thing, but then B=-B:</span>            <span class="comment">%  A = diff(X);  A = A(1:end-1);</span>            <span class="comment">%  B = flipud(diff(flipud(X)));  B = B(2:end);</span>            <span class="comment">% thus, we then have to check A.*B&lt;=0 in the following</span>            varargout{narg} = <span class="keyword">...</span>                find(A.*B&gt;=0 &amp; X(1:end-2).*X(3:end)&lt;=0 &amp; <span class="keyword">...</span><spanclass="comment"> % zero-crossing</span>                min(abs([A B]),[],2)&gt;delta) <span class="keyword">...</span><spanclass="comment">              % non constant</span>                + 1;            <span class="comment">% &amp; abs(X(2:end-1))&lt;= min([abs(X(1:end-2)) abs(X(3:end))],[],2)</span></pre>      <pre class="codeinput">        <span class="keyword">case</span> <span class="string">'crossing'</span></pre>      <p><tt>CROSSING</tt> - Find the crossings of a given level of a signal</p>      <pre class="codeinput">            <span class="keyword">if</span> interpol                [ind,varargout{narg}] = crossing(X);                   <span class="comment">%#ok</span>            <span class="keyword">else</span>                varargout{narg} = crossing(X);            <span class="keyword">end</span>            <span class="comment">% [ind,t0] = CROSSING(S,t,level,par)</span>            <span class="comment">%   INPUTS:</span>            <span class="comment">%       S - input signal.</span>            <span class="comment">%       t - interpolating time (possibly [] for no interpolation).</span>            <span class="comment">%       level - crossings at this level will be returned instead</span>            <span class="comment">%           of the zero crossings.</span>            <span class="comment">%       par - optional string {'none'|'linear'}: with interpolation</span>            <span class="comment">%	        turned off (par = 'none') this function always returns</span>            <span class="comment">%	        the value left of the zero (the data point that is</span>            <span class="comment">%           nearest to the zero AND smaller than the zero</span>            <span class="comment">%           crossing).</span>            <span class="comment">%   OUTPUTS:</span>            <span class="comment">%       ind - index vector so that the signal S crosses zero at</span>            <span class="comment">%           ind or between ind and ind+1</span>            <span class="comment">%       t0 - time vector t0 of the zero crossings of the signal</span>            <span class="comment">%           S; the crossing times are linearly interpolated</span>            <span class="comment">%           between the given times t</span></pre>      <pre class="codeinput">        <span class="keyword">case</span> <span class="string">'findextrema'</span></pre>      <p><tt>FINDEXTREMA</tt> - find indices of local extrema and        zero-crossings.</p>      <pre class="codeinput">            <span class="keyword">if</span> any(strcmpi({met_max; met_min},{<spanclass="string">'findextrema'</span>;<spanclass="string">'findextrema'</span>}))                <span class="comment">% Zero has been computed already</span>                varargout{narg} = Zero;            <span class="keyword">else</span>                [~, ~, varargout{narg}] = findextrema(X); <span class="comment">% see above</span>            <span class="keyword">end</span></pre>      <pre class="codeinput">    <span class="keyword">end</span>    <span class="keyword">if</span> ~isnan(valabs) &amp;&amp; valabs~=Inf,        <span class="keyword">if</span> ~exist(<span class="string">'mv'</span>,<spanclass="string">'var'</span>),   mv = find(abs(X)&lt;=valabs);  <spanclass="keyword">end</span>        varargout{narg}(~ismember(varargout{narg},mv)) = [];    <span class="keyword">end</span>    <span class="keyword">if</span> ~isnan(mindelta) &amp;&amp; mindelta&gt;0        <span class="keyword">if</span> ~strcmpi(met_zeros,{<span class="string">'local3'</span>,<spanclass="string">'morph'</span>})            A = diff(X(1:end-1)); B = diff(X(2:end));        <span class="keyword">end</span>        md = find(max(abs([A B]),[],2)&gt;=mindelta)+1;        varargout{narg}(~ismember(varargout{narg},md)) = [];    <span class="keyword">end</span>    <span class="comment">% retrieve the coordinates in the original system</span>    varargout{narg} = x(varargout{narg});    <span class="keyword">if</span> isempty(varargout{narg}), varargout{narg} = 0;  <spanclass="keyword">end</span><span class="keyword">end</span><span class="keyword">if</span> narg&lt;nargout  <span class="comment">% too many variables have been required in output</span>    varargout(narg+1:nargout) = cell(nargout-narg,1);    <span class="keyword">if</span> narg==0        error(<span class="string">'findzeroextrema1D_base:errorinput'</span>, <spanclass="keyword">...</span>            [<span class="string">'at least one non empty string must be entered as a method - '</span> <spanclass="keyword">...</span>            <span class="string">'see variables met_min, met_max and met_zeros'</span>]);    <span class="keyword">end</span><span class="keyword">end</span></pre>      <pre class="codeinput"><span class="keyword">end</span> <span class="comment">% end of findzeroextrema1D_base</span></pre></div>    <!--##### SOURCE BEGIN #####%% FINDZEROEXTREMA1D_BASE - Base function for FINDZEROEXTREMA1D. %%% Syntax%   [Max, Min, Zero] = FINDZEROEXTREMA1D_BASE(X, x);%   [Max, Min, Zero] = FINDZEROEXTREMA1D_BASE(X, x, delta);%   [Max, Min, Zero] = FINDZEROEXTREMA1D_BASE(X, x, met_max, met_min, met_zeros);%   [Max, Min, Zero] = FINDZEROEXTREMA1D_BASE(X, x, ...%              met_max, met_min, met_zeros, delta);%   [Max, Min] = FINDZEROEXTREMA1D_BASE(X, x, met_max, met_min, [], delta);%   Max = FINDZEROEXTREMA1D_BASE(X, x, met_max, [], [], delta);%   Min = FINDZEROEXTREMA1D_BASE(X, x, [], met_min, [], delta;%   Zero = FINDZEROEXTREMA1D_BASE(X, x, [], [], met_zeros, delta);%%% Remarks% * A feature won't be computed only if its method is passed as an empty string:% eg., no |Max| is computed (and output) when |met_max=[]|; however, a default% feature is always computed when its method is not passed (e.g. all features% are output when calling |FINDZEROEXTREMA1D_BASE(X, x, delta))|. %% * |delta| is a |(1,n)| vector, with |n<=3|, of the form |[delta mindelta valabs]|% (see help |FINDZEROEXTREMA1D| for explanation).%% * When no extrema and/or zeros are found, this function returns a row vector% of null indices (|[0 0]| for |Min| and |Max|, |[0]| for |Zero|).% This is implemented this way to enable further used of this function besides% its call in the function |FINDZEROEXTREMA1D| (which, on the contrary, returns% an empty vector in such case).% %% Credit% <mailto:grazzja@lanl.gov J.Grazzini> (ISR-2/LANL)%%% See also% Related:% <FINDZEROEXTREMA1D.html |FINDZEROEXTREMA1D|>.% Called:% <matlab:webpub(whichpath('PEAKFINDER')) |PEAKFINDER|>,% <matlab:webpub(whichpath('PEAKDET')) |PEAKDET|>,% <matlab:webpub(whichpath('FINDEXTREMA')) |FINDEXTREMA|>,% <matlab:webpub(whichpath('EXTREMA')) |EXTREMA|>,% <matlab:webpub(whichpath('CROSSING')) |CROSSING|>,% <matlab:webpub(whichpath('FIND')) |FIND|>.%% Function implementationfunction varargout = ...    findzeroextrema1D_base(X, x, met_max, met_min, met_zeros, delta )%%% check/set internal parametersif nb_dims(X)>1    error('findzeroextrema1D_base:inputerror', ...        '1D signal required in input');elseif length(X)<3    for i=1:nargout,  varargout{i} = [0 0];  end    returnend% special caseif nargin==3 && isnumeric(met_max)    delta = met_max;    met_max = 'peakfinder';elseif nargin<6,     delta = (max(X)-min(X))/4; % see PEAKFINDERend% default values for default approachif nargin<5,  met_zeros = 'crossing'; % by default, we compute it    if nargin<4,  met_min = 'peakfinder';        if nargin<3,  met_max = 'peakfinder';            if nargin<2,  x = []; end        end    endendif isempty(x),  x = (1:length(X))';  endif size(X,2)>1,  X = transpose(X);  endif size(x,2)>1,  x = transpose(x);  endinterpol = false;% default values when empty options are passedif length(delta)<3,  valabs = Inf;    if length(delta)<2,  mindelta = 0;        if isempty(delta),  delta = 0;  end    else        mindelta = delta(2);    endelse    valabs = delta(3);    mindelta = delta(2);enddelta = delta(1);%%% main computation starts herenarg =0;if any(strcmpi('morph',{met_max,met_min,met_zeros}))    d = [X(2:end-1) X(3:end) X(1:end-2)];    I = find(max(abs(diff([d d(:,1)],1,2)),[],2)<delta);endif ~isempty(met_max)     % no max computation takes place only when met_max is passed as an empty     % variable    narg = narg+1;    switch met_max                 case 'ecke'             %%             % |ECKE| - Iterative filtering.            S = X;            for j = 1:2                A = diff([X;X(1)]);                B = flipud(diff(flipud([X(end);X])));                % min = find(~(((A<0)&(B<=0))|((A<=0)&(B<0))));                S(~(((A<0)&(B<=0)) | ((A<=0)&(B<0)))) = 0;                % figure, plot(X, 'x-')            end            Max = find(S);                case {'local3','morph'}            %%            % |'local3'| - Fast naive method for finding extrema in local            % (3,1) neighbourhoods.            % since local maximum and minimum points of a signal have zero            % derivative, their locations can be estimated from the zero-            % crossings of |diff(X)|, provided the signal is sampled with            % sufficiently fine resolution;                        % for a coarsely sampled signal, a better estimate is            A = diff(X(1:end-1)); A(abs(A)<eps) = 0;            B = diff(X(2:end));  B(abs(B)<eps) = 0;            % Max = find(sign(A)-sign(B)>0 & abs(A)>delta & abs(B)>delta) + 1;            Max = find(sign(A)-sign(B)>0 & ...                min(abs([A B]),[],2)>=delta) + 1;                    case 'local5'            %%            % |LOCAL5| - Method for finding extrema in local (5x1) neighbourhoods.            % typically, each signal value is compared to its 4 neighbours             % (2 left, 2 right) to check if it is a local extremum.            % examples of accepted configurations ('o' represents the tested            % value, the '_' represents a locally constant signal, while '/'            % represents a locally increasing signal and '\' represents a            % locally decreasing signal:            %            %      o       /o\   _/o\      o__    o_     o            %    _/ \_    /   \      \    /      /  \   / \_            %                            /      /      /            % examples of rejected configurations            %            %     _o_       _     /            %    /   \    o/    o/   /\o/\  /\o       o      o_/            %           _/     /               \/    / \/   /            %                 /                     /      /            A = diff(X(2:end-2));  A(abs(A)<eps) = 0;            B = diff(X(3:end-1));  B(abs(B)<eps) = 0;            C = diff(X(1:end-3));  C(abs(C)<eps) = 0;            D = diff(X(4:end));  D(abs(D)<eps) = 0;            Max = find(sign(A)-sign(B)>0 & sign(C)-sign(D)>0 & ...                min(abs([A B]),[],2)>=delta) + 2;                              case 'peakfinder'            %%            % |PEAKFINDER| - Noise tolerant fast peak finding algorithm.            % |PEAKFINDER| quickly finds local peaks or valleys (local extrema)            % in a noisy vector using a user-defined magnitude threshold to            % determine if each peak is significantly larger (or smaller) than            % the data around it. The problem with the strictly derivative            % based peak finding algorithms is that if the signal is noisy            % many spurious peaks are found. However, more complex methods            % often take much longer for large data sets, require a large            % amount of user interaction, and still give highly variable            % results. This function attempts to use the alternating nature            % of the derivatives along with the user defined threshold to            % identify local maxima or minima in a vector quickly and robustly.            [Max, vMax] = peakfinder(X, delta, 1);            % [peakLoc, peakMag] = peakfinder(x0,thresh,extrema) returns the            % indices of the local maxima as well as the magnitudes of those            % maxima.            %   INPUTS:            %       x0 - A real vector from the maxima will be found (required)            %       thresh - The amount above surrounding data for a peak to            %           be identified (default = (max(x0)-min(x0))/4). Larger            %           values mean the algorithm is more selective in finding            %           peaks.            %       extrema - 1 if maxima are desired, -1 if minima are desired            %           (default = maxima, 1)            %   OUTPUTS:            %       peakLoc - The indicies of the identified peaks in x0            %       peakMag - The magnitude of the identified peaks                                case 'peakdet'            %%            % |PEAKDET| - Detect peaks in a vector.            % Using the well-known zero-derivate method. Due to the noise,            % which is always there in real-life signals, accidental zero-            % crossings of the first derivate occur, yielding false detections.            % The typical solution is to smooth the curve with some low-pass            % filter, usually killing the original signal at the same time.            % The result is usually that the algorithm goes horribly wrong            % where it's so obvious to the eye.            % The trick here is to realize, that a peak is the highest point            % between "valleys". What makes a peak is the fact that there are            % lower points around it. This strategy is adopted by |PEAKDET|:            % look for the highest point, around which there are points lower            % by X on both sides.                        [Max, Min] = peakdet(X, delta); % Max and Min are already complete           % [maxtab, mintab] = peakdet(v, delta, x) finds the local maxima            % and minima ("peaks").            %   INPUTS:            %       V - input vector.            %       delta - a point is considered a maximum peak if it has            %           the maximal value, and was preceded (to the left) by            %           a value lower by delta: we require a difference of             %           at least delta between a peak and its surrounding in            %           order to declare it as a peak.            %       x - the indices in MAXTAB and MINTAB (see below) will be            %           replaced with the corresponding x-values.            %   OUTPUTS:            %       MAXTAB, MINTAB - consist of two columns; column 1 contains            %           indices in V, and column 2 the found values.                                case 'fpeak'            %%            % |FPEAK| - Find peak value of data.            % |FPEAK| reports the minimum data points and requires more inputs             % than the |PEAKFINDER| method for instance.            varargout{1} = fpeak(x, X, delta);            % peak = fpeak(x, y, s, Range)            %   INPUTS:            %       x, y - input signal coordinates and values            %       s - sensitivity of the function.            %       Range - peak value's range            varargout{2} = [];                    case 'findextrema'            %%            % |FINDEXTREMA| - find indices of local extrema and zero-crossings.            [Max, Min, Zero] = findextrema(X);             % [IMAX,IMIN,ICRS] = FINDEXTREMA(X) returns the indices of local            % maxima in IMAX, minima in IMIN and zero-crossing in ICRS for             % input vector X                               case 'extrema'            %%            % |EXTREMA| - Gets the global extrema points from a time series.            % |EXTREMA| reports many maxima peaks            [vMax,Max,vMin,Min] = extrema(X);            % [XMAX,IMAX,XMIN,IMIN] = EXTREMA(X) returns the global minima             % and maxima points.            %   INPUTS:            %       X - input vector, possibly containing NaN values (ignored)            %   OUTPUTS:            %       XMAX - maxima points in descending order            %       IMAX - indexes of the XMAX            %       XMIN - minima points in descending order            %       IMIN - indexes of the XMIN                           end        if strcmpi(met_max,'morph')        S = X;        ero = min(d,[],2); ero(ero<0) = 0;        S(I+1) = ero(I);        A = diff(S(1:end-1)); B = diff(S(2:end));        M = find(sign(A)-sign(B)>0) + 1;        Max = Max(ismember(Max,M));    end        if ~isnan(mindelta) && mindelta>0        if ~strcmpi(met_max,'local3')            A = diff(X(1:end-1)); B = diff(X(2:end));        end        md = find(max(abs([A B]),[],2)>mindelta)+1;        Max(~ismember(Max,md)) = [];        if exist('vMax','var') && ~isempty(vMax),              vMax(ismember(Max,md)) = [];        end    end       if ~isnan(valabs) && valabs<Inf && valabs>0,          mv = find(abs(X)<=valabs);         Max(ismember(Max,mv)) = [];        if exist('vMax','var') && ~isempty(vMax),              vMax(ismember(Max,mv)) = [];        end    end     if ~strcmpi(met_max,'fpeak')        % retrieve the coordinates of the extrema in the original system and        % determine the extrema values, if not done already        if size(Max,2)<2,            if ~exist('vMax','var') || isempty(vMax),  vMax = X(Max);  end            varargout{narg} = [x(Max) vMax];        else            varargout{narg} = Max;            varargout{narg}(:,1) = x(Max(:,1));        end    end        if isempty(varargout{narg}), varargout{narg} = [0 0];  endendif ~isempty(met_min)    % no min computation takes place only when met_min is passed as an empty    % variable    narg = narg+1;    switch met_min                case 'ecke' % nothing output            S = X;            for j = 1:2                A = diff([X;X(1)]);                B = flipud(diff(flipud([X(end);X])));                S(~(((A>0)&(B>=0)) | ((A>=0)&(B>0)))) = 0;            end            Min = find(S);                    case {'local3','morph'}            if isempty(met_max) || ~strcmpi(met_max,'local3')                A = diff(X(1:end-1));  A(abs(A)<eps) = 0;                B = diff(X(2:end));  B(abs(B)<eps) = 0;                % else: A and B have been already previously computed            end            % Min = find(sign(A)-sign(B)<0 & abs(A)>delta & abs(B)>delta) + 1;            Min = find(sign(A)-sign(B)<0 & ...                min(abs([A B]),[],2)>=delta & ...                max(abs([A B]),[],2)>mindelta) + 1;                    case 'local5'            if isempty(met_max) || ~strcmpi(met_max,'local5')                A = diff(X(2:end-2));  A(abs(A)<eps) = 0;                B = diff(X(3:end-1));  B(abs(B)<eps) = 0;                C = diff(X(1:end-3));  C(abs(C)<eps) = 0;                D = diff(X(4:end));  D(abs(D)<eps) = 0;            end            Min = find(sign(A)-sign(B)<0 & sign(C)-sign(D)<0 & ...                min(abs([A B]),[],2)>=delta) + 2;                    case 'peakfinder'            [Min, vMin] = peakfinder(X,delta,-1);                    case 'peakdet'            if isempty(met_max) || ~strcmpi(met_max,'peakdet')                [~, Min] = peakdet(X, delta);                % else: we already computed a Min            end                    case 'fpeak'            if isempty(met_max) || ~strcmpi(met_max,'fpeak')                varargout{narg} = fpeak(x, X, delta);            end                    case 'findextrema'            if isempty(met_max) || ~strcmpi(met_max,'findextrema')                [~, Min, Zero] = findextrema(X);                % else: we already computed a Min            end                    case 'extrema'            if isempty(met_max) || ~strcmpi(met_max,'extrema')                [~, ~, vMin, Min] = extrema(X);                % else: we already computed Min, vMin            end                end        if strcmpi(met_max,'morph')        S = -X; d = -d;        ero = min(d,[],2); ero(ero<0) = 0;        S(I+1) = ero(I);                        A = diff(S(1:end-1)); B = diff(S(2:end));        m = find(sign(A)-sign(B)>0) + 1;        Min = Min(ismember(Min,m));    end        if ~isnan(mindelta) && mindelta>0        if ~strcmpi(met_min,'local3')            A = diff(X(1:end-1)); B = diff(X(2:end));        end        md = find(max(abs([A B]),[],2)>mindelta)+1;        Min(~ismember(Max,md)) = [];        if exist('vMin','var') && ~isempty(vMin),              vMin(ismember(Min,md)) = [];        end    end        if ~isnan(valabs) && valabs<Inf && valabs>0,          if ~exist('mv','var'),  mv = find(abs(X)<=valabs);  end        Min(ismember(Min,mv)) = [];        if exist('vMin','var') && ~isempty(vMin),              vMin(ismember(Min,mv)) = [];         end    end        if ~strcmpi(met_min,'fpeak')        if ~isempty(Min)            if size(Min,2)<2,                if ~exist('vMin','var') || isempty(vMin),  vMin = X(Min);  end                varargout{narg} = [x(Min) vMin];            else                varargout{narg} = Min;                varargout{narg}(:,1) = x(Min(:,1));            end        else            varargout{narg} = [];        end    end    if isempty(varargout{narg}), varargout{narg} = [0 0];  endendif strcmpi(met_zeros,'morph')    if any(strcmpi('morph',{met_max,met_min}))        X = S;    else        ero = min(d,[],2); ero(ero<0) = 0;        X(I+1) = ero(I);    endendif ~isempty(met_zeros)    narg = narg+1;    switch met_zeros                case 'naive'            %%            % Naive method            % to obtain  the indices where signal x crosses zero            i0 =  find(diff(sign(X)));            % the kth zero-crossing lies between x(i(k))  and x(i(k)+1)            % linear interpolation can be used for subsample estimates of            % zero-crossings locations            if interpol     % linear interpolation                varargout{narg} = i0 - X(i0)./(X(i0+1) - X(i0));       %#ok            else                varargout{narg} = i0;            end                    case {'local3','morph'}            %%            % |'local3'| - Extraction of zero crossing by comparing a value            % with its direct neighbours.            A = diff(X(1:end-1));  B = diff(X(2:end));            % same thing, but then B=-B:            %  A = diff(X);  A = A(1:end-1);            %  B = flipud(diff(flipud(X)));  B = B(2:end);            % thus, we then have to check A.*B<=0 in the following            varargout{narg} = ...                find(A.*B>=0 & X(1:end-2).*X(3:end)<=0 & ... % zero-crossing                min(abs([A B]),[],2)>delta) ...              % non constant                + 1;            % & abs(X(2:end-1))<= min([abs(X(1:end-2)) abs(X(3:end))],[],2)                    case 'crossing'            %%            % |CROSSING| - Find the crossings of a given level of a signal            if interpol                [ind,varargout{narg}] = crossing(X);                   %#ok            else                varargout{narg} = crossing(X);            end            % [ind,t0] = CROSSING(S,t,level,par)            %   INPUTS:            %       S - input signal.            %       t - interpolating time (possibly [] for no interpolation).            %       level - crossings at this level will be returned instead            %           of the zero crossings.            %       par - optional string {'none'|'linear'}: with interpolation            %	        turned off (par = 'none') this function always returns            %	        the value left of the zero (the data point that is            %           nearest to the zero AND smaller than the zero            %           crossing).            %   OUTPUTS:            %       ind - index vector so that the signal S crosses zero at            %           ind or between ind and ind+1            %       t0 - time vector t0 of the zero crossings of the signal            %           S; the crossing times are linearly interpolated            %           between the given times t                    case 'findextrema'            %%            % |FINDEXTREMA| - find indices of local extrema and zero-crossings.            if any(strcmpi({met_max; met_min},{'findextrema';'findextrema'}))                % Zero has been computed already                varargout{narg} = Zero;            else                [~, ~, varargout{narg}] = findextrema(X); % see above            end                end        if ~isnan(valabs) && valabs~=Inf,        if ~exist('mv','var'),   mv = find(abs(X)<=valabs);  end        varargout{narg}(~ismember(varargout{narg},mv)) = [];    end        if ~isnan(mindelta) && mindelta>0        if ~strcmpi(met_zeros,{'local3','morph'})            A = diff(X(1:end-1)); B = diff(X(2:end));        end        md = find(max(abs([A B]),[],2)>=mindelta)+1;        varargout{narg}(~ismember(varargout{narg},md)) = [];    end       % retrieve the coordinates in the original system    varargout{narg} = x(varargout{narg});    if isempty(varargout{narg}), varargout{narg} = 0;  endendif narg<nargout  % too many variables have been required in output    varargout(narg+1:nargout) = cell(nargout-narg,1);    if narg==0        error('findzeroextrema1D_base:errorinput', ...            ['at least one non empty string must be entered as a method - ' ...            'see variables met_min, met_max and met_zeros']);    endendend % end of findzeroextrema1D_base##### SOURCE END #####--></body></html>