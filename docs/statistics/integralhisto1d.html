<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html>  <head>    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">    <!--This HTML was auto-generated from MATLAB code.To make changes, update the MATLAB code and republish this document.      -->    <title>INTEGRALHISTO1D - Integral histogram of an image.</title>    <meta name="generator" content="MATLAB 7.14">    <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">    <meta name="DC.date" content="2012-05-31">    <meta name="DC.source" content="integralhisto1d.m">    <style type="text/css">html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}html { min-height:100%; margin-bottom:1px; }html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }html body td { vertical-align:top; text-align:left; }h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }a { color:#005fce; text-decoration:none; }a:hover { color:#005fce; text-decoration:underline; }a:visited { color:#004aa0; text-decoration:none; }p { padding:0px; margin:0px 0px 20px; }img { padding:0px; margin:0px 0px 20px; border:none; }p img, pre img, tt img, li img { margin-bottom:0px; } ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }ul li { padding:0px; margin:0px 0px 7px 0px; }ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }ul li ol li { list-style:decimal; }ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }ol li ol li { list-style-type:lower-alpha; }ol li ul { padding-top:7px; }ol li ul li { list-style:square; }.content { font-size:1.2em; line-height:140%; padding: 20px; }pre, tt, code { font-size:12px; }pre { margin:0px 0px 20px; }pre.error { color:red; }pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }span.keyword { color:#0000FF }span.comment { color:#228B22 }span.string { color:#A020F0 }span.untermstring { color:#B20000 }span.syscmd { color:#B28C00 }.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }.footer p { margin:0px; }  </style>  </head>  <body>    <div class="content">      <h1>INTEGRALHISTO1D - Integral histogram of an image.</h1>      <!--introduction--><!--/introduction-->      <h2>Contents</h2>      <div>        <ul>          <li><a href="#1">Description</a></li>          <li><a href="#2">Syntax</a></li>          <li><a href="#3">Remark</a></li>          <li><a href="#4">References</a></li>          <li><a href="#6">See also</a></li>          <li><a href="#7">Function implementation</a></li>        </ul>      </div>      <h2>Description<a name="1"></a></h2>      <p>Compute the integral histograms in cartesian space of an image as        defined in [Pori05].</p>      <p>From [OPENVIDIA]: An integral histogram is created by iteratively        building a histogram of an image pixel by pixel and recording the        histogram at each step. For example consider scanning pixels in raster        order - left to right, top to bottom. The histogram for all pixels        between the current pixel and back to the origin pixel is found and        recorded as the histogram for that pixel. Then, to find the histogram        for the next pixel (covering the region from that pixel to the origin),        the only operation needed is to take the previous histogram, and        increment the bin corresponding to the input pixel's value, yielding the        histogram for that pixel. The complete set of these histograms is the        integral histogram.</p>      <p>To find the histogram of the region between two pixels, <img src="integralhisto1d_eq69357.png"          alt="$x_0$">        and <img src="integralhisto1d_eq06004.png" alt="$x_1$"> say, with <img          src="integralhisto1d_eq28395.png"          alt="$x_1 &gt; x_0$">        (i.e. <img src="integralhisto1d_eq06004.png" alt="$x_1$"> is farther        out in scanline order), simply subtract the histogram of <img src="integralhisto1d_eq55674.png"          alt="$x_0-1$">        from the histogram of <img src="integralhisto1d_eq06004.png" alt="$x_1$">.        This removes the contributions to the histogram of points from <img src="integralhisto1d_eq13975.png"          alt="$[0, x_0-1]$">        and leaves only contributions from the region <img src="integralhisto1d_eq29488.png"          alt="$[x_0,x_1]$">        (this is the region, or scanlines, between <img src="integralhisto1d_eq13695.png"          alt="$x0$">        and <img src="integralhisto1d_eq07811.png" alt="$x1$">).</p>      <pre class="codeinput"><span class="comment">% Generating integral histograms in scanline order is called a "string scan"</span><span class="comment">% method [Pori05]. Another method of generating histograms is via "wave</span><span class="comment">% propogation" where the histograms cover the rectangular region between the</span><span class="comment">% current pixel and the origin. This type of integral histogram is useful</span><span class="comment">% for finding the histograms of rectangular regions in of the image. This</span><span class="comment">% can be implemented by, taking a row histogram of the left neighbour pixel</span><span class="comment">% (ranging to the row origin) and then adding the wave propogation histogram</span><span class="comment">% of the pixel above the current one, then adding the current pixel</span><span class="comment">% contribution to the histogram.</span><span class="comment">%</span></pre>      <h2>Syntax<a name="2"></a></h2>      <pre>   IH = INTEGRALHISTO1D(I, nbin, bound);</pre>      <h2>Remark<a name="3"></a></h2>      <p><tt>IH(X,Y,:)</tt> provides the global histogram of the image when <tt>X</tt>        and <tt>Y</tt> are the dimensions of the input image: both commands <tt>hist(I(:),nbin)</tt>        and <tt>plot(squeeze(IH(X,Y,:)))</tt> display the same results.</p>      <h2>References<a name="4"></a></h2>      <p>[VJ01] P. Viola and M. Jones, "Robust Real-Time Face Detection",        International Journal of Computer Vision, 57(2):137-154, 2004. <a href="http://www.springerlink.com/content/q70v4h6715v5p152/">http://www.springerlink.com/content/q70v4h6715v5p152/</a></p>      <p>[Pori05] F. Porikli: "Integral histogram: a fast way to extract        histogram features", Proc. IEEE CVPR, pp. 829?836, 2005. <a href="http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=1467353">http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=1467353</a></p>      <p>[PT06] F. Porikli and O. Tuzel: "Fast construction of covariance        matrices for arbitrary size image windows", Proc. IEEE ICIP, 2006. <a href="http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=4106846">http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=4106846</a></p>      <p>[OPENVIDIA] <a href="http://openvidia.sourceforge.net/index.php/IntegralHistograms">http://openvidia.sourceforge.net/index.php/IntegralHistograms</a></p>      <h2>See also<a name="6"></a></h2>      <p>Ressembles: <a href="integralhisto2d.html"><tt>INTEGRALHISTO2D</tt></a>,        <a href="integralhistojoint.html"><tt>INTEGRALHISTOJOINT</tt></a>.        Requires: <a href="integralimage.html"><tt>INTEGRALIMAGE</tt></a>.</p>      <h2>Function implementation<a name="7"></a></h2>      <pre class="codeinput"><span class="keyword">function</span> [IH, I] = integralhisto1d(I, nbin, bound)[X,Y] = size(I(:,:,1));<span class="keyword">if</span> nargin==3,    imax = bound(2); imin = bound(1);<span class="keyword">else</span>    imax = max(I(:)); imin = min(I(:));    <span class="keyword">if</span> nargin&lt;2        nbin = round(imax - imin) + 1;    <span class="keyword">end</span><span class="keyword">end</span><span class="keyword">if</span> imax==imin,    error(<span class="string">'integralhisto1d:inputerror'</span>, <span class="string">'constant image - nothing to do'</span>);<span class="keyword">elseif</span> nbin==0    nbin = round(imax - imin) + 1; <span class="comment">% again, default</span><span class="keyword">end</span><span class="keyword">if</span> nbin&gt;0<span class="comment">% quantize the input image</span>I = floor((nbin-1) * (I - imin) / (imax - imin));<span class="keyword">else</span>    nbin = abs(nbin); <span class="comment">% a way not to quantize</span><span class="keyword">end</span><span class="comment">% method 1: optimized, fully vectorial (non sparse) calculation and</span><span class="comment">% representation of integral histograms</span>IH = zeros(X, Y, nbin);ind = (1:X*Y)';IH(ind + X*Y*I(:)) = 1;<span class="comment">% IH = cumsum(cumsum(IH,2),1);</span>IH = integralimage(IH);<span class="keyword">if</span> false    IH = sparse(reshape(IH, [X*Y, nbin]));                             <span class="comment">%#ok</span><span class="keyword">end</span><span class="comment">% % method 2: non vectorial version</span><span class="comment">% subind = nbin * (0:Y-1);</span><span class="comment">% % create the output histograms</span><span class="comment">% IH = zeros( X+1, Y, nbin );</span><span class="comment">% % propagate the histogram along x-dimension</span><span class="comment">% for x=1:X</span><span class="comment">%     % method 2.a)</span><span class="comment">%     H = zeros(nbin,Y);</span><span class="comment">%     hh = I(x,:) + subind + 1;</span><span class="comment">%     H(hh) = H(hh) + 1;</span><span class="comment">%     % cumulate the histogram along y-dimension</span><span class="comment">%     H = cumsum(H,2)';</span><span class="comment">%     % propagate</span><span class="comment">%     IH(x+1,:,:) = H + squeeze(IH(x,:,:));</span><span class="comment">%</span><span class="comment">%     % method 2.b)</span><span class="comment">%     % H = zeros(nbin,1);</span><span class="comment">%     % for y=1:Y</span><span class="comment">%     %     H(I(x,y) + 1) = H(I(x,y) + 1) + 1;</span><span class="comment">%     %     IH(x+1,y,:) = H + squeeze(IH(x,y,:));</span><span class="comment">%     % end</span><span class="comment">% end</span><span class="comment">% % get rid of the dummy row</span><span class="comment">% IH = IH(2:end,:,:);</span><span class="keyword">end</span> <span class="comment">% end of integralhisto1d</span></pre></div>    <!--##### SOURCE BEGIN #####%% INTEGRALHISTO1D - Integral histogram of an image.% %% Description% Compute the integral histograms in cartesian space of an image as defined% in [Pori05].%% From [OPENVIDIA]:% An integral histogram is created by iteratively building a histogram of an% image pixel by pixel and recording the histogram at each step. For example% consider scanning pixels in raster order - left to right, top to bottom. % The histogram for all pixels between the current pixel and back to the % origin pixel is found and recorded as the histogram for that pixel. Then, % to find the histogram for the next pixel (covering the region from that % pixel to the origin), the only operation needed is to take the previous % histogram, and increment the bin corresponding to the input pixel's value,% yielding the histogram for that pixel. The complete set of these histograms % is the integral histogram.%% To find the histogram of the region between two pixels, $x_0$ and $x_1$ say,% with $x_1 > x_0$ (i.e. $x_1$ is farther out in scanline order), simply% subtract the histogram of $x_0-1$ from the histogram of $x_1$. This removes % the contributions to the histogram of points from $[0, x_0-1]$ and leaves% only contributions from the region $[x_0,x_1]$ (this is the region, or % scanlines, between $x0$ and $x1$). % Generating integral histograms in scanline order is called a "string scan"% method [Pori05]. Another method of generating histograms is via "wave% propogation" where the histograms cover the rectangular region between the% current pixel and the origin. This type of integral histogram is useful% for finding the histograms of rectangular regions in of the image. This% can be implemented by, taking a row histogram of the left neighbour pixel% (ranging to the row origin) and then adding the wave propogation histogram% of the pixel above the current one, then adding the current pixel% contribution to the histogram. %%% Syntax%     IH = INTEGRALHISTO1D(I, nbin, bound);% %% Remark% |IH(X,Y,:)| provides the global histogram of the image when |X| and |Y| % are the dimensions of the input image: both commands |hist(I(:),nbin)| and% |plot(squeeze(IH(X,Y,:)))| display the same results.% %% References% [VJ01]  P. Viola and M. Jones, "Robust Real-Time Face Detection", %      International  Journal of Computer Vision, 57(2):137-154, 2004.%      <http://www.springerlink.com/content/q70v4h6715v5p152/>%% [Pori05]  F. Porikli: "Integral histogram: a fast way to extract histogram%      features", Proc. IEEE CVPR, pp. 829?836, 2005.%      <http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=1467353>%% [PT06]  F. Porikli and O. Tuzel: "Fast construction of covariance matrices%      for arbitrary size image windows", Proc. IEEE ICIP, 2006.%      <http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=4106846>%% [OPENVIDIA]  <http://openvidia.sourceforge.net/index.php/IntegralHistograms>%%% Credit% <mailto:grazzja@lanl.gov J.Grazzini> (ISR-2/LANL)%%% See also% Ressembles:% <integralhisto2d.html |INTEGRALHISTO2D|>,% <integralhistojoint.html |INTEGRALHISTOJOINT|>.% Requires:% <integralimage.html |INTEGRALIMAGE|>.%% Function implementationfunction [IH, I] = integralhisto1d(I, nbin, bound)[X,Y] = size(I(:,:,1));                                                   if nargin==3,    imax = bound(2); imin = bound(1);else    imax = max(I(:)); imin = min(I(:));    if nargin<2        nbin = round(imax - imin) + 1;    endendif imax==imin,      error('integralhisto1d:inputerror', 'constant image - nothing to do');elseif nbin==0    nbin = round(imax - imin) + 1; % again, defaultendif nbin>0% quantize the input imageI = floor((nbin-1) * (I - imin) / (imax - imin));else    nbin = abs(nbin); % a way not to quantizeend% method 1: optimized, fully vectorial (non sparse) calculation and % representation of integral histogramsIH = zeros(X, Y, nbin);ind = (1:X*Y)';IH(ind + X*Y*I(:)) = 1;% IH = cumsum(cumsum(IH,2),1);IH = integralimage(IH);if false    IH = sparse(reshape(IH, [X*Y, nbin]));                             %#ok   end% % method 2: non vectorial version% subind = nbin * (0:Y-1);% % create the output histograms% IH = zeros( X+1, Y, nbin );% % propagate the histogram along x-dimension% for x=1:X%     % method 2.a)%     H = zeros(nbin,Y);%     hh = I(x,:) + subind + 1;%     H(hh) = H(hh) + 1;     %     % cumulate the histogram along y-dimension%     H = cumsum(H,2)';%     % propagate%     IH(x+1,:,:) = H + squeeze(IH(x,:,:));%     %     % method 2.b)%     % H = zeros(nbin,1);%     % for y=1:Y%     %     H(I(x,y) + 1) = H(I(x,y) + 1) + 1;%     %     IH(x+1,y,:) = H + squeeze(IH(x,y,:));%     % end% end% % get rid of the dummy row% IH = IH(2:end,:,:);end % end of integralhisto1d##### SOURCE END #####-->  </body></html>